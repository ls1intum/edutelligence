{
  "id": 6794,
  "meta": {},
  "type": "text",
  "title": "H04E02 Design Goal Trade-offs (SS22)",
  "course_id": 169,
  "max_points": 6,
  "submissions": [
    {
      "id": 1291747,
      "meta": {},
      "text": "Functionality vs. Usability: \nA system can either be very usable, meaning it's easy to learn, having not too many options, or it can be very functional, being powerful but also hard to understand. As an example one could use SAP ERP systems. SAP tools have so many functionalities that many people are not able to use all of them (on top of that it's not very user-friendly if you look at the UI). Therefore there are many SAP consultants helping companies setting up SAP.\n\nCost vs. Robustness: \nThe more robust a system should be, the more tests are required. These tests then also lead to higher cost. Examples for this are online registrations. Inputs of phone numbers and birth dates are mostly strictly prescribed. Any input in another format is declined. This of course grants the provider of any software/social network to have persistent data, but of course as this takes longer to implement, it's also more costly. \n\nRapid development vs. functionality: \nDeveloping a system with a lot of functionalities takes time, but time is money and especially when you look at startups, applications have to be shipped fast, as startups are bootstrapped and must gain customers fast. (E.g. Personio had very few functionalities in the beginning, just enough to gain their first customers. From this point on they constantly developed their Software, for example with several APIs to other systems.) Of course, there were some unhappy customers in the beginning, but still, Personio got at least some money from them to further develop their tool. On the other hand, Personio might not have survived by first working to a fully functional software in the beginning, as they would not have made any revenue.\n\n//some parts taken from my submission from last year - Thomas Schuhbeck (ga84xoc)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292389,
      "meta": {},
      "text": "1. Functionality vs. usability \nAs we known, system design should follow \"7+/-2\"(seven plus or minus two) rule. It guarantees the user does not spent too much effort to learn this system. \nAn example: The old version MVG Automaten for purchasing a ticket. There are too much bottoms to purchase a ticket. \n\n2. Cost vs. robustness\nIf we build something cheap or with less time and it's usually not so robust. \nAn example: If the budget is not enough, some aspects like security and performance will not be considered in software development.\n\n3. Efficiency vs. portability \nIt's obvious that different platforms have their own features. System Design is supposed that this specific software is based on one specific environment. If the software run on another platform, it's not so efficient or directly fails.\nAn example: Adobe Pr runs well on Microsoft and runs slowly on MacOS",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1296592,
      "meta": {},
      "text": "Typical design goal trade-offs in the field of software engineering are often between the client, the end user and/or the developer.\n\nTradeoff between rapid development and best functionality: When choosing functionality of the software this will be time consuming and therefore a quick software development is not possible. However sometimes the first draft/prototype needs to be online quickly and then functionality is the one that suffers. An example in terms of code is deciding between using a heuristic and key algorithm. For a key algorithm you need more time to collect all data and to create a good/useful key algorithm (resulting in: high functionality but slow development). Whereas using a heuristic its more like the rule of thumb which you can find quickly and adjust/improve over time (resulting in: rather a quick development than a good functionality at first).\n\nTradeoff between cost and reusability: An economic cost and scarce resource is time. When concentrating on reusability the cost in terms of time are hight because when you want to reuse code you need time to create a structure of the code so the maintenance and reusing of the code is actually possible and costs time. When you want low time cost you probably do not get a code that is structured/readable and therefore cannot be reused.\n\nTradeoff between functionality and (easy) usability:  Having a high functionality and therefore lots of functions in your code or (when talking about coupling from the lecture) in the interface it can reduce the usability as it will get more confusing, harder to learn from or use. However, when reducing those functions in an interface the usability will increase but the functionality of the code will suffer.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1330722,
      "meta": {},
      "text": "First the cost of a software almost everytime conflicts with the robustness of it. That's because either there is not enough time to plan the system well enough, for example too few iterations in system design, that the final design might get much better in the next iteration, but they have to go on because it would be too expensive for the client, or not enough testing, so there might be many bugs left after just a short testing phase, which also results in a lack of robustness.\n\nAnother trade-off is efficiency versus portability. An example would be a very slow algorithm which operates on a very large array of integers. In order to optimize it in a very good way, developers could split the array up into several smaller ones, that each one fits into a cache line and can also it can be implemented with concurrent functions. That would be a very processor specific optimization, so that on other architectures it might even has a negative impact in terms of performance, so it is not portable.\n\nLastly Backward compatibility often comes with unreadability. That is because programming languages evolve in a way that they become more user friendly. A very good example for that is the introduction of Records in Java 14, which made it much easier to implement classes, that only hold data. So if the rest of the systems relies on an older version, records can't be used.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344279,
      "meta": {},
      "text": "1. Trade-Off between Low Cost and Functionality. Both are desirable goals, but the more functionality a software has, the more does it cost to develop because the developers have to do more work.\n\n2. Trade-Off between Modifiability/ Readability and Runtime Efficiency. Sometimes, improving runtime requires using more sophisticated technologies/ algorithms, which, in turn, are harder to modify/read. Brute-force solutions for example are relatively easy to read and modify, whereas more complicated solutions require much more time to understand and dive into.\n\n3. Trade-Off between Rapid development and good documentation. The faster you want to develop software and bring features to the end user, the less time you have for crafting an extensive and good documentation. This is because documentations are mainly only valuable for the future and in the present, they are only a cost factor.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1349443,
      "meta": {},
      "text": "1. Functionality vs. Usability:\nHigh functionality doesn't mean high usability.\nFor instance, an online dictionary displaying all contained words on one single page, is functional, as it serves its purpose of containing near to all words a language consists of, however, it is not usable, as it is very difficult to find a given word.\n\n2. Cost vs. robustness:\nWhen not spending enough money on a big software project, it is not likely to be very robust and the other way around. For instance, Facebook is spending a huge amount of money to resist against any possible user misbehavior or error in changing environments. For instance, Facebook designed complex algorithms to cope with violence and hate speech, by deleting certain comments or pictures.\n\n3. Rapid development vs. functionality:\nA rapidly developing software application often will not have the same functionality as a slowly developing one. \nThis is due to overseeing important aspects of the system's functional requirements. When taking more time to develop a system, there will occur fewer errors as well as fewer unintended misbehavior. For instance, when I created my second mobile-phone application, I didn't take the time to develop a fully functional app. I rushed the process by overseeing for example the functionality of quitting the game. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1505891,
      "meta": {},
      "text": "1. Functionality vs Usability\nUsability can be defined in software engineering as a level of simplicity of an interface use and a functionality - as a number of methods that support following interface. A problem that often occurs in this case is a difficulty to comprehend the code and use the interface when having many methods defining it. However, on the other hand, reduction of interface's functions makes it less potent in current implementation.\n\n2. Cost vs Robustness\nMinimise the production cost while achieving robust performance of a product is another trade-off. \nRobustness is the ability of the system to respond to abnormal inputs and conditions. Therefore, additional expenses will be allocated for the analysis of possible edge cases and further detailed testing.\n\n3. Efficiency vs Portability\nWhenever a program uses special hardware features, it will be more efficient and less portable. Sometimes accessibility features can provide significant improvements, but their use requires specific codes that need to be updated when the installed hardware is replaced. For example, Scalable Linear Algebra PACKage in order to be efficient and still portable(and other way around) constructs its software so that as much as possible of calculations is performed by PBLAS, which in its turn performs calculations by relying on the optimised version of BLAS for local computation and BLACS for communication.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291856,
      "meta": {},
      "text": "Design goals often conflict with each other therefore there are design goal trade-offs.\nA typical design goal trade-off is cost vs. robustness. The client wants to invest as less money as possible, which leads to the developers not being able spend much time to make the system robust. If the system is made more robust the cost increases.\nA second design goal trade-off is rapid-development vs. functionality. To get a system with good functionality you need to spend time to analyse, design, implement and test it. If you want to have it fast you don't have a lot of time for that, so the functionality decreases.\nAnother design goal trade-off is cost vs. reusability. As with the robustness to increase the reusability of a system the developers need to work on it and change the system, which consumes time, which leads to an increased cost of the system.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292618,
      "meta": {},
      "text": "1. functionality vs. usability:\nA system which has lots and lots of functions may not be easy to learn for users and therefore they don't use it at all. While the app GoodNotes may offer more ways to structure one's files (e.g. folders, topics, themes, tags, documents, dividers) than Notability, the latter is easier to use since there are just two possibilities (subjects and dividers) to arrange one's files. \n\n2. efficiency vs. portability:\nA system may be efficient on a certain platform, for example the microsoft office applications run efficiently so smoothly on Windows based PCs but have limited functionality on Apple devices (iPad, MacBook). A concrete example would be MS Word which has all functionalities on a Windows PC but is very restricted in its use on an iPad (limited portability of the MS Word Software).\n\n3. rapid development vs. functionality:\nA quickly developed software project may only be for a certain entity, for example a seat reservation system for a library will only that one reservation function but users will need a different system to reserve and borrow books of that library.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1310816,
      "meta": {},
      "text": "The first Trade-Off is the functionality vs usability, on the one Hand adding 200 different Functionalitys and fancy features to your app is very powerfull, adding all of it to one toolbar so it takes 5 rows and 200 icons does not help the user, a perfect example would be Microsoft Products, they are very powerfull but some people are overwhelmed by extreme nische Functionalitys and thus change to Google Docs (for example) which often lacks fancy functionality, but is very intuitive to use.\nThe next big Tradeoff is is Cost vs Reusability, the cost of specific, unclean and unreusable code is very low because its easy to code and test, but if Code is only created for this one particular Case (on which it works great) it is hard to use for other Cases even if those are very similar, making it once again lower cost to just create new Code with the same Problem, making cheap Spaghetti code. If for example I code a user login service for a Website and it works fine but even adding one button or changing one field would destroy the whole code, its cheap but not reausable in any real way.\nAnother Trade Off is Robustness and Cost, If Code is made cheaply and without too much testing and thinking about edge Cases, it is very cheap and easy, but any attack or unexpected user input can destroy the whole system. If, for example my Code is made quick and cheap but once the user inputs the MAX.INTEGER as his age, the whole system is destroyed, my code was cheap but not robust.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1313240,
      "meta": {},
      "text": "One major type of design goal trade off is: functionality vs. usability.\n\nWith usability we mean how easily an interface is to use, with functionality how many functions it supports. \nThe problem here typically is: that with more functions that should be supported, the interface becomes very complex and difficult to use and understand. Let's use the example of a ticket machine. If the machine should just provide the functionalities to book a ticket from a place to another and to pay, the interface will be simple and easy to use. If wen now want it to provide 50 more functions, navigation will become very difficult and make it almost unusable. \n\nThe next trade off is: Rapid development vs. functionality. \n\nA client might want the software for his ticket machine to be developed extremely fast. In a short time frame functionalities, the system should have can't be built as good as possible and some errors might arise later. \n\n\nAnother common dilemma is: efficiency vs reusability.\n\nA very efficient software utilizes the underlying hardware extremely well. This also means, that it is likely built for a certain Cpu architecture etc. The drawback of that is, that the software is not very portable to another hardware architecture, because it is specifically built for the first one.  An example would be pre installed software on Mac OS vs windows. \n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1363605,
      "meta": {},
      "text": "\nTime vs space:\nIn some cases the algorithm of our codes works fast but it needs more storage in comparison with another version of our code, which works slower than ours. In that case we should make a choice according our usage aims of our code.\nFor example: Mergesort  works faster than quicksort ; but merge sort  requires additional memory space to store the auxiliary arrays , while quick sort  doesn’t need any extra storage.\n\nCost vs. Robustness:\nRobustness is an ability of the system to handle with extrem situation/cases. Our program should not only work correctly, but also be resistent against extrem cases, such as any errors or bad intention of some users . But , to write a code, which is robustness needs more time to code it and it's more expensive.\nFor instance: The online banking applications are more robustness against the hackers, since the banking applications are used for monetary processes. Therefore the cost of robustness against the hackers of banking applications or websites are more expensive than a game website.\n\n\n\nCost vs. Reusability:\nReusability is the useage of existing code from  previous projects and writing reusable codes eases the processes of future works/projects. But only high-quality code (bug-free) can be reused.And writing such codes cost more time and money.\n\nFor instance big applications or softwares(such as ios) write their codes in a reusable way and therefore they can reuse again  making some changes and we can use the new softwares by installation of ios.\n \n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1372276,
      "meta": {},
      "text": "Functionality vs. Usability:\nWhen you want to design a Kids app, you might run into the problem that you have to limit your functionalities to make it usable for kids. So in the development process you often times have to evaluate between more functionalities and a good usability.\n\nEfficiency vs. portability:\nWhen you want to design a math program that calculates very complex formulas, you have to decide whether you want to have a very efficient solution (calculation method) you might have to use very advanced hardware. Now, the problem could be that the customer wants this app to run on a smartphone, but the hardware of the average phone doesn't allow fast and efficient calculations. So you have to evaluate between efficient but hardware consuming option or very portable solutions.\n\nRapid development vs. functionalities:\nWhen the developers are rushed or the customer wants the development phase to be very fast. You don't often times don't have the time to implement all the functionalities from the product backlog, so in your sprint backlogs you have to focus on the most important ones which you can get in the least amount of time. ",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1372700,
      "meta": {},
      "text": "1: Low cost - Functionality trade off.\n\tUsually in order to be an app to multifunctional, devoted work put in to the app needs to increase. More work means costly projects: either new developers and managers need to be hired or more time need to be spared. Which increases the cost. An example would be a social media app: If messaging, posting pictures, sharing locations etc. functionalities are added, the resulting app would be more demanding sometimes in both time and work. \n\n2: Rapid Development - good documentation.\n\tWhen the client demanded an app in a very short time, dealing with both functionality and good documentation would be cumbersome. Thus resulting documentation may not be complete in the sense of complete functionality. For instance when a new interface design needed for an app in a very short time, team may skip to mention certain complicated interactions: failing to mention how to close the app.\n\n3: Flexibility - Maintainability.\n\tA system that needs to be flexible requires, in most cases, high complexity. Because in order to adapt changing internal or external requirements, system needs related functionalities to overcome these. To use these functionalities, objects will most probably need to refer more to each other:  which result high cohesion and maybe even high coupling. Thus, it might be more challenging to update or debug such a system. For instance an inventory management system may able to store various type of inventory, even though they are not used by particular customer yet. Suppose that this inventories is linked with other functionalities in the system. One bug in the less used inventory type might create total collapse at those functionalities and debug might take more time.\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1403169,
      "meta": {},
      "text": "One commonly seen design goal trade-off, that is known both - among industry and students is the: Rapid Development vs. Good documentation. When a product has to be released quickly, such as within the time frame of a single week (i.e. EIST / PGdP exercises) there's often barely any documentation written, which results in rather poor readability, but allows workers and students to quickly modify and deploy code.\n\nAnother trade-off that often comes as a downside of rapid development is robustness and fault tolerance. That means that the software tends to be less reliable as the result of fewer tests and a tighter schedule, which does not allow for covering and debugging all possible inputs and edge-cases. That often results in code being deployed to the production machines (or submission CI servers) that has never or barely ever been tested. The Artemis CI system and student submissions would be a great example for that.\n\nFinally, one other common trade-off would be the one of low cost vs. usability. This one is particularly often seen in video games. Game companies want to reduce the development cost and maximize the income, which prevents developers from optimizing the game oftentimes.\nPerformance updates are rather rare and result in the very high minimum machine requirements on modern triple A titles.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1467274,
      "meta": {},
      "text": "Cost vs Rapid development: From a client's point of view, it would be nice to combine both low cost and fast development, however, it is not feasible. For developers, high speed requires more intensive use of resources and thus is associated with a high cost and vice versa.\n\nRapid development vs Reusability: If we consider a system with one-to-one multiplicity, it will be easier and faster to code, with no additional tests required. As multiplicity increases, more time is needed in the development.\n\nFunctionality vs Runtime efficiency: Clients prefer a functional system that delivers results quickly, however, as the functionality increases, it is more complex and takes more time for a system to complete processes. \n\n\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1663694,
      "meta": {},
      "text": "Functionality vs. usability \nFor example, a computer with many functions that can design top aerospace technology algorithms, it is functionality, but for ordinary people, the cost of usability is too high.\ncost and robust\nIn electronic products, for example, the lower the cost, the worse the parts it uses, and the worse the parts, the shorter the service life of course. For example, earphones, low cost and poor parts will produce current sound.\nEfficiency vs. portability\nFor example, word and Excel. From the earliest text editing function to the more and more functions later, the development time is longer. The longer it is, the more functions it has.",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291951,
      "meta": {},
      "text": "1. well-defined interface vs. ease of learning: \na well-defined interface might contain a lot of useful information and functions, however an end user would expect an interface which looks easy and friendly to use.\n\n2.  modifiability vs. rapid development:\nwhile client would expect a rapid development of a software, on the other hand, developer would prefer to develop it with modifiability if there is a need for future usage.\n\n3. low cost vs. robustness:\nfrom a client's point of view, cost should be as low as possible, but a robust software sometimes requires more effort to maintain which induced more cost\n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1294061,
      "meta": {},
      "text": "A client usually wants to keep the costs as low as possible, which often means that developers are working under time constraints, possibly leaving little time test for and fix bugs, which comes at the cost of user satisfication, as an end user wouldn't be happy to use a faulty product. In particular, crunch time is a known phenomenom in game development, rushing developers to finish a product, resulting in games that are notorious for being extremely buggy on release.\nA developer may want to structure the system build in such a way that as many parts as possible can be re-used again, keeping them relatively flexible, which generally requires a certain amount of abstraction. This often comes at the cost of ease of lerning for end users, as keeping many options open is one way to achieve this, requiring users to get familiar with all of them before being able to proceed, instead of intuiting the pre-sets and directly picking up how to use the system.\nThe way an end user wants to use a system may not always 100% match what the client and developer had envisioned, leading to situations that the system may identify as faulty, even if the user may consider it to be a proper use case. For instance, a platform may offer to let users upload longform texts and then download them as an .epub, with the terms of service limiting the kinds of text permitted; but some users may try to use the function for other purposes, leading to conflicts with what the client wants.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1320917,
      "meta": {},
      "text": "1) Efficiency vs. Portability: It would be nice if an application is available and works equally well on every device such as laptops, smartphones, and tablets. But in reality, you may have to focus on one important device to ensure great efficiency on that device. For example, Instagram works with many latest features and always gives a perfect UX on the mobile App. However, the PC browser version of Instagram lags such UX and efficiency.  \n\n2) Rapid Development vs. Functionality:\nIt would be nice if you could deliver your software product to your client in a very short time with full functionalities. However, in reality, you may need to prioritize them.  For example, assuming that your developer team can offer a software development with main 3 functionalities in 1 month. If your client says they want to have a software with 5 main functionalities in 1 month, you as developer team and the client need to find a compromise either developing 3 functionalities in 1 month or developing 5 functionalities in 1.5 months.\n\n3) Cost vs. reusability:\nAssume that you currently develop an app for editing pictures. Considering you want to develop a video editing app in the future,  it would be convenient if you already develop general functions that can be used for both the photo editing app and the video editing app. However, it needs more time and money to develop them than just developing functions needed only for the photo editing app at this moment.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1617913,
      "meta": {},
      "text": "1. Cost vs Robustness: When the cost of the development is less, then the development is usually focused to  work on a particular problem. Which means if it works for now it's good, which may present a problem in the future or even when doing further testings. Example: In frontend development, we used an external JavaScript module which was working for us at the moment, but after few days there was a bug where customers could not even click on items.\n2. Functionality vs Usability: The system will have many functionality and features, but it will not be organized which gives plethora of options which makes it confusing to use. Example: Amazon is an example, intended as an ecommerce website as a customer I did not know they had gaming, donation and live shopping feature until I read an article about it.\n3. Rapid development vs functionality: With rapid development, it usually goes through prototype, refine and test then deploy phase which makes it very hard for the developer to identify the real functionality the end user wants because of the lack of quality feedback. Example: A freelancer usually does all the feature and functionality a client wants but has little to no feedback from end users, which makes the product not so good.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1648919,
      "meta": {},
      "text": "1. Backward compatibility vs. readability\nKunden, die die Software schon seit einiger Zeit nutzen können in dieser Zeit sehr große Datenmengen generieren. Von diesen Datenmengen sind sie anschließend abhängig, da sie beispielsweise ihr Geschäft damit aufgebaut haben. Für diese Kunden ist es sehr wichtig, dass ihre Daten weiterhin kompatibel bleiben. Trotzdem gibt es häufig Design Entscheidungen, die das System des Kunden inkompatibel machen könnten. Um die Kompatibilität mit dem Kundensystem zu gewährleisten muss viel zusätzlicher Code geschrieben werden, der die neue Funktionalität mit der alten verbindet, was häufig zu unintuitiven Code führt. Möchte man den Code lesbar halten muss man also von der Rückwärtskompatibilität absehen.\n\n2. Efficiency vs. portability\nMöchte man ein besondes leistungzehrendes Programm entwickeln wie zb. für Physiksimulationen sollte dieses trotzdem in kurzer Zeit durchlaufen werden, da ein Programm, dass Minuten- oder Stundenlange nur berechnet nicht besonders Nutzerfreundlich ist. Um dieses Ziel zu erreichen muss das Programm sehr hardwarenah implementiert werden, damit eine hohe Effizienz erreicht werden kann. Allerdings ist das Programm durch eine Hardwarenahe Implementierung stark vom Betriebssystem angewiesen auf dem es läuft und ist somit kaum noch transportabel.\n\n3. Functionality vs. usability\nEine besonders wichtige Eigenschaft bei der Gestaltung eines UIs ist die Nutzbarkeit. Ein UI sollte intuitiv vom Benutzer bedient werden können, ohne das dieser sich lange einarbeiten muss. Je mehr Funktionalität dem Nutzer dabei gegeben wird desto komplizierter ist auch das UI. Daher sollte man die Funktionalität so begrenzen, das der Benutzer noch eine angemehme Erfahrung bei der Benutzung des Programms hat.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1291289,
      "meta": {},
      "text": "Ein erster Konflikt kann entstehen, wenn der Kunde eine schnelle Entwicklung des Systems möchte, aber trotzdem alles funktionieren soll. Wenn die Entwicklungszeit möglichst kurz sein soll, haben die Entwickler vielleicht nicht ausreichend Zeit alles noch ausführlich zu testen oder es kann nicht jede einzelne Funktion perfekt umgesetzt werden, was zu einer sinkenden Funktionalität führen kann. Ein zweiter Kompromiss muss getroffen wenn es um Funktionalität und Nutzerfreundlichkeit geht. Wenn ein Programm zum Beispiel möglicht viele verschiedene Funktionen umsetzen soll, gibt es auch mehr Möglichkeiten beim Bedienen des Systems und somit wird es für den Benutzer komplizierter und unübersichtlicher. Und ein dritter Kompromiss muss getroffen werden wenn ein System möglichst robust sein, aber trotzdem nicht zu viel kosten soll. Zum Beispiel die Fehlerbehandlung um falsche Eingaben durch den Nutzer abzuzfangen und richtig zu behandeln, benötigt extra Zeit und Aufwand bei der Entwicklung des Systems und steigert somit auch die Kosten. ",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1291359,
      "meta": {},
      "text": "functionality vs usability:\nWhen developing a CAD software, developers offer a lot of functionality. E.g., they offer multiple ways to manipulate vertices of a mesh, each one of which follows a different logic. This is desirable since different users have different intuitions when confronted with the task of vertex manipulation. On the downside it's hard to unify those different logics into one sole logic, leaving the user with the need to learn multiple logics on their own.  \n\nrobustness vs low cost:\nWhen developing a video game, bug fixing increases the robustness of it, since it means that possible unwanted game states caused by unusual user input are avoided, but costs a lot of time and resources.\n\nrapid development vs functionality:\nWhen developing Bumpers I had to leave out a lot of planned functionalities since there was a deadline which forced me to develop rapidly. \n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291870,
      "meta": {},
      "text": "Backward compatibility vs. readability\nBackwards compatibility in computing means that after a software or program has been updated to a newer version, the document or system created with the old version of the program can still be operated or used normally. For example windows 10 is compatible with programs developed to run Windows 3.1 , then windows 10 has backwards compatibility. In a software compatibility scenario, for example regarding the compatibility of different versions of jdk, if a project edited in jdk 1.4 can be compiled with jdk 1.5, then jdk is said to have backwards compatibility. Sometimes it is not easy to achieve backward compatibility e.g. due to different hardware. So readability is given much higher weight\n\nEfficiency vs. portability\nMany too many multiplicity between classes has additional coding and testing costs. That's why portability is so important. There are two general types of portability: software portability and hardware portability. Software portability means that the code can be ported between different platforms, for example java's cross-platform, portability is stronger than the portability of the c language, because java is compiled into byte code with a compiler and the byte code is run with an interpreter, the same byte code can be run under different operating systems by different interpreters. Running hardware portability means porting between different hardware, such as an external hard drive or external DVD drive.\n\nCost vs. reusability\nFor example, many programming languages provide a large number of library functions to enhance their functionality. The user of a library function can call it as long as he knows the name of the function, the type of return value, the parameters and the function function. There are also a variety of templates (e.g. document templates, web templates, etc.) that can be used to build the corresponding software product relatively quickly.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1293649,
      "meta": {},
      "text": "1. Rapid development vs. functionality:\nDieser trade-off stellt eine schnelle Entwicklung ins Verhältnis mit der Funktionalität des Produkts. Wenn man sich das Ziel setzt das Produkt schnell fertig zustellen muss man eventuell Funktionalitäten weglassen oder diese werden qualitativ schlechter, da z.B zu wenig getestet wurde. Bei der Spieleentwicklung ist dieses häufig der Fall. Sogenannte Patches müssen oft an einer bestimmten Deadline veröffentlcht werden. Diese sollen das Spiel verbessern/ändern. Ist die Änderung der Funktionalität zu Umfangreich und die Zeit der Entwicklung zu kurz kommt es dann oft zu bugs oder Fehlverhalten des Programms. Auf der anderen Seite wissen die Spieler natürlich wann ein Patch kommt und das Spiel verbessert sich ständig, was das Spielerlebnis verbessert.\n\n2. Cost vs. robustness:\nProdukte möchte man immer möglichst Kostengünstig herstellen. Jedoch müssen bei weniger Kosten andere Aspekte des Produkts, wie die Stabilität und Robustheit in kauf genommen werden. Spart man bei diesen Aspekten kann es sein z.B bei Regen oder zu hohen Temperaturen das Produkt nicht mehr funktioniert. Handys sind hier ein Beispiel. In den letzten Jahren werden die Handys immer stärker verbessert. Es wird nicht nur Geld für bessere Funktionalität bezahlt, sondern auch für Bereiche wie härteres Displayglas oder Wasserdichte.\n\n3.Functionality vs. usability\nIn diesem Trade-off wird verdeutlicht, dass ein Produkt, welches viele und gute Funktionen hat nicht umbedingt geeignet ist, da die verwendung für den Nutzer ungeeignet ist. Je mehr Funktionen das Produkt liefert, desto unüberschaubarer und schwerer zu Nutzen ist es. Stellt man zum Beispiel Linux und Windows Systeme gegenüber, sieht man schon an der Nutzer Anzahl, dass Windows Systeme besser verkauft und häufiger genutzt werden, da diese einfacher zu verstehen und Nutzer freundlich sind. Kennt man sich jedoch mit Linux Systemen schon gut aus, weiß man, dass dieses Funktionalitäten bietet, die Windows nicht hat.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1296675,
      "meta": {},
      "text": "cost vs robustness\n\nMore robustness requires higher costs, because more work has to be put in to increase the robustness of a system. An example would be a project for a nuclear power plant, where high robustness is key. The software must work flawlessly. Therefore most of the costs will flow into robustness work and overall costs will be higher.\n\nrapid development vs. functionality\n\nIn order to be fast, rapid development demands focusing on principles and basic functionalities.\nThat means that more detailed/sophisticated functionalities may be left out of a project to save time.\nAn example would be a calculator app which should be developed within an hour. Only + and - and / operations are possible to implement in that time\n\n\nfunctionality vs. usability\n\nA system with too many functions can be less usable because the user is overwhelmed by the amount of possible actions of a system. An example would be a calculator program which features every possible operator at once. It would be hard to find simple symbols like + or -\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1299912,
      "meta": {},
      "text": "A first typical design goal trade-off is the opposition of cost and robustness. If a system will be developed with low costs, it is hard to maintain proper robustness. A great example for this is a system that takes lots of inputs from the user. Due to low development cost, the developers cannot be aware of and fix all defeciencies. Therefore it is possible, that many of the inputs from the user, are not checked for their correctness. Because of that the system is sensitive to wrong input from the user, which makes the whole system very fragile and not robust.\nAnother trade-off in design goals is functionality vs. usability. If a system is meant to have much functionality, it is hard to give it high usability as well. An example is a geometry application. The more functionality the developer(s) build in to the system, the harder it is for the user, to learn how the app works (learnability).\nThe trade-off between rapid development and functionality is also very common. A software system that is forced to be developed in a short period of time, will surely have lacks regarding functionality. This means, that if you are meant to develop a calculator application and only have one hour to do that, you will be to implement methods for basic operations. You probably though will not be able to implement matrix operations, square-root or qubic-root calculations and a graphical user interface for functions as well. Therefore the functionality of the system is limited due to the rapid development.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1302432,
      "meta": {},
      "text": "Typical design goal trade-offs:\n\n 1) the goal of fast and optimized code and readability on the other hand:\n\taltough it is possible to write doumentations, highly optimized code is by far more complex to understand \t\t\t\t\t \n        and therefore less readable. Especially in high performance computing this can be a challenging task to get a \t\t \n        good trade off between this two points \n2) low cost ~ and almost everything else for example robustness:\n\tachieving a low production cost will often lead to a shorter development time and therefore extensive \t\t \n        testing may be neglected and this will increase the risk of robustness issues\n3) backward compability and usability:\n\tusability may be worse if the development concentrates on backward compability instead of using new easy \t\t \n        to learn features",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1334223,
      "meta": {},
      "text": "A typical design trade-off is functionality vs. usability. The more operations an interface offers, the more powerful it becomes. But a large number of functions can be overwhelming or hard to learn, thus decreasing the usability. For instance, if you put all the differernt possible actions of a videogame onto the screen at the same time, the player might be confused and stop playing as it is too hard to unserstand.\n\nAnother typical trade-off is cost vs. robustness. If you want a solid product that can handle errors, it will lead to high costs. As the peaople making the product will have to work longer and harder, the cost naturally increases. If you give a development team a year to finish their work to be robust, they will deliver a better product than if you only gave them a month. But you will have to pay them for the extra eleven months.\n\nRapid developement vs. functionality also is a known design trade-off. If one focuses on fast development, the developers will only be able to add so much. Let's take look at scrum to further understand. If you are given four weeks to present a working program, you will not be able to implement the entire product backlog. The developers rather focus on the fundamental requirements, which would then make up the sprint backlog. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344121,
      "meta": {},
      "text": "For example, Photoshop on computer and Photoshop on phone. The one on computer has lots of functions and complicated interface. It is also hard to learn. Another one on phone has fewer functions, and it is easy to use. I think this is a trade-off between functionality and usability.\n\nLike some software which a user needs to log in. Some of this software have a two-step verification. If a user wants to log in with a different device, and if he turns on the two-step verification, he should use his old device to agree that the new device can log in. It is inconvenient but safe for users. If a software team wants to develop this kind of function, their software should be extensible and maintainable. So this is a trade-off among maintainability, extensibility, backward compatibility, cost and rapid development. Because more functions and better development mean more cost and long time development.\n\nAlso, some software products support different languages and support in different lands. But for different lands, the software should change because of laws and customs. For example, the decimal point ',' in Germany  and the decimal point '.' in some other countries. Localization and Cost is also a trade-off.\n\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344205,
      "meta": {},
      "text": "1) Functionality vs. Usability\nThis is the most common conflict when it comes to complex systems. This conflict may be caused by the system having too many possible functions, as well as by the system's functions being very complex for the users (not really user-friendly). A good example is programming platforms such as RStudio. There are hundreds of possible functions and methods for the users to use, but if you open its library, you'd be overwhelmed by the immense data storm that you'll face. In this case, they have chosen functionality over usability, because one can do almost anything, but is not very user-friendly.\n\n2) Cost vs. reusability\nThis conflict appears when the cheapest option is bound to one-time usage (or a very little amount of times usage), while the long-lasting option is more expensive. One good example is straws. Lately, many people are opting to buy metal straws, that are reusable, instead of the usual plastic/paper straws. However, these metal straws are way more expensive, plus the user must bear with the not really easy cleaning process.\n\n3) Rapid development vs. functionality\nThis is a huge trade-off that may be set off by time boundaries/deadlines. Many planned/wished functions might be put aside because the customer has put a deadline for the product and it would take more time to build them perfectly. An example is the bumpers game. The game is very simple, but it could have been done with way more complexities, such as phases, scenarios, car characteristics to be developed, etc. However, because of the rapid development time proposed, we've put those possibilities aside.\n\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1346007,
      "meta": {},
      "text": "- Rapid development vs. functionality:\nIf you want to program a new video game it is difficult to keep the balance between rapid development and functionality, because there is often not a real limit on how many features you can add. Because it takes more time to add new features the development is slower the more functionality you add. So when it comes to deciding if a new feature should be implemented you need to take the time it takes to implement the feature in consideration.\n\n- Functionality vs. Usability:\nIf you compare for example Paint with Photoshop, it gets clear that Photoshop is more powerful and has a lot more functionality, but it is a lot more difficult to learn than Paint. So Paint has better usability but Photoshop has better functionality. The challenge is to achieve both at the same time, because it is almost always a trade-off. A possible solution is to release different versions of the software. One with more functionality and one with less, which is also cheaper, so it isn't overwhelming for people who want to use only basic functions of the software.\n\n- Efficiency vs. portability:\nWhen you want to focus on efficiency you often need to program closer to the hardware on a lower level, because the things that make a language portable are also making it slower and you can not really take advantage of the hardware. Unlike languages like java low level programs such as assembly are not compatible with every operating system, cpu graphics card or other hardware components.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1392123,
      "meta": {},
      "text": "1) Functionality vs. usability\nMore functionality that you add to your software will often lead to over saturation, hence worse usability. As it's becoming harder for a user to interact with the interface. E. g. consider a TUMonline website: it has to offer functionality to all of the students, tutors and professors. \n2) Rapid development vs. functionality\nRapid Development is a process of generation of code that's fast, addaptive (and at the same time cheap). Using this development model a developer concentrates on the bare minimum requirements, thus excluding the obligation to improve functionality.\n3) Efficiency vs. portability\nIf the developer is required to make the most efficient program, he should be also be informed about the specific characteristics of a given device (CPU-architecture etc.), where the program is to be run. However when asked to write the most portable program one could forget about different computers' specifics and concentrate on similarities of systems, the more systems he can run his code on - the better. \n",
      "score": 100,
      "language": null
    },
    {
      "id": 1631444,
      "meta": {},
      "text": "rapid development vs functionality: Each added functionality takes time to implement and thus increases the development time. For instance \n\nefficiency vs portability: Some optimizations are platform specific (e.g. vectorized instructions), using them can drastically increase performance, but requires to target a smaller number of platforms\n\nminimum # of errors vs functionality: Adding features, and thus code, tends to increase the complexity of the software and the number of bugs.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1290856,
      "meta": {},
      "text": "Design goal trade-offs entstehen, wenn man verschiedene Design Goals (nicht funktionelle Anforderungen) hat, die bei einer Verbesserung von einem zur Verschlechterung des anderen führen\n\n1Bsp: Die Bewegungen und Graphiken werden in einem Spiel verbessert, was aber auch die nötige Leistung des Geräts, auf dem es abläuft erhöht. Es wird dadurch auf weniger Plattformen einwandfrei laufen können.\n\n2Bsp: Die Herstellungskosten eines Spielzeugs werden gesenkt, indem billigeres Material gekauft wird. Dadurch sinkt auch ihre Qualität und sie gehen schneller kaputt.\n\n3Bsp:  Der Zugang zu einer Website wird durch mehrere Sicherheitschecks geleitet, bevor man wirklichen Zugang zu einer Seite hat. Die Sicherheit der Website wird erhöht, während es länger dauert sie zu öffnen.",
      "score": 33.3,
      "language": "GERMAN"
    },
    {
      "id": 1291068,
      "meta": {},
      "text": "1. Functionality vs. usability\nPhotoshop is a software for image editing, it offers hundreds of professional, but complex opreations, which leads to bad usability. Normal users prefer use Instagram or shapchat, which offers easy operations. Avoid making users remember information.\n\n2. Cost vs. robustness\nInstagram has multiple redundant servers to give response to all users' requests, whichs costs lot of manpower and finance. At the same time, it increases the robustness of the system and\nhelps the system stay online.\n\n3. Cost vs. reusability\nA online-drugstore-App for Garching costs less than a online-drugstore-App for Munich. The latter requires higher code reusability.\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1376096,
      "meta": {},
      "text": "Functionality vs Usability - with grows of functionalities the application can become more complicated for the end-user, therefore a \"the golden mid\" should be found between what is really needed for the end-user and usability \n\nCost vs robustness - every software development process requires continuous financing: therefore if you want to improve robustness you need more time for development and therefore higher costs, if you want to improve robustness with hardware, you need additional investments, which increases costs \n\nRapid development vs functionally - in order to improve functionality of the system more time for development should be spent, however it is in conflict with time of the delivery of the solution ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1646637,
      "meta": {},
      "text": "(inspired by my own solution from last year)\n\nSometimes you have to decide between 2 different design goals to achieve the optimal solution.\n\n1. Cost vs Reusability:\nthis trade-off looks at the 2 aspects of cost and reusability. On one hand, we want to optimize ourselves so that our costs are minimized, but on the other hand, we want to be able to reuse the resources we have obtained. A sample example for this would be masks. We all are still obliged to wear masks in specific areas. There comes the choice between 1-time use surgical masks, or the reusable ffp2 mask. One is cheaper and can be bought in bulk, while the other is reusable.\n\n2. Functionality vs Usability:\nThe two aspects considered here are functionality and usability. The functionality offers the user many different things he can do, but going overboard here can really overwhelm them and decrease the usability. An example would be the menu card of a restaurant. The owner has to decide whether he wants to have a great variety of dishes, or whether he'd rather offer a specialized menu. On one hand, the chef only needs to prep for specific dishes and can increase their quality while on the other hand, we have a greater variety the customer can enjoy.\n\n3. Efficiency vs Portability:\nEfficiency delineates with which measures the \"power\" of our system can be increased and possibly hinder the overall portability of the system. An example would be the case of laptops and PCs. A PC is on average in the same price spectrum a lot more powerful due to there not being the constraint of limited space a laptop has. A laptop is, therefore, more portable due to it being compact but this definitely affects its power/efficiency.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292297,
      "meta": {},
      "text": "Für jede Software wird man die für sich wichtigsten Design Goals bestimmen müssen und akzeptieren das, wegen so genannte Trade-offs andere nicht komplett erfüllt werden können. Im folgenden werden einige erklärende Beispiele dazu gegeben:\n\nEin einfaches Beispiel ist Maintainability gegen rapid Development.\nWenn ein Entwickler ein sauber, einfaches Wartbares System schreiben soll , dann benötigt er dafür mehr Zeit, weil er gelegentlich Code refactor muss, Modele auf den neuesten Stand bringen und so weiter... . Die Zeit die er dafür extra nehmen muss steht direkt im Kontrast zu einem möglichst schnellen Projektabschluss.\n\nEin weiters Trade-off ist Functionality gegen Ease of Learning\nEin gutes Beispiel für diesen trade-off ist LaTeX. Man hat durch eine scheinbar unendliche große Menge an Kommandos die besten Möglichkeiten eine formelle Arbeit zu schreiben. Man findet in fast keinem Textverarbeitungsprogramm mehr Funktionalität. Der sich daraus ergebene Nachteil ist das man als Benutzer sehr oft Googlen und ausprobieren muss, damit LaTeX das tut was man will. Das Ease of Learning wurde durch die zahlreichen Funktionalitäten eingeschränkt.\n \nDas letzte Trade-off ist zwischen low Cost and Minimum Number of Errors.\nDie Zeit jedes Entwicklers muss bezahlt werden. Low Cost hat also das Ziel möglichst wenig Zeit der Entwickler in Anspruch zu nehmen. Ein Gebiet wo man diese gut minimieren kann, ist das zeitaufwändige Testen und das darauf folgendes debuggen. Wenn wenig getestet wird, hat man meistens unbemerkte Fehler. Es ist also schwer möglich wenig Geld auszugeben und möglichst wenig Fehler zu haben. ",
      "score": 75,
      "language": "GERMAN"
    },
    {
      "id": 1297293,
      "meta": {},
      "text": "1: Two design goals that will often collide with each other are Rapid development and a minimum amount of errors and bugs, so even if the client would like a software to be ready or finished in a few weeks, it will likely take the developers some months to find and fix most bugs.\n2. Functionality and ease of learning may often also collide, a program which has a lot of functionality, like for example photoshop, takes a lot of time to learn even the basics of all function due to the amount of them.\n3. Security and runtime efficiency can be in conflict if it takes a lot of computing power to securely perform certain tasks, one example would be the blockcain tecnology which uses a lot of computing power and energy to certify every transaction",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1334795,
      "meta": {},
      "text": "a big desing goal trade off is usually Functionality vs. usability, the more functiuallity a system has the harder it is to learn how to use or where to find functunalities. e.g. in MMORPGS the playebale characters have a lot of abilities, somtimes more then 10. it takes a lot of time and practice for the player to use all these abilities. \n\nanother trade off is Rapid development vs. functionality. it is simply not possible to develop a lot of functions in a short amount of time. e.g. in the gaming industry the programmers are under a lot of stress, because the users expect the game to be out as fast as possible. this leads to a lot of bugs and some functunalitys missing. for example No mans sky was very rushed, the developers promised a lot of funktions, for example being able to meet another player on a planet by chance, so every planet is vistable by everyone, because the launch was rushed a lot of these functionalities had to be added after release.\n\nthe last tradeoff we are discussing today is Efficiency vs. portability. a system can be optimized for a certain type of computer. e.g. games made specifically for consoles are very optimized for the console, wich means that they can run a lot smoother for those consoles, but are also only playebale there.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344069,
      "meta": {},
      "text": "1. Cost vs. robustness\nReducing the cost of a product leads to lower robustness of the product. For example, if the client reduces the amount he is willing to pay, the developer has to cut costs at some point and could build a less robust product for a lower price.\n\n2. Rapid development vs. functionality\nThe developer needs a certain time to develop each feature. If the client moves the deadline for the finished product to a closer date. The developer has less time for each feature than planed. He probably won't be able to deliver the product with all expected features, reducing the functionality.\n\n3. Efficiency vs. portability\nIn the case where the client demands maximum time efficiency, and the developer optimizes the product for specific hardware and writes in a hardware-oriented programming language such as C. Portability is limited. since the product won't run as efficiently on different machines and other platforms.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344379,
      "meta": {},
      "text": "Rapid development vs. functionality:\nIf there is a need for rapid development, often the functionality of the application suffers which is simply due to the lack of time. An example is the Corona Warn app which was developed within a month but it took more than a year before you could scan your digital vaccination card. This is because the developers' immediate focus was contact tracking, but the functionality for the user was secondary.\nThis was also reflected in the fact that at the beginning only German and English were available and only in the course of time it developed to now 20 languages, which may have limited functionality for some users.\n\nEffiency vs. portability\nEfficiency and portability are at odds with each other in that focusing on one (a few) protocol(s), one (a few) language(s) leads to faster processing. Portability, on the other hand, expects the ability to respond to different languages/protocols, which can lead to delays in translation/processing.\nAn example is macOS, which in itself runs highly efficiently but also seals itself off from the outside world with portability, denying users features compared to Windows.\n\nBackward compatibility vs. readability\nIf the software should also function for older versions of the hardware/software this influences the readability of the code, which is due to different programming needs of the systems. Example here is also MacOs which runs since last year on the one hand Intel based but also on the new computer architecture Apple Silicon - which is why there are now two different versions of many programs.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344487,
      "meta": {},
      "text": "1.) Ease of learning vs. efficiency for professional users\n\nThe easier and self explanatory a software is the less efficient it might be for very professional users that already know the tool and want to use a minimum number of interactions with a maximum of efficiency. A typical example is the text editor \"vi\" which is very hard to learn in the first place but becomes a very efficient tool for those who already learned it. In contrast the editor \"nano\" focuses more on the ease of learning.\n\n2.) Functionality vs. cost\n\nEvery new functionality needs to be modeled, implemented and tested. All these things need resources and time which eventually increase the cost. On the other hand customers might decide against extra functionality in order to reduce cost. One example is the open source software LibreOffice that offers less functionality than Microsoft Word because it has a smaller budget (among other reasons).\n\n3.) Portability vs. maintainability\n\nIf many platforms should be supported, e.g. many different browsers, Desktop and mobile platforms, ... it becomes harder to test and maintain all configurations and to keep track of changes. E.g. if a web browser gets an upgrade, which effects the functionality of our website than it might be necessary to react. However, different web browsers might have different distinctions which makes it harder over time to support all configurations and versions a user might have.\n\n ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1535790,
      "meta": {},
      "text": "-Usability: is the easy of use of an interface.\n-Functionality: is the set of operations that an interface supports \nUsability Vs Functionality :\nthe Intellij IDE has a lot of Functionalities, so the user even the beginners faces difficulties to know all of them and handle them, so when we omit some functionalities it will be easy to use.\n\n-Reusability: Goals related to reuse of a product such as a battery that can be integrated with solar power systems.\n-Cost: Targets for a unit cost or operating cost.\nReusability Vs Cost :\na client has his own website and he want to make a change with the payment-mehtod and add neu one ( Paypal ) so the cost increases because you have to write an API that supports multiple payment-methods.\n\n- Portability: deals with moving the component from one environment to another.\n-Efficiency is defined as the ability to produce something with a minimum amount of effort.\nPortability vs.Efficiency :\nWe want the game ( ex Bumpers )to be platform independent which means that we will have losses in efficiency. For maximum efficency resource usage must be minimized which is not possible as high conversion effort arises when designing a portable game.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1640539,
      "meta": {},
      "text": "1) Efficiency vs. portability: Incase we build a system with a top notch efficiency but only for a particular Operating system , the portability suffers in this case. To ensure portability to multiple operating systems and environments , the system maybe would not be as efficient as in the previous case. \n\n2) Cost vs. robustness: In order to be able to build a highly robust system, generous amount of both cost and time investment would be required. If we want to minimize the cost, we need to somewhere compromise with the robustness of the system design.\n\n3)Rapid development vs. functionality: If we go with the rapid development approach, there is a much lesser emphasis on planning tasks which in turn can , in some cases , lead to a poor functionality. This is also one of the most challenging Trade-offs.\n\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1658514,
      "meta": {},
      "text": "Design goal trade-offs as a classic issue of software engineering. When writing a code, we will always face the problem of time vs. space. Applying pre-computed values takes up lots of space. When trying to minimize the area, it could lead to an extensive use of valuable time. \nThere may be greater range on the larger photograph, however the biggest one is sort of constantly implementation time vs. capabilities, wherein capabilities are a huge bucket. It takes greater time to create something very popular and reusable, it takes extra time to make something extremely performant, it takes greater time to add all the person-dealing with capabilities that have been requested, and so on. \nBoth cases involve knowledge no longer than what is requested, but what the desires for the answer are, due to the fact that’s what's going to decide the candy spot for the software program to be built. \nAnother trade-off is the question of flexibility vs. simplicity. Some systems request to have a wider range of flexibility and expandability built into them because you’re starting with the kernel of an idea and it’s going to get bigger. Others virtually require a straightforward implementation with repeated reminders of something you are not going to need.\nImportant to mention is also that when minimizing risk while setting up the groundwork to address the negative side of the compromise,  trade-offs are the most successful.",
      "score": 8.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344227,
      "meta": {},
      "text": "functionality vs. usability:\nis one of the most prominent design trade offs, because one can always add features and additional functionality to a product but at some point there are so many things to use that it becomes unusable.\nAn example could be a maps service in the direction of google maps. Maybe a user wants to search for restaurants and now also want to reserve tables and another one wants to order tickets for a soccer game. All things that could be done add functionality, but in the end make the system less usable, because it's so bloated of things.\n\nefficiency vs. portability:\nOften times it its possible to create an application that is very optimized for one system, let's say a new M1 Macbook. But now you also want to use it one a Mac with an Intel chip. Here you have to trade between being very optimized for one system or being able to be used on another second one, in which case you usually can't optimize your to architecture and loose some efficiency for portability.\n\ncost vs. robustness\nDevelopment of software products is many times on a very tight schedule often for cost saving measures. Because more time would equal having more development costs and not having a product on the market. Because of this corners have to be cut. And these corners often lead to instability in the system.\nAnd example could be specifically the testing of the security features. Maybe there wasn't enough time or not an expert(who would have cost more) and then when the product is launched some hacker or so brings the system down.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344405,
      "meta": {},
      "text": "One typical design goal trade-off is functionality vs. usability. Here you have to wager between having as many functionalities in as possible/as you like while still mainting a clean user interface or at least easy ways to reach those functionalities. If you for example program a calculator for your phone, then you have to decide how many different calculation operators you want to include before the calculator becomes too complicated to use.\nAnother trade-off exists between rapid development and functionality. Here you can either quickly develop new functions and get onto the next one to quickly have a usable product, or you can focus on certain functionalities and improve them up to perfection. An example would be one of the many mobile games built to capture the attention span of the broad audience for a couple of weeks before becoming insignificant again. Here, the developer focusses on a quick development of the app to get it quickly into the app store but thereby does not invest a lot of time into functionality which leads to a game that looks nice at first glance but turns out to be flat regarding its functionalities.\nThere is also a trade-off between cost and robustness. On the one handside you want to pay as little as possible for the development of the system but also want it to be as robust as possible. If you use a Microsoft product, lets say Teams, then there is almost no serious competition for that program. That leads to a full focus on cost and only a little need to provide a robust system because investing in that would cost money and time and effort.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344508,
      "meta": {},
      "text": "The first trade of emerges from functionality vs. usability. If you want to create a software that covers a lot of functionalities it often leads to less usability. Lets say you create an interface. If there is 100 functionalites it  will be very hard to fit them on to the page. Also sub categories will be long and not easy to search through by the user. Often users will not realize the full power of the software due to the volume of functionalities.\nCost will often conflict with reusability. If you want to lower cost you will taylor your program to your specific needs. There may be an API that lets you connect your software to other systems but often it is the cheapest to just write code that fits your needs. If you would make it more abstract you could reuse it in other scenarios by adjusting it slightly. However this will need more time and therfore increase cost. For example you could either design a payment system specifically for your web shop or you could create a payment system that is not taylored to the web shop but uses an api that lets you connect it to mobile apps etc as well.\nOften you also have to decide between cost and robustness. Suppose an app is only used by trained employees that will adhere to the use guidelines. Also the app is not visible on the internet since it is only connected to the intra net. This app can therefore be developed less carefully and you do not need to pay to much attention to edge cases and hacking attacks. This saves time and money but increases error rate when used by untrainied new personal.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344612,
      "meta": {},
      "text": "A design trade-off in software engineering is a process of losing a certain quality of something in order to gain another quality.\n\nCosts vs. schedule:\nProduct owners have the option to either get the result sooner or later based on i.a. their willingness to pay more or less. \nE.g., a project would take 1 year to be completed by 2 developers. If 2 developers were added, it would take just 10 months, and an additional developer would reduce it to a total of only 8 months. Adding a developer for a shorter development period comes with obvious salary-related burdens which eventually need to be covered by the client or end-user.\n\nFunctionality vs. performance:\nProducts with many more functionalities tend to be less performant and slower than their respective less functional variants. \nE.g. in e-commerce, one can build a website with special features like images rotating 360°, full-HD videos, accessibility to disabled users, etc. to attract more customers. But such features usually reduce site performance and result in longer render times, potentially frustrating impatient customers and thereby lowering turnover.\n\nSchedule vs. quality:\nOften, software products have bugs or parts with potential for optimization. \nIt would take a lot more time to develop a game with no user-noticeable bugs than one that is filled with more bugs. By opting for the latter, losing customers due to bugs is foreseeable. By doing extensive testing, one may lose impatient customers.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344743,
      "meta": {},
      "text": "1. Angenommen, man hat ein delivery-date gegeben, an dem das Produkt fertig übergeben werden soll. Jetzt ist das nicht möglich, dann besteht ein Trade-off zwischen der Fertigstellung des Produkts oder der pünktlichen Abgabe. Entweder gibt man pünktlich ein unfertiges Produkt ab oder verspätet ein fertiges.\n\n2. Der Produkt owner will das Produkt möglichst günstig und gleichzeitig aber qualitativ hochwertig produzieren lassen. Aber ein \"fehlerfreies\" Programm bedingt zb eine Menge Testing, was Zeit und somit Geld kostet. \n\n3. Das dritte Beispiel ist ein Trade off zwischen usability und funcionality. Man kann die Universitätsapp aus den Tutorstunden mit sehr vielen nützlichen Funktionen ausstatten. Allerdings kann es dann schnell unübersichtlich werden oder viele Klicks von einer Funktionen zur nächsten benötigen.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1292104,
      "meta": {},
      "text": "Functionality vs. Usability\n\nUsability refers to a user's ability to interact with a system via an interface. The collection of operations that this interface provides is referred to as functionality. Usability and functionality are frequently perceived as a design trade-off, because a user interface with a great number of capabilities is difficult to learn and use.\n\n\nRapid development vs. Functionality\n\nRapid Application Development is a software development methodology that emphasises rapid prototype and feedback. This helps to ensure that the final product is more quality-focused and meets the needs of the end-users.\n\nThe customer was allowed to provide feedback on what functionalities were necessary throughout the development process. All of those features were quickly added as and when they were requested, and the product was eventually provided to the client; however, because the functionality was built at such a rapid pace, the quality and complexity suffer.\n\n\n Portability vs. Efficiency\n\nEfficiency is essential for a good system, because efficient software does not waste CPU cycles,  It makes extensive use of the hardware while frequently ignoring portability concerns. Although efficient software appeals to purists, the benefits of executing the software on a variety of machine architectures tip the scales in the opposite direction.The reason is more financial than technical: in today's computing environments, software that runs on only one architecture sharply limits its potential marketability.\n\nhttps://kissflow.com/low-code/rad/rapid-application-development/ \nhttps://technative.io/overcoming-the-trade-off-between-quality-speed-and-cost-in-software-development-with-ai/\nhttps://flylib.com/books/en/2.506.1.28/1/#:~:text=Efficient%20software%20doesn't%20waste,and%20specialized%20floating%2Dpoint%20instructions.\nhttps://arxiv.org/pdf/1608.04336.pdf \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1316357,
      "meta": {},
      "text": "A typical design goal trade-off would be low costs <-> fault tolerance because less cost usually means that there is less time that can be invested in software development especially in the testing part. So when a customers budget is not sufficient for the requirement software testing procedure, there will be some issues that could not be located and will be kept in die final product.\n\nAnother classic trade-off is functionality vs usability because as the range of functionalities and the flexibility of a system increases, the usability of the system decreases because the complexity simply increases. If you design a software that only covers 5 use-cases, the system should be relatively easy to use for the end-user but therefore the software does only cover these 5 use-cases.\n\nThe third trade-off I want to mention is the cost <--> maintainability trade-off. The most important thing, if you want to make a software maintainable, is a good and complete documentation, which needs a lot of time to create. Which refers to the problem mentioned during my first trade-off: If the budget is simply too low to make the developer invest time in creating these documentations needed, maintaining the software will be harder in the future.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1327705,
      "meta": {},
      "text": "A software project involves stakeholders of incompatible interests(e.g. client, enduser, developer)which leads to compromising and choosing a goal over another. Examples of such tradeoffs:\n\nFunctionality vs. usability: The product of a software project is presented to an average enduser who isn't able to get used to a large number of (complex) operations. But offering a bigger set of functionalities makes the app more powerful and interesting for certain user-categories. When developing a text-editor app, is it better to offer a large set of operations to allow flexibility or limit them to keep the GUI simple/user-friendly?\n\nEfficiency vs. portability: Developing an app to run on multiple platforms contradicts with the development of consistent, efficient and secure functionalities. A cross-platform shopping-app shouldn't have different functionalities on androids and iPhones. The app must deliver a consistent look and user experience, which requires heavy testing. And if I open this app on Chrome incognito mode, are transactions still secure? \n\nCost vs. robustness: The contradiction between considering uncertainties and (rarely-occuring) edgecases which may require the change of code, introducing other technologies and testing and the fact that these require money and time. If I develop an app for connecting earphones to the computer and an edgecase like leaving the earphones connected while turning off the computer may cause the earphones to persist in a turn-on state, is it better to invest money and time to solve this issue or should I ignore the problem due to its unprobability?\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1336022,
      "meta": {},
      "text": "Cost vs. functionality\nClients always want their product to be able to do a lot of things, but they don't want it to cost a lot. \nA library might be an example for a client who would want their software to manage all kinds of things such as: book checkouts and returns, employee work days and -hours, new book orders and a detailed history for all of these things. And while the library might want all of these things, they don't necessarily have a budget that allows for the development of such a system.\n\nEfficiency vs. portability\nObviously code can only run really fast if it uses all the advantages of the hardware it is executed on. But when you want your code to run on lots of different hardware, optimizing it for each and every processor is impossible.\nJavaScript is quite a slow language if compared to certain others such as c or c++, yet it is extremely widespread. And that is for two reasons: For one, it operates at a higher level than c(++) which makes it easier to use, but more importantly, pretty much every single machine can execute JavaScript code.\n\nRapid development vs maintainability\nIf the development of a system has to be rushed, maintainabilty usually suffers, and if you want a maintainable system, you will need to spend more time planning.\nAn example where this comes heavily into play is prototyping, where you usually don't care about maintainability in favour of quick development. That isn't necessarily bad tough, because prototypes are made to be thrown away after having fulfilled their purpose.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344483,
      "meta": {},
      "text": "Backward compatibility and readability are a typical tradeoff because as you keep updating backwards compatible code you end up having more and more redundant code in your program in order to be backwards compatible which ends up making the code harder to read.\n\nTime, money and functionality are a threefold tradeoff.\nIn order to implement more functionality you either have to increase the budget of the project or allocate more time to it.\nIf you want to reduce the cost you either have to increase time allocated or cut down on functionality.\nIf you want to develop the application quicker you have to either reduce functionality or increase the budget of project.\n\nEase of learning and functionality are tradeoffs because the more functions an applications has the easier it is for the end user to be overwhelmed by it and struggle to understand how to use the application.\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344742,
      "meta": {},
      "text": "1. Performace vs. Robustness\n\n   Many software engineers face the question: which design goal is more important in the project, performance or robustness. They must find a stategy to balance between them. As I explained in previous week homework \"H03E01 Bumpers Nonfunctional Requirements\", developers can introduce some restrictions (on a game board can be max. 25 cars at the same time) to avoid application crashes by collision evaluation. \n\n2. Portability vs. Functionality\n\n   Another problem, that developers (web designers or game developers) can face too, is portability or fuctionality. How to port for example a game from PC/console version on mobile version without losing most important functions? For instance, at the start of develop a developers' team choose to create a game with simple functions, that can be ported without any problems (corona time bestseller \"Among us\"). Or they can create a complex functional game for PC or console (Call of Duty) and then port it on mobile version (Call of Duty: mobile), but simplify most functions.\n\n3. Low cost vs. High efficiency\n\nHow to create a product, that works effectively, but client wants to pay low price for its develop? That is another trade-off between client and developer team. Client must understand, that low payment for the develop leads to rejection of developers work.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1392011,
      "meta": {},
      "text": "The three different types of design goals stem from three different perspectives (the client, end user and developer perspectives). Design goals can coincide but also contradict each other which requires for tradeoffs to be made. \nSo, while it would be nice to have reusability and low cost as design goals, reusability incites additional coding and testing costs, with goes against the notion of low cost.  \nAnother design tradeoff would be choosing between backwards compatibility and modifiability because upholding compatibility comes at the cost of needing to support ever aging interfaces and code that should already be deprecated, increasing the rubbish that needs to be accounted for when changing something. \nEfficiency and potability is another common design goal tradeoff. Writing efficient code often times requires hardware specific knowledge and optimizations that cannot be easily ported to other hardware, inevitably decreasing portability.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1539940,
      "meta": {},
      "text": "Like the sayng: You loose some, you get some - in software development most decisions have some positive and negative effects on the system. \nFor example if you choose a simple an clean UI with very few buttons for an application with a lot of options - all the possible settings need to be hidden away from the users in a lot of sub menus. This can have an impact on the user friendliness.\nFurther if the goal is to minimize the cost of a software project and  just implement the bare minimum to get a usable product, functionality and security might be sacrificed. And finally if a project focuses on performance to gain the maximum out of the hardware its running on portability gets sacrificed, because to get these gains abstraction needs to be avoided. And therefor the software is more and more hardware dependent",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1659251,
      "meta": {},
      "text": ". Rapid development vs. functionality : either develop a basically functional software within a short period of time that can be used on base cases or take more time to test it, make it more robust and guarantee a better functionality of it.\n\n. Functionality vs. usability : develop a functional software without a gui interface or a facade where all the functions are presented to the end user vs making sure it's easy to use by providing a facade for example \n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292660,
      "meta": {},
      "text": "Functionality vs Usability: \nA particularly important consideration when it comes to design goal trade-offs, especially for the end user. In general, this is the tradeoff where adding options (functions) to the system/product tends to make the system/product more confusing/less usable\nAs an example, the user interface for Artemis could be considered very usable with little functionality (customization) for the user. There are only several options in the top right corner of the interface for the user to choose from, including dark/light mode, and the language. Were we to increase functionality but decrease usability for the user, we could add countless more options that could (theoretically) improve quality of life, such as font choice, settings for reminders, etc. But this may eventually become unübersichtlich for the user\n\nBackward Compatibility vs Readability:\nThis is the trade off of adding new code to a system instead of updating the code which ultimately leaves old code that allows a product to be run on previous devices. Especially after several iteration of doing this, one must parse through more and more variants of the same code to find what they're looking for\nFor example a 64 bit program that is also 32 bit compatible likely has redundant code when being run in a 32 bit system, as the code specific to 32 bit is unused, ultimately making the code harder to read through\n\nRapid Development vs Functionality:\nThe trade off between rapidly developing a product and making the product versatile\nThere are often times where developers must adhere to a limited time frame when developing a product, requiring them to omit implementing certain functionality that they deem to potentially be unnecessary. The product will be developed quicker, but may be lacking in functionality \n\n\n\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1296304,
      "meta": {},
      "text": "Compatibility vs Stability/Performance:\nThe first example many people can think off is the stability of IOS applications vs Android applications. The reason is the hardware standards provided by Apple for the software developers. Android apps, just like the operating system, are used in a wide range of phones, tablets, and many other media devices, therefore it's not easy to test the applications on all the platforms. Also two different smartphone brands may require different minor tweaks in-app for better performance. So it'll always be a challenge for the developer to have wider compatibility and better performance/stability at the same time.\n\nDelivery time vs Measurability:\n(for all database-involved applications) Let's say we're developing a bookstore management software and creating a database structure as well. We can enter only the name and address fields for customers and book names and publishers for the books. With only these data, it'll hard to make a detailed sales analysis. However, if you also add age, gender, education, etc. fields for the customers and genre, author, origin, etc. for the books, you can analyze much better. You can send your newsletters to more accurate reader groups, you can decide how many books you should order when a new release comes, and you can have much wider opportunities. But on the other hand, employees who enter the data into the system should spare more time to keep it usable too.\n\nPrivacy vs Efficiency:\nThis is also a recent problem. Lots of apps want to track the activity of their users in order to increase service-quality. On the contrary users don't want their private informations to be collected and they prefer to use apps anonymously.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1332024,
      "meta": {},
      "text": "\n1) Funktionalität gegenüber Benutzerfreundlichkeit:\n    Software benötigt ein Ausgleich zwischen Funktionalität und Benutzerfreundlichkeit. Programme, die wenig Funktionalitäten haben (Bsp: Bankingapp: Überweisen, Karte sperren), sind meist sehr benutzerfreundlich, haben jedoch zu wenig Funktionalitäten. Programme wie Photoshop überquillen nur so mit Funktionen - die Benutzerfreundlichkeit ist dabei nicht mehr gegeben, da man erst Kurse besuchen müsste, um die meisten Funktionen zu verstehen, finden und anwenden zu können.\n\n2) Abwärtskompatibilität vs. Lesbarkeit\nSoftware sollte in alten Versionen /Betriebssystemen weiterhin funktionieren, d.h unterstützt werden. Gleichzeitig birgt jede neue Version auch mehr arbeit & mehr Einschränkungen. Als Beispiel sollten Programme wie Spotify auf dem Computer für Windows 11,10... , x86, x64 PCs funktionieren.\n\n3) Schnelle Entwicklung vs. Funktionalität\nDer Softwaremarkt ist ein sich wandelnder Markt. Entwickler sollten Software sehr schnell, da sie sich auf aktuelle Trends bezieht / der Auftraggeber seine Software möglichst schnell haben möchte. Dabei steht Geschwindigkeit mit Funktionalität im Gleichgewicht - Mehr Funktionalitäten => Mehr Zeit investieren, Weniger => Schneller\nWenn eine Software nur 10 mittelschwer Umsetzbare Funktionalitäten hat, braucht eine vergleichbare Software mit 15 mittelschweren Funktionalitäten eben länger...",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1334878,
      "meta": {},
      "text": "1. Efficiency vs. Portability\nOne typical design goal trade-off is efficiency vs. portability. That means, that you can improve the performance of your software, if you sacrifice portability and vice versa. You can do that by using specific methods or features of an operating system or hardware, that improve your performance, but now you require this specific operating system or hardware thus it is not that easily portable to other platforms. E.g. you can develop a native Android app or a hybrid app with a framework like Ionic. The native Android app will be more performant, but the Ionic app can easily be adapted to iOS.\n2. Backward Compatibility vs. Readability\nThese two are also a design goal trade-off. You can develop your system to only support newer operating systems, hardware or other underlying software. This way you get the cleanest code. If you also want to support older software, then you can not use newer syntax or methods, which leads to a messier code. For example if I not only want to support Windows 10 but also Windows 7, then you often have to make case distinctions, beacause you have to implement a certain feature with the tools, that Windows 7 provides, and again with Windows 10 tools.\n3. Functionality vs. Usability\nThe more functionality you add, the harder it gets to provide this functionality to the user in a clean and easy to use interface. E.g. if you develop a calculator with only the basic operations +, -, * and / it will be easier to use then if you provide all the features of a scientifiy calculator, as it is harder to find what you are looking for.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344216,
      "meta": {},
      "text": "Functionality vs. usability:\nA Tesla is a great car and is more functional than every other car. You can browse the Internet, watch netflix, play games, sing caraoke or just drive around. When driving you can choose the Power distrubution on the front and rear axis. You can switch off the ESP and choose the power of recuperation. On the other side you have can drive the car for more than three years without even trying out all the posibilities, which leads to a feeling of being overwhelmed.\n\nCost vs. reusability:\nOften its cheaper to develop a System to solve a special task, like finding the closest chinese restaurant. But in case the developerteam wants to expand its product for italien restaurants and didnt implement the code to work restaurant names written in Latin charackters. So in this case it takes an aditional process to restructure the code to accept Latin Charackters too.\n\nBackward compatibility vs. readability\nSome applications like whatsapp stopped to support older versions of IOS an Android. Thats due to the conflict between Backward compatibility and readability. a newer operatingsystems are more efficient with different code. Companies have to decide how long they want to support older OS. It is not easy to write code that fits the new and the older OS. So the companies have to decide weather they want to write hardly readable code to fit all the OS or to employ more developer to retro fit the code.\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344417,
      "meta": {},
      "text": "A backwards-compatible product will inherently suffer from a reduced level of user-friendliness. For example, web-technologies such us pure JavaScript or CSS need to work on all browsers and because there still are users out there who use Internet Explorer 9, programmers need to use special, more obscure functionalities and attributes, in order to be sure that their product will work on all browsers. In this example, JavaScript or CSS are the products which traded off user-friendliness, the users being the programmers, and backwards-compatibility.\n\nA low-costing product will lack functionality. Comparing LibreOffice to Microsoft's Word we can see how LibreOffice, the free alternative to Microsoft's Word is behind Microsoft's Word as it is trying to emulate the same functionality however the people working on it do not have the same founding that Microsoft offers for the Microsoft Word team.\n\nA rapid development might hinder the writing of a proper documentation. Linux' X11 API is famous for the lack of documentation and the lack is mainly caused by the fact that the API was developed a while ago but also by the fact that the development of the API was hurried, as Linux needed a way for its users to create windows and do general graphic computation as fast as possible.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1347064,
      "meta": {},
      "text": "Usability vs. Functionality: there is always the question what is more important for us that the software is easy to use or that the software has many different functioFOr ns. For example the programm Adobe Photoshop, for the standard hobby photographer this program has way to much functions so for them the usability is pretty bad, because all the different functions makes it to complicated. For a professional photographer in contrast the usability is pretty high and the functioanlity good maybe for some already to less. So we always have to ask us, who is our main target group and than we can think about what is more important functionality or usability.\n\nCost vs. Robustness: We always have to find a compromise between robsutness and costs, if we have more time or more money which we can use to develop a software system usually we can make it more robust. On the other side when we don't have so much money for the product the code is getting easier, less robust. In this case we have to ask ourselve who will use the software in which surroundings. A system to control planes at an airport for example should be better robust than easy.\n\nCost vs. Reusability: There has to be always a compromise between costs and Reusability, usually if we want a high reusability the costs for developing a software are getting higher, because it needs more interfaces for different environments and also should be easy to modify for a new environment. For example the plane system again, a different airport could need a pretty similar system to another airport. So we have to ask ourselves again, who is our main target group, and are there possibilities to reuse the system for another customer? \n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1390458,
      "meta": {},
      "text": "One typical trade-off is between cost and resusabilty. Because the cheaper and simpler you implement a certain method, the less likely it is to be used for another purpose. For example I once had to make a labyrinth solver which I coded to work on certain types of mazes. This was quite a bit simpler and took less time than making one which works for every case, but consequently, I couldn't solve other kinds of mazes. \n\nAnother typical trade-off is cost vs. robustness. Since the functionalities of a system have to be developed no matter what, it sometimes happens that parts that are only concerned about the keeping the system running in special situations get cut for budget. E.g. with a lot of new games, it seems like they have to cut costs or at least time but still have to offer most gamemodes. This often leads to buggy, lagging and crashing games which frustrates the players. \n\nThe last trade-off that seems quite typical is between  functionality vs. usability. This happens because a lot of functionality is added but the user can't really maneuver within all of these functions and gets overwhelmed. For example a washing maschine that has an uncountable number of programs and options might make it harder for the user to actually get the stuff done that he wants to do, which is washing his clothes.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1477567,
      "meta": {},
      "text": "1) Functionality vs. usability \nSometimes there are systems with hundreds of functions, and in such cases the question always arises whether such systems are practical for use.  For example, take the systems that are used by person. \nOf course, when hundreds of functions are present in the system and each of these functions makes its own output(not similar to another), then it is not practical to use. Because it’s easier for a person to remember several complex functions and what they are responsible for than learn how to manage a system with hundreds functions.\n\n2) Rapid developments vs functionality\nThe rapid development can lead to a not-well-functioning system but if you take time your time then you can implement more functionality.\n\nFor example, while programming a game... If you take your time, then new hardware and resources come out and you can make the game even better and implement more new features.\n\n3) Cost vs.  robustness\nA low cost design does not check for errors when the user enters wrong data or or when the user is theoretically right, but the system does not understand this.\n\nFor example, in some online test, some question is asked and written, answer by writing Answer: (Yes or No). One of the users wrote \"Answer:Yes\" and forgot to put a space after the colon. The system shows that the answer is not correct and the correct answer looks like this - \"Answer: Yes\".  The same answer, only with a space.\n\n\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1488010,
      "meta": {},
      "text": "Cost vs Performance/efficiency: probably the most important design goal trade off, keeping the cost low either results in less or worse programmers or less time invested into said project. This leads to worse code an increase in bugs and overall poor software, this can especially been seen in performance.\n\nScalability vs. Cost: another trade-off regarding cose the downsides and results of lowering spending are already described above, another result of this is less scalability. In general lower cost results in only the completion of functional requirements, non functional requirements like scalability often fall under the table since they are not top priority.\n\nEfficiency vs time to market: if a project has a short time frame, because of low time to market. Making optimisations in your code takes a lot of time, as does writing code in time efficient languages like C or even assembler. If theres only a short timeframe, tradeoffs will have to be made.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1493115,
      "meta": {},
      "text": "1. Functionality vs. Usability:\nPreviously the systems which were heavily loaded with functions and features were seen to be the best. Over time this has drastically changed to the current systems being less complicated and having a more simpler approach to getting things done. For example, a basic sign-up procedure for new users to a system used to be very long & complicated and users were required to enter a lot of personal data each time they had to use a new platform. But today, we have features like Google OAuth, SSO, etc. which make it possible to onboard new users with just One click. This shows that usability is priority in current development trends.\n\n2. Efficiency vs. Portability:\nPeople use all types of systems (Linux, Windows, etc.) having different underlying architectures. If a software is optimised to be efficient on one type of system, then essentially a huge customer base is lost because of portability. Best example: Apple's Macs are known for efficiency as they run their own software on their own silicon, but they're incapable of gaming like Windows does. This is a huge trade-off for people who want to game and be productive. Consequently, Apple has been working on Portability (Rosetta 2), making gaming and intel-based apps runnable.\n\n3. Cost vs. Robustness:\nMoney rules. A project can always be completed, but testing it in all aspects to ensure robustness is costly. For example: Software giants (Google, Github) are able to handle attacks like DDOS efficiently. Their systems are heavily tested before deployment to Userbases. But many Startups struggle with this and are vulnerable. Mostly its unaffordable to invest in robustness when the primary goal is maximum functionality with limited investment.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290906,
      "meta": {},
      "text": "In software engineering you often have to deal with design goal trade-offs. By improving one design goal another one often has to be restricted.  A typical design goal trade-off is the conflict between Functionality and Usability. Take for example a website for an online shop. On the one hand, you want the website to be very user-friendly, so that people can easily find their way around it. But on the other hand, this can limit the functionality because there is less complexity possible.\nAnother typical design goal trade-off arises between reusability and cost.  For example, improving software through updates is often associated with high costs, as sometimes new devices appear on which the new software is exclusively available. Take phones and new android/IOS versions for example. Often the device one owns is no longer compatible with the latest software. Therefore, for example, it is almost impossible to combine reusability with low costs. \nTo name another aspect of design goal trade-offs you could take portability vs. efficiency. \nAchieving high portability and yet also efficiency are two design goals that strongly compete with each other. Of course, it is important to use software efficiently and not to work wastefully or to provide inefficient software. On the other hand, high portability also plays a major role, as it is important to make software available for a variety of devices of different types. With high portability, efficiency often suffers, and it is important to find a good middle ground in order to have realtively efficient software that runs on a reasonable number of devices. \n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291909,
      "meta": {},
      "text": "1)\nUnity is a great and functional game engine. However if your are new,, you might find it very confusing. There are several windows with hundrets of options. Unity here had to make a design trade-off between functionality and usability, and decided, that functionality for experienced users is more important than usability for new ones.\n2)\nMy bumpers game, isn't doing a lot. Even though the third sprint is over and it could have a lot of functionality by now. However the due date was too early to really get into it.  The trade-off here was between repid development and functionality.\n3)\nAnother typical design goal trade-off is between cost and robustness. You can buy a lock for your bike for 5€ or you can buy one for 40€. In the first case. In the most cases, the one for 40€ will be more secure than the one for 5€. ",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1292234,
      "meta": {},
      "text": "Functionality vs Usability:\nAdobe Photoshop has a lot of functions. Somebody even made a picture showing a woman out of a picture showing a slice of pepperoni pizza. But without the knowledge on how to use all the different tools, you can't really do anything with the program. So photoshop was planned to be more functional, and therefore is less useable.\n\nCost vs Robustness:\nWhen writing code, exception handling is very important. Especially if the program uses user-input. For example: if a program requires your age for any equation, etc. and asks the user to type their age in the input field, the user could write 35 or thirty-five, 35.6 , .... Usually you would want to catch all unintended/unexpected inputs, but that costs a lot of time. You don't only have to implement the exception handling, but you also need to test it. And time is money, so the costs will rise. \n\nBackward Compatibility vs Readability:\nBackware Compatibility is for example, writing a new software code to use with a new hardware (example: new Nintendo) but to make it compatible with the older Nintendos. Since the hardware is not the same, the software has to implement additional things in oder to be that compatible. Even thought, this is often wanted by the client, it causes lower readability of the code, which makes debugging, changes to the code, etc much more difficult for the developers.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1330877,
      "meta": {},
      "text": "three typical design goal trade-offs with examples:\n1. Delivery time vs. quality. For example, if a game development falls behind the schedule, they may deliver the game with known bugs first and later provide a patch to fix the serious bugs.  \n2. Cost vs. Robustness. A low cost design that does not check for error when user enters wrong data. For example, early version on ebay in 2005 cannot detect the use of \",\" komma and \".\"  dot when entering the price. Which will then result in the wrong respond price.\n3. Functionality vs. Usability. The system can design an entry menu with all functions available for the system but it will make the entry menu too complex and hard to use and be not user friendly. For example, when using \"PowerPoint\", you can see many functions displayed, but many be some user don't really know how to fully use many of them. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1334371,
      "meta": {},
      "text": "Quite often, portability and efficiency partly contradict each other. When coding a matrix multiplication routine, hand-optimized x86 assembly may be the single most performant way. On the other hand, it is the single least portable approach. When coding in very  high level languages like python, performance is sacrificed for portability.\n\nAnother quite natural trade-off can be seen between development time and functionality. Implementing functionality takes time. Thus, more functionality implies less rapid development. When developing e.g. an entertainment system for a car, building a whole custom operating system may offer more specific functionality to the user, but it will take considerably more time than porting an existing OS.\n\nSince human attention  span and memory are limited, a user can really only keep a finite amount of functionality in his active memory. When creating systems with tons of functionality, e.g. a very specialised trading app like InteractiveBrokers, the usability, especially  but not only for inexperienced users may suffer.\nThus, sometimes, lots of functionality may impact the usability of an application.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1338780,
      "meta": {},
      "text": "Functionality vs usability: This can happen when the client wants many different functionalities of a system combined in one user interface. The user could therefore get lost in the system / the usability of the system would be rather bad. An example would be a flight booking system, that at the same time offers different insurances, hotel choices, restaurant bookings, car hires on the same booking interface. The user would be overwhelmed and the usability would be rather low, if no trade-off solution is found. \n\nCost vs robustness: The client could want to have highest possible availability and no crashing of the system, even though he is only willing to pay a very low price. For a higher availability however, different servers need to be used, which would increase the cost. Here a trade-off would have to be found. Facebooks availability e.g. is at close to 100%, however this requires a significant amount of servers that would cost a significant amount of money.\n\nRapid development vs functionality: The client could give the software developers a time limit of 6 weeks to develop an entire clothing shop inventory software including an e-commerce online store to be accessed by users. In this case the trade off could be to focus only on the inventory software or the online store. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344346,
      "meta": {},
      "text": "A first typical design trade-off is cost versus robustness: usually the client wants the product to cost as less as possible and be as profitable as possible. But by keeping the costs low, development time will necessarily be short too. This leads to a deliverable product that meets the basic requirements but was not tested enough and consequently is not robust.\nA second design trade-off is efficiency versus portability: an example demonstrating that is a platform-independent application which normally is programmed in java. While the application is portable, it may not be that efficient because some machine-dependent optimizations were not possible. At the same time, if the development team chose efficiency as one of their design goals, the product would not be portable because of the same machine-dependent optimizations used to make it more efficient.\nA third design trade-off would be functionality versus usability: a highly functional product with 100 functions makes developing an adequate user interface complicated. The development team will have to divide the methods into different categories by sorting them by similarity but result in a very intricated user interface which is not minimal, going against Nielsen's 10 Usability Heuristics.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344498,
      "meta": {},
      "text": "\n\nWhen the goal is to design powerful software that can solve complex problems and meet all of the clients needs. Then this high functionality can usually only be achieved at the cost of usability, as all of the functions have to somehow be incorporated into a user interface which will eventually become so bloated, that users will have a hard time finding the right tool in the submenu of another submenu. \n\nFurthermore the more difficult the problem the longer it will take to design a software solution for it.   When a company requests the development of a program but sets a very short timeframe then this will directly affect the quality of said program, because its a long process that requires a lot of thinking. This trade off is referred to as Rapid development vs functionality.\n\nAnother common trade off is Efficiency vs portability. As efficiency is a term that is not clearly defined in software development trade offs are unavoidable when it comes to it. Efficiency can mean speed or low electricity consumption or something else. In the case of speed this means that the software is unfit for mobile devices like phones, as they have a low battery capacity and have to prioritize electricity consumption over high performance. Therefore developers have to deliberately make their program slower in order to meet the needs of portability when designing programs for mobile devices. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292226,
      "meta": {},
      "text": "In system design one has to trade of between backwards-compatibility and readability, so you for example look at the design of the operating system Windows, with each update or new version, the code gets more and more complex, so it´s very hard to understand if you did not take part in developing the old versions, but it ensures the compatibility with the old versions of the code.\n\nAlso in software engineering you have to find the balance between efficiency and portability, so if you want your program to be compatible with different operating systems you might have to trade of in terms of efficiency since the code has to be more generic and cannot take into account the advantages of the different operating systems.\n\nAnd lastly, if a costumer wants their software to be developed very fast, because of different reasons, for example new features that have to be added to a fixed realease date, the functionality might suffer, due to exeptions not being considered and fundamental mistakes.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292669,
      "meta": {},
      "text": "Functionality vs. usability:\nThe more functionality is added to a programm, the more visible buttons need to be added to use the new functionality. If something has only few possibilities, like a simple audio player which has a pause, skip and volume buttons it's easy to understand for the end user. Complex Adobe programms with lot's of functionality like Photoshop are really hard to learn because there are so many buttons hidden in several sub menus.\n\nEfficiency vs. portability\nIf you know exactly the platform you are programming for, you can optimize the code to be efficient, because you know the architecture of the processor and it's features. If the code should run on multiple systems, there has to be a virtual machine or translation and you have to write more general code, that works on all systems.\n\nBackward compatibility vs. readability\nIf a programm runs only on new machines you can use all new funktionalities that were newly added to processors. They are more powerful and do multiple things in one step, for example the calculation of a square root. If it should be compatible to older machines, you have to use instructions that work on all processors, which means more code and less readability, because a square root needs lot's of instructions.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1293608,
      "meta": {},
      "text": "Users want the system to be as robust as possible but clients want it as cheap as possible. These two design goals typically compete against each other because for exaple the system can only be designed really robust if many really good software developers work on the project which costs a high amount of money. With less money you could only \"buy\" less or not so good developers which will make the system not as robust as in the other case.\n\nUsers want the system to be as functional and usable as possible but these two design goals also often compete agasint each other. This occurs because system with high functionality are often really difficult to use which decreases the usability. For example software which helps users to create 3D models could be either really easy to use but then it won't be possible for the user to create extraordinary shapes or it will allow the user to create every imaginable shape but then the system will be really hard to use.\n\nWhile users want the system to be functional, clients often want the system to be developed as fast as possible. But in less time the development team obviously cannot make the software as functional as if they had more time. In the example of the 3D design software shows this design trade-off as well either the team takes more time to develop the software to implement more complex functionality or the software will only be able to do basic 3D design stuff which makes it not as functional as it would be if the team took more time.\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1336897,
      "meta": {},
      "text": "1. Functionality vs. usability\nBy adding more functionality to your system, the usability decreases. It's becoming more difficult for the user to learn the functionality and it can be really overwhelming.\nOne example is vim, a highly configurable text editor, but it's hard to learn. So it has good functionality but lacks usablity and most people just need basic editing and not all these functions.\n\n2. Cost vs. reusability\nIn order to keep the cost at a minimum level, one has to minimize the work hours. This can be done by doing something quickly and hideous, eg. writing spaghetti code. This makes it harder in the future to add more functionality, so that one can reuse the programm.\nEg. the code base used by banks is patched, so no one has to rewrite the code base to keep the cost down, but it becomes harder to reuse the base.\n\n3. Rapid development vs. functionality\nDeveloping a prototype with a hard upcoming deadline often causes lack of functionality because there isn't enough time, to focus on details and addons. So the trade-off is between having a shippable product in a short period of time or adding more functionality by expanding the work hours.\nFor example corona warn apps had to be deveploped quickly, so there were trade-offs in the fuctionality eg. the security.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344623,
      "meta": {},
      "text": "Efficiency vs. portability:\n\nThis Tradeoff posses the problem that efficiency on one specific device contradicts itself directly with portability between multiple devices. For example if you optimize a game for the playstation system so it runs more smoothly on the specific device you limit its potential on the computer. \n\nBackward compatibility vs. readability:\n\nBackward compability tries to give the software the chance to interact on devices not only fit for the current, supported version or device. To accomplish this software feature it is needed for the code to support a lot of options, catch ups for old software features or general old code from earlier software. This is a good offering for the user but comes at a problem for the readability for the code. Bugfixing and error finding becomes a lot harder because maneuvring the code \"massacre\" will become an issue for every developer touching the current code. \n\nCost vs. robustness:\n\nThe two design goals are in a direct tradeoff as bullet-proof robustness of a software needs a lot of time during development, which also costs a lot of money for the input time. So make sure your system stays intact during almost every special strain put upon it, you have to spend a lot of cash on bugfixing etc.. If you dont costs will be low but the risk for special bugs will be pretty high\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344718,
      "meta": {},
      "text": "1.   Usability and functionality both must be considered when developing for e.g. moblie phone/tablet version of a PC application.  \n\n Because of small screen and low performance of phones/tablets, it should not have too many functionalities like the PC version, otherwise it will have a low usability. But too few functionalities make the App meaningless to use. Developer must make a trade-off, and deceide which is more important.\n\n2.   We should alse make trade-off between rapid development and functionality.  \n For example we want to develop a calculator application in a short time, then it's hard to implement it with complex calculate functionalities. We are only able to offer some basic ones, like elementary arithmetic functionalities.\n\n 3.If we just want to deliver a simple program for a small group of people to use, which helps the to do their project easier, then we don't have to do addional testing for hundreds of users.  \n\n And the coding cost is also low. But then it won't have a good resusabilty, because it's designed for a certain group and a certain project. High usability demands high costs. We must make trade-off.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1634599,
      "meta": {},
      "text": "Als erstes Beispiel hätte ich den Konflikt zwischen \"Low cost\" und \"Minimum # of errors\". Wenn der Client die Kostensenken möchte, kann das Produkt nicht ausgiebig getestet werden und hat dann möglicherweise mehr Fehler als ein Programm, welches gut getestet wurde, von mehreren Entwicklern beispielsweise.\n\nAls zweites Beispiel hätte ich den Konflikt zwischen \"Rapid development\" und \"User-friendliness\". Wenn das Programm schnell entwickelt werden soll, werden andere Design Goals wie User-friendliness nicht besonders stark beachtet. Beispielsweise wird das Interface des Programms nicht besonders übersichtlich und bedienbar, da es schnell entwickelt werden musste. Die Folge wäre, dass weniger Kunden sich an das Produkt binden, da sie vom User-Interface enttäuscht sind. Durch Vernachlässigen des Design-Goals \"Rapid development\" wäre dies vermeidbar.\n\nDas letzte Beispiel wäre der Konflikt zwischen \"Rapid development\" und \"Good documentation\". Wenn man nicht sehr viel Zeit für die Entwicklung haben, dann hat man erst recht nicht die Zeit für eine gute Dokumentation. Die Folgen sind, dass nicht neue Developer nicht mehr so schnell wie bei einer guten Dokumentation in das Projekt einarbeiten können und User keine gute Auskunft über das Programm in der Dokumentation zu bekommen.",
      "score": 91.7,
      "language": "GERMAN"
    },
    {
      "id": 1642478,
      "meta": {},
      "text": "1) Functionality vs. usability: If we add a lot of feature to the interface, it becomes more functional but less usable. Because it makes interface hard-to-learn and complex. On the other hand, if we reduce the features, interface can lose its power of functionality.\nFor example when I want to buy a ticket in DB machine, I see tons of different ticket type & info and it takes a lot of time to pick the right one. And everytime I forgot which one to choose again because it is complex. Oppositely, in Turkey there are just 3 types of ticket but there are no explanation about ticket categories, so I have to click on ticket and go to the payment in order to see the difference.\n2) Rapid development vs. functionality: If customer needs an urgent product, he may have to give up some functionalities in order to fasten the design process. \nFor example customer needs an interface for training but building a test evaluation feature after every training takes long time, so they except it without this feature.\n3) Cost vs. reusability: Cost of a one-off project is low, however if customer wants to use the product for a long time, it needs to be reusable. So customer needs to be willing to pay more for a more usable project.\nFor example: driver training platform can also be used as internal employee training platform. It is better make a reusable project with more price instead of building a new one when internal training is needed.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290782,
      "meta": {},
      "text": "1. Cost vs. reusability:\nA developer wants to design a University app for TUM to manage the courses a student has. If the developer takes more effort and time (consequently money) he or she can develop a generic framework which is applicable to more use-cases such as schools that can benefit him or her her more because it is more profitable for the developer. Therefore, the developer creates a system that can be used multiple times.\n\n2. functionality vs. usability:\nWhen a website for ticket reservation has too many options to choose between at once it is overwhelming and thus less usable for the user. In that case, an algorithm that generates the best ticket for the user is a lot more functional than a list of all tickets available since it sees that the usability of the website can be significantly improved by changing up the functionality the website provides.\n\n3. rapid development vs. functionality:\nWhen an app for the DB is created in a very short period of time it may happen that a lot of functionalities are missing due to the short time frame for its development. Therefore, the functionality of the product is not optimally used. It could happen that the ticket reservation system as mentioned above is implemented in a way that is not as usable for the user since its rushed development. Consequently, the rapid development of the product hinders the good functionality and success of the product.  ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1332293,
      "meta": {},
      "text": "Software engineering enables a structural approach to develop a software. \n\n1. Maintainability vs. simplicity \n\n\tTo guarantee the maintainability of a software, it requires flexibility and expandability. This can be well \t\n\trepresented by a long-running game service. Developers maintaining this service now aren't the \n\tdevelopers who first contributed to this game maintenance. On the other hand, some systems require\t\n\tsimplicity focusing on the present requirements, for example software projects following the \"YAGNI\" - \n\tprinciple based on XP.  \n\n2. rapid development period vs. guarantee of developer's Work and Life Balance\n\t\n\tExtremely rapid development paces are common due to many factors \t\n\tsuch as cost minimisation. This tight deadline can not only be associated with economical \n\treasons, but can correlate to a shallow knowledge of a client about practical software development, \n\tfor example a client demanding unrealistic software designs and shortening development period to an \t\n\tunacceptable extent not considering developer's situation. \n\n3. cost minimisation vs. high quality \n\n\tFinding a balance between cost and quality represents a typical design goal trade-offs in software \n\tengineering. Costs that incur during software development are mainly allocated to the software \t \t\t\n\tdevelopers. \n\tFor instance, every line of code correlate to a myriad of components leading to an exponential increase \n\tof possible test cases of code execution combinations when fixing bug even in a single line of code. \t\n\tProportional to this increase of test cases, the cost also rises. However bug fixes and test cases \t\t\n\texecutions are crucial steps for qualitative improvement of software. \n\n\n\n\n\t\n\n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344564,
      "meta": {},
      "text": "Functionality vs. usability. Obviously, it is very difficult to achieve both of these goals at the same time. The more functionality the program has, the more time the user needs to deal with all the functionality. If the program has 10 tabs, each of which has 20 different functions, then it will be very difficult for the user intuitively to understand, where is the required function.\n\nMinimum # of errors vs. Functionality. The more functionality in the program, the more likely the appearance of various errors. Especially if different functions are related to each other, then adding new ones can cause a lot of bugs.\n\nLow cost vs. Well-defined interfaces. If the client is not ready to enough money for the development of a quality product, then, accordingly, one should not expect that programmers will do everything perfectly in a short time.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1347084,
      "meta": {},
      "text": "Cost vs Robustness \nWhen designing a system and in order to ensure it's robust, one has to invest time and effort and hence costs into error handling and considerations of environmental changes. If the costs are to be reduced though, then the robustness of the system might be compromised (e.g. if we want to reduce the price of development of a banking app, one might run less tests like fuzzing or fault injection)\n\nRapid development vs Functionality\nWhen designing a system, one can extend the development phase to months or even years to add all the desired functionalities or one can limit it with a specific delivery date and reduce hence the number of functionalities to be developed (e.g Intelligent Chatbots in a banking app could be compromised if they require a long time to develop and the client needs the app sooner)\n\nFunctionality vs Usabilty\nWhen designing a system, one can opt for multiple functionalities (e.g on a banking app, one can add QR Code payment, adaptability with Apple Pay, ATM locator, voice payments, budget planner, IBAN image recognition which can compromise the easy usage of the app) or one can limit and reduce these functionalities to allow a user friendly interface (e.g remove voice payments or IBAN image recognition to reduce the process of decision-making of the usage and reduce the number of clicks to perform a specific task on the app)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1355760,
      "meta": {},
      "text": "Cost vs. robustness:\nA very common scenario would be when you buy something from China, usually the products are cheaper but they dont last as long as for example the german version of it.\nRapid development vs. funcionality:\nwhile developing software one always can choose between being fast and the quality of the programm. one can realise software early but possibly with bugs or giving it more time to have a programm with as little as possible or no bugs.\nCost vs. reuseability:\nDrinking e.g. coffee from a plastic cup is cheaper and easier but using a solid cup that can be reused is better for the enviorment but is more expensive to produce.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291970,
      "meta": {},
      "text": "• Cost vs. reusability\nA client wants to spend as little money as possible for the product but this is in conflict with reusability since a program thats reusable has to be more carefully developed and it takes more time than a non reusable one. And more time needed is more money spent. A Bumpersgame that only supports one type of Collision is more straight forward to develop than a Bumpersgame that supports many different Collisions on the fly and is therefore less expensive  but also less reusable.\n\n• Functionality vs. usability\nMore functions often lead to a less usable product. While having more functions is generally good, it gets increasingly difficult for the user to grasp all of it. Often times therefore, functionality has to be limited to ensure better usability. Currently the Bumpersgame only supports one input which is the mouse click and is therefore not overwhelming but if you were to add functions to every single button on the keyboard, then it suddenly has increased functionality but the usability got alot worse.\n\n• Backward compatibility vs. readability\nIn order to maintain backwards compatibility, a programmer has to add new functionality on top of the already existing functionality. The old code which is necessary for backward compatibility then has to remain inside the program and after some years and a few personell changes later the code is cluttered with a huge amount of old code. This increase in code and maybe also difference in coding style then decreases readability.\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1298794,
      "meta": {},
      "text": "Ein erstes Beispiel für einen Design Goal Trade OFF ist die Cost vs Security Abwägung. Hierbei kann ganz simpel die Menge an Kosten die für z.B: 10 Entwickler benötigt werden dem Sicherheitsanpsruch der Software gegenüber gestellt werden. Beispielhaft bedarf es eines Entwicklers, welcher die durch die kritische Log4j Schwachstelle auftretenden Sicherheitslücken behebt. Im Falle dass Kosten gespart werden sollen und diese Sicherheitslücke nicht rückwirkend behoben wird ist es potentiellen Angreifern möglich Zeichenketten hochzuladen um Informationen über das System zu erlangen.\n\nZweites Beispiel ist der Rapid Development vs functionality Trade Off genannt werden. Als Beispiel dafür kann die Spielebranche mit den Titeln Elden Ring und Assassins Creed genannt werden. Letzteres zeichnet sich durch eine extrem beschleunigte Entwicklungszeit aus (und dadurch sehr geringe Kosten), welche zunehmend auf Kosten der Spieleinhalte und Funktionalität geschieht, da immer weniger Inhalte, Kartenareale und Spielmechankien in Spiele dieser Reihe eingebaut werden. Gegensätzlich dazu bietet EldenRing mit einer Entwicklungszeit von mehreren Jahren deutlich mehr Inhalte und bessere Spielmechaniken.\n\nAls Drittes müssen die DesignElemente Funktionalität und Usability gegeneinander abgewägt werden. Dabei kann ein extrem einfaches System wie z.b: eine App auf dem Handy (beispielhaft ein Foto Editor) niemals die Funktionalität von Adobe Photoshop Pro erreichen, da hier nur einfache Zuschneideoperationen und Filter verfügbar sind. Die Möglichkeit in Photoshop Aquarelfarben zu benutzen und komplexe Farbeffekte einzubinden geht natürlich aber nicht ohne Kosten einher. Hierbei muss ein User oft mehr als 100 Stunden mit der Software arbeiten um alle Möglichkeiten zur Bildbearbeitung ausnutzen zu können.",
      "score": 75,
      "language": "GERMAN"
    },
    {
      "id": 1333324,
      "meta": {},
      "text": "Design goal trade-offs:\n\nCost vs. reusability\nBei \"Cost vs. Reusability\" stehen wir vor der Entscheidung entweder kosten zu sparen oder wieder verwendbare Dinge zu entwickeln. Da wieder verwendbare Produkte oder Entwicklungen deutlich stabiler und aufwändiger sind, sind sie daher auch teurer.\nEin gutes Beispiel wäre Besteck und Verpackungen aus Plastik. Produkte aus Plastik sind leicht verwendbar und im Gegensatz zu Geschirr aus Porzellan sehr günstig. Jedoch ist Geschirr aus Porzellan deutlich stabiler und kann deutlich häufiger verwendet werden.\n\nRapid development vs. functionality\nBeim trade-off von \"rapid development vs. functionality\" möchten wir in möglichst kurzer Zeit Produkt mit erschaffen, welches seinen Zweck erfüllt. Eine schnelle Entwicklung kann jedoch zur Folge haben, dass die Qualität des Produkts nachlässt und somit der Zweck nicht mehr erfüllt werden kann. Jedoch kann durch eine schnelle Fertigung der Preis gesenkt und unter Umständen ein höherer Absatz erzielt werden.\nEin Beispiel ist zum Beispiel Kleidung. Es ist bewiesen, dass günstige und schnell hergestellte Kleidung langfristig schneller kaputt geht und somit nicht seinen Zweck erfüllt. Im Gegensatz dazu ist hochwertige Kleidung eher teuer und zum Teil sogar handgemacht, was einen größeren Aufwand und mehr Zeit mit sich bringt.\n\nEfficiency vs. portability \nDer trade-off von \"efficiency vs. protability\" kann besonders gesehen werden, wenn man eine herkömmlichen Laptop mit einem Desktop-PC vergleicht. Ein Laptop ist sehr gut dafür geeignet mitgenommen zu werden und ist jederzeit einsatzbereit. Jedoch besteht das Problem, dass meist der Bildschirm sehr klein ist und der Akku des Laptops nur wenige Stunden ausreicht. Ein herkömmlicher Desktop-PC ist hingegen dauerhaft am Strom angeschlossen und verfügt über einen größeren Bildschirm. Dadurch ist dieser aber nicht sehr leicht mitzunehmen. \n\n\n\n\n",
      "score": 33.3,
      "language": "GERMAN"
    },
    {
      "id": 1344476,
      "meta": {},
      "text": "1: A common design goal trade-off of runtime efficiency is bad backward compatibility. If you want your code to run on 5-year-old machines as well, you must not use features which have been introduces in the latest generation of CPUs. This will make your code bulkier than necessary, reducing its runtime efficiency.\n\n2: One trade-off of minimizing the amount of errors are higher developing costs. In order to minimize errors, a lot of testing and optimizing of code is necessary. This requires additional work of paid developers, which leads to rising costs.\n\n3: A trade-off of high functionality is the lower ease of learning. Software with only few functions can be easy to understand and to learn. Additional functions obviously have to be learnt and understooden as well, and therefore reduce the ease of learning",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1349520,
      "meta": {},
      "text": "Example 1:\nA classical example is rapid developement and functionality. Let's say I want a program with 200 functionalities with a high quality user interface within 1 month. This leaves the developement team with 1 to 2 scrum meetings to developement my program. This is difficult as 2 scrum meetings are too little for 200 functionalities. The tradeoff here is then, that in one month, I can only get my hands on a program with 50 functionalities. \n\nExample 2:\n Another example is efficiency against portability. Lets say, I have designed a program which runs incredibly efficient on the windows system because I took advantage of a specific hardware component, which does not exist in the MacOS. If i would make my program work on the MacOS as well, the exploitation of the specific windows hardware will now have to be discarded, or reimplemented, and the overall efficiency rate will decrease.\n\nExample 3:\nThe last example is that of backward compatibility and readability. In this example, we will assume that I have a video editing software which stores a specific format of video, that is only accessible with my program. To support backward compatibility, my program will have to implement extra methods and attributes to ensure that the new version of the program can edit old video files 5 versions ago. This adds an element of complexity within the code, which makes the code harder to read and hard to maintain as well.\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1381068,
      "meta": {},
      "text": "One typical design goal trade-off is cost vs. functionality. A client who does not have enough budget might not be able to get a fully fledged software package that they want. Their option is either to pay more money for more developement or settle for the product with the features they get.\n\nAnother design goal trade-off is rapid developement vs. robustness. The more robust a software system is supposed to be, the longer it will take to develop. Finding security and safety gaps takes time, and fixing them does as well.\n\nA third design goal trade-off is efficiency vs. backwards compatibility. A software system that is supposed to be backwards compatible has to support a wider range of other system, and therefore can't be optimized for just one really efficient application.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1402549,
      "meta": {},
      "text": "Blender ist ein gutes beispiel für Funktionalität vs. Benutzungsfreundlichkeit. Das programm kann so gut wie alles mit 3d modellen und animationen machen was man sich nur vorstellen kann aber die oberfläche ist jetzt nicht super übersichtlich und man muss sehr viele shortcuts wisse um es richtig bedienen zu können.\n\nWenn ein Spiel zu einem bestimmten zeitpunkt fertig werden soll die deadline aber viel zu kurz für geforderten features ist dann kann man weniger zeit und in die test phase stecken wodurch das programm mehr bugs hat oder mal abstürzt was zum beispiel bei cyberpunk 2077 leztens der fall war. (Zeit vs Features)\n\nIn in einem handy spiel kann man als entwickler nicht den selben detailgrad der 3d modelle benutzen wie bei einem PC Spiel da die rechenleistung der handys geringer ist. Das währe ein beispiel für plattform vs. visual quality.\n\n\n\n\n",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1642907,
      "meta": {},
      "text": "1. trade-off: Reliability vs. performance\nThe reliability of the system is in conflict with the performance. The more available it is, the more difficult it is to optimise it.\n\n2. Availability vs. consistency\n\n3. Scalability vs. reliability",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1291168,
      "meta": {},
      "text": "1. Rapid development vs. functionality\nExample: If the development team is forced to create the system faster then possible. The due date for delivering is set in 90 days, but the estimated time to implement all functions would be 150 days. Therefore they don't have enough time to fully integrate all functionalities and have to leave out some of them to meet the shipping date. The company has to talk with the customer which functionalities should be prioritized.\n\n2. Efficiency vs. portability\nExample: A system can be designed with two possibilities for its main algorithm. One variant uses little memory, but is slower, the other one is very fast, but requires a considerable amount of memory more to be implement. By choosing the fast algorithm, the system would get too big, to be used by many small devices like smartphones. Therefore, the developers have to decide in dialog with the customer if he would rather have a fast system, with lots of memory usage, or sacrifice some performance, to make it usable for small portable devices with less memory.\n\n3. Backward compatibility vs. readability\nExample: A new version of a presentation program is being developed. It uses a newer file format then the old version. To ensure, old files can still be edited and used, the system has to be build with additional functionalities that support the old format, which leads to 20% more code, handling the editing of old files. Due to this additional code, the systems files get less readable, making changes and debugging more difficult.\n\n\n\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292065,
      "meta": {},
      "text": "One can write a system faster when not caring about documentation. An example where that trade off could be made is when you have a stack of forms you would like to digitalize. You save time by not writing documentation. It's an acceptable trade off because the system will never be used again after you have scanned all forms.\n\nWhen you want a maintainable system you have to spend a lot more time upfront. With this additional time you can spend more time on writing tests that help you spot regressions and issues more quickly. This is important for example if you're working on a system that you know will spend at least 10 years in production.\n\nIf you want a particularly fast system you need to spend more money. For example a 3D game engine needs to be very fast and snappy so you need to spend a lot to hire experienced developers.",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1300170,
      "meta": {},
      "text": "1. Cost vs robustness. In the scenario that we are asked to develop a support center form for the customers of a store. The development team can develop the form in 1 week (short time = cheap) but only include 1 review before pushing it to production. The same team can develop the form but consider several extra features and reviews to ensure a robust system (that continues working in case the end-user changes something). While the first one is cheap but can have bugs because it is not a robust system, the second one can be costly (take a lot of time) to develop. We must choose a middle ground point between having bugs and being costly.\n\n2. Functionality vs. usability. With the previous example. On the one hand, the team can develop a form with 15 multiple choice questions that ensure that the support team can resolve tickets in less than 1 hour, however, the user test says that 80% of users do not understand the questions. On the other hand, the team can develop a form with a single open-ended question that benefits users but takes the support team at least 2 hours to resolve each case.  In this case, you should also look for a middle point where maybe there will be 3 well-explained questions and also an open-ended question to make it efficient for both.\n\n3. Cost vs. reusability: Using the same example. On the one hand, you can develop a fast (cheap) form that focuses on solving the queries of \"product A\" (50% of the complaints come from product A) leaving the other products without a form. On the other hand, you can develop a modular form that can be reused by all 20 products of the store (reaching 100% of complaints) but this would take more than twice the development time. The middle ground would be to make one that can at least be reused for 80% of the user complaints.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1388242,
      "meta": {},
      "text": "Design goals often have a conflict since for example the client and the user has different goals. \n\nFor example the client has the goal that the software is produced by low cost. On the other hand the end user has the goal that it is very robust, for example better material is used or it is more resistant regarding high temperature. Therefore, there is a conflict between low costs and robustness.  (cost vs. robustness)\n\nAnother example is the conflict between functionality and usability. The end user want that it is functional, that means that the system does all the tasks it is supposed to do. On the other hand the system should be easy to use and not be very complicated. Therefore there is a conflict that the system can handle all tasks but on the other hand is still clear enough for the end user. (functionality vs. usability)\n\nThe last example is the conflict between rapid development and functionality. The client has probably the goal that the software is engineered rapid since this is as this is also associated with lower costs. But on the other hand the end user has the goal that the software fulfill all the requirements and functions. This takes probably more time in the development process. Therefore there is also a conflict. (rapid development vs. functionality)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1459188,
      "meta": {},
      "text": "1-Cost vs Robustness:  the more a system is robust , the more its cost will increas. Example: a mobile phone should tolerate more then 50 degree C but should not cost more then 400 euro.\n2- Cost vs Performance:  The more system performs better in critical cases , the more its cost increases .Example :the bumbers game should support 10000 players at the same the time and the app should not cost more 1000 euro. \n3- Rapid development vs functionality: The more functions the system does support, the more time it takes to develop those functions.  Example : when systems supports 200 functions in a reservation system of a compagny flight , it would be diffuct execute a rapid development in less then 3 days \n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1651511,
      "meta": {},
      "text": "Design goal trade-offs. \nTypical design goals that can arise:\n\n1.  Time and Space trade-off. \n- This could be a typical trade-off since a request could be that an application should be fast for the end-user but since it stores a lot of data could mean that it takes a longer time to compress.\n\n2. Cost vs Maintainability. \n- A client could request that there should be continuous software updates made to the application but this could also mean that each update increases the total cost. \n\n3. Fault tolerance vs Flexibility\n- Flexibility for the client could be compromised if the software that has been built can not detect any possible bugs. And leave the software to be inflexible. \n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291691,
      "meta": {},
      "text": "In some cases, the design goals are conflicting with each other, which is called 'design goal trade-offs'. Here you can find three examples for the design goal trade-offs: \n1. Most of the clients ask for scalability because they want to provide service to large amount of customers but it could be hard to have maintainability for a high scale product from perspective of developer. \n2. Many developers would like to have reusability for products but the clients ask for rapid development. It takes time to develop a product that can be reusable.\n3. Client wants to have low cost but end user would like to have functionality. For a low cost product, it could be hard to offer high functionality. \n\n",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1297649,
      "meta": {},
      "text": "Efficiency vs Portability\nDie Effizienz und die Portabilität eines Programms stehen im Konflikt. Auf der einen Seite möchte man, dass ein System effizient arbeitet, um möglichst wenige Ressourcen zu verbrauchen. Auf der anderen Seite soll das System natürlich auch auf mehreren Plattformen und für verschiedene Anwendungen laufen können. Das ist schwierig zu realisieren, weil man abhängig von der Plattform Effizienz anders definiert. So läuft ein Antivirenprogramm für ein Heimnetzcomputer besser, während es bei einem Computer eines Unternehmens viel weniger gut läuft, weil er anderes aufgebaut ist.\n\nRapid development vs Functionality\nDie schnelle Entwicklung und Funktionalität einer Software stehen im Konflikt. Auf der einen Seite möchte man, dass sich ein System z.B. ein Internet Browser schnell weiterentwickelt, im Wettstreit gegen andere Anbieter mithalten kann und mit der neusten Betriebssystemversion übereinstimmt. Auf der anderen Seite möchte man auch, dass das System einwandfrei funktioniert. Das kann man in den allermeisten Fällen vor allem unter Zeitdruck nicht gewährleisten. \n\nFunctionality vs Usability\nFunktionalität und Nutzerfreundlichkeit/Lesbarkeit stehen im Konflikt. Auf der einen Seite möchte man, dass das Programm funktioniert. Auf der anderen Seite sollen die zukünftigen Nutzer nicht überfordert werden. Besonders größere Systeme und Programme können nur schwer einfach und übersichtlich realisiert werden, sodass ein dritter das Programm ohne Kenntnisse verstehen kann. Häufig geht es nicht anders.\n",
      "score": 75,
      "language": "GERMAN"
    },
    {
      "id": 1298387,
      "meta": {},
      "text": "Three possible trade-off are for example the trade-off's between:\n\n1. Cost and Robustness, Usability\n2. Efficiency and Portability\n3. Functionality and usability.\n\nThe objective of every company is to deliver a product or service while keeping costs as low as possible.\nLower costs come with a poorer quality of the product or service if the money that is spend for the engineering team falls under a certain threshold. This results in code which is buggy and does not expose the issues behind of conception of the system design as clearly.\n\nWhile enhanced functionality makes the product more versatile for different use cases it also enhances the complexity of the software. In order to use complex software the user has to learn how to use it first and depending on the complexity it could take several days. Sometimes highly complex software cannot be avoided. Though it depends on the specific use case if it is a good idea to add a lot of functionality. For instance CAD-Software would be very restricted if the design of it would have a very simplistic approach to the amount and types of functionality which is provided, while a voice-memo-app should not be overloaded with unnecessary functionality.\n\nIf a software needs to be ported onto very different devices the usability and the availability of software might suffer at the expense of the maximum performance a device can offer or how good the connection to the internet is. A Webapp might not be dependent of hardware specification but it might not be efficient if a computer does not have a connection high enough although performance wise it could handle the Web app on hardware.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1300950,
      "meta": {},
      "text": "First of all, the trade-off between usability and functionality. An example for this trade-off would be that you are working on a common calculator app. Here you don't want to create a UI that displays every single mathematical function or operation there is since the standard operations such as addition, multiplication, sqrt etc are sufficient in many cases for a lot of people. Adding too many operations would make it harder to find the operations you want to use and thus harm usability, however you still want to have a big enough selection to satisfy user needs.\n\nSecondly, the trade-off between security and ease-of-use. Here you have to weigh importance of security measures such as two-factor authentification against for example the login time effort for the user. If the time effort is too high it may lead to losing customers whereas an insecure program or a scandal of stolen user data may lead to the same result.\n\nLastly, the trade-off between rapid-development and functionality. For example when developing a game, it is beneficial if development is fast since it saves money and effort and gives you the opportunity to work on something else afterwards. However if the game is bugged and only offers a limited number of game-modes or similar, it harms the product.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1315439,
      "meta": {},
      "text": "Functionality vs. Cost\nAny developed system can implement many functionalities but every functionally will require more resources, either human or digital. For example, to develop the basic interface of instagram could be done very effectively, but to implement all the functionalities it has now, it needs a lot of resources in storage, developers, servers, etc. \n\nPerformance vs Flexibility\nThe fastest computers today are by far the quantum computers, however they can only be used for very specific purposes like simulations of the universe or of certain quantum states. They are only used for research purposes since they only have this function and can not do anything else for now. They have to be build with a cooler that keeps the system at an almost absolute zero. They exceed every performance measure in the specific cases that they are used for, however they are not flexible at all. \n\nRapid Development vs Maintainability\nWhen something has to be developed fast it is normal that many bugs arise in the first part. When developing something it is hard to think of ways to make the system easier to fix later by using its best practices or to even think how to make the system to cope with changes in the future. An example could be an app for a to-do list, if it has to be developed fast it would make it impossible to think what future uses or changes the app could have. \n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1363510,
      "meta": {},
      "text": "1. Functionality vs. usability\nFunctionality and usability are classical trade-off factors. The underlying factor is complexity. A very usable product is also very simple. Simplicity implies that there is not much functionality. This needs to be tailored to a specific use case. Very knowledgeable workers want to have lots of functionality and don't mind the complexity that comes with it. For casual users this is not the case. They want simplicity and high usability. In terms of software engineering it is important to do a good job in the requirements analysis and only define functional requirements that the users really need. Complexity has to be as low as reasonably practicable.\n\n2. Rapid development vs. functionality\nI am involved in a start-up right now, which wants to develop a software for CO2-Measurement, so I experience this trade-off first hand. As I said before, functionality adds complexity, which results in longer development times. Especially as a start-up which tries to develop a minimum viable product, this trade-off is highly relevant. The challenge is to define the most relevant functions and disregard everything else to keep development times as low as possible. Of course, for other use cases (e.g. banking software) functionality may be more important than development times\n\n3. Efficiency vs. portability\nThe underlying factor that influences efficiency and portability is the level of abstraction. Since a high level of portability needs to have some middle-layer or abstraction for working on multiple systems this can't be as efficient as a custom built program. Each system has it's specifics which can't be used when building highly portable software systems.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1387599,
      "meta": {},
      "text": "Some typical design goal trade-offs are, for example, functionality vs usability, cost vs robustness and efficiency vs portability. The first one of these is clear. There are times when you want to create a system that works, but it is a very complex system, and when it is finally completed and it actually works, it is very difficult to use. But then if you want to make it more user-friendly, it ends up barely working because of the extreme complexity of such a system. \nThe second of these trade-offs is something a lot of users end up encountering. Sometimes they want to save costs by purchasing a cheap software, but a reason for the software being so cheap is because it lacks polish. Developers might have to make decisions like these. Is it better if we ship this as it is for a cheaper price or should we invest more time developping it, making a better product but charging more money for it? \nLastly, the third trade-off is also time-related. Where should the time in development be invested in? In making an efficient product or in making it available in as many hardware devices as possible? Is it better to make a better app for a mobile device or is it better to invest that time in making the app available for all mobile devices?\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1403959,
      "meta": {},
      "text": "The first typical trade-off is the rapid development vs functionality:\nSo, to make an app that has many functions, more time must be consumed. So to make a good app, there must be a balance between development time and functionality.  My experience: After two months of development of a game, the game looks pretty \"empty\". It works, but there are few features. For example, if I wanted to implement ray tracing to my game, I would take another two months of development into account. More time consumed->more features.\n\nThe second typical trade-off is the functionality vs usability:\nFor example a 3d Modeling app like Blender must offer the correct tools for 3d modeling but not be too complicated. An untrained user who first started to use blender without any knowledge about the program can already create a cube and export it. Because these few features are very intuitive and easy to access. For more detailed use, the user must watch some tutorials to understand new functionality.  Blender does a good job of making the massive functionality quite easy to use and learn. \n\nThe third typical trade-off is the efficiency vs portability:\nIf a developer wants to optimise the app for a specific plattform and make use of all its features, he sacrifices the portability. For example there are Games like Half Life Alyx, which use PC and VR-specific features to make a PC-only game. This game does not work on any other device because there is no hardware for example consoles, that can run all the features of this game(This game needs a VR headset to work properly, and not every for example console has it). ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1547358,
      "meta": {},
      "text": "1) Rapid development vs. Good documentation\nRapid development does not provide good detailed documentation due to lack of time.\n2) Cost vs. Modifiability\nModifiability is design goal that directly depends on cost; low cost significantly limits it.\n3) Ease of learning vs. Increased productivity\nIncreased productivity is often caused by more complex functionality, that negatively affects the ease of learning for end user.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1290880,
      "meta": {},
      "text": "1. Functionality vs usability\n\nTrade off more functionality against the usability of the system. Because the more functions there are, the more stress there is on the system, the less usability there is. For example, if a racing game needs to have real-time combat, music, animation, and other features, but also requires the usability of the system, it needs to make a trade-off between the two, and choose the most appropriate functions to maintain the system usailability.\n\n2. Cost vs reusability\n\nOnce the reusability of the software system is required, it leads to increased costs, as it leads to testing costs, maintenance costs, etc. So there's a tradeoff between the two. For example, if a chess program needs to be able to play at least 100 million games without any bugs, and then wants to keep the cost under 10,000 euros, it needs to balance the reusability requirements with the cost, and modify both to achieve the best position.\n\n\n3. Efficiency vs portablity\n\nSoftware systems need to make a trade-off between efficiency and portablity, and efficiency often has high requirements on the system or requires a large space, which is contradictory to the requirements of portablity. For example, a racing game that needs to respond quickly to player actions and display on the screen without delay and in high definition, and then requires software that doesn't take up too much space, needs to balance efficiency requirements with portability requirements and find the optimal tradeoff.\n\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291261,
      "meta": {},
      "text": "Im Softwareengineering kann es passieren, dass nicht alle festgelegten Ziele gemeinsam erreicht werden können, sondern ein Trade-off stattfindet, welches Ziel nun priorisiert werden soll. \n\nVerschiedene Arten von Design Goal Trade-offs:\n- Schnelle Entwicklung vs. Funktionalität: Es kann passieren, dass der Zeitplan für einen App-Launch nicht eingehalten werden kann. Der Kompromiss in diesem Szenario besteht zwischen der erforderlichen Funktionalität und dem Timing: Das System ist entweder pünktlich und unvollständig oder vollständig und verspätet. Es muss priorisiert werden.\n\n- Efficiency vs. portability: Das System sollte effizient und nach den Kundenwünschen laufen, aber auch auf mehrere Plattformen portierbar sein. Wenn ein System schnell und spezifisch implementiert wird und sehr effizient läuft, werden Schnittstellen und für die Allgemeinheit wichtige Features nicht mitgedacht. Das führt aber in der Zukunft zu Problemen bei der Portability -> das System ist nur einseitig nutzbar und nicht auf vielen Plattformen.\nBeispiel: Ein Onlinehandel möchte eine App für seine Shopper und ein effiziente Implementierung einer App. Das System sollte aber auf mehreren Plattformen einsetzbar sein und bei Bedarf leicht auf eine neue Architektur portiert werden können. Deshalb muss hier zwischen Effizienz und Portability abgewogen werden.\n\n- Cost vs. Reusability: Kostensparen bedeutet, dass es relativ einfachen und schnell schreibbaren Code gibt, wenig Testing. Gleichzeitig ist der Code nicht vielseitig einsetzbar, da er spezifisch mit wenig Manpower finalisiert wurde. Darunter leidet die Reusability: Möchte man das System vielseitig nutzen, werden in der Zukunft Kosten hinzukommen -> zusätzliches Coding sowie Testing. \nBeispiel: Ein Ratingfeature wird in einer Restaurantapp implementiert. Der Code kann entweder nur für diese App anwendbar sein (wenig Zeitaufwand beim Coden -> günstig). Besser wäre aber die Wiederverwendung von Komponenten: Das Teilsystem Rating soll leicht extrahierbar, wenn ein anderes System eine ähnliche Funktionalität benötigt.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1294295,
      "meta": {},
      "text": "- The design engineer has to balance the three factors of technical spec, development cost and unit price. But most of the time the design engineer have to make a  decision, which factor is most importent for the system. One design engineer may have consider unit cost as the most important factor while another will have designed the product to minimise development cost. For exemple: In embeddes designs, using more costly components such as modular microprocessor solutions with production-ready board support packages, rather than creating a design with components and reference software only, helps cut the software development time.",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1315696,
      "meta": {},
      "text": "1. cost vs. robustness\n\tIt's very hard to create a program which is secure and reliable while having a very limited budget. For a\n\tprogram to be robust, it usually needs quite a lot of storage which is expensive. The program must know\n\ta lot of edge cases and have lots of functions so that when one crashes due to a false input another can\n\treplace it easily. And that again needs a lot of storage which can be costly.\n2. usability vs. functionality\n\tUsability by itself means how easy a program is to learn and use. Functionality, however, shows how many \t\t\n\tdifferent functions an interface can carry out. These two clash because the more functions a program has,\n\tthe harder it is to understand and use. For the user the most important thing is the usability, however, the\n\tdeveloper ususally wants the program to be as powerful as possible\n3. efficiency vs. portability\n\tProgram's efficiency describes the speed, reliability and programing methodology in a program. the\n\tportability, on the other hand, describes the ability to software on different platforms. The efficiency\n\trequires to get rid of any unecessary code and make use of coding practises applicable to the related\n\tsoftware whereas for a program to be portable developer might need to build executable programs for\n\tdifferent platforms from source which requires lots of code which is uneccesary for one platform but\nimportant for the other",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344951,
      "meta": {},
      "text": "Starting by a very typical one: Cost vs Robustness. The basic idea is that the robustness of a software is usually tied to longer development times, more budget for more complex hardware systems and exhaustive testing. This results in a high cost. A classic example is military-grade software, which should cover a very broad range of edge cases and therefore, is usually extremely costly (flight control systems for a helicopter, for instance).\n\nAnother one which is readily understood is Efficiency vs Portability. Efficiency concerns itself with making code as dry (no \"redundancies\") as possible, and fully utilizing the advantages and details of one system to make it run faster. Portability on the other hand, is the attempt to generalize a system enough so that it runs on different hardware configurations. A very good example of this is the JVM, which is a very portable concept and allows for very platform independent-code, but at the cost of performance.\n\nThe last one is the relation between functionality and usability, which is a little more subtle. Functionality defines the amount of use cases a certain system can encompass within a project scope, whereas usability defines the easiness of using and learning to operate a system. The reason they have a inverse relationship is that expanding functionality ceteris paribus increases the system complexity, which in turn decreases the usability of said system. An example of it is the historical development of C++ (which was originally supposed to be an expansion of C) compared to its originator C. Whereas C is a relatively simple language, being therefore more usable than C++, C++ offers a host of extended functionality, which C doesn't support natively. No wonder the manual for C++ is almost 6x bigger.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1389778,
      "meta": {},
      "text": "Design goals can be concluded from the nonfunctional requirements  and many design goals are in a conflict with each other. There are 3 design goal trade-off examples, which explains the conflict in a better way.\n\n1) cost vs. robustness\n\nIf a client  wants to pay  a developer to develop a website with a large budget, then he  is able to receive a website with high quality and security . But if a client wants to make it more affordable , then the quality and the security of the website will decrease comparatively. This conflict explains the typical trade-off of cost vs. robustness\n\n2) functionality vs. usability\n\nThere is a brochure from a travel bureau in Munich.The  brochure contains the museum  names in Munich and what can a traveler do in these places. Unfortunately the pictures and the locations of the museums are not given. As functionality-wise, the brochure is successful  because it explains the activities you can do. But the usability of the brochure is not enough due to the lack of pictures and locations.\n\n3) rapid development vs functionality\n\nWhile a developer is building an app, he may focus more on the rapid development. This means that the software development will put more focus on the process rather than the planning. That is why the app will be built earlier. On the other hand this will bring along less functionality for the app. Because less planning and less time will indicate less control over the app-building. Therefore  rapid development and functionality are two design goal trade-offs. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292045,
      "meta": {},
      "text": "Backward compatibility vs. Maintainability:\n\tSometimes keeping legacy systems up and running helps a business keep going, however since the technology used is old, maintenance is also very hard or specialized and people who maintain them are rarely found compared to modern techs.\n\n Efficiency vs. Portability:\n\tWriting the app in Java may make it more portable and easier to run on most platforms, however because of a large overhead, it might use a lot of resources and decrease performance. If it was written in some other language that would provide higher performance, then portability would not be as wide.\n\nSecurity vs Usability:\n\tMaking a platform or an app as secure as possible has some trade offs. Biggest one of them all is the time it takes for the user to interact with the platform, because most security measures make the system work slower. If it takes the user 10 minutes to reach the main page, then all that security would be for nothing beacuse no one would use the platform. Making the system as secure as possible without making the users feel frustrated is the goal.\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292152,
      "meta": {},
      "text": "-Functionality vs. Usability : Usability is the facility and the ease of using an interface of an Application by the user while Functionality is the set of implemented features and functionalities developed and available to the user. Those two major design goals often come as trade-offs since adding new features and operations to an interface makes it harder for users to access and use and deleting some of them will make it easier and more \"user-friendly\" but the interface will be less powerful.\nExp: For example, in the bumper game if we add new features to the car maybe it will be hard for the user to steer it while if we keep it simple maybe the user will find it boring at some points due to its simplicity\n-Efficiency vs. Portability:  Those two design goals often collied with each other where efficiency describes how efficient the software application is in matter of Device components (CPU, RAM..) and generally that will affect the portability of the App which will makes it hard to run on different platforms.\nExp: In the Bumper game , we can make the game run faster have more frames per seconds but then many phones wont be able to launch and support it\n-Cost vs. Robustness: those are two important Design goals that are generally set in trade-offs .Since the quote that says \"everything comes at a cost\" , we can understand that the more we spend on our application the better the application will be.\nexp : we can add for example security patterns for the application or also make it a bigger project by employing new developer to help implement the software application. But we should not forget that that we have a balance we shouldn't pass.\n\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292643,
      "meta": {},
      "text": "In software engineering there are several design goal trade-offs. \n\nOne of them is the achievement of effiency of a program in contrast to its portability. An example for that are computer games like the Dark Souls series or Nier Automata. These games were originally developed for consoles and the performance and effiency on them was great. But when they were ported to PC, the performance was quite bad, as (in Dark Souls' case) the controls weren't optimzed at all, or many of the game settings just didn't work properly (in Nier Automata's case).\n\nAnother design trade-off is the fast development of software in contrast to its functionality. An example for this can also be found in video games, like, for example, Battlefield 2042 or Cyberpunk 2077, which were both released with massive amounts of bugs and missing features due to them having to stick to their release plans. These games both have / had mostly negative reviews on platforms like Steam. The lack of functionality in those games reaches from bad performance and gamebreaking bugs to features, like a scoreboard or some weapons missing from the game. \n\nFurthermore, a design trade-off can be seen when making software robust and reusable. To achieve these aspects more often than not it is necessary for the developers to spend more time refining the software and thus the overall cost of its development increases. An example can be found by looking at the spendings of my parents' startup, as the cost of the development of the company's app was at least three times lower than what had to be invested when it came to making the app work stable and reliable.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1303381,
      "meta": {},
      "text": "Development Speed and Cost are usually a trade-off. The more money you spend on better technology, more engineers or longer working hours, the faster the project gets done. So you have to decide how much money you can spend to make progress as quick as possible.\n\nAnother trade-off is complexity and usability. It is very hard to make a complex yet easy software. The more functionality there is in a project, the more interface there has to be for the user to use that complex thing, which makes it harder to learn and harder to use (think of all the different menus and settings in windows).\n\nLastly, a rather technical but very relevant trade-off is always Speed vs Memory Usage. The more data you cache in algorithms, the faster they usually are. However, memory is limited (especially on embedded systems or something similar), so sometimes you have to take hits in performance to keep memory usage low.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1310636,
      "meta": {},
      "text": "One typical trade-off of design goals is cost vs. robustness.\nThis means e.g. the problem of wanting to save money on the programming part of your website and due to that not being able to include every possible case of user input or user action and cause problems by that. For example forgetting to limit the maximum length of user input and creating a safety issue.\nAnother one is functionality vs. usability.\nThis means the problem of wanting to give the user every possible option to make his product or experience unique, but on the other hand not wanting to loose potential customers/consumers by having to click through hundreds of steps/functionalities and therefore taking a long time. \nThe third trade-off is rapid development vs.functionality.\nDue to the very fast and flexible development it could happen that certain functionalities are forgotten in the process. Also due to the fast occurrence of new features, new steps, new problems etc you could maybe not be able to detect every part that was set at the start, or you could not be able to think of every aspect, that would be nice to have and improve the functionality. \n\nBased on the submission of last year: https://artemis.ase.in.tum.de/courses/121/text-exercises/4162/participate/798181",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344102,
      "meta": {},
      "text": "1) Privacy vs Functionality\nDevelopers want to collect data from the users in order to use in statistics, but they also value their privacy, so they only collect anonymous data and compromise functionality. \n\n2) Cost vs Robustness\nIn bank systems there must not be a single error, because they deal with money and neither a customer nor a bank can lose their money.  For this companies, that release bank systems should test their systems properly to avoid fatal mistakes and that will cost money. \n\n3)  Functionality vs Usability\nIn smartphones usually there are less than 20 options (possibilities to click) at one time. Developers group functionality and hide in folders, so it's more convenient for a client and more usable. For example I want to change a language of my phone. I go to settings, then to General, then to Language & Region.  In 3 clicks I achieve my goal and I find it more quickly, as if there were 100+ options on a screen at one time. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344200,
      "meta": {},
      "text": "Portability vs. Runtime efficiency:\nWenn ein system auf die spezille hardware eines systems optimiert ist, führt das zu bessere performance. Allerdings wird das system dadurch auch weniger portable, da platform spezifische Optimierungen nicht auf andere hardware funktionieren. Ein Spiel wie bumpers das in java geschrieben ist profitiert von der portability einer java application die auf viele systeme laufen kann, jedoch sind diese anwedungen in der Regel langsamer als binarys die speziell für eine platform gebaut sind.\n\nBackward compatibility vs. readability:\nWenn ein system backwards compatible bleiben muss, heißt das oft, dass bestehender code bzw. das system design nicht verändert werden darf. Dadurch wird ein system in seiner längeren Lebenszeit oft immer schwere zu verstehen und mehr veraltet abhängigkeiten bestehen, die die readablility verschlechtern. Bei webapps muss z.B. auf neuere technologien verzichtet werden, um alte browser clients weiterhin zu unterschützen.\n\nLow cost vs. Reliability:\nKosten lassen sich sparen, in dem systeme vereinfacht werden ohne direkt die experience des useres zu verändern. Statt z.B. eine komplizierte architektur die dynamisch skaliert wie z.B. kubernetes zu werden, wäre es billiger, sowohl von erntwicklungsaufwand als auch von den Betriebskosten her, einfach nur einen Hardware node zu verwenden, was die Reliability des Systems deutlich verschlechtern würde.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1431077,
      "meta": {},
      "text": "Rapid development vs functionality: If the time is limited, the functionality is limited and the shorter the time, the less functionality.\nE.g. if a team wants to develop a messenger in a year and after 3 months the time gets shortned to half a year, then extra features like audio or video calls might not be implemented, even if they were planned.\n\nCost vs. security: If the product has to be cheap, but its essential that all the functionality is given, things like security have to suffer. \nE.g. cheap IOT devices or unusually easy to hack. To get more secure devices one has to pay more.\n\nFunctionality vs. usablility: More functionality implies more options to chose from and when there are two many options one has to know the system well enough in order to use it properly and its barely usable for some who is new to the system.\nIf there is one button on the screen, one knows what to do, but one can only do one thing. If there are a thousand buttons on the screen, there are a thousand different options, but its hard to figure out whats the right one.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1661679,
      "meta": {},
      "text": "Design goal trade-offs simply explained, are situations/cases, where certain attributes and products are given priority and made more usable/desirable than others. This can be due to them being better, easier to implements, client-wish/demand oriented. This is needed so that a system can be maintainable and understandable in the long run.\n\nSome examples:\n\nmarket versus correctness: For example, a game might earn a lot of profit, but it was not implemented and designed correctly so it leads to the opposite\n\nA good example of it is cost VS. (versus) robustness.  Like a program that is able to handle every possible input from the user without crashing... is more expensive to develop.\n\nA further example is rapid (fast) development VS. functionality.  In this case: Developing the bumpers game within a week does not lead to a lot of special and cool features compared to developing it for a longer period of time (like over the course of a month-4 weeks). \n\nThe third example is functionality VS. usability.  For example an editing program like Photoshop offers a lot of functionality and features, However, it is more difficult to use since it is more complex.",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1290997,
      "meta": {},
      "text": "1. Functionality vs. Ease of learning\nIf a software has many functions, it will be hard for users to use. For example, a simple painting software with only a pen and an eraser with different colors will be very easy for people to learn to use. However, a professional painting software has hundred different functions more than that. If users want to use a pen, for example they have to choose between different kinds of pens. The buttons and choices increase which makes it hard to use. During the development in order to compromise between functions and ease of learning some functions may be deleted.\n\n2. Cost vs. Maintainability \nA good software usually needs maintenance, which has to cost the client to pay for the development. For example, an online game needs maintenance regularly in order that glitches could be fixed and updated. However if the client does not pay enough money for maintenance then the quality of the software will decline, after that no one will be playing the game and the client also gets no money.\n\n3. Rapid development vs. Minimum number of errors\nA client wants to rush the development process and market the software to profit. However, the developer wants to make sure the number of errors are as low as possible and needs time to eliminate them, so that the development could not be so rapid.\n\n\n\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292083,
      "meta": {},
      "text": "A typical example is the trade off between supportability and performance, i mean with that its super normal to abstract things in software engineering. A lot of times because of the abstraction there comes an overhead with it.\nFor example to use the Network Stack you dont have to communicate directly with the hardware and write thousand of lines of code you just have to use the abstraction layer that the os or others give you, there you will just need ~100 lines.\n\nOften rapid development and runtime efficienty is a huge trade off. If you dont take your time in architecting and developing the system you want to realize. There will often be the situation that you only use naive solutions for some problems that will harm the runtime efficienty. A good example is sorting so if you want to sort Student names at a large scale and you just use the naive Bubblesort algorithm instead of some better one.\n\nThe same thing with the runtime efficienty can be applied with reliability so rapid development can be a trade off of reliability if you cant take the time to fully test your code the code might break. For example if you dont test fully some edge cases like negative numbers, zeros or so will proceed to undefinded behavior.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292506,
      "meta": {},
      "text": "1. Cost vs Quality (robustness)\nBetter quality products, e.g., more Storage capacity or faster response time usually have higher costs associated, because these elements are more expensive to purchase or the Labour and time to create those elements (like bug fixes) costs more money. Therefore quality comes at the price of cost. \n\n2. Time (rapid development) vs functionality\nIf time is an important design goal, e.g, the client wants an app developed where the user can compare the weather in different locations in 3 days, then this would often come at the price of functionality - as it is very hard to go through multiple sprints and implement and improve existing functionalities in only three days. \n\n3. Functionality vs usability \nToo many functionalities can hinder the usability of a system and overwhelm the user. For example if you want to play bumpers, but the developers have added extra functionalities such as sharing photos and instant messaging, the user will get so overwhelmed as there would be too much happening on and taking up the display that they would not be able to play bumpers anymore, thus too many functionalities would hinder the usability. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1295440,
      "meta": {},
      "text": "Functionality vs. usability:\nA product might be functional and works the way it should, but the end-user can not access those functions and successfully use the product.\nFor example, a multifunctional backpack with an integrated water dispenser, life jacket, solar-powered phone charger, and parachute might be able to fulfill all of its requirements and functions but is way too big and heavy to be carried by a person.\n\nCost vs. reusability :\nWriting code that fits only one problem is often much easier and faster than witting more general and reusable code. An example from the real world would be: reusable coffee cups are much more robust but also way more expensive in the making than single-use cups. In addition, you need a much more complex hygiene system so that cup and dispenser won't touch to avoid transmitting germs from all the different reusable cups. \n\nEfficiency vs portability:\nOften, when software which has high portability runs a little bit sower and is not as efficient for example \nMac OS usually runs smoother than Windows but Windows is developed to run on a huge range of hardware while OS X is Tailor-made for that particular hardware.\n\n\n\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1297753,
      "meta": {},
      "text": "Cost v. Robustness\n- For example, to design a computer very robust against effects from the outside, you often need much better resources ( materials and people) which concludes higher costs.\n\nRapid development vs. functionality\n- Often the goal is to finish a system as fast as possible to bring it on the market, but that could harm the functionality. For example, while developing a game, if you do have not enough time you can not implement all desired features. So, the functionality will be not as good as it would be with more time.\n\nFunctionality vs. usability\n- For example in the development of a car, as a developer, you want to make the functionality as good as possible  ( safety, etc.) but the user should also have no problems driving this car. In this trade-off, the problem is that with more functionality the usability will be more complex.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344254,
      "meta": {},
      "text": "Widerspruch Schelle Entwicklung - Robustheit:\n\tSollte ein Produkt möglichst schnell dem Kunden zur Verfügung gestellt werden, dann bleibt zumeist wenig Zeit für eine saubere Architektur. Ebenfalls werden nur die notwendigsten Features getestet und Randfälle meist aufgrund des Zeitdrucks vergessen. \n\tBeispiel: Eine neue Pandemie sucht die Erde heim. Um entsprechende Testangebote anbieten zu können, entschließt sich die Gemeinde Garching eine Website erstellen zu lassen. Da die Tests möglichst schnell über die Website gebucht werden können, sollte innerhalb von 2 Wochen alles funktionieren. Eine Woche nach Übergabe an den Kunden, kommt es leider zu einem Systemabsturz, welche durch eine falsche Benutzereingabe ausgelöst wurde. Dieser Randfall wurde ungünstigerweise nicht beachtet.\n\nWiderspruch Niedrige Kosten - Erweiterbarkeit: \n\tMöchte man ein neues Produkt möglichst günstig entwickeln, so wird zumeist an der Anpassbarkeit und Erweiterbarkeit gespart.\n\tBeispiel: Ein knausriger Bäcker möchte einen morgendlichen Lieferservice anbieten. Die Bestellung für den nächsten Tag sollte über eine Website mit responsivem Design für Mobilgeräte erfolgen. Nach Inbetriebnahme beim Kunden fällt auf, dass die Zielgruppe ebenfalls gerne die Waren der Konditorei erwirbt. Enttäuschenderweise ist das durch das schlecht erweiterbare Systemdesign nicht möglich.\n\nWiderspruch Benutzerfreundlichkeit - Rückwärtskompatibilität:\n\tSollte dem Nutzer eine möglichst nutzerfreundliche Oberfläche geboten werden, dann kann das mit der Rückwärtskompatibilität in Konflikt stehen. Aufgrund der Kompatibilität mit älteren Geräten und Versionen kann es vorkommen, dass neue Funktionalitäten nicht genutzt werden können. \n\tBeispiel: Die Website des knausrigen Bäckers sollte auch auf älteren Browser-Versionen laufen. Dadurch können leider manche moderne Browserfeatures nicht genutzt werden. Beispielsweise kann die Website nicht am Gerät als App umgewandelt werden, da dies von älteren Geräten/Versionen nicht unterstützt werden. Siehe PWA-Kompatiblität",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1379716,
      "meta": {},
      "text": "Functionality vs Usability:\nTypically, having a lot of functions for example requires a lot of buttons and fills the screen with information, resulting in low usability. Having a less cluttered, simple, clean and precise user interface makes for good usability but as a trade of lacks feature, to ensure the interface is clean.\n\nEfficiency vs. portability:\nMaking a portable product means having a lot of abstract code to be platform independent. For a efficient project, it's important to use a lot of platform specific features, to improve performance. This makes it harder to port to other platforms, since the platform specific code has to be rewritten for every platform, to make use of its strengths and platform-specific features. So having an efficient projects means using platform specific features, therefore trading of portability. To achieve portability, a lot of efficiency is lost.\n\nRapid development vs. functionality:\nMaking a lot of features takes a lot of time. For rapid development, omitting a lot of features can speed up the development process a lot, since the features don't have to be developed, maintained and their bugs fixed. Therefore, for more rapid development there is less functionality and more functionality slows the development down.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1388265,
      "meta": {},
      "text": "1. Benutzerfreundlichkeit vs. Kosten: \nEine Anwendung, in der alle Funktionalitäten auf einem Bildschirm zu sehen sind, ist schneller und einfacher zu erstellen, da man keine Ordnung und kein System in das Nutzerinterface bringen muss, also kosten sie weniger Zeit/Aufwand und damit auch Geld. Sie sind allerdings auch viel schwerer zu verstehen, wenn man das System nicht bereits kennt, und damit nicht benutzerfreundlich.\n2. Verlässlichkeit vs. Kosten:\nGrundlegende Funktionalität lässt sich häufig schnell und damit schnell implementieren. Dadurch passieren aber auch häufig Fehler, weil man verschiedene Situationen nicht bedacht hat. Wenn bspw. in einem Spiel Wände existieren, von denen die Spielfigur abprallt wenn sie sie trifft, kann es bei zu kurzer Entwicklung schnell passieren dass Fehler auftreten, wie solche, dass die Spielfigur wenn sie mit zwei Wänden gleichzeitig kollidiert eine Kollision ignoriert und durch die andere Wand durch geht anstatt abzuprallen.\n3. Wartbarkeit(und erforderlicher Speicherplatz) vs. Performance:\nHäufig lassen sich Programme schneller ausführen, wenn kurze Schleifen einfach ausgeschrieben werden, Lookup-Tabellen erstellt werden oder Ähnliches. Das macht das Programm aber häufig sehr schwer zu warten weil man leicht den Überblick verliert oder den Fehler nicht findet. Damit Programme wartbar sind, verallgemeinert man wenn möglich meistens Funktionen in Schleifen oder anderen Funktionen/Methoden, benutzt nur begrenzt Lookup-Tabellen und erstellt Interfaces die die wichtigsten Informationen für Kommunikation nach außen sammeln und zurückgeben (bzw.  verschiedene kleine Funktionen zu einer großenn nach außen sichtbaren zusammenfassen). Dadurch werden Programme deutlich leichter wartbar und verbrauchen auch weniger Speicher als riesige Lookup Tabellen. Bei Programmen die rieseige Datenmengen verarbeiten und mehrere 1000 Male am Stück aufgerufen werden macht das aber einen deutlichen Performanzunterschied.",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1291712,
      "meta": {},
      "text": "1) Cost vs. functionality: While a client may want to complete the project with low cost, the end user may insist on certain minimum features and functionality of the software. It may not be possible to develop the required functionality of the software at the low cost demanded by the customer. The result is either lower functionality of the software or higher cost.\n\n2) Backward compatibility vs. readability: If the client requires the software to be backward compatible with old software that have been around for e.g. 30 years, this can lead to readability issues.  Because of the complexity involved with the old system, many special cases and old functionalities must be included, making the code for some parts unreadable and more difficult to understand.\n\n3) Robustness vs. cost: Budget constraints on the part of the client can very quickly lead to the product not becoming robust in software projects because, for example, it is not tested extensively enough. As a result, specific cases are overlooked and bugs creep into the software. The trade-off that must be made is therefore between the costs incurred and the degree of robustness of the software.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1294219,
      "meta": {},
      "text": "A tipical trade of you have to make regarding design goals is functionality versus usability. The more features you add the more cluttered the application gets and the learning curve of the user gets steeper. But if you don't add enough functionalities you may lack something important that would help more experienced users.\n\nAnother tradeoff would be betweeen low cost/rapid developement and good documentation/maintainability. \nThese two pairs of goals go hand in hand in my opinion. Documentation takes time to create and time costs money. Also documentation is an easy place to safe time and cost, as the lack of documentation will effect the project only in the long run and not immediatly.\n\nThere is also a tradeoff to be made between Well-defined interfaces and flexibility for the client. The client would love to be able to change whatever in the software easily (things that would alter the project structure) but the developer wants to have a clear long term goal and not have to change things up multiple times.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344248,
      "meta": {},
      "text": "One design goal trade-off is robustness vs rapid development. The client obviously wants the software product to be finished as soon as possible but on the other hand its is difficult for the developer to ensure that the system will still function accordingly under different circumstances. Any bigger software project needs time for testing for example to be able find bugs in their software product.\nAnother design goal trade-off is cost vs robustness. Similar to the robustness-vs-rapid-development-trade-off not having enough financial recources can be problematic for developing robust software. Testing as an example again does not only take tim but of course also costs money. And as already mentioned if steps like tested are neglected due to a low budget the system might not always function properly.\nOne last design goal trade-off is Functionality vs Ease of learning. Having many different and useful functionalities in your system is at first sight something profitable. But the end user might have a hard time to understand all the functionalities wich makes it harder for him to understand the system and might even hinder him to use the system properly. For example a Bumpers game with many different collision-types and different ways to steer your character on the gameboard gives the game a lot more functionalities, but can also make it harder for the player to understand the game.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1428709,
      "meta": {},
      "text": "1. Cost and robustness - often a robust system is able to, for example handle a large number of users at once. This means more resources are needed to be able to serve what is demanded and thus the cost of the system increases, sacrificing the low cost design goal.\n\n2. Usability and functionality - it is no surprise that clients and developers would want to design a complete system that can have a lot of useful functionalities. But the more functions it has, the usability of the system may decrease as for the end users, for example, may find the system too difficult or complicated to use as there are too many detailed steps required or the function they want to use may be too hard to find in an ocean of functionalities.\n\n3. rapid development and functionality - as rapid development relies heavily on prototyping rather than planning, unlike agile development, some important or essential functionalities may be overlooked by the team.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1438260,
      "meta": {},
      "text": "One is \"functionality vs usability\". It means that you can have many functions but therefore your user interface for example is not easy to learn or easy to remember what all the functions do. But it can also be that you have a good user interface, where you can remember all the things easily but for that you have less functions. So an example would be a video game like street fighter. You have many attacks or combos a player can execute but they are not easy to remember and then maybe it is not enjoyable to play because there are to many things you can do but you cannot remember all the things and you have to look always at the control system.\nAnother is \"efficiency vs portability\". It means that your system can be efficient but for this it maybe is not portable so that you cannot call it on multiple platforms. For example you are developing an app which runs perfectly on iOS but not on android or other platforms. \nAnother is \"rapid development vs functionality\" and that means your project cannot be that good if you developed it fast to satisfy the client. Because if you develop something fast then it means that you have left a few things out so you have less functionalities in your system. An example for that is an online shop where you can buy fancy clothes for example but you left out the function to pay with Apple Pay and only have the function to pay with Visa card because you developed this rapid and therefore you did not thought about apply pay for example.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1472853,
      "meta": {},
      "text": "Functionality vs. usability:\nA higher functionality in the program is normaly accompanied with more options and icons, to use those Tools accordingly. In most cases this leads to complicated menus and hidden buttons witch make the software difficult to use. Especially if the user wants to use specific functionalitys.\n\nEfficiency vs. Portabiblity:\nA program can be optimized to run well on specific hardware and with specific software. But there is a myriad of different combinations of hardware and software. As a result it`s difficult to optimize a program for them all. An Optimization for one system can often backfire on anohter. As such developers need to find a balance beetween portability and efficiency.\n\nCost vs. Robustness:\nAs projects are usually developed as low cost as possible, the robustness of the project suffers. Low cost in production creates a scenario, where the product gets shipped as soon as it´s funcional. Even though the first iteration of functionality almost always has several weak points, witch could easily be avoided with a higher development cost (which would result in more development time).",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291189,
      "meta": {},
      "text": "+cost vs quality:\n\tzb. wenig/viel Budget bei der entwicklung von SW folgt meist ein Produkt von wenig/gute qualität, \n\t(elektronik aus china, made in Germany produkte,...)\n+functionality vs usability: \t-simplen app ist leichter zu benutzen zb whatsapp. Viele feature sind cool, muss \n\t\t\t\t\t\taber von user gelernt werden (insta bei älteren menschen schwierig zu lernen)\n+rapid development vs funktionality: \t-Games die schnell entwickelt werden meisten verbuggt und hat viele Fix \n\t\t\t\t\t\t\t\tupdate \n+Cost vs reusability;\t-elektroautos sind zwar Umweltfreundlich aber teuer von Herstellung",
      "score": 41.7,
      "language": "GERMAN"
    },
    {
      "id": 1292077,
      "meta": {},
      "text": "Functionality vs Usabilitzy:  This trade-off describes the conflict between the scope of functionalities the systems should have and the usability, so the ease of use of the system. If the bumpers game functionality wants the player to decide every property of the car, but the player should also be able to start the game in less than 3 system steps. \nCost vs. Robustness: This trade-off describes the conflict between the robustness, so the ability to maintain all functions, of the system and the maximum cost of the system at the end of the project, e.g the development of a vending machine should at most cost 2000€, but should also maintain all functions while extreme changes of temperature between summer and winter occur.\nRapid development vs. functionality: This one describes the conflict between the dinal product deadline but also the scope of functionalities the system should have, e.g. the smart vending system should be delivered in 1 month but should also have an AI-voice control with web communication, that definitely is too complicated to be finished within 1 month\n  ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1299543,
      "meta": {},
      "text": "typical design goal trade-offs involve having a less maintainable codebase because not enough founding has been provided. Another one would be having a documentation inside of the code but not offering a good public documentation because manpower is more necessary for  the codebase instead of having a documentation. \n\nA typical design goal trade off is \"Rapid development vs. functionality\". Here the goal has to be correctly select. You might have a working product in a matter of a few days,  but it doesnt cover all of the functionalities that you wished for. It might still do all of these but then not have a simple to use UI. \n\nA third example could be that it is a very runtime efficient program but it only works on certain devices. You could develop a software that is very quick and powerful but only works on arm-chips. Due to that you have created another limiting factor by yourself.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1332573,
      "meta": {},
      "text": "1. cost vs. reusability:\n       Example: a company wants to have a app that the employees in the company can work on one object      \n       together, they can command and share the opinions in this app and see the job schedule of the \n       others.\n       if the developer team spend more money and more time on developing this app. this app may can used     \n       by many other companies not only this one.\n       but if they chose to spend less cost on this, this app may can only be used by this one company.\n\n2. functionality vs. usability for the end user:\n       Example: i keep using the situation above. the end users of this app are the employees in this company.\n       when we choose functionality from this trade-off. There are maybe more than 50 functions in this app, \n       User can do almost everything in the company with this app. but its hard to learn how to use these all \n       functions.\n       If we choose the usability, this will be nice to the older employees in the company. To learn a new system       \n       is maybe hard for them. so if the app has only 10 functions , it will be more usability. but maybe they need    \n       to do something else without this app to handle the business thing in the company.\n\n3. cost vs. robustness \n       Example: i keep using the situation in the first one. \n       For the developer team for this app, they can develop     \n       this app with lower cost, but then this app may have more errors in the future, because its not so\n       complete and not so safe and needs more work on it.\n\n       but when they add some additional coding and the testing costs. the app may don't have so many errors \n       in the future and the developer team doesn't need to speed more time to debug this app so many times \n       after they finished development of this app and give this app to the users.\n       They want to finish this job once and just like that can increase the satisfaction of the customers.\n     \n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344209,
      "meta": {},
      "text": "There are three main actors, the developer, the end user and client which each have a different focus and objective /goal with the system. These objectives or design goals can interfere with each other and the you have to trade-off design goals. Typical design goal trade-offs incluce:\n\nFunctionality vs. usability: One of the end users design goals is functionality which describes what the software is supposed to do and another one is usability which measures how \"easy\" an actor can use the system functions.\nThe trade off could be to focus on usability because maybe the functionality can be way too concrete and complex and it would take a lot longer to develop the system. Usability may also be more important because it increases the user interction and makes it better.\n\nEfficiency vs. portability: Efficiency is a design goal of the end user and the client while portability is a design goal of the end user and the developer. Efficiency means that once you learned how to interact with the system that it is fast to use while portability means you can run the systen on any device and on multiple operating systems. \nThe trade off could be to focus on efficiency, that the system is not to complex and hard to understand and later implement it on other operating systems.\n\n\nRapid development vs. functionality: \nThe trade off could be to focus on functionality rather than rapid revelopment because it is more important that the system works and what it does rather than it being produced fast with a lot of errors.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1470113,
      "meta": {},
      "text": "1) Functionality vs. usability means that the more functional the system is, the more complex it will actually be, that puzzles the end user sophisticates the ease of usability. The example here is Android smartphones vs. Apple iPhone: iPhone functionality is severely reduced, but iPhone itself is very easy to use, whereas Android smartphones are way more complex in functionality and settings, but few if any use all of them, since they are not that easy to use.\n2) Cost vs. robustness: creating and maintaining a really robust system demands a variety of tests from the developer and, of course is bounded with additional costs: both money and time. The example here is ill-reputed Battlefield 5 - a famous game, that after the release had a lot of bugs to be fixed, while the management barely sponsored the proper testing.\n3) Rapid development vs. functionality: the conflict is raised by the disability to fastly implement lots of functionalities, since development costs time and the final development is dependent on the complexity of the system and it's functions. The example might be also a game: Cyberpunk 2077 was released with really cutdown in-game functionalities, since the developer team was forced by the management to present the final product earlier than the game could actually be ready. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1496267,
      "meta": {},
      "text": "Functionality vs. usability\nThe more functionalities a program has, the more decisions a user has to make, reducing the efficiency for finishing a task. E.g. Photoshop has a lot of functionalities however finding the exact function needed to for example add a gaussian blur requires a lot of research or prior training.\nCost vs. Robustness\nA robust program needs a lot of time to develop and test edge cases, therefore making it more expensive to produce. For example video games by EA Sports are usually released unfinished with alot of bugs making the game more profitable in trade of bugs and crashes.\nEfficiency vs. portability\nPortable programs are not dependent on the operating system but usually slower since they have to account for the differences in hard- and software. Java for example is running on 5 billion across the world but runs only inside its own virtual machine therefore reducing it's response time.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1659065,
      "meta": {},
      "text": "First design goal trade-off is usability: if the software-engineering team designs an interface for the user (for example) it might be harder to use in the end, when there is to much going on. Simplicity in design can often lead to a better overview and is mostly more usable for the user.\nNext you might thinkt about maintainability: is the design goal of the end product even maintainable? Often when your product needs to be maintained, a design goal might not be completed because of its detail or complexity, etc.. This can lead to dangerous flaws such as problems in the structural planning (for example maintaining a design goal for a long time, not keeping the deadline for the end product).\nLastly you need to consider platform independence: if the end product with all your design goals runs on your machine, that will not guarantee it to run on any machine of your end users. Software changes rapidly, so what might be a good software/hardware now, can easily be considered \"below standard\" in a few years from now. If you don't take this in consideration, your end product might not run on some devices, which would be a serious problem. Many GPU cannot run applications properly with highly detailed graphics/designs. This is a design goal trade-off you definitely have to think about.",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1291595,
      "meta": {},
      "text": "Backwards compatibility vs. readability:\nThese two mostly conflict because backwards compatibility makes code readability or even system models that take old features into consideration bad. In a model for example, old features that still have to be supported might be an annoying part that always has to be carried and destroys the good overview of the rest of the model. In terms of code, there might be old file formats for certain features that have to be supported with following versions of the product. This can turn out really unfortunate when there is a better solution or the rest of the system is being refactored.\n\nEfficiency vs. portablility:\nIn order to make software efficient, in most cases it has to be tightly integrated and optimzed. However a tight integration often times implies that readability as well as the ability to reuse the code in other cases have to suffer. In high performance computing for example, it is the programmers job to optimze the code towards one specific use case, so he / she tries to use every single piece of known information to improve efficiency. To stay  portable however requires to leave some information out which is dependant on the use case.\n\nFunctionality vs. usability:\nThis conflict mostly has to do with the user inferface of a product. On the one hand, a UI should be kept simple for an easy to learn experience. On the other hand, too much functionality might be great for people that know the software well but overwhelming for new user. While MS paint is great for new users it lacks the functionality of Photoshop, which itself might be too functional and therefore not useable for many unexperienced users.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291880,
      "meta": {},
      "text": "A typical design goal trade-off is that the costs are in conflict with the robustness of the system. Of course you'll need your code to be as robust as possible so that all failures are handled well and it is as safe as possible. But catching all exceptions and checking all edge cases might be very expensive and make your programm slow and inefficient. For example if you create a platform where every user has a user name and your code is only able to handle words and no numbers, you'll have to check that there are no numbers in a new name if somebody changes their name. But that will make changing the name slower.\n\nAnother trade-off is that often rapid development is requirered, so that functionality suffers. For example if a team works on a project with 10 requirements and they need half a week for implementing and testing each, they won't be able to finish the project in two weeks. Mayby they won't test and there will be more bugs. Or they'll have to leave out some functionalities. So if there isn't enough time functionality will suffer and you'll need lots of time to make a system as good as possible.\n\nEfficiency and portability are contrary too. To make a program as effective as possible it's necessary to design it for operating system or to make it even more effective for a special hardware. Of course this will limit the portability. So for example if you wrote a code especacially for a multicore system it might be super efficient there. But it should still work for single core processors too.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292050,
      "meta": {},
      "text": "There are many kinds of design goal tradeoffs in software engineering, but (amongst others, here are three of them:\n\n(1) Functionality vs Usability:\n\t- This one is probably the most common one out of all them, which takes place whenever an application is \t \n           needed  with a very specific/universal functionality, but it also needs to be \"easy to use\" and \n           understandable for the end user\n\t--> The more functions an application has, the more \"Buttons\" and interactions are needed from the user to \n               use the application to its fullest extent, which in turn, makes the application crowded and hard to use.\n(2) Cost vs Maintainability:\n\t- Whenever an application needs any sort of maintainance, there needs to be a certain cost tied within it, \t \n           such as, for example, server upkeep costs.\n\t--> The more maintained the app needs to be, the more money needs to be spent, inorder to afford such \n               tools/maintainabiltiy\n(3) Efficiancy vs Portability\n\t- For a program to be efficiant, it needs to be \"perfected\" first, which means that a lot of effort needs to go \n          into developing an algorithm that makes the most sense and is the most usable at the same time. If the \n          program also needs to be portable, then a lot of time and resources, which otherwise would be used to \n          \"perfect\" the application, now are allocated towards portability instead.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1297658,
      "meta": {},
      "text": "One typical design goal trade-off in software engineering is between cost and robustness. That is, if one wishes to have a to develop a cheap software by hiring less developers and having less development time means that there won't be enough time to thoroughly cover off edge cases and possible instabilities. For example, a hasty development of a web application may leave a form unsecured, so that if an user types in a string instead of an integer, the application may crash.\n\nAnother typical trade-off is backward compatibility and readability. This means that if the software should run on old hardware, the necessary implementation in the solution domain may be very archaic and difficult to undestand, mantain and further develop. For example, if a team has to develop a banking software which is able to run on IBM mainframes from the 60's, it will have to be implemented in COBOL, which is a very archaic language with difficult syntax.\n\nLastly, one has to choose between rapid development and functionality: if the software has to be delivered quickly, it can not have as much functionalities as one that had more time to be developed. For example, in game development, if a game has to meet tight deadlines, the dev team has to crunch a lot and will not be able to implement a lot of functionalities, since it has to fix bugs and focus on delivering a finished game. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1330932,
      "meta": {},
      "text": "functionality-usability: if we provide so many options to increase the functionality, then the end user may get confused and get lost by choosing the right function. So it decreases the usability.\n\nCost-robustness:If we try to get rid of robustness, then it costs more because we need more developers or new technologies.\n\nefficiency-portability: For example, If we use the programing language C, then the program runs faster but on the other hand, the program is now less portable because of the level of the language C.",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344665,
      "meta": {},
      "text": "1. Functionality vs. usability. \nTo increase functionality and the number of methods or functions, a lot of buttons will be added to the user interface, where the user has a variety of choices, of which functions they now want to use. However, an user interface with a lot of buttons often looks messy and disorderly. The user often doesn't have an overview of the functionalities and could feel uncomfortable to use the messy user interface, which decreases the usability.  In vice versa, the functionality could decrease, as the usability increases, which makes it important to find the middle point to compromise.\n2. Cost vs. robustness\nOften a great cost is needed to guarantee the robustness. For example, many great Tech-giants such as Google possesses many spare (extra) servers, in case the current server stops working. As they have the extra servers, their system or service stays robust and establishes the trust of users. They are accepting that the maintenance of multiple servers costs a lot of money, work, and effort, which certainly is a disadvantage for them. It is therefore important to find the middle point here too.\n3. Cost vs. Reusability\nIt takes often much more effort and work to develop reusable software than software for one purpose. For example, it is much easier to develop software, which recognizes the lyrics of songs in the English language. However, it would cost much more money and work to write software, which recognizes lyrics of songs in every language, which yet would be far more reusable.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1348013,
      "meta": {},
      "text": "Three typical design trade-offs are maintainability, scalability and adaptability.\n\nMaintainability is basically when the main focus while developing the product is in making it more robust so that is lasts longer and not necessarily implementing every single feature right away but maintaining always a clear and defined structure (eg. clean code, intuitive system design) because that allows more people to work on that project.\n\nScalability is when a product or service is designed to continue working smoothly despite the number of users using it. This is necessary since it is almost in any businesses interest to attract new users, which is why its platform should be able to provide its service to any customer.\n\nAdaptability is necessary since every business should be able to fulfill new market needs, be flexible to utilize new technologies and be open to new business models as well. \n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1350932,
      "meta": {},
      "text": "1. Cost vs. Reusability\nIn our team project we opted to build the list of selected flights so that it inherits the global flight list and adds some extra capabilities like add and delete. Because the code will be reused, extra effort and time will be spent on implementation and final design to ensure that everything functions together well. \n2. Cost vs. Robustness\nIn addition, in our team project, we chose to invest extra time than intended for testing to ensure that all of the capabilities implemented perform as expected and without bugs. As a result, it will cost us some extra time.\n3. Efficiency vs. Portability\nIn many cases a language like C is much more efficient because it allows better access to the hardware level. But often people choose the less efficient but much more portable language Java, if the product being developed requires it. Therefore, for example, many mobile games are developed in this language, since there are a lot of different devices.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1371064,
      "meta": {},
      "text": "A design goal trade-off that I encounter often is rapid development vs. modifiability. When I have an assignment due at 23.59 and only start an hour before, I will prioritise rapid development over modifiability. This means that my code cannot be extended or modified well because I might have hardcoded specific aspects or I might have decided to implement everything in my main-method instead of writing different methods and classes that implement the functionality.\n\n\nAnother trade-off that I observe frequently is ease of learning vs. functionality. This is most often the case with applications that I download. Open-source linux applications often choose functionality over ease of learning, because the target demographic often already knows how to operate similar applications. One example of this could be \"grep\". iPhone apps choose ease of learning most often. Most apps and games I have on my phone could be operated by kindergardeners, who are (presumably) also part of the target demographic. I think the outcome of this tradeoff mainly depends on the way the information is presented (website more functional than app) and the target demographic.\n\nLastly, efficiency vs. portability is something that I only really learned about last semester while taking ERA. I wanted to write ASM-Code and I usually ssh on my raspberry-pi for homework. r-pis use ARM architecture though, so I wasn't able to run x86-Code on it. If I had wanted to implement something that ran on both the pi and my machine, I would have needed to either implement two different versions or used a higher-level-language (and sacrificing efficiency of my code). The benefit to writing C code would, of course have been, that I would only need to implement, debug etc. everything once.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1449552,
      "meta": {},
      "text": "The most common design goal tradeoff is portability VS. efficiency. This example is best described with the usage of Java vs. for example C++. Java has been designed with portability in mind, allowing for a wide range of devices being able to run a specific program. By employing mulitple different helper methods that parse the code Java is able to run by a wide variety of end users. On the other hand, C++ is not very portable but because it is so close to actual assembly the speed and efficiency of all methods are greatly increased due to no extra methods slowing the program down. \n\nFurthermore an always discussed tradeoff is cost VS. re-usability. Obviously most customers want to keep the cost of a project as low as possible whilst still delivering a good enough product. As each hour the software developer works costs money, the time spent on a project also needs to be kept as low as possible without taking a hit on program quality. Developers like to implement pretty methods that can  be used in many different parts of the code, unfortunately these methods aren't written in the first iteration. To create a class or method that can be reused often, some improvements on the code have to be thought of. All of this reiterating costs developer hours which in turn costs the customer money.\n\n\nLastly a big topic in software development is robustness and safety of the program. The tradeoff here is cost VS. robustness. The reasoning behind choosing one over the other is the same as in the example before, because writing safe programs take time and time costs money. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1499879,
      "meta": {},
      "text": "In software development, there often are certain goals for the products that almost always make sense. For example, most software should be bug-free or not take too much time in development. Sometimes though, some of these goals are not necessarily compatible.\nIf we take a look at massive software products, such as MS Office, or the Adobe Creative Cloud, we reach such high standards, that bugs become unacceptable. In cases like those, it becomes necessary to spend more time and resources on development to maintain the high standards that these companies have established. Therefore it becomes difficult to develop those products in a small timeframe or at a low cost.\nAs we have entered the era where every last company wants you to download their own app, those should be talked about as well. Most of those apps are free, for example the Campus TUM app. For them, it's often more important to get people to download the app and use it than to make money with it. Offering an app for free doesn't erase it's development costs, unfortunately.\nAlso there's the market of Open Source apps - apps that give out their source code in it's entirety to everyone on the internet. That of course, is great for maintainability, because everyone can see what the code does, but it limits the possibilities of marketing and profits, since everyone can just copy and paste it in it's purest form straight from the internet.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1505700,
      "meta": {},
      "text": "Cost vs. robustness :\nwhen developing a software system robustness must be taken into account as in important design goal to ensure a good quality  and strong product but this occurs on behalf of another design goal which is cost because guaranting high performing components will cost more .\nFunctionality vs. usability :\nIn software engineering having a multi-functional product could affect its usability and this by being over charged and complicated which will make it hard to understand and use by the user . So making an simple interface between the product and the client with compressed functionality will make it easier to use .\nEfficiency vs. portability : The client system should be usable on multiple platforms, and should be accessible to the different users but this could affect the Efficiency of the prodcut and this depending on the used softaware and how much it can be applicable to other hardwares .\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1290808,
      "meta": {},
      "text": "The User wants a rapid development of his software as a design goal and the End User wants alot of functionality.\nThese two design goals have a big trade-off. \nIf the developer doesn't have much time to work on the software he can't spend much time on working on the functionality of the software. So in the end a compromise has to be found.\n\nAlso the client wants a software at low cost but the developer want a good software with minimum of errors.\nSo creating that software with minimum errors costs time and the more time a developer has to work on the software the more it costs.\n\nRuntime efficiency and portability are also big trade offs.\nIf you want a software portable on diffrent os or devices like computer, smartphone or tablet you lose on runtime efficiency because you can't optimize your software on one specific enviroment.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1295462,
      "meta": {},
      "text": "Funktionalität vs. Nutzbarkeit \nDie Funktionalität einer Software beschreibt die Menge der Operationen, die eine Schnittstelle unterstützt während die Nutzbarkeit die Benutzerfreundlichkeit untersucht.\nAnhand des Beispiels der Software von SAP ist es relativ einfach den Designkonflikt zu verstehen. Datenmangement ist eine zentrale Aufgabe von Unternehmen. Hierbei ist es für das Unternehmen wichtig, möglichst viele Geschäftsprozesse über die Software abwickeln können und gleichzeitig Zugriff auf viele Daten zu haben. Aus Seiten der Mitarbeiter ist es aber auch wichtig, dass die Software einfach zu verstehen ist. Wenn das Programm zu komplex ist, also nicht nutzerfreundlich ist, bringt es dem Unternehmen eher Nachteile, da Prozesse oftmals länger brauchen.\n\nKosten vs. Robustheit\nMöglichst geringe Kosten spielen bei der Entwicklung nahezu jeder Software eine große Rolle.\nIm Falle der Garantie der Robustheitist einer sicherheitskritischen Software ist es allerdings sehr wichtig, zwischen den zwei Positionen genau abzuwägen. \nBeispielsweise ist es im Falle eines Luftfahrtsystems sehr wichtig, viele Tests durchlaufen zu lassen. Da Menschenleveb von der Sicherheit und Zuverlässigkeit der Software abhängen, können es sich Entwickler nicht leisten, einen Fehler zu machen.\n\nKosten vs. Wiederverwendbarkeit\nDas Erstellen und Bereitstellen von wiederverwendbarer Software ist durch erhöhten Zeitaufwand/Programmieraufwand in der Entwicklungsphase häufig mit höheren Kosten verbunden. \nHierbei ist es allerdings wichtig, gut zwischen den vorerst erhöhten Kosten und den darauf folgenden Vorteilen in der Zukunft abzuwägen.\nDie Wiederverwendung einer Software bringt signifikante Produktivitätserhöhungen,  eine Reduzierung der Kosten und eine Verkürzung der Entwicklungszeit in der Zukunft mit sich. \nAllerdings sind auch die mit der Verwendung bereits besthender Stoftware verbundenen Kosten  - Wartung der Software und Pflege der Komponentenbibliothek - nicht zu vergessen. \nEin Beispiel hierfür ist die Wiederverwendung von Software für die Automobilindustrie. Die Wiederverwendung von Software hat hierbei den Vorteil geringerer Entwicklungskosten und die Steigerung der Software Qualität.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1334301,
      "meta": {},
      "text": "One of the most typical design goal trade could be functionality vs. usability. In a perspective of a developer, it is important to think all about what client could do with the application/website or vice versa, therefore developer implements more functions whereas these can be overwhelming for the client. One example of these trade-offs can be Spotify's design change of its app: It was overwhelming to search for your podcasts, playlists, and literally everything because Spotify had implemented so many functions. With the new updates however, everything is merged under one category which made some functionality get lost but it became more usable.\nOne more trade-off that mostly young startups would do is that they would implement their products rapidly, therefore not caring about so much functionality because of the competence with other startups. I have been using Freeletics since 2016. Freeletics, right now one of the most successful unicorns from TUM, had an app back then which was not that functional: There was not a nutrition plan or challenges or a community that can boost each other. But as time goes by, Freeletics also took care of functionality and implemented new functionalities. \nLastly, cost vs. robustness is one of the main design goal trade-offs that one can see. One needs to think about all possible scenarios that the application can experience and implement correspondingly but this would cost much. While doing PGdP it was necessary to think about all the scenarios because one couldn't see what the hidden tests were. But this would cost too much time, therefore one would make a trade-off between cost and robustness.\n\n\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1347551,
      "meta": {},
      "text": "In software engineering, design goals, which can be seen as additional nonfunctional requirments for the system are often in conflict with each other. Therefore one has to decide on the most important aspects through various design goal trade-offs. Three typical examples of those are:\n\n1. Functionality vs. usability. Beeing a jack of all trades and having a system with lots of different functionality often greatly decreases the usability of said system. This is of great importance for applications such as calendar apps, because while being expected to provide a wide range of functionality, it cant simply bombard the user with functions that would be hindering ease of use. They therefore have to limit themselves and keep a cleaner interface, while potentionally providing additional funtionality that can be accessed through a facade-like interface hidden at launch.\n\n2. Rapid development vs. functionality. Developing a system with good functionality is obviously very time consuming and is hence difficult to accieve for systems that seek a short development phase. Sticking to the example from above, a google calendar app that has to be developed quickly due to a new apple calendar releasing in 1 year, cant possibly provide all desired functionality in such a short amount of time and has to limit itself to the most important aspects in order to meet the deadline. \n\n3. Cost vs. robustness. A sytem that is robust and is able to maintain its functions despite various changes in the environment or the user input is by nature very costly. If the calendar app wants to be equipt against wrong user input such as non existent birthdays or dates and times, it can't be made keeping a low budget due to extensive testing and will thus be more costly.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1348543,
      "meta": {},
      "text": "- efficiency vs. portability:\nif you want to implement let´s say a weather application in an efficient way, then using C programming language might be more efficient but using Java is much more portable.\nAn efficient implementation often times reduces portability because the implementation migth be machine-specific and therefore doesn´t neccessarily run on every machine\n\n- rapid development vs. functionality:\nthis conflict addresses the problem that realizing functions in a system takes time. So if only a short period of time is provided to develop a system, the functionality might be limited or boiled down to the core functionality without any extra features. e.g.  if a ticket booking application for a spontaneous school event is needed, the development shouldn´t be that time consuming -> instead limit the functionality to the core aspects like having a central name list containing all people who bought a ticket and sending an email to them\n\n- functionality vs. usability:\nthis conflict points out the problem, that many functionalities cannot be realized with having high usability. Or the other way: if a system should have good usability, some functions might be limited or excluded because complex user input might be neccessary and confuse the user\ne.g. if you want to develop a system that helps the user doing his taxes, the  functionality-aspect might overweigh the usability-aspect because the user might get in trouble if he submits his taxes wrong -> the user will not be able to do everything with 3 clicks ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1417218,
      "meta": {},
      "text": "EFFICIENCY VS. PORTABILITY: A cloud-based program might be much faster/capable, but is it worth it over the program being able to run locally on a portable device, in situations without any internet connection? \n\nRAPID DEVELOPMENT VS. FUNCTIONALITY: A development team might choose to release a program in an \"unfinished\" with limited functionality but keep improving it through updates\n\nCOST VS. REUSABILITY: Using an in-house engine might be more cost and time intensive but may pay off in the long run being reused for other projects.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292970,
      "meta": {},
      "text": "Functionality vs Usability\nAs a software developer, it is not that simple to find the balance between functionality and usability. For example the new system of Mercedes (MBUX), it has many functions, but as a user who uses the system for the first time,you can quickly get overwhelmed with this ammount of functions, so the system sacrificed the user friendiness for its functionality. It is hard to develop a system which has many functions and is still user friendly. \n\nCost vs Robustness \n If a company want to save money in the software development stage, it might directly affects the robustness of a system. For example company which develops the game Cyberpunk 2077, it cuts the budget very often in the development stage of the game, therefore the whole system of the game isn't well tested by the software developers. It turns out , that is is a game with many bugs and the server also crashed very often. So the company sacrificed the robustness of the system to reduce the cost.\n\nRapid development vs. functionality\nIf a company want to develop a software in a very short time, it might affects the functionality of the softeware. Because of the short priod of the software development stage, the development team doesn't have enough time to think about all nessecary functions that the system should have or doesn't have enough time to implement all these functions. Therefore, some functions taht the users wished for the app may be missing .\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1302205,
      "meta": {},
      "text": "-readibility vs. efficiency: to make code more readable and understandable, it may have to be written in a less efficient manner which compilers can't optimize. For example bubblesort is easier to understand than quicksort\n\n-maintainability vs. functionality: the more functionality is added, the complexer the code and thereby harder to maintain. For example if the GUI has many buttons and input possibility reworking it due to a flaw of one button takes more effort in comparison to a GUI if a low amount.\n\n-rapid development vs. fault tolerance: the less time there is to work on the code, the more flaws are overlooked.\nFor example when there is a deadline for making bumpers, the focus is on the points first and not the details.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1351918,
      "meta": {},
      "text": "One of design goal trade-off is the trade-off between rapid development and functionality. It takes time to implement new functionalities and to make them work. And the more functionalities you want to implement, the more time it will cost. For example an app you only use for chatting is developed much faster than an app you use for chatting, calling, videocalling and playing games.\nAnother trade-off is between cost and robustness. If you want your product to be robust you have to put in the time and therefore the money to maintain it and to build it robust. If you want it to be cheaper, then you have to put less time in it and less maintenance. That makes the product less robust. For example, you have a team extra for the maintenance of your product at all times. That team costs a lot of money, but you product won't be broken that often or for that long as if you didn't have the team.\nAnother trade-off is between functionality and usabitility. The more functionalities your product has, the harder it gets for the user to understand every functionality. For example a user needs more time to understand every feature of an app and to be able to use every feature, if the app has many functionalities.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1361527,
      "meta": {},
      "text": "Cost vs robustness: Robustness is the ability of a system to maintain a function if the environment changes or if the user enters a wrong input. If you want to save costs you obviously have less ressources to deal with exceptional conditions, therefore you cannot build software that deals with a lot of exceptions. On the other hand a software which can deal with a lot of exceptions will take more time/labor to develop which will eventually lead to an increase in costs.\n\nRapid development vs. functionality: The fuctionalites of a system describe what the system is supposed to do. If your team now has less time to develop the system it won't be possible to build a system with a lot of functionalities respectively a system with very good functionalities. This is because building very good functionalities takes time and effort, which is not something you can do very quickly.\n\nEfficiency vs. portability: An efficcent software makes use of the computers architecture it is supposed to run on, obviously software that is designed to run on a single machine architecture in order to have maximum efficency is not portbale and can not be properly used on any other architecture. On the other hand if you develop general software which is supposed to run on many different architectures it is not possible to take full advantge of the respective architecture it runs on.\n",
      "score": 66.7,
      "language": null
    },
    {
      "id": 1423215,
      "meta": {},
      "text": "Efficiency vs. portability: \nIt's easier to optimize software to one specific running environment f.e. for a specific system (f.e specific CPUs,...) to make it more efficient (f.e. better power efficiency,...).\nDeveloping software with such a drastic commitment to one kind of system affects of course portability negatively. In some cases, you won't even be able to run it on another system.  F.e. many programs are optimized for Windows systems and will have worse performance on other OS like Linux (f.e. games,...). \n\nFunctionality vs. usability:\nTrade-off between making it easy to access all features (usability) and providing all features even for \"experts\" (functionality). To be more specific: you can either implement all features a user might need and have high functionality or you only provide features most users would need to have better usability. F.e. PhotoShop has many \"niche\" features and it's extremely hard to find the tools to accomplish even basic tasks like cropping a photo.\n\nCost vs. robustness:\nIt's cheaper to develop software that isn't as resistant to failures that might be caused by not having the time to think about them. F.e. handling user inputs could lead to insecurities, crashes,... if they aren't handled properly.  An example of this was the website of my old school, through which you could easily access the grading system. The task to create the website was delegated to a teacher in addition to his normal task and he hadn't the time to check for every security issue that might occur. \n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1466560,
      "meta": {},
      "text": "1. Functionality vs usability: A pizza restaurant wants a online ordering portal in which the user can customize his pizza to a wide extent (functionality), but the user only wants to order a pizza fast, if he is hungry and not spend a lot of time in the ordering process and fail to understand his endless options (usability).\n2. Cost vs robustness: A book shop wants to have  a cheap online store for his books (low cost), but the user does not want to be kicked out of his ordering process because too many other customers want to purchase a book at the same time (robustness)\n3. Rapid development vs functionality:  a clothing store wants an online shop built within one week (rapid development), but the user wants to be able to create an account, save his payment information, save favorites for later, get notified if clothes are available again in their size, have full detailed information about the clothes organized, compare different items in an overview, filter by category, price, size and color and be able to finish their shopping session and saved items in their shopping cart days later (functionality)",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291190,
      "meta": {},
      "text": "Security versus usability:\nSecurity measures the level of system protection against attacks and unauthorized users.\nUsability assesses the level of ease for users to use the system interface. It may further refer to the learnability of the interface, once the users learn the design, how quickly they can perform certain tasks, and how many steps it takes to perform the tasks.\nTrade off: More measures are placed for a system to become more secure, but the added measures created more steps for users to perform certain tasks, compared to a less secure system. \nExample: Multifactor authentication versus password login.\n\nEfficiency versus reusability:\nEfficiency refers to how efficient the limited resources are used. \nReusability measures the level of recycling parts of the system in other products/services. \nTrade off: a reusable system tends to have a more generalized functionality so that it can be used in different applications, however, it may compromise the performance of the system that would be optimized for a single application.  \n\nPerformance versus portability:\nPerformance refers to the system’s response speed to user actions. \nPortability measures the ability of the system migration to various platforms. \nA system may be optimized for performance in one operating system, but compromise on its portability to different operating systems because different operating systems have different functionalities which reduce the performance of a system. \n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291919,
      "meta": {},
      "text": "The design goals are different for different perspectives. The design goals for the developer are not the same for the end user and the Client. The End user want in general something user-friendly, easy to learn with many functionality. But for the Client the low cost is a big issue and the rapid development also. Because the Client is generally running business and cares about the low costs to increase the profits. For the developer the design goals are different and focus more on the technical side. Developers want in general minimum errors, re-usability, ...\nThis situation causes many conflicts between the end-user, Client and Developer. That is called: Trade-offs.\n\nExample 1: Low cost vs. functionality\nAs an example of the trade-off, is the conflict between the low cost and functionality. The end-user needs the functionality to serve what he/she needs. But on the other side the Client need to lower the cost as much as possible because he needs to increase the profits.\n\nExample 2: readability vs. Rapid development\nThe conflict happens when the client want a rapid development of the system (or the program) and in the other hand, the developers want to focus on the readability and documentation, which take much more time.\n\nExample 3: Modifiability vs. Fault tolerance\nBetween the developers and the end-user there some trade-off. The developers tend to develop something modifiable and reusable, however the end-user is interested in the \"Fault tolerance\". Which is somehow a little bit hard to balance between. Because low Fault tolerance need much time and focus just on the functionality itself.  ",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1311648,
      "meta": {},
      "text": "A first design goal trade-off lies within balancing rapidity of development and functionality. Time pressure is most certainly one of the major limiting factors when it comes to developing quality software, because with limiting the hours available to develop, it becomes more difficult to deliver a given number of features yet with high quality. Consider developing a chat system: When it comes to maximizing one of the two dimensions, one could either deliver a highly basic product (basic UI, only sending text, one chat at a time, ...) within a short period of time or otherwise use multiple months to incorporate a more diverse functionality (e.g. sending images, emojis, ...). It is difficult to find the sweet spot in between.\n\nSecondly, one has to trade-off functionality and usability when developing software. On the one hand it is important to provide a variety of features to fulfill all needs of the user, but on the other hand one should not confuse the user by providing an overload of different functionalities. As example, if one would try to develop an ERP system it is necessary to cover all relevant functionalities (like order, inventory, accounting etc.), yet keep it all comprehensive and easy to use.\n\nAlso, it is important to balance robustness and costs. A straight forward use case might seem to be simple to implement, however circumstances can vary from your initial test case. When developing for example a web application, it all may work out using a specific browser. However, one would need to ensure that the application behaves accordingly once a different browser is used and should therefore invest into using additional frameworks etc.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1332564,
      "meta": {},
      "text": "rapid development vs functionality\n\nSoftware development is a lengthy process. To make sure programs are working as intended, many steps such as requirement analysis, prototyping, and testing are needed. This pattern needs to be repeated for every feature, so that no problems are missed. That means adding new functionality goes along with prolonging the development time, a factor even using more developers cannot decrement. An example would be the majority of today's mobile games. Many are rushed in their development, as they are only seen as a quick, simple way to earn a lot of money. They only feature a handful of gameplay elements, often rooted in a simple gameplay loop.\n\n\ncost vs reusability\n\nReusabilty means being able to adapt a system to new environenments without major change to underlying code or databases. Only having to handle fixed, known values and inputs could allow for static, more context-driven implementation. Accounting for every possible circumstance extends code requirements (catch exceptions for new, unknown inputs) and thus overall cost. Imagine a security system with a set amount of cameras (say 4). Changing the number of incoming video channels could mess up the system's ui, if not accounted for by the programer (making it reusable).\n\nfunctionality vs usability\n\nHaving a lot of features in a system is often mutually exclusive to it being simple to use.\nThink of the MVV-ticketsystem. Now there may be a ticket best suited for every situation (number of passengers, time of day, distance/ zone travelled), but many users will buy their ticket based on simplicity to aquire it (steps needed to billing), rather than invest their time to buy the most cost-efficient one.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1335196,
      "meta": {},
      "text": "//hallo, ich benutze meine Loesung vom letzten Jahr :)\n\n\n\n\n\n\n- Functionality vs Usability - Je mehr Funktionen es gibt, desto schwieriger ist. Zum Beispiel wenn wir für die alte Generation sprechen und für die neue Technologien, Smartphones bieten so viele Möglichkeiten an, die aber die Benutzung schwerer machen. Beispielsweise können nicht viele erfahrene alte Leute mit dem Touchscreen zurechtzukommen und das macht ihr Leben nicht so einfach, weil wenn sie ihre Familienmitglieder kontaktieren wollen, kann dieses Prozess ewig sein und am Ende ohne Erfolg.\n\n- Cost vs reusability - Viele Leute kaufen sich sehr teure Kleider von bekannten Marken. Im Gegensatz dazu gibt es auch reiche Leute, die sich dafür entscheiden Kleider Zweite Hand zu kaufen, die billiger sind, nicht nur wegen dem Preis, sondern auch für die Praktische Seite dieser Tätigkeit, was auch sehr gut und umweltfreundlich ist. Man verwendet das, was noch verwendet werden kann. In vielen Fällen die Produkte, die reusable sind, sind aber teuer, zum Beispiel die Bottles in dem Laden, die nicht aus Plastik sind, aber sie können für lange Zeit benutzt werden und sind gut für die Umwelt.\n\n- Cost vs Robustness - Wenn man sich ein Auto kauft, entstehen verschiedene Aspekte, die für den Einkauf wichtig sind. Der Preis ist ein sehr wichtiges Argument. Manche Leute bevorzugen sich billige Autos zu kaufen, aber das kann auch gefährlich sein und in der Zukunft sogar mehr Kosten zu verursachen. In meiner Familie bis jetzt hat mein Vater ein bisschen günstigere Autos gekauft und immer danach haben sie Probleme und die Kosten für das Reparieren waren wie das Geld für ein besseres Auto. Deshalb soll man die Qualität und Robustness zuerst betrachten, um mehr Jahren das Auto problemlos zu benutzen.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344068,
      "meta": {},
      "text": "1. Functionality vs. usability:\n\tThe user wants many functionalities, but he still wants a minimalistic UI, with few buttons and easy to find functionalities. The more features an app has, the more the UI gets bloated. Its a tradeoff between functionality and usability.\nIf one hides the functions in sub-sub-submenus, the user misses functionality, if one adds all functionality to top level menus the user misses usability.\n\n2. Efficiency vs. portability:\n\tThe user wants his app to work on all platforms to work and to be fast.\nBeing fast usually means implementing hardware near algorithms, outsourcing tasks to application servers or using high performance libraries. These contradict to portability, as the software has to be built differently for different hardware machines, different operating systems. So one cannot simply copy the app to another computer, but one has to compile the app newly for each system, and possibly configure them independently and different, as all OS use different libraries.\n\n3. Backward compatibility vs. readability:\n\tAs functions change as the app progresses, an app is not simply backwards compatible by saying so.\nFor different versions the same object has to be handled differently, as functions changed in newer versions.\nIn the worst case each version needs it own function. Now a big switch case construct needs to be added around calling functions, to switch to the correct function call for the current version. Also code might be duplicated, only containing slight changes, and functions have to be renamed according to their version.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1382586,
      "meta": {},
      "text": "1. Functionality vs usability:\nSometimes security requires multiple identifications when logging in but this will scarify the ease of use.\n2. Rapid development vs functionality：\nBumpers can be quickly developed but it has few functionalities. If people want to have more functionalities, they will need to spend more time developing.\n2. Efficiency vs portability：\nIf people want the system become more efficient, it will become more complex and has more algorithm which makes it become less portability\n\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1391610,
      "meta": {},
      "text": "Many of the design goals that a software development team aims for stand in conflict to each other. Aiming for one of the design goals often happen at the cost of the other one, and are therefore called design goal trade offs.\n\nA first example of a typical design goal trade off is functionality vs. ease of learning. A good example for a software that traded ease of learning with functionality is SAP S/4HANA, a complete ERP system designed for every business need from Finances to Supply chain management. Due to the wide range of functions, the software has become cluttered and so complex to the point that it takes around 10 weeks to train a new employee to use SAP.\n\nLet's also look at the example Cost vs. Robustness. An example for such a trade off can be found in Boeings 737 Max's Flight Control System MCAS. Due to cost saving mesures imposed by Boeing executives, the software engineers have failed to include redundancy by reading from multiple sensors instead of relying on one. Implementing these (critical) features would have made the system more robost but at the same time would have increased development time and development costs.\n\nOne last example is backwards compatibility vs. rapid development. Backwards compatibiltiy is especially important for entreprise software like Windows Enterprise. As a consequence, when implementing dark mode for example, Microsoft can't just upgrade legacy UI Elements to UWP as it would break programs that depend on the old UI, but therefore also have to update all legacy UI Elements like explorer.exe individually. This slows down the development process.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1426147,
      "meta": {},
      "text": "First, functionality and usability can be the example of the typical design goal trade- off. Usability is the ease of use of interface. If the system has so many function, that user can use, than it lost sometimes usability. For example, the more function a system has, the more difficult it is for users to use it without a separate guidebook. Another example is cost and robustness. More costs are needed to build a more efficient and stable system. Hardware that can process more data at once is expensive. Therefore, cost and robustness are incompatible design goals. In designing a system, it is important to calculate the appropriate cost to have enough robustness to operate the system reliably. Lastly, there is efficiency and portability. It is also a difficult choice the programmer faces. The meaning of portable is not only for the weight of devices, but also in code. Favoring efficiency results are usally in heavy code, that can't be portable. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1435184,
      "meta": {},
      "text": "• Efficiency vs. portability:In addition to being efficient, a program should be easy portable. For example, a program may be very efficient and useful, but because it requires a lot of memory to run the program, it can not run on laptops and phones. It can only be installed and run on computers with a lot of memory. Which does not allow easy movement for the user.For example, some computer games\n• Rapid development vs. functionality:The program must have a good development speed and good performance. For example, an engineering calculator program that is developed quickly but has difficulty in calculating large numbers, as opposed to another program that is developed at a slower pace but has no problems in calculations.\n• Functionality vs. usability:Usability and functionality are important points in the program, for example, a program for ordering food that works very accurately and has a fast and good function for taking orders and announcing to the kitchen, but does not have a good user interface and has no pictures. They are not used and it is difficult for other people and it takes a long time to place an order.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1479300,
      "meta": {},
      "text": "1. Functionalibity vs usability\nFunctionality can be defined as a set of fuctions supported by the system whereas usability may be defined as an ease of using the system. In the context of this design goal trade-off it can be seen that aiming for having multiple functions cotradicts the desire for simple and more user-friendly design. A great example of that trade off may be visible in TUM Online. Theoretically it can be used for everything - checking your timetable, registering for exams etc. but the multitudes of functions means that using it is not simple and intuitive.\n2. Cost vs reusability\nThis design trade-off seems fairly self-explanatory. AIming for cheap price encourages searching for quick and easy solutions, which require less testing or thoughts put in code. Aiming for reusability means the opposite i.e. a lot of additional coding and tests, which are helpful to make the program reusable. For example creating and using frameworks in JS programms allows the developers to work faster and avoid repetive and mundane tasks but the development of them costs time and money.\n3. Cost vs robustness\nLower costs create not only quick and not well thought-through solutions but also the ones, which are prone to errors. On the other hand robustness, which can be understood as accuracy, aims to dimish the amount of such errors. Therefore aiming for one means that we get rid of the other (aka trade off). For example Newton-type algorithms may converge fast, but don't show a fully accurate result - they show the nearest optima instead.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1587159,
      "meta": {},
      "text": "Ein typisches design goal trade-off ist zum Beispiel \" Stabilität vs. Kosten\". Man will als Entwickler natürlich möglichst wenig Geld ausgeben, um etwas zu entwickeln, dennoch soll genug Geld in ein Projekt investiert worden sein, da das Endprodukt sonst evtl. überhaupt nicht mehr stabil ist. Oft ist es ja so, das wenn man billige Sachen kauft, dass diese auch dementsprechend schneller kaputt gehen. Wenn man zum Beispiel ein Fahrrad für 20 euro kauft, welchees mit sehr billigem Material gebaut wurde, so hält das warscheinlich viel weniger als ein Fahrrad für 500 Euro mit besserer Bremse und robusterem Material.  \n\nEin weiteres Beispiel wäre \"Benutzerfreundlichkeit vs. Funtionalität\". Wenn ein System viele Funtionalitäten hat, ist das natürlich einerseits schön, dennoch kann es schnell dazu führen, dass es nicht mehr so Benutzerfeundlich ist. Wenn man bei Mario Kart zum Beispiel kurz seinen Charakter und sein Fahrzeug auswählen kann, ist das angenehm, doch wenn man dazu noch den Hut, die Hose, das T-Shirt und so weiter auswählen muss, wäre es nicht mehr so benutzerfreundlich.\n\nDann gibt es noch \"Zeit vs. Funtionalität\". Ein System entwickeln braucht Zeit und je mehr Zeit man reinsteckt, desto mehr Funtionalitäten kann es haben. Dennoch gibt es auch da gewisse Konflikte. Bespielsweiße bei der Hausaufgabe, neue Funktinalitäten in Bumperscar zu implementieren. Da hatte man nur 1 Woche Zeit und neben Eist noch 4 andere Fächer, in denen man auch Hausaufgaben machen muss, weshalb das Spiel letztendlich dann nicht sehr stark ausgebaut wurde.\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1644668,
      "meta": {},
      "text": "Functionality vs. Usability:\nI think nowadays, this trade-off can be seen in lots of different apps. Consider, for example, a todo list app where you can plan todos in a Kanban board or organise small personal projects. Since many people are using such kind of apps, it is difficult to find the right amount of functionality such that users are still flexible and can adapt enough settings but without being overwhelmed with too much functionality. Practical examples are a simple Kanban board app that comes with three columns (todo, in progress, done) and you can't change any settings. And on the other hand JIRA software which is designed to fit every company, so single unexperienced users are overwhelmed by the functionality even though it's free for small teams.\n\nRapid Development vs. Functionality:\nConsider the recent covid outbreak. Restaurants need to track attendance so you decide to develop an app to fill this need. Since you're not the only one working and this kind of app, you need to decide what's more important: Having lots of functionality right from the beginning or being one of the first to have a shippable product.\n\nCost vs. Robustness:\nConsider you're developing a gaming app. You want to have high profit and thus minimise costs. On the other hand, you want the game to be robust so that users enjoy playing on the long term. Ensuring robustness comes with higher costs, though, since possibly more code and further software tests are needed.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292299,
      "meta": {},
      "text": "One example of a design goal trade-off is modifiability and readability of code vs its runtime efficiency. Most often, optimized code ends up being more ugly and unintuitive to a human reader/developer. For example, you might write an assembly program that copies a given number  of bytes to another location, but realize that doing as many as possible sets of megabytes at once first would significantly speed up the process. However, you have to add additional checks to make sure you find out how many MB to copy before switching to bytes, etc.\n\nBackward compatability also often decreases readability, especially when an application is undergoing major changes, but the app still needs to support older systems/versions. For example a web app might implement an older API to communicate with windows XP devices, and now the developers are using a new and improved API, but still need to maintain the old ugly code in order to support the older devices.\n\nFunctionality vs usability is a common issue when adding new features to an app. Increasing functionality tends to increase complexity and thereby make it less clear for the end user. For example in a bumpers game, adding various different attack methods/ways to crash other cars would become confusing and less usable, especially to a beginner player.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1296753,
      "meta": {},
      "text": "1. One big Design Goal Trade-off is efficiency vs. portability. Since no system should be inefficient almost every program should be efficient. But for example using Java would make the system very portable but c could make it much more efficient. Some optimizations cloud also depend on the hardware itself so optimizing for one hardware could make the system much slower on another.\n\n2. Functionality vs. usability: Making systems with many functions is not always highest priority because a high amount of \"features\" can make a program much more complex for the end user to use. Every function needs its own button so many functions lead to many buttons or alternative ways for input. Organizing them in a structured layout can help but too may functions always make a system more complex.\n\n3. Rapid development vs. functionality: Every company wants a product to be delivered fast. But the faster you are finishing the system the less functionality it can have. Some features you wanted that aren't very important wont make it into the finished product. And it wont have all the functionalities.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1312074,
      "meta": {},
      "text": "Cost vs Quality is one of the important design goal trade-offs. If your game can be uploaded for free, but it can't be attractive while being played. In the same case, design patterns can solve the problem with the fewest costs as much as possible.\nMaintainability vs performance is an equation hard to realize because the more our system is complicated the more developers need time to make their modifications, that's why design patterns are highly recommended to facilitate the program and to reduce the downtime to the minimum. For example, a successful bank can't work with a system that can be down for more than thirty minutes in the whole year because they will lose a lot of money.\nFlexibility vs security is also one of the most needed calculations because you have to create a platform that works on more than one device and at the same time it has to afford security, which is not easy at all. For example, you can open your Facebook account on more than one device but at the same time, on which devices your account is opened and what the device's name is. Not only that, but you can hardly detect their locations.",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1313104,
      "meta": {},
      "text": "1. Rapid development vs. functionality.\nRapid development means less time and leads to less testing and worse quality in general.\nFor example: If you are forced to fininish your product just in one month the developers have to work very fast and have almost no time to implement functionalities or test features.\n\n2. Efficiency vs. portability\nTo make software more efficient you can optimize it for a specific platform.\nPlatforms are often very different and high portability means you want your software to run on most platforms.\nThe problem is that you can not optimize you software for every single platform at the same time because they are so different.\nFor example in the video games industry. It is hard to make a game running on Linux, Windows, Mac, Playstation and Android with the same efficiency on every platform.\n\n3. Functionality vs. usability\nMore functionality equals a more complex product and usabibility means to keep the product simple and clear for the user. Basically funtionality is just the opposite of usability.\nFor example if you are asked to make an On-Screen-Keyboard for a german person, it is not very usable to implement the whole unicode-table. It can be very functional if the user wants to use mathematical symbols but it would probably take a long time to find a specific symbol, so it would not be very usable.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1313132,
      "meta": {},
      "text": "functionality versus usability:\nIt is very difficult to design an easily usable program with a lot of different functions. Usable programs have to fulfil different categories such as memorability or learnability. These aspects are usually fulfilled if a program is structured rather simple. If a program has lots of different functions this simple structure is hard to achieve. \n\nAnimation programs such as blender for example offer a lot of functionality, as they are used professionally. Unfortunately the program is not self explanatory at all, so learning it takes some time, because there are so many effects that can be animated.  \n\ncost versus reusability:\nDeveloping reusable systems is important, as there are so many different operating systems and devices. Unfortunately, adapting the system to be very compatible, takes a lot of time and manpower and is thus very expensive.\n\nThe notes app goodnotes started with offering their app on apple systems only, to achieve the best possible result for one system, for a rather low cost. this is one example for optimising this tradeoff.\n\ncost versus robustness:\nA web application that is robust and able to handle lots of users at the same time is rather expensive to build, as handling lots of users takes up more resources, also testing a system properly can be costly. Thus tests and resources are limited.\n\nTicketing sale websites do only have high traffic, when certain tickets are offered. Thus they limit the active users on their website, when a ticket is offered, so the system does not collapse. it would be possible to increase the capacity, but as the user numbers are not always that high, it is not profitable, and thus this tradeoff is made.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1315474,
      "meta": {},
      "text": "Example 1: Backward compatibility vs. Readability\nMany clients want to maintain backward compatibility with a new version of a software project because many different teams build their tools with a specific interface of that software project and as soon as the backward compatibility is gone, every team is basically forced to update their tools to the new interfaces. Because many companys have very large code bases this is due to the lack of money and time very often not possible.\n\n\nExample 2: Cost vs. robustness\nEvery client strives to keep the cost down of their project and to get their final product as less expensive as possible. This means that in many cases as soon as the product somehow works the client thinks that its time to release the product and to stop the development of the product. On the contrary side that means that most of the times the client saves money with reducing the amount of testing of the product which directly leads to possible fragile systems with serious bugs.\n\n\nExample 3: Rapid development vs. well-defined interfaces\nRapid development is often a deep desire of the clients because time equals money. Rapid development means that time taken to analyze requirements, to create the UML models and testing is probably not included in their timeschedule which leads to developers starting directly with the implementation phase of the product. Because of lacking system knowledge and bad requirements many topics will be implemented time after time which leads directly to bad interface design or no interfaces at all.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1334756,
      "meta": {},
      "text": "A typical design trade-off is rapid development vs. minimum # of errors. Being fast will almost always come at the cost of being less thougthful. If you need to be fast and can't go in to detail about everything, more mistakes will occur which then endanger the goal of a minimum number of errors. At the company I work a new version of our App is released every week. However, we also have a Slack channel to collect mistakes that occur. With the fast development cycle we certainly have more bugs.\n\nSecondly, one can mention backward compatibility and functionality. An example for this tradeoff is Word. You have the option to work with older data formats. However, then some functions that were introduced later cannnot be used in the text. One cannot do both because the old format does not know about those new functions (e.g. ways of formatting etc.) So there is a trade-off between backward compatibility and functionality.\n\nLastly, I want to mention the trade-off between low costs and robustness. Robustness refers to the ability of the system to maintain a function f. ex. when environmental circumstances change. Imagine there is a massive power breakdown in the city you have your servers. Low costs could mean that you only have one server and no back-fall option available. If this power breakdown happens your system cannot maintain function, whereas if you would have been willing to spend more money you could easily switch to another server for a couple of minutes.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344538,
      "meta": {},
      "text": "1. Functionality vs. usability\n\n\tDecision between the different options and functions given in a system and the simplicity for the user.\n\tAn example would be a application to trade stocks. There can be many different functionalities, as different order\n\ttypes, that a experienced user would like to have available. A new user that has not yet heard of all this and\n\twould just simply like to buy and hold stocks would be overwhelmed and probably opt for an easier alternative.\n\tIf the application wants to target this \"uneducated\" user, not offering that many functions would be the better\n\tdecision\n\n2. Cost vs. robustness\n\n\tWeighting the costs for additional resources against the resistance of the system in different environments.\n\tAn example is the decision to buy additional server capacity for a system that currently only uses 40% of the\n\tcapacity most of the time, to be sure the system would not crash if the number of users would multiply for\n\tsome reason\n\n3. Rapid development vs functionality\n\n\tWeighting the development of additional functionalities against the speed of completion of the project.\n\tOften important when the intention is to capture market share with a first mover advantage. An example\n\tcould be a navigation app, that decides to not offer multiple stops and no satellite card initially, to come to\n\tmarket faster and capture some users before other applications hit the market",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349696,
      "meta": {},
      "text": "As in many other aspects of life, there is no one concrete \"good\" in software development. Rather, it is always a balancing of various factors that are in a contradictory relationship to each other. \n\nHere are three possible trade-offs with examples:\n\nsecurity vs. accessibility:\nFor example, apps on Android vs. apps on iOS. On iOS, the only way for users to install apps is via the App Store. This is controlled by Apple and every single app is checked. Although this ensures that you will not download a virus via an app, on the other hand, you have less choice and no possibility to install programmes from other sources. On Android this is exactly the opposite.\n\nrapid development vs. reliability:\nA reliably functioning programme with hardly any bugs needs time and intensive testing. But time is often a problem. For example, I worked for an ed-tech start-up and we had to get the new version of the app ready in time for the start of school in September. Reliability suffered and at the time of the launch there were an incredible number of bugs that had to be solved in a painstaking process over the following months.\n\nfunctionality vs. usability:\nOften it is difficult to get complex functionalities into an interface that is easy to understand. \nAn example are the video programmes iMovie and Premiere Pro. iMovie is very easy to understand for non-professionals, but you can only apply prefabricated effects and make simple cuts. In Premiere, you can produce big individual projects, but you need several weeks of practice until you can handle all aspects of the programme with confidence.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1363288,
      "meta": {},
      "text": "Robustness vs Cost:\nA project that only has a small budget is probably not tested as intensively for cost reasons and could still contain bugs or errors after release. On the other side are e.g. Games whose manufacturers don't shy away from any costs are in the beta version for up to years and are intensively tested for errors by a pre-selection of players so that the end customer, i.e. the buyer of the game, does not have any negative experiences (even if this is obviously the case with the latest Battlefield 2042, which went massively wrong).\n\nCost vs GUI:\nWhile software solutions that have a higher budget always have a well-designed GUI that provides the user with an easy-to-understand and well-thought-out concept.\nHowever, if costs are saved at this point, the consequences are that even the most robust or error-free software does not look appealing and is possibly not even considered by potential customers, since the condition of the software probably represents a too negative user experience.\n\nComputational power vs portability:\nA high-performance solution is not always the simplest, since computationally intensive operations in combination with more complex software require more power on average. The software could be used on a home PC or a server without any problems, but if the application is to be operated on a mobile device or generally with a battery, the high power consumption is already a problem.\n\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1420637,
      "meta": {},
      "text": "One type of design trade off is rapid development vs functionality. The best example I can think of is the video game cyber punk 2077. Because of the hype behind the game, the developers rushed the development of the game, which resulted in several glitches and bugs, which made the game initially almost unplayable. The developers sacrificed functionality for rapid development\n\nAnother type of design trade off is functionality vs usability. There is a famous game called path of exile that is famous for the hard entry point due to the massive skill tree. There are hundreds of skills in the skill tree, which the player needs to understand, before he / she can create their own \"build\". This is an example of high functionality as the user can choose a lot of different functionality, but the actual usability is quite low. As only very dedicated people would be willing to understand all the skills and min and max them. \n\nAnother type of design trade off is cost vs reusability. This aspect is quite important for a lot of big game development companies, because if they have to start from scratch for every new AAA game they create, the cost will be very high. That is why companies are willing to spend a bit more to time and money to create \"reusable code\" for future games. Which indicates that they prioritise high reusability and low cost. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1423444,
      "meta": {},
      "text": "One typical design goal trade off is between the design goals low cost and robustness. because guaranteeing robustness requires lots of testing of for example unexpected inputs or fault injections. These large amounts of tests take much time and hence are very costly.\nAnother typical design goal trade off is functionality vs usability. If for example a system which sells train tickets provides to many different functions and options, the average person who just wants to ride a train might get confused and has to waste to much time checking which options are fitting for him/her.\nPortability vs efficiency is also a common software design trade off. Because developing software which is usable on as many platforms as possible is not optimised for most of those single platforms, and therefore has a relatively low efficiency. One example are mobile games which have to work for android as well as for iOs.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1469904,
      "meta": {},
      "text": "Rapid development vs Minimum # of errors:\n\tWhen under time crunch the odds of bugs and errors slipping through the cracks rises at a rapid rate. If a product needs to be delivered at a certain date, developers are going to prioritize creating a shippable product within the given timeframe and not be able to go through all the testing and fixes necessary. A great example of this would in game development, where time pressure often leads to the release of unfinished products. \n\nPortability vs Maintainability:\n\tWhen a piece of software needs to be portable, the amount of effort to update the product at the same pace across all environments can be a large weight on the backs of developers. Since different operating systems as well as differing pieces of hardware need to be adapted to, programmers need to in many cases change a large chunk of the code to ensure cross-compatibility. This is the reason why many mobile developers choose to only develop for either iOS or android. \n\nEase of learning vs Functionality:\n\tWhile a variety of different functions can be beneficial, enabling the user to achieve their goals in a rapid period of time due to specialized functions for specific use-cases, it is also important to not that too many options can be overwhelming for new users. An example for this would be photo editing apps, experienced users can easily use the dozens upon dozens of tools in sync to achieve their goals, while newer users can be lost among all the options. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1491900,
      "meta": {},
      "text": "Functionality vs. usability: shall we let the system become more functional for users to use in any conditions or shall we make the user interface to be more clear to emphasize specific functions? weibo has a lot of functionality ex. purse, receive a bonus, the e-commerce shopping mall, texting, post, but users usually only use a post function (from h04e01)\nEfficiency vs. portability: shall we design the system to operate a lot and efficiency in equipment/platforms or shall we design the system which can move from equipment/platforms easily because this system doesn't need to work a lot? ex the PS5 video games work really well on PS5 but it cannot work on other platforms\nCost vs. reusability: shall we reduce the cost for the project just from one-time use or shall we spend more money to make it more complete and can use longer? ex the bumper game can only work on pc and cannot store the user information on a cloud but it can become profitable and let more players want to plan again and again if they can store user data and game records on the cloud and make it have more complicate races and become the online game if someone can hire more developers.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292603,
      "meta": {},
      "text": "Functionality vs. Usability\nThe trade-off often occurs in systems solving complex problems requiring a lot of knowledge from the user. You need to define between power users and first occasional users and on which group you want to focus. One good example is  CAD system. During my mastercraftsmen examination I used different CAD systems (SolidWorks) and their functionality was almost limitless. However, for non-power users, it was difficult to solve simple problems, because it required not just one click to navigate through the functionality. Therefore, it would have been better to switch to CAD with a lower degree of functionality and a friendlier user interface.\n\nRapid development vs. functionality\nThe requirement for rapid development decreases the ability to create the best functionality for the user. During a startup project, I created a landing page and we just had two days to test the functionality and user-friendliness. The main problem was that we didn't have enough time to get feedback from the customer and analyze its behavior. Furthermore, proper testing was not possible and some default cases were not considered. \n\nCost vs. robustness\nMaking a project robust and secure is key to ensuring longevity and preventing cyber attacks. However, testing attacks on a system is also costly and requires experts. In my opinion, currently, the best example is the attack on the Theta coin. Early state visionary project that wasn't tested properly. Considering similar attacks such as George Soros on the British pound. With costly financial DD measures could have been implemented in the contracts to keep the coin stable. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292768,
      "meta": {},
      "text": "Rapid development vs. functionality: \nRapid development focuses on the speed of optimzing an old product or of the development of a new product, for example the updates of an app which needs to be adapted to the fast changing user needs. However functionality has its focus on the quality of the products functions and therefore the process can take a little longer for example developing a new enterprise resource planning software. Thus it is very important to figure out if your focus lies on one of these two or maybe on a bit of both.\n\nCost vs. robustness:\nWhen being cost oriented you try to have an easy process with low cost while developing the product and not focus too much on the stability or quality of it, for example the development of a prototype. Robustness on the other side values the reliability of a product, for example an algorithm that got tested multiple times. But if the purpose of a product is to be robust the cost will come in again in form of revenue, because the product fulfills what its supposed to do.\n\nFunctionality vs. usability:\nFunctionality wants to provide as much practical possibilities as possible, however usability tries to make the use of the product more simple and easy to learn. An example would be the comparison of the software systems iOS and Adroid. While iOS is a very simple and intuitive system, Android is, even if not much, a little more complex and has a some more possibilities regarding the openness of the system.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1298302,
      "meta": {},
      "text": "Functionality vs. usability：\n for software which can support magnitude of strong functions, it could have many entrance to run these functions. In this case, it could be hard to design a user-friendly plattform for example UI-board, so that the functions could be ordered in a brief and clear view. \n For example, the UI design of Microsoft-Teams is could be much harder than the same job of Zoom. \n\nEfficiency vs. portability\n designing a efficient software can usually means, that the software is implemented lightweightly without considering much comprehensive but imperative details. Such software could be not portable in different enviroments like different versions and systems.\n For example, the speedly edition of tik tok can have more bugs on the mobile system Android in old version.\n\nCost vs. reusability\n to control the cost, the scope and methods during the software designing could be shrunk and simplified in comparing with the standards. So that it could be not such flexible and suitble by resuring the old structure for extension of this app or building a new app.\n For example if the developmen group decide to implement all functions in the local package to save cost, such codes could be hard to reuse if they want to extend this app in cloud side.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1306988,
      "meta": {},
      "text": "Functionality vs. Usability: On a high level, functionality means the sum of (useful) operations a software can perform, whereas usability refers to the ease-of use of the software. An example from my own experience where these two contradcited each other was when we developed a solution to improve food management in hospitals. While we wanted to include options to choose meal sizes, extend dishes, integrate with local delivery restaurants, etc., we soon realized that especially elderly patients struggle with an interface overloaded with functionality.\n\nCost vs. robustness: Costs are often critical in budgeted software projects and can stand in stark contrast with the robustness of a software, meaning its ability to cope with incorrect or unexpected user input. With our food management software solution, we experienced this tradeoff before the pilot phase in a hospital in Munich. While we had carefully developed the software, we felt that additional testing would have improved the robustness of our solution. On the other hand, the time-invest (i.e., the cost!) would have been substantially higher, too.\n\nRapid development vs. functionality: Rapid development is based on quick prototyping and fast feedback loops - an iterative approach to building software. We found that a trade-off between these two design goals is necessary  and much-discussed in many startup which want to show an early proof-of-concept that the software is actually solving the problem it claims to solve. We did this in the context of the TUM TechChallenge and reduced the functionality to only address the core aspects of the problem statement with our features.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1424290,
      "meta": {},
      "text": "One design goal trade-off is functionality vs usability. This is quite obvious because the more functionality you add to a given program, the more complex it gets thus reducing the usability and making the program harder to understand. An example for this would be Unreal Engine 4, an outstanding game engine which has a ton of features and thereby a very steep learning curve. \n\nAnother design goal trade-off is rapid development vs functionality. You cannot develop a software really fast and still have a ton of features because the less time you spend developing the software the less features you are able to implement. An example for this would be the \"Corona Warn app\" which had to be developed really fast at the start of the pandemic but therefore lacked a lot of features which were added later on through updates, for example the feature to add a test or vaccination certificate to the app.\n\nAnother design goal trade-off is efficiency vs portability. Native solutions will always run faster than for example emulated or virtualized ones because you can optimize the software much more if you develop it for a specific environment. An example for that would be a given software developed in Java which would run on windows, linux and macOs, but if you would develop the same software in C for all three different operating systems respectively, it would run much faster.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1451740,
      "meta": {},
      "text": "One of the most known disign goals is functionality vs usability. Because the more functionality you want to get into a system the more difficult it gets to keep it simple and easy usable. My favority example is linux and epecially the linux layout managers. Most of the people don't want to use linux, as it is not easy to use and understand in the first moment. On the other hand a lot of especially comuter science students love the variety and possibilities they have being able the designe everything as they like to. If you design a system you have to decide which group you want to address.\n\nMy second trade-off is rapid development vs functionality. Everyone knows that the more things you want to get done the more time you need. As mentionedon the first trade-off. The more funtionality you get the more difficult it gets to organize them well and also the more difficult it gets to keep everything working and to test everything. And things being difficult in software engineering means they need time to be well done. This shows the more funtionality you want the more time you need to implement this.\n\nMy last trade off is backward compatibility vs readability. I think every one who has ever programmed himself knows that things are easy as long you have one clear way the system works. It keeps things simple and elegant, or as described readable. If you then start to consider more and more different ways systems can work, as you have to do in order to be compatible for olter systems it makes things complicated and less clear.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1502179,
      "meta": {},
      "text": "1. Robustness vs. Rapid development\n\nIf you want your system to be developed very fast, there isnt a lot of time to test for edge cases \n--> f.e. a lot of edge cases (f.e. wrong user inputs) arent always clear from the get go and are only found when actively using the software (whatsapp surely tested their software a lot, but didn't figure out that you can't delete a picture for everybody that you already deleted for just yourself) --> you need to use the software to find theses mistakes and to do that you need time \n\n2. Cost vs. Functionality\n\nIf you want your system to have a lot of usefull functions it obviously takes longer to develop and that raises the price\n--> f.e. a software like intelliJ that offers a lot of functions is very complex and because of that it takes a lot of time to code and to test --> more time to develop --> costs are rising \n\n\n3. Functionality vs. User-friendliness\n\nIf you want your system has a lot of functions it can get very confusing for the user \n--> software like f.e. IntelliJ has a lot of functions but it isnt really user friendly --> you have to look up where you find different settings(because the system is very complex(has a lot of functions))",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1627292,
      "meta": {},
      "text": "Three typical design goal trade-offs in the context of software engineering:\n1. Functionality vs. usability. For example, software can provide with a large amount of functions, but this can confuse customers about how to use the software.\n\n2. Cost vs. robustness. The more robust system, the more expensive it is, the more investments it needs. Because of limited financial resources, developers must find a solution to ensure reasonable reliability with a reasonable amount of finances.\n\n3. Efficiency vs. portability. Favoring efficiency results in nonportable code, while selecting portability often results in software whose performance is unsatisfactory.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344466,
      "meta": {},
      "text": "Functionality vs. usability\nusability = wie leicht dein Produkt zu nutzen ist\nFuntionality = Wie viele Funktionsbereiche dein Produkt abdeckt.\nDiese beiden dinge stehen meist in Kontrast. Den, wenn dein Produkt viele Funktionen hat, wird es automatisch komplex und schwer zu verstehen, wenn es aber sehr leicht zu verstehen ist, kann es auch nicht so komplex und tiefgründig sein.\nWenn man bei einem Kundenservice anruft, kommt man erst in ein Anrufmenü, in dem zum Beispiel gesagt wird: \"wenn sie mit einem Menschen sprechen möchten drücken sie die 1\". Dieses System ist zwar einfach zu verstehen aber es ist in der Funktionalität eingeschränkt da man nur 10 tasten am Telefon hat, wenn man also jetzt 11 verschiedenen Service anbieten will gibt es ein Problem.\n\nEfficiency vs. portability\nEfficiency = wie effektiv dein Produkt eine Aufgabe erfüllen kann\nportability = wie leicht dein Produkt in eine andere Umgebung übertragen werden kann (zb ein anders BetriebsSystem)\nwie spezifischer ein Programm auf ein Gerät zugeschnitten ist desto effizienter wird es, je spezifischer es ist, desto schwerer ist es aber dieses Programm auf ein anderes Gerät zu übertragen.\nWenn man ein Sortieralgorithmus schreibt, kann man ihn sehr schnell, aber speicher intensiv oder langsam, aber speicher schonend schreiben. Wenn nun ein großes Programm auf Geschwindigkeit getrimmt ist, kann es sein, dass es bei einem System mit wenig Speicher nicht funktioniert.\n\nRapid development vs. reusability\nreusability= die Möglichkeit den Code deines Produkts nochmal zu verwenden\nRapid development = ein geringer Zeitaufwand in der Entwicklung.\nWenn man reusable code schreiben will, muss man besonders auf die Qualität des Codes achten, es braucht also mehr Zeit, mehr aufwand, und bessere Programmierer.\nWenn für mein software projekt eine geringe Entwicklungszeit angesetzt ist muss irgendwo an aufwand gespart werden, z. B. in der Qualitätskontrolle wodurch schlechterer Code entsteht.\n\n",
      "score": 91.7,
      "language": "GERMAN"
    },
    {
      "id": 1344491,
      "meta": {},
      "text": "1) Clients usually want very low cost more than everyhting else. However, the end user expects fault tolerance and the developer wants \"Wartbarkeit\" of the system. With lower cost, the other 2 areas have to decrease in quality and therefore a design trade off has to be reached to make the system \"wartbar\", not buggy but at the same time as cost effective as possible. The solution to this should be found by the developer.\n\n2) Annother difficulty would be that user want total user friendliness, however at the same time the client wants rapid development. The core functionality of a system takes its time to properly develop. But it takes even more time to then develop a responsive and easy to use user interface. These two requirements are in direct contrast and once again a trade-off has to be found where the program is both easy to use but still fast to develop.\n\n3) Users want a powerful tool at their disposal. The more functionality, the more possibilities for errors. Therefore, functionality can not be increased indefinitely, because developers want the smallest amount of erros as possible and a readable, modifiable software project and not a bunch of unreadable functionality that new developers can not even comprehend.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1347187,
      "meta": {},
      "text": "The trade-off functionality vs. usability describes the decision between a product/solution that is incredibly mighty and can maybe cover the most remote special case you can think of, but on the other hand becomes extremely overloaded, slow in performance, and confusing in its UI. For example, SAP is extremely mighty and not without reason THE ERP-Solution (at least one of the market leaders), but you need to be an expert or at least need good training to work successfully and efficiently.\n\nEfficiency vs. portability is a trade-off between a lightweight, performant application that runs with the least system requirements or is incredibly fast, but on the other hand, can be used only on one specific device it was designed for. Portability would maybe require delivering more dependencies with the software or would need emulation which would slow down the application during runtime. \n\nCost vs. robustness describes the trade-off between a low-cost, fast-coded solution, which is feasible but maybe not that reliable when it comes to different hardware pre-requisites, errors, or wrong handling by the user. Creating a robust solution that can withstand all the difficulties a program can be encountered with is maybe also possible, but that would need significantly more man-hours for specifying, coding and testing. That drives the cost, of course. An example would be a script, that is written for a specific, returning task, but maybe can run only on the device it was written on or only by the person who wrote it (due to knowledge in using). ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349163,
      "meta": {},
      "text": "Often design goals conflict with each other. That means that two goals can not be realized at the same time because meeting one goal would contradict the other. \n\nOne very common contradiction is the one between achieving a low cost and creating a robust system. In order to achieve the latter many exceptions need to be covered which requires time. But the more time the developers spent on the design and the coding, the more expensive the product gets. So if e.g. a self-driving AI vacuum cleaner is developed there need to be many safeguards in place so it can deal with all kinds of obstacles one might encounter on the floor. On the other hand, the client will want to keep the development cheap in order to maximize their profit. Therefore, trade-offs have to be made.\n\nAnother common conflict is the one between functionality and usability. One the one hand, the end user might want a system with many different functionalities, but on the other hand, the systems still needs to be user-friendly. Take a role playing computer game for example: you want to be able to do many different things with your character in oder to model a real situation as best as possible, but if you have to scroll through a hundred buttons every time you want to do something, it becomes tedious very quickly and takes the fun out of it. Therefore, you need to make a trade-off: keep as many functions as possible while still keeping the game and its functionalities overseeable for the user.\n\nFurthermore, there often is a conflict between achieving peak efficiency while creating a portable system. Let´s stay with the example of the game: On the one hand, we want to program the game as efficient as possible, using the easiest implementations and not using too much code, but on the other hand we might want to make sure the game runs on different operating systems. The latter automatically requires to keep the coding more general which often is not the most efficient solution.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1424832,
      "meta": {},
      "text": "One Design goal tradeoff is robustness and cost. Designing high uptime systems rises the cost of software development as it adds complexity to the project. The reason is the increase in the need of testing the software for bugs that could lead to crashes. \n\nAnother tradeoff is rapid development vs functionality. Or rapid development vs everything else. Having less time to build a software project leads to a lot of issues. Developers get less time for a task than they would otherwise. Due to the lack of time, they have to compromise functionality because this would need more man-hours. However, on the other side, the project gets done quicker. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1462983,
      "meta": {},
      "text": "1. cost vs. reusability\nsoftwares for shopping:\n- some shopping softwares (for example: Amazon) will keep items in basket for the customers until the customers pay for them or delete them. (high reusability but high cost)\n- but some cheap shopping softwares won't keep items for the customers, or the memory will only last for several hours, and then they will clear the basket automatically. (low cost but low reusability)\n\ngame softwares:\n- some game softwares will keep the records and game tools of the player (for example: LOL). (high reusability but high cost)\n- some game softwares will restart the game and won't keep any informations of the player. (for example: Tower of the Sorcerer) (low cost but low reusability)\n\n2. rapid development vs. functionality\nif software engineers decide to develop a software in a rapid way, then they usually need to ignore or give up some not-that-important functional requirements (and also some non-functional requirements), and in the end only a software with limited functionalities will be released. \n\n3. functionality vs. usability\nif a software has a lot of functions, the user interface of this application will either fill with lots of option buttons, or many functions will be hidden in somewhere, so it will be very difficult for users to find out the function(s) they really need to use, so the usability will become very low.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1505588,
      "meta": {},
      "text": "Functionality vs usability: we have to ask if we want the system to have as many funcionts as possible or if it should be user friendly. For example a photoshop program, depending on the target audience we have to shift the focus. If we want our system to be used by professionals we can put a lot of funcions in it but if we want it to be amateur friendly we have to limit those since it can get confusing and overwhelming quickly.\n\nCost vs robustness, We have to weigh the extra work to make the system robust with error handeling against the costs it would take. For example if input from the user is needed. Having to weigh how important it is to control if the input is in the correct form, eg if we are talking about shipping information it would be crutial to check it since errors in that area could have big consequences. In that case it would be smart to invest more money to ensure that such mistakes do not occur\n\nCost vs reusability. We have to ask ourselves if we want to invest the extra money to make sure that wen can reuse the system and make it easy to adapt and build on upon. Hard coding would be cheaper and quicker. For example if we want to have multiple photo editing tools, it would be smart to have one good foundation we can use for all the upcoming projects. But if its about a small business who has a game idea, but is unsure of it would be smarter to tailor the code to that one project",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1654660,
      "meta": {},
      "text": "As the cost is higher the software will be more rpremium and robust. For example, apple produces expensive but robust OS compared to Nokia.\n\nIf there are too many features in the system it can be functional but usable too much. For example, Excel can have a lot of features but can give hard time for new users.\n\nIf backward compatible like Windows it is hard to read",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292697,
      "meta": {},
      "text": "Efficiency vs. Portability:\nEin Beispiel sind mobile Anwendungen (Apps). Diese lassen sich einerseits native für Android oder iOS entwickeln, was die Effizienz enorm verbessert, da Eigenheiten beider Betriebssysteme besser genutzt werden können, jedoch lässt sich so die App entweder nur auf iOS oder nur auf Android ausführen (schlechte Portabilität). Umgekehrt lassen sich Tools wie React Native oder Flutter nutzen, welche es erlauben plattformunabhängig Apps zu entwickeln. Diese laufen dafür meist aber nicht so effizient wie native Apps.\n\nCost vs. Robustness:\nEin Beispiel hierfür wären User Interfaces. Um diese sehr robust gegenüber gewollten oder ungewollten Fehleingaben der User zu schützen, müssen viele verschiedene Test-Cases programmiert und alle möglichen Szenarien bedacht werden. Bei Interfaces von Banken müssen zudem Angriffsszenarien bedacht und z.B. durch ein TAN-Verfahren verhindert werden. Dies kostet Entwicklungszeit, was sich im Preis der Software niederschlägt, aber dessen Robustheit steigert. Auf der anderen Seite müssen User Interfaces für weniger kritische Systeme weniger robust sein. Dadurch müssen weniger Test-Cases und Angriffsszenarien bedacht werden, was Entwicklungszeit und Preis senkt.\n\nFunctionality vs. Usability:\nEin Beispiel für diesen Gegensatz wären die Betriebssysteme Linux und MacOS. Unter Linux ist man der User sehr frei, indem was er tut und hat eine Vielzahl an nutzbaren Funktionen. Die Vielzahl an Funktionen stört aber dafür die Benutzbarkeit, wodurch dieses Betriebssystem von den meisten Usern nicht genutzt wird. Eine völlig andere Richtung verfolgt dabei Apple (nicht nur mit MacOS). Hier werden dem User weniger Funktionen bereitgestellt und mehr vom Entwickler übernommen. Dies verbessert die Benutzbarkeit erheblich.\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1315496,
      "meta": {},
      "text": "Functionality vs. usability\nyou can have a lot of different functions but this might lead to the UI being not really usable, because there is just too much that you can do.  An example might be the different philosohphies of microsoft and Apple. While apple gives the user and very intuitive Way of a very selected amount of functions Microsoft offers more functionality but sometimes lacks usability. Another example would e Photoshop that offers a lot of functionalities but is not really intuitive to use and easy to learn. \n\nrapid developement vs. functionality \nIf the development of a software project is very fast it could be that the product is not really thought through completely since software development also requires good testing and a smart design. This often just needs time. For example the Luca corona  was developed pretty fast due to the urgency of the corona situation. The result was that some important functions were left out and the app did not work that well in the beginning.\n\nCost vs. robustness\nIf you design a very cheap system it might be that this system is not very robust (low in performance when a lot of people want to access it) This is due to many reasons. one might be a very practical one that saving money when buying the hardware might lead to less CPU and less computation power \n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1348534,
      "meta": {},
      "text": "First typical design goal trade-off in the context of software engineering following my experience was complexity vs easy to understand. When i tried to solve a programming problem, i tend to make the program in a complex way (to check some edge cases etc). Then, i can solve the problem, but it looks obviously complex. On the other hand, when i try to make code easier to understand, then it is hard to find solution for me.\nSecond trade-off is accuracy vs effort (time). If i put more effort to coding, my code will be more accurate because i can check all edge cases. It leads to less mistakes and better accuracy. But, when i do not put lots of efforts, then code could have more errors.\nLast trade-off is creativity vs time. I think creativity plays a big role in coding because programmers have to be creative and different from others to develop a new system. For example, thinking about what kind of collision or car type there is took a lot of time for me. I need to take time and think about it creatively. If you are not creative and just take ideas from others over, it does not take time, but you do not develop yourself.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1358937,
      "meta": {},
      "text": "Functionality vs. usability:\nIf a software has a high degree of functionality there is no guarantee that this program is also user-friendly and easy to interact with. Mostly you have to find a way to archive both, usability and functionality but it should remain in a equally proportion, since high functionality might cause a decrease in usability and the other way round.\n\nCost vs. robustness:\nA system should be quite robust and don't crash as soon as the user interacts with it. But with robustness comes cost. For example if you want to upgrade the robustness of your system you probably buy more servers which increases the cost of your project. In order to to balance both you should plan how robust you want your system to be and upgrade the robustness accordingly. The best way would be if you have enough power to process all requests but not too much unused power, since unused power would be a waste of money.\n\nBackward compatibility vs. readability:\nDevelopers are required to write clean code. But developers should also keep there code backward compatible, which often leads to a worse readable code, since you have to check for different software versions and provide multiple solutions for the same process. Therefor code readability and backward compatibility should be well balanced and in some cases it might be better to not support a very old version in order to keep the code readable.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1382297,
      "meta": {},
      "text": "cost vs reusability, once a model is scalable it can be applied to other ones.\nRapid development, over time you will have to survive massive changes in underlying technology\nfunctionality / platform independence, it has to work on many platforms\n",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1408014,
      "meta": {},
      "text": "1.\nOne example is is the trade-off between low cost and robustness.\nHaving a second fall back system does cost a lot to set up and maintain, but if you don't pay that money a lot of robustness gets lost, because if the live system fails the user will no longer hav the option to use the system. That's why show productions often pay that extra money for even multiple fallback systems to make sure the show can go on, whilst not caring that much about the costs.\n2.\nAnother example is the trade-off between rapid development and minimum number of errors.\nIf a project has to be developed rapidly, often there is not enough time for extensively testing the implemented features and many false user inputs haven't been tasted and many bugs haven't been found or there just isn't enough time to fix those bugs.\n\n3.\nMy third trade-off I'll talk about is the trade-off between rapid development and functionality.\nAs already explained in my second example when there just isn't enough time to due everything, due to short deadlines or the need to immediately react to competitors, some write offs have to be made. One example is (as already described) the lack of testing before going live, another is just releasing a version with less features.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1299441,
      "meta": {},
      "text": "Functionality vs. usability:\nThe more functionalities a system is expected to cover the more complex and thus less usable it becomes.\nBecause every functionality needs to be accessable by the userinterface in some way, adding more and more functions to an application will lead to the UI becoming less clear structured and original functions becoming harder to find.\nA good example for this would be Amazon's website, which at first glance overwhelms the user with the number of buttons and functions embedded in one system.\n\nFunctionality vs. rapid development\nIncreasing a system's functional requirements will furthermore drastically increase the time a development team needs to finish the entire project. The development time is not only extended by the amount of time it takes to create the new features but also by the amount that is needed for restructuring the software architecture or respectively integrating the new features into the existing architecture.\nTo stick with the previous example, if a development that is currently working on an online shop is asked to also implement a movie streaming service within the same application (for whatever reason :D), the system's time of development will thus increase a lot. \n\nCost vs. Robustness\nReducing the costs of development automatically means a decrease in the system's robustness. \nIf for example the online shop's development team is asked to reduce the originally planned number of available servers by 50%, in the end the server infrastructure might not be able to handle peaks in the number of concurrent users appropriatly.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1320937,
      "meta": {},
      "text": "Design goals often conflict with each other. In the following, I will provide three examples for typical design goal trade-offs in the context of software engineering to illustrate this challenge.\nExample 1: Functionality vs. usability\nEnd users mostly demand functional software (that the software does what it is supposed to do) that is usable at the same time. However, systems with too many functions might become unusable. One example could be a game for which users demand to be able to change all parameters. The game might become unusable if changing the parameters becomes too complex for the user to learn and enjoy.\nExample 2: Cost vs. robustness\nClients ideally want to develop software for low cost, while end users demand robust software that maintains its functions in case of wrong input or changes of the environment. For developers, it is hard to fulfil both design goals as is it challenging to build robust software for low cost. For example, the developer might not have the change to test software excessively for wrong inputs before shipping it to end users if clients demand to develop it low cost.\nExample 3: Rapid development vs. functionality\nClients often demand software to be developed rapidly, which may conflict with the functionality of the software, a design goal by end users. If software must be developed rapidly, developers might not have enough time to implement all functionalities in the first iterations. For example, software in an early development stage mostly only has base features that fulfil the most important functionalities.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1345350,
      "meta": {},
      "text": "Functionality vs Usability:\nPhoto editing software is usually packed with all kinds of different features, to manipulate the picture in question to ones desire. Many drop down menues with many nested options or little boxes in some hidden setting can have a great impact on ones projekt, if you know where to find them. On the other hand this kind of overwhelming amount of features and buttons scares new users and almost forces them to always google for the setting the desire and/or watch tutorials for a rather long time, until they climbed the often steep learning curve to the point, where they know most of the basic features, yet still can't use the software to its fullest potential.\nEfficiency vs. Portability:\nProgramming languages like java, that are made using a virtual maschine to ensure a wide variety of platforms beeing able to support them, come with a ,sometimes huge, performance cost in comparision to simpler, but more platform depending languages. A programm thats made for one platform alone can usually also exploit some unintended behaviour of said platform, which can not be translated when trying to port the software.\nRapid development vs funtionality:\nMany Games published by big publishers like EA are mostly made to create revenue, not to please the player. To lower cost or to ensure a set release date, rapid development is often necessary or forced onto the developing studio. This can lead to planned features not being implemented, even if they are much needed like \"fast Traveling\" in games like \"Lost in Random\"(published by EA)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1374820,
      "meta": {},
      "text": "-Functionality vs. usability: With more functions the software is harder to understand therefore less usable. For example the settings menu for your software can let the user tweak every setting or be limited and the user can only tweak some settings. On the one hand it is good to have the possibility to change everything to your liking on the other hand the user can be overwhelmed and maybe he then doesn't use the settings menu at all.\n\n-Cost vs. robustness: You can use more time and therefore money to make your program more robust or leave it less robust and safe money. The developer has to decide according to the project if it is worth it to spend more money on it. For example if you design a banking app then it should be really robust and you should probably spend more money on it. But if you just code for a smartphone game as a hobby project on the side you don't need it to be that robust so you might not want to spend that much more money on it.\n\n-Rapid development vs. functionality: To implement additional functions you need time to develop them. Therefore if you want to publish your software \"early\" then you have to forgo (? verzichten) some features aka functionality. For example we are designing the campus app and we are around half done with all the features we wanted to add. But its almost start of the new winter semester and we want the new Erstis to be able to use the app when they start their uni-journey. So we have to take the trade-off and leave some features out for the app to be finished in time.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1634134,
      "meta": {},
      "text": "1.Functionality and usability\n\nFor a software, the trade-off between functionality and usability is very important. Excessive functionality means that the number and types of functions available to the software are relatively large, and a collection of many functions can be completed, but this also means that its usability will be reduced, because users cannot quickly locate themselves among the many functions. which one is needed. For example, a map software, on which each location has a detailed introduction and is marked on the map, its functionality is self-evident. However, when users open the software and want to quickly find the desired location, it often takes more time and even errors.\n\nOf course, higher usability also means that the software is faster, easier, and more efficient to use, and it is accompanied by the fact that the software cannot display more functions at the same time, that is, hide some functions that are not commonly used to ensure usability. Taking map software as an example, if its usability is too high, the software will be very streamlined, and users will also not be able to know the information of a specific place at the first time. For example, whether there are restaurants, cafes, etc. with high ratings nearby.\n\n\n2.Rapid development and functionality\n\nIt is obvious that when a piece of software is required to be developed rapidly, its functionality cannot be guaranteed. Similarly, a software with complex and powerful functions must require a long period of development and testing to receive feedback.\n\n3.Cost and reusability\n\nIt also needs to be weighed when developers are considering cost and reusability. For example, an association between two classes in a rental system. If a one-to-one association is implemented, that is, each item lent is directly associated with the rental information class, which saves a lot of testing costs, but if there is a problem with any node in the rental information class, for the system, it will be Greatly reduces reusability.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1653074,
      "meta": {},
      "text": "1. Funcionality vs. Usability\nSoftware often has the problem that it is difficult to combine functionality and usability. Thus, many professional software solutions focus on maximum efficiency and functionality. However, in order to be able to use the software at all, the user has to familiarize himself with the program for a very long time. (Learnability)\nExample: Adobe Photoshop - the program has many buttons through which an experienced user can work very quickly. As a layman, however, one is lost.\n\n2. Cost vs. Robustness \nAnother conflict is cost and robustness. It can be comparatively cheap to finish a running program. See Agile Development. Making sure that this program is protected against e.g. any kind of wrong input can be a long process.\nFor example, many computer games have started to release unfinished games that still have many bugs because of the cost. (not robust) The bugs are then found by the users themselves, which is cheaper than looking for them yourself. The bugs are not always solved afterward.\n\n3. Rapid development vs. functionality\nWhen a program is produced in Scrum, it is clear that less functionality can be implemented in a shorter time (with the same number of developers). But even if more developers are used, it can be difficult to get sufficient feedback and ensure quality in a shorter time.\nExample: Many software projects only map the important core functionality at release. Additional functions are only added in the course of time. For example, the MVG app could only display the timetable at the beginning, but no tickets could be purchased.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291604,
      "meta": {},
      "text": "(Low)cost vs. robustness:\nto keep robustness, we should build a solid system,which often means that we need invest more and more \nexample:\na low cost design can not make the system tolerate temperatures up to 80 degrees .So when user use the system, may have much more problems\n\nRapid development vs. functionality:\nrapid development is not always a good idea,if every development do not improve the functionality,do not solve the problem that user now face,it just develop the other which not important, in this case actually the development is meaningless, and unnecessary.\nexample:\nthe software develop rapidly,the function in the system always do not change or even improve \n\nFunctionality vs. usability: \nFunctions that are particularly advanced may not necessarily be the best for users to use and understand.Sometimes relatively low-level functions may be more suitable to use\nexample:\nan app has 100 different functions, but because of too much functions , it is difficult for user to use and understand the app",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291985,
      "meta": {},
      "text": "A typical situation were you have to find a trade-off, is when you decide wether the program should be more usable in terms of speed or extended functionality or more understandable and hence more easy to work on as a Developer. In C for example, the code of an unoptimized algorithm can look logically, but once it is optimized to run faster, the code can get very complicated and unstructured at a first glance. If you need multiple dev(-teams) to work on such code, it can be more practically to keep things simple even if it means not to unveil the whole potential.\n\nReferring once again to my Example with C, there can also be a problem with compatibility. When you want or have to archive the highest performance of your code, you don't get around optimizing it - especially in a low level Language like C. But its not granted, that that kind of optimization is also fast (enough) on a different system with probably a different architecture or other internals. Sometimes it even can happen, that such optimized codes doesn't run at all on other systems because this system may not support certain basic commands / operations. Here you have to choose between portability and speed or performance of the code.\n\nAnother trade-off situation is, when you want to be cost effective or fast in development, but also a well-developed Project. When the deadline is tight and the budged is limited, you often have to decide where to put in your effort because finishing everything as planed might not be possible under these circumstances. An example would be that a planed feature have to be delayed to a later update like in MacOS Monterey with Universal Control. It was planed for the release in September 2021 with V. 12.0 but came later in March 2022 with V.12.3\n\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292802,
      "meta": {},
      "text": "1. Functionality vs. Usability\n\nA common design goal trade-off is Functionality vs. Usability. When developing a product, one often thinks of all the features one could add. However, this often leads to more complexity in the development process as well in the UI design. When adding to many features, the users might not understand how the application words. For example, an app adds plenty of setting so the user can modify almost anything, but the settings menu is due to all those options too confusing for the user.\n\n2. Cost vs. Reusability\n\nAnother common design goal trade-off is Cost vs. Reusability. Designing small software pieces e.g. simple java program with just some features and low dependency requires only a small amount of time spent with coding and testing. However, the java program that e.g. calculates a specific value is not very reusable in other cases than the one it was explicitly designed for.\n\n3. Backward compatibility vs. readability\n\nWhen developing software, e.g. a messenger app, the developers usually want that users who still run the older version can still communicate with users who use the older version although some new features (newest version can use reactions on messages) are only available for new users. However, differentiating between different versions and paying attention to all those details makes the code very complicated and not very readable.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1297883,
      "meta": {},
      "text": "The trade-off between cost and robustness is balancing how much time and therefore money will be invested into ironing out the potential bugs in a system might have. In other words, when do you cut costs and stop fixing bugs and call the product finished. Since the system may never be entirely bug-free one has to make the trade-off between the project's cost and its robustness. For example, a major tech company such as Mircosoft will always invest the time needed to fix every bug they discover since they have the money to cover all the expenses.\n\nThe trade-off between rapid development and functionality is that a system that was developed under a very tight time constraint is not going to be as fitting for the purpose it was designed for compared to a when the system had enough time to be properly implemented. When we look at Google, for example, their teams are given enough time to properly fulfill the requirements for the task at hand.\n\nThe trade-off between cost and reusability is when you design a system in a way that allows certain structures to be reused in different parts of the project but in turn, you need more time and money to first implement the system to be able to work in that manner. For example when you have a project and have identified that several subsystems serve a similar role you can implement one in a way to allow the other to extend the already present functions.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1301583,
      "meta": {},
      "text": "Portability/localization (Over time, if your product is successful, you will have to survive massive changes in underlying technology — Eg: in the case of FirstClass, Mac->Windows NT->Mac OSX->Mobile->Cloud.)\nScalability/extensibility(Eg: Our first customer had 3500 users on a server. We engineered it for 100,000. Our largest customer had 1,000,000.)\nMaintainability (Originally FirstClass shipped in 1990. Still shipping. The person maintaining it now was not even born when it first shipped.)\nTime vs. space is the biggest trade-off in the code itself. It’s often faster to use pre-computed values, but it takes a lot of space. You can use less space by doing things on the fly, but that generally takes more time.\n\n",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1330521,
      "meta": {},
      "text": "The first design goal trade-off i want to talk about is functionality vs. usability:\nThe more functionality is added, the more time you have to spend on keeping everything usable. As more functionality has to be put in intuitive order and layout. As more functionality is added, this gets harder and harder. If you e.g. want to develpo a scientist math application, you can't keep this app as easy to use as a tic tac toe game, simply because there will be plenty of functions. \n\nThe same thing goes for functionality and cost. You need time to develop functionalities, which is something you dont have if you want to keep costs low. \n\nLast but not least, rapid development and maintainability is another design goal trade off. If development is rapid, the developers dont have much time to focus on a good structure with low coupling and high cohesion as well as atomicy of functionality but they are more focussed on getting the functionality done quickly. That means maintainability will be low.  ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1330822,
      "meta": {},
      "text": "A common design trade-off is between functionality and usability. Usability describes the ease of use of a user interface and functionality the number of functions and operations in a user interface. But with more functionality built into a user interface, it becomes less intuitive to use the interface and it requires more time and knowledge to start enabling the potential of the functionality, which is built into to the user interface. This problem can arise building a website where you don’t want to overcharge the user with a lot of buttons and options by still retaining the core functionality provided by the website (like online shopping).\nAnother trade-off arises between Portability vs. Development cost. Typically, when designing a system, the client wants to keep the costs at a minimum. On the other hand the system should work on multiple platforms which require more time and money to adapt the system to each platform. Just think about computer games. Is it worth it, to make a game run on Windows, Linux and macOS?\nA third trade-off lies in rapid development. Often there exist deadlines for completing a certain project. But if development runs behind, or if the planned timeline is just not realistic for the specified functionality, there has a choice to be made between less functionality on time or full functionality later. This e.g. plays a role when you want to publish an app on a specific date, but the development runs behind. maybe the app must be published with less than the desired functionality or later.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1334008,
      "meta": {},
      "text": "Cost vs. Rapid development \n\nA brand wants to have a new Website and therefore hires a five-person development team to develop the page. The team states that the page will take two months and cost 2000$. But the firm wants the website already in two weeks, therefore the team needs to hire five additional developers which drive the price up to 4000$. So now the brand has to judge if the faster delivery is worth the extra costs.\n\nWell-defined interfaces vs. flexibility\n\nA client wants to get a new smart home App developed. The big selling point for that new App is the customisability and flexibility.  Because the app can adapt to all kinds of home layouts, the used smart products and even to the end customers' taste. But because of that high level of flexibility, it is very hard to define an Interface, because it changes with all the variables. As a result, a compromise has to be found between the level of flexibility and a somewhat defined and predictable Interface that is actually possible to implement.\n\n\n Backwards compatibility vs. Maintainability\n\nA bank wants a new account management system because they already have a system they want the new system to be backwards compatible with the old. But through this connection, the systems get very hard to maintain, because changes in the new System might affect the old and vice versa. So now the bank has to decide on how much Backward compatibility they want, while also having good maintainability. \n \n ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344351,
      "meta": {},
      "text": "The first typical desgin goal trade-off is \"Functionality vs usability\":\nThat means that on one hand a system should include as many useful functionalities as it could but on the other hand it should also be easy to use and to understand, so that the user can use and understand the full range of functions in a brief timespan. If for example a calendar system has hundreds of different functions for every kind of calendar-entry you can think of and the users take multiple hours to learn how the system works in its full range of functions, the usability design goal isn't given anymore.\n\nAnother typical design goal trade-off is \"rapid-development vs functionality\":\nOne design goal is \"rapid-development\" which means that the development of a system should only take as much time as really needed and should be fast. Another design goal is (as mentioned above) \"functionality\" which means that a system cover a very wide range of functions. But its not possible to meet both goals perfectly at the same time, because in a short timespan you can implement fewer functionalities than in a longer timespan. So if you want a lot of functionalities, the development takes a lot longer than if you are content with just a few functionalities.\n\nThe third typical design goal trade-off I wanna talk about is \"cost vs robustness\":\nIn order to create a system which is cheap in terms of cost its necessary that you put as little working-time as possible in its development. But on the other site it takes a lot of time to make a system as robust as possible. So as you can see those to design goals clash with each other.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1344527,
      "meta": {},
      "text": "1. Backward compatibility vs readability \nLet's say someone has worked at a company for a good amount of time, starting off as a beginner programmer who didn't know much about how to implement good interfaces or cLeaN coDe. The software he wrote is used by a lot of people, and in the coming years said person finds it more and more difficult to improve his old code, which he wrote years ago. Now he has a bit of a problem, because backward compatibility is so big that any changes to the interface are nearly impossible.\nEither he has to create an entirely new software and offer users a discount for the update, or remove the part where the software is compatible with earlier versions and thus making new code independent of old code.\n\n2. Rapid development vs functionality\nWhen you put rapid development over functionality you may run into problems and issues that could've been avoided if you had taken your time. On one, if you finish something in a haste you might be missing out on newer functionalities or improvements, while on the other hand, if your development period is stretched out, you might find that your competitor, who released his product earlier (when the demand was bigger than the supply) is more successful then you after you release it sometime later. \n\n3. Functionality vs usability \nImagine a video game where every key on your keyboard had a function. Every. Key. That would be a bit overwhelming, no? In comparison, there are a lot of other games where you only use the standard ones like m for map, the movement keys, etc. Now the question is, aren't more functions usually better? In terms of how people approach things, it's important to keep things as simplistic as possible while still making everything available to a player. There has to be a balance between functionality and usability, because if either one is too pronounced, then you're either too overwhelmed with all the possibilities or too underwhelmed with the shortage of actions you can do.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344585,
      "meta": {},
      "text": "Functionality vs. usability: When a system offers multiple functionalities that may go beyond what a \"normal\" user would need, it could be seen as very powerful, however this could also lead to functions that are used in a high frequency being harder to find and thus make the system more complex as it would need to be. This could for example lead to a huge and confusing menu, resulting in an aggravated usability.\n\nRapid development vs. functionality: With rapid development, simple functionalities can be ensured that run quite robustly and are tested. For example, a simple booking system for a restaurant can be developed within one semester. However, if further, complex functionalities are to be added, more time must also be calculated for this. Complex use cases must also be sufficiently tested here to function reliably in use.\n\nCost vs. robustness: a robust system runs very reliably with a very low failure rate under normal usage. This means that many borderline cases were considered during development and also many tests were performed to identify sources of errors. Such development can be very costly, depending on the complexity of the system. If you want for example a simple system with basic functionalities that does not show any errors during normal use, you can expect lower costs, but also a higher failure rate when the conditions of use or requirements change.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344596,
      "meta": {},
      "text": "1. Rapid Development vs Functionality\nRapid development in software engineering means that there is a low development time at the cost of lower amount of features. This often also means that the diligence in the development functionality is lost. On the other hand, functionality requires diligence and trades with an increase in required time. For instance, in a minimum viable product for a chat application it would be required that the main functionalities of receiving and sending messages are completed in a minimal amount of time. Therefore there is a tradeoff of keeping track of contacts as a functionality but the time required is lower.\n\n2. Usability vs Functionality\nThe tradeoff between usability and functionality is that of simplicity. Usability occurs when an application is simple enough to be used without a large amount of practice. Simplicity is destroyed however, with the abundance of functionality. An application that is made for everything around stock trading for instance, trades usability with a large amount of functionality which in turn is effective if used right.\n\n3. Cost vs Robustness\nThe tradeoff between cost and robustness is that of quality. Quality is achieved when the software has been developed diligently. For software to be diligent in engineering, the cost must is high because more time and expertise is required to account for edge cases and vulnerabilities. A low cost however, will sacrifice diligence and hence robustness. For instance, low cost in a banking application will take a toll on robustness because it may take a toll on quality if for instance, security is not accounted for.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344757,
      "meta": {},
      "text": "Rapid development vs. functionality:\nUm eine schnelle Entwicklung durchführen zu können, wird oft auf eine gute Dokumentation oder einen Cleanen Code verzichtet. Dadurch ergeben sich häufig bugs, die die gewünschte Funktionalität des Programs negativ beeinflussen. Auch kann es bei einer schnellen Entwicklung möglich sein, dass nicht alle Features implementiert werden können. Zum Beispiel wenn man versucht zu viele Features in einen Sprint zu nehmen, kann es dazu kommen, dass die Features nicht alle umgesetzt werden können.\nFunctionality vs. usability:\nWenn mehr und mehr Funktionalitäten in eine Anwendung eingebunden werden, wird es schwerer das Programm zu bedienen, da man sich viele Tasten merken und ausführen muss. Zum Beispiel lassen sich die meisten Computerspiele mit den vier Tasten w,a,s,d Lenken. Auch wenn man mit mehr Tasten eine präzisere Steuerung erreichen könnte, würde die Nutzung komplizierter werden, ohne das Spiel deutlich zu verbessern.\nCost vs. robustness:\nUm eine möglichst gute Fehlerbehandlung durchzuführen, muss das Programm viel getestet und verbessert werden, was die Kosten für das gesamte Projekt in die Höhe treibt. Beispielsweise wenn sehr neue Software auf den Markt kommt, wurde in diese oft nur möglichst wenig Geld investiert, was oft zu vielen Fehler kurz nach dem release führt, da die Nutzer die Software mit ungewollten inputs ausführen. Auch Sicherheitsprobleme können bei fehlenden abfangen von falschen Eingaben entstehen.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1501859,
      "meta": {},
      "text": "1. Functionality vs usability is a typical tradeoff with almost all systems. This is because a program with many \t \n    complex functions is confusing for a inexperienced user, and he might get overwhelmed (an example \n    would be vim, a Linux text editor; it has a lot to offer, but in return of that has a steep learning curve). On the \n    other site, if it is to simple (for example the windows Notepad, it is just a Texteditor), experienced users might \n    not find what they need and may install a more complex program.\n2. Rapid development vs. functionality is another tradeoff. It often happens that if a program gets rushed in \n    development, so that it gets released on time, it only has half of the functionality it promised and \n    even those could be full of bugs. That is because the developers just had not enough time to implement all \n    of the functions and/or test the program enough to find all bugs. (E.g. Cyberpunk 2077; on its release \n    date it was full of bugs, because the deadline was met way too early). But if you take your time to make a bug- \n    free program, the consumers have to wait and will get annoyed (For example GTA VI; it is still not released [we \n    are waiting for over 5 years])\n3. Efficiency vs. portability: If you want that your program can be used on many different devices, you probably \n    have to calculate with efficiency loss. Since all those devices have different hardware and use different \n    operating systems, which all use their resources differently. An example would be Java. It is supported by \n    almost every device, but is in comparison with other languages (e.g. C) it is pretty slow.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1654297,
      "meta": {},
      "text": "1. Rapid development vs. functionality: it is impossible to develop a software really fast while also having all functionalities. It takes time to implement everything so having both is unrealistic. For example when the Corona Warn App was being developed it had to be on the market quite fast so extra functionalities like qr codes for events where added later and not during the first release even if it would have been a useful function at the time.\n\n2. Functionality vs. usability: having all the functions imaginable in a system makes it quite complex and unusable. therefore having both is hard and the developers have to cut both a bit down to have a functioning system in the end. For example our university systems (tumOnline, Moodle, Artemis, etc.) could be all on one website but then there would be too many functionalities and it would be way to hard to organize everything so it was split up to be more usable.\n\n3. Cost vs. Robustness: It takes time and money to develop a system and if you wanted a completly robust system that never fails at doing its job it would be quite costly. So you have to trade off some of the robustness to save money. For example when designing clothes you would want them to not rip under any unwanted circumstances but having a material that is undistructable or at least quite robust costs more than many would pay.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291685,
      "meta": {},
      "text": "Functionality vs. usability\nThe end user wants lot of functions & capabilities but also wants an user-friendly interface. But the more functions, the complexer the system.\n\nCost vs. robustness\nClient wants low cost, developer & end user/Developer wants minimum # of possible errors-> takes time to define possibilities of error and to erase them, but more time on development costs the client money\n\nRapid development vs. functionality\nRapid changes in underlying technologies nowadays make it hard that the implemented functionalities will also work with them.\n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1297782,
      "meta": {},
      "text": "When developing software, you have to consider the trade-off between functionality and usability. The more functionality the software has, the more confusing it becomes for the user to use it. On the other hand, if an app has just one function, for example playing music, it becme very easy to use. You trade in the other functions for better usability. Software always needs to maintain a good balance between having the necessary functions while still being usable.\n\nAnother trade-off you have to make is between rapid development and functionality. The faster you want to develop the software, the less complicated functions you can integrate. For example, if the customer wants the software to be developed as quickly as possible, you only have time to implement the basic functionalities of the sowftware, without getting too complex. Otherwise if the customer cares more about the functionality, developing the software will take a much longer time, but it will also be more complete and provide more functions.\n\nAnother one is a trade-off between cost and robustness. If you want a robust software, it needs to be tested thoroughly to make sure it runs smoothly and can handle a lot of different inputs and environments. This stands in contrast to trying to minimize the cost fpr the software development, because testing takes a long time and therefore increases the cost of development. An example for that is a graphics card. If you want your copmuter to be able to handle awesome graphics and fps, you will need to pay a lot more money for a robust graphics card that doesnt crash all the time. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1300771,
      "meta": {},
      "text": "Nicht selten überschneiden sich die Design Goals insofern dass sie sich die Waage halten. Legt man den Fokus stärker auf das eine Ziel, \"leidet\" darunter ein anderes. \n\nEin typisches Beispiel wären zum Beispiel das schnelle Entwickeln eines Projektes, also eine kurze Entwicklungszeit und die Funktionalität die dadurch oft auf der Strecke bleibt. Ein Beispiel wäre die Corona Warn App in den ersten Wochen und Monaten. Sie sollte schnell entwickelt werden um in der akuten Lage zu helfen. Funktionalitäten wie das Tagebuch der Kontakte, eine einwandfreie Kontakterkennung oder eine Erkennung auch im Ausland blieb dadurch aber erstmal auf der Strecke, was die App sehr viel schwerer nutzbar gemacht hat. \n\nEin anderes Beispiel für so ein Tauziehen wäre zum Beispiel die Rückwärtskompatibilität und die mangelnde Möglichkeit des lesen, überarbeiten oder effiziente nutzen des Programms. Ein bekanntes Beispiel wäre dafür zum Beispiel die Programme sämtlicher Versicherungen. So erneuern manche ihr komplettes Design, aber durch die geforderte Rückwärtskompatibilität ist das schreiben dieser Systeme unglaublich aufwenig, da diese Systeme in längst nicht mehr bräuchlichen und mit keiner sinnvollen Struktur entwickelt wurden.\n\nEin letztes und wahrscheinlich das offensichtlichste und bekannteste Beispiel eines solchen trade-offs ist die Funktionalität im Austausch mit der Nutzbarkeit. So werden viele Programme mit viel weniger Funktionen eher benutzt als welche mit einem Überschwung an diesen. Ein Beispiel ist das benutzen von Zoom oder Weber statt Discord (der Datenschutz mal außer acht gelassen) während Corona an den Schulen. Discord mit seinen vielen Funktionen aus verschiedenen Channeln, Test chats, bots und vielem mehr, war für fast alle Lehrer und den Großteil der Schüler unverständlich und nicht nutzbar, sodass auf Zoom zurückgegriffen wurde, obwohl Discord viel mehr Möglichkeiten parat hält.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1334167,
      "meta": {},
      "text": "Functionality vs. usability\n\nIf a user is inundated with functionalities, then the user may not know which functionality is best suited for her need and may find the software lacking in usability.\n\nExample) If a user has the option to search for specific data within a database in numerous ways that each use a different methodology of locating data, then the user may be unsure of which data location tactic functionality would be most efficient.\n\nCost vs Robustness\n\nA software development project with a very low budget may not be a robust as a project with a larger budget.\n\nExample) Due to a low budget, the software development team for a washing machine has to complete the project in an expedited time window, and they do not have time to ensure that the washing machine stops rotating when the machine door is forced open by the user.\n\nEfficiency vs Portability\n\nA portable system may not be the fastest to use because changes to one subsystem have a minimal effect on other subsystems. Therefore, a user may need to implement changes on many different subsystems.\n\nExample) To change the temperature of the interior of her home, a homeowner must turn on the air conditioner and also turn off the heater, because changing the air conditioner has no effect on the heater.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344434,
      "meta": {},
      "text": "One design trade-off is rapid development and fault tolerance. If I have to develop a system very quickly I can’t cover all potential special cases so that the system can deal with them. Therefore some e.g. unintended inputs can lead to the crash of the system. This can be explained by the example that a student starts to study one day before his French exam. Due to the short preparation time, he can only learn the vocabularies but in the exam he’s given grammar exercises. He doesn’t know how to deal with this case (similarly to the above described cases). \n\nAnother design trade-off is functionality vs. usability. This can be compared to our lecture-game “Bumpers”. The game can have many different functionalities, like many different car and collision types, sound effects, many different rules or steering possibilities… If this gets too much it is not really usable for the End-User anymore, as he can’t play the game because he can’t possibly understand all the information and different interactions at once.\n\nOne last design trade-off is rapid development and readability. If I have to design a system very quickly I can’t pay as much attention to the readability and structure of the code. This can be compared to an exercise in an exam, where the student is asked to describe a historical event and has only 5 minutes left. He therefore starts to write everything down he knows without any structure and bad possibility to follow/read/understand.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1411576,
      "meta": {},
      "text": "When developing a project there certainly comes a time where decisions have to be made that include design trade-offs. Three examples are:\n\n1. Functionality vs usability: A user might be able choose a lot of options, but the user friendliness take a big hit. The app/ website gets cluttered with features leaving the user confused. Less features may lead to less control/ choice, but more simplicity and better user experience.\n\n2. Cost vs reusability: While developing a project, the team must decide how much they want to document their code/ project, which leads to more understandable code, but also takes time they could use to implement new features/ functions. Documenting and keeping the code clean takes time which in the end costs the client more money.\n\n3. Cost vs robustness: Like the example above. A client has to decide if he wants the system to be extra robust which in turn also costs him more money, because developers now have to think about how to make the system as robust as possible, too. Hours spend on trying to harden the system aren't spend implementing functionality which in turn leads to longer developing time, costing the client more money.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1636185,
      "meta": {},
      "text": "1. Schnelle Entwicklung vs. Funktionalität:\n\t\n\tJe mehr man auf eine schnelle Entwicklung einer Software setzt, desto weniger Funktionen wird diese am \t\t\t\t\t \n    \tEnde haben. Der Hauptfokus liegt nun mal auf einer schnellen Entwicklung um am Ende Kosten zu sparen, \t \n \tdennoch sollte man zumindest die Hauptfunktionen ordentlich implementieren und testen. Natürlich gibt \n \tes bei jeder Software auch gute Features, welche nice to have wären, jedoch muss dort immer evaluiert \t\t \t \n \twerden, inwiefern sich ein einzelnes Feature mit einer schnelle Entwicklung unter einen Hut bekommen \t \n \tlässt. \n\n2. Kosten vs. Stabilität:\n\t\n\tEin weiteres Design Goal Trade-Off ist der Zusammenhang zwischen Kosten und Stabilität. Für eine \t \n \tbessere Stabilität muss in der Regel mehr Geld ausgeben werden für beispielsweise weitere Tools. So wäre \t \n \teine Überlegung eine Datenbank redundant aufzubauen, womit bei einem Absturz der Software dennoch \n \tkeine Daten verloren gehen. Diese kostet allerdings wiederum Geld, wodurch sich hier der Widerspruch \n \tergibt.\n\n3. Effizienz vs. Portabilität:\n\n\tMit Portabilität ist hier die Möglichkeit die Software auch für andere Probleme, nicht nur für das sie \n  \teigentlich entwickelt wurde, auch nutzbar zu machen. Wenn im Extremfall von Anfang an klar ist, dass die \n \tSoftware ausschließlich für den Selbstzweck genutzt wird, kann man sehr viel explizit (hard) coden, \n \twodurch der Aufwand gesenkt und damit die Effizienz gesteigert wird. Sobald man nun die Software für \n \tandere Nutzen auch einsetzen will, muss das Design schon viel generischer und offener gestaltet werden. \n\n\t\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1317309,
      "meta": {},
      "text": "Design Goal Trade-offs:\n\nBackwards compatibility vs. readability:\nIntel decided to support backwards-compatibility in their computer architectures for example are their newest architectures still compatible with the first architectures from the late 1980. But this is often a problem for readability because old concepts are today often out-dated and adding new Things to existing means is often not the best idea, for example old computer architectures where only very limited to a register size of 32 bits or even less. Because Intel decided to support backwards compatibility they had to add another 32 bits to every existing register and come up with new registers which names sound odd.(eax->rax, rsi, edi, r11-r15, etc.).\n\nEfficiency vs. portability:\nThe best example for this trade-offs are laptops and desktops. Laptops are more portable and easier to transport but also often slower and less efficient. Desktops are often way faster, but also not at all portable and very big.\n\nCost vs. robustness\n\nlow Cost Applications are often developed with a minimal amount of testing for bugs or malware or not at all prepared against hacking attacks. With a higher budget comes a higher possibility to build smooth applications which are bug safe and protected against attacks of any kind for example hacking attacks.\n\n\n\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1330282,
      "meta": {},
      "text": "Die Design goal trade-offs entstehen vor allem an den schnittstellen der Ansprüche vom enduser, developer und client. \n(1) Zum Beispiel an der schnittstelle zwischen developer und client steht die Wartbarkeit, welche im trade off zu den Kosten steht. Je besser die Software wartbar sein soll, desto gründlicher muss diese vom Developer umgesetzt worden sein. Dies beansprucht mehr Zeit und somit auch mehr Geld. \n(2) Ebenso steht die Effizienz der Laufzeit von der Software direkt in der verknüpfung zu den Kosten, da besserer Hardware auch die Laufzeit beieinflusst. Diese Kostet natürlich wieder mehr. \n(3) Aber auch zwischen dem End user und dem Developer gibt es Trade-offs. So möchte der Developer seine Software möglichst vielseitig verwendbar machen, das bedeutet aber das die Funktionalität dieser darunter leidet, da die speziellen Funktionen nicht vielseitig anwendbar sind. \nZusammenfassend lässt sich sagen dass Trade-offs natürlich vorkommen, da diese Parteien andere Ansprüche an die Software besitzen und diese in Spannungen enden. Daher ist es wichtig diese Spannungen am anfang bereits zu sehen und aufzulösen, sonst können diese Spannungen zu großen Problemen führen, was dem Projekt sehr stark schadet.",
      "score": 33.3,
      "language": "GERMAN"
    },
    {
      "id": 1344213,
      "meta": {},
      "text": "With Rapid development the goal is to develop the Software as fast as possible, while fulfilling all the clients requests. Example: A company might choose to rush development because they could another client waiting for a project.\n\nWith Functionality the objective is for the system to do all the work it was intended for. For Example: In the Bumpers game, there the right conditions to win the game should be working. Unfortunately the downside might be a longer development cycle. \n\n\n\nBy developing a system designed for a specific cause, the cost might a lot higher. For Example: NVIDIAs: \"Control Panel\" is a software exclusively designed for their own products. Meaning it cannot be used for another system like for AMD Graphics. \n\nAnd by developing a system that can be reused, the cost is naturally reduced as the system is already made. \nFor Example: The Game Engine \"Unity\" is a software that can be used to create a lot of different Games.\n\n\n\nEfficiency is when the size of a developed software uses most of its Resources to achieve maximum performance. For Example: Adobe Premiere Pro should use all of its Resources to give the user its rendered video as fast as possible. However to be that efficient you need to have a powerful machine.\n\nThat most of the time cannot be portable. With portability you don't use all of the resources possible at the advantage of using the software everywhere. For Example: Adobe Photoshop Rush is a version of Photoshop on Mobile Phones, using less resources than a Computer.\n",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1423798,
      "meta": {},
      "text": "Efficiency vs. portability\nOft leidet die Effizienz wenn man portable Software verwendet.\nPortable Software ist Software die auf unterschiedlichen Computern oder Betriebssystemen laufen kann. Wenn man allerdings eine solche Software hat, vernachlässigt man meistens die Effizienz, da hierbei  beispielsweise Betriebssystemspeziefische Optimierungen für eine bessere und schnellere Laufzeit nicht angewendet werden können, oder Optimierungen Aufgrund einer evtl. kleineren RAM Kapazität oder ähnlichem nicht vorgenommen werden können, weshalb hier die Efizienz leidet, die Portabilität allerdings nicht.\n\nCost vs. reusability\nEin anderes Beispiel wären die Kosten vs. dem Nutzen einer Software für mehrere Sachen. Also die Wiederverwendbarkeit.\nDamit man Methode, Klassen oder andere Strukturen auch für anderes benutzen zu können, wie als das wofür sie ursprünglich gedacht waren, ohne viel ändern zu müssen, braucht man eine höhere Abstraktion, wie zum Beispiel die Vererbung, abstrakte Klassen oder Interfaces, wodurch es übersichtlicher und leichter änderbar ist. Allerdings gibt es hier einen höheren Aufwand diese zu programmieren oder zu testen, weshalb sie mehr \"kosten\". Hier in diesem Beispiel leiden also die Kosten unter der Wiederverwendbarkeit\n\nBackward compatibility vs. readability\nEin anderes Software tradeoff wäre dieBackward compatibility vs. readability. Also dass etwas rückwärtskompatibel ist(also ein Design dass mit früheren Versionen von sich selber kompatibel ist) und das man es einfach lesen und/oder verstehen kann. \nBeispielsweise werden in älteren Systemen ganz andere Funktionen, Methoden oder Konventionen verwendet, die man heute nicht mehr benutzt und man erst nachlesen muss was das macht, bevor man das Programm oder System versteht, weshalb die readability, also das leichte lesen und verstehen des Programms an der Rückwärtskompatibilität leidet.\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1656870,
      "meta": {},
      "text": "1-Cost vs Robustness : \n\nAs an example to this type of trade-offs, i would derive a bit from software : why isn't every common robust utensil made of aluminum instead of iron (let's say air conditioners in restaurants besides beaches) when iron oxidates and deteriorates ? it's because iron is way cheaper than aluminum. That's also the reason why most PC chassis are made of plastic and not aluminum. \n\n2- Efficiency vs. portability: \n\nNow, here portability can have two meanings, and i'll give examples for both: \n\na- easily movable : desktop vs laptop in gaming \nGaming desktops traditionally have better performance than gaming laptops because they can house more powerful graphics cards and a wider variety of hardware. Laptops also have limited space for airflow and cooling features.\nb- \"the ability of software to be transferred from one machine or system to another.\" ~Oxford Dictionary \nWhile software portability widens the audience and increases the reach of its contents, it can lead to a less efficient program since it won't take advantage of the full range of SPECIFIC services a programming language has to offer. \n\n3- Usability vs. functionality : \n\nSince usability = ease of use and functionality = range of use/ set of operations, it is easy to find examples in any field. Let's take the example of drones. We can add multiple functionalities like being able to take pictures, being able to record a video, being able to shoot mini \"Nerf\" bullets etc. which would make it super fun, the issue is, it would be extremely hard to control in an efficient way. Let's suppose we have a remote controller, there is only a finite amount of buttons a person's mind can think about at the same time, so it would pnly add confusion.  ",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291097,
      "meta": {},
      "text": "1. Efficiency vs. portability\nAn application is using the Observer pattern. The benefit of this is the flexibility it provides such as allowing the software to dynamically register event handlers with the subject (event publisher). On events the subject can iteratively invoke all registered event handlers without knowing details of the registered observers.\nWhen this component is re-used for an embedded system with real-time requirements. As it turned out, applying the Observer pattern is a bad idea when predictability and real-time Behavior are more important than flexibility due to the dynamism the pattern provides.\n\n2. Rapid development vs. functionality \nSometimes it is better to choose rapid development. For example when developing an application, the faster the application comes out to the customer, the more likely it will take over the early market by winning the first batch of customers. But it also has risks, for example when the application can’t fully fulfil customers' requirements, so it needs more functions and more changes in the later phase of development.\n\n3.  Functionality vs. usability\nFinding the balance between functionality and usability is also very important. For example when developing an application. It is better to keep the main user interface clean and simple. So it will not be a burden for the customer to understand how it works and easier to use. When there are too many functions and instructions on one page, it will be hard for the user to read information.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291569,
      "meta": {},
      "text": "Functionality vs. usability: Usability is the ease of use of an interface. Functionality is the set of operations that a interface supports\nFor example an onlineshop that has lots of functionality but not usable for everyone. This makes the system only usable for special type of customers and not everyone can buy from this shop.\n\nCost vs. Security: A low cost design does not care about security of the user when the user enters his data. \nIn OnlineShop example If costumer enters his account number and pin, a system with low security may leak that confidentional information to another user.\n\nCost vs. Performance: A low cost design can not have a really good performance.\nFor example if we want to have system that handles credit card transactions the system should fulfill different performance requirements,  for managing thousands of account informations at the same time.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292555,
      "meta": {},
      "text": "1) Cost vs. robustness: Increasing robustness usually needs very extensive testing which will take more developers or more time per developer where both options will lead to more man-hours of development which then lead to more cost.\n2) Backward compatibility vs. readability: To achieve backward compatibility in general a lot if (edge) cases need to be implemented in the code which leads to complicated execution paths which then leads to unreadable code.\n3) Efficiency vs. portability: Supporting different platforms prevents a software from using the platform specific highly efficient feature of the system architecture and usually only allows generic working but unefficient features.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292587,
      "meta": {},
      "text": "Functionality vs. usability: \nWenn ein Programm mit vielen Funktionen ausgestattet ist, sollte es dem Nutzer auch leicht sein auf diese zuzugreifen. Bei zunehmender Zahl an Funktionen wird das komplizierter. Wenn eine steuerbare Spielerfigur in einem Spiel sehr viele Aktionen ausführen kann, muss es dem Spieler auch möglich sein diese mit wenigen Schritten anzusteuern. Wenn das Spiel mit einem Controller verwendet werden soll, wird es bei zunehmender Zahl an Aktionen schwieriger, diese Aktionen auf die wenigen Buttons und Cursor zu mappen.\n\nCost vs. robustness:\nEin System zu entwickeln, das bei jedem erdenklichen Input und auch bei großen Veränderungen im Umfeld, korrekt funktioniert, braucht Zeit, was wiederum die Entwicklungskosten in die Höhe treibt.\nWenn das Geld für weitere Arbeit an einem System fehlt könnten sich die Verantwortlichen bspw. gezwungen sehen, die Entwicklung vor ihrer Zeit einem Ende zuzuführen. Solch eine übereilte Fertigstellung manifestiert sich leicht in Mängeln hinsichtlich der Robustheit des Programms.\n\n\nRapid development vs. functionality:\nZeit ist für alle Parteien (Endnutzer, Kunde, Entwickler) eine wertvolle und begrenzte Ressource. Komplexe Funktionalitäten zu implementieren kostet Zeit, die man in den seltensten Fällen hat. Besonders für den Client ist es wichtig, dass das System besonders schnell entwickelt wird und Zeit kann man sparen, indem man bei der Funktionalität des Programms zurückstellt. \nZ.B., wenn der Client verzerrte Vorstellungen davon hat, wieviel Zeit die Implementierung von diesen oder jenen Funktionen braucht und zu wenig Zeit eingeplant wird, wird das zu Mängeln bei der Funktionalität oder gar fehlenden Funktionen führen.\n",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1295131,
      "meta": {},
      "text": "Cost vs. robustness: The customer commissioning a new software development project wants it to be as cost-effective as possible, but this leaves the developer no choice but to cut corners at some point. This could mean developing the software very quickly without ensuring that all edge cases are covered to meet the client's requirements. For example, problems could arise when several players want to access the online version of the Bumpers game at once. \n\nFunctionality vs. usability: when developing a software, the client has in mind all the possible features that should be included in the app. This is not always optimal in terms of usability for the end user. If a software is to be used as a payment system, it may be possible to integrate all the logistics into the app, but this could lead to customers being overwhelmed with too many features to choose from. \n\nCost vs. reusability: the goal of the client of a software is to develop it as cheaply as possible. This can lead to a software design that is too specific for that one use case, making it impossible to reuse the software when it is sold, for example. An example of this is Instagram's \"Stories\" feature. If this feature is too tailored to the Instagram app, the software part could not be sold to Snapchat if they also wanted to implement a\"Stories\" feature. If Instagram had put a little more money into development, they could have gotten the money back by selling the software to someone else. However, this is only possible if the software is developed in such a way that it can also be linked to other systems. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1330661,
      "meta": {},
      "text": "1. Efficiency vs. Portability:\nWenn eine Software für mehrere Systeme programmiert werden soll, wird die benutzte API meist sehr allgemein bzw. abstrahiert gehalten, damit der Programmierer sich nicht auf die spezifischen implementation details konzentrieren muss. Das bedeutet meistens reduzierte Effizienz. Ein gutes Beispiel hierfür ist Java: sehr viele Platformen sind unterstützt, jedoch wird hierbei ein sehr allgemeiner Java-Bytecode erzeugt, welcher natürlich langsamer ist als Assembly.\n\n2. Rapid development vs. functionality:\nWenn Software möglichst schnell entwickelt werden soll, ist es natürlich, dass einige Funktionalitäten vernachlässigt oder sogar ganz weggelassen werden, damit man sich auf die wichtigsten Features konzentrieren kann und somit ein Funktionierendes Produkt hat. Ein sehr gutes Beispiel, bei dem Rapid development vor Functionality gestellt wurde, ist das Spiel Cyberpunk 2077. Da das Spiel zu früh veröffentlicht wurde, waren viele versprochene Funktionaltäten, wie z.B. eine funktionierende AI, noch nicht implementiert.\n(Ich hoffe das Beispiel war nicht zuuu speziefisch, es hat halt sehr gut gepasst :D)\n\n3. Backward compatibility vs. readability\nDamit Software auch in Zukunft noch auf alten Systemen nutzbar ist, sollten Software (und Hardware) updates auf backwards compatibility achten. Da die Software somit jedoch auch auf mehr \"edge-cases\" achten muss, wird die Lesbarkeit reduziert. Wenn z.B eine Software auf ein neues System geportet werden soll, jedoch noch auf dem alten System laufen muss, werden wahrscheinlich viele if-Anweisungen in dem Programm zu finden sein, welche checken auf welchen System es sich grade befindet, damit Systemspezifischer Code ausgeführt werden kann. Dies reduziert die lesbarkeit des Programms.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1333017,
      "meta": {},
      "text": "a typical design goal trade-off is to trade usability for functionality, for example, if you implement a system with a low amount of functions it is very usable but less functional than a system that has the same functions plus more. So by adding more functions to the system it becomes more complex and functional but less usable.\n\nanother design goal trade-off is portability vs performance, where you trade off some of the performance that you could achieve if your system would be optimized for only one operating system instead of multiple ones. \n\nlastly scalability vs robustness, where you trade larger amounts of users at a time for a smaller amount, but the system stays stable and reliable to use for every current user over having a lot of users with long loading times, potential errors or crashes of the system. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1348052,
      "meta": {},
      "text": "Design goals often conflict with each other. For example there is a conflict between the goals of Client,  End User and  Developer or there are conflicts between the goals within one of thise groups.\n\nFunctionality vs Usability: End User want as much functuonality but at the same time an easy to use system. this is mostly not possible because the more functinalities the more complex our system gets. For example an shopping app. user want to see only cloths that fit his needs but he also want to start shopping as fast as possible and not set alot of filter. Need to find the right way between those two goals. E.g ask for the most important filter: type of cloth (Pants, tops...)\n\nCost vs Robustness: Client wants to have system cheapest possible, End User wants  lot of robustness. But robustness needs time to code, lot of knoledge.... This need money. Forr the shopping example the company want to pay as less as possible for the programm. The User want to have a system that is workling and not an app that is throwing a lot of errors druing the process (e.g. the website is linked to an not existing site or  paying process is not working and always crashing)\n\nRapid development vs Functionality: Client who want it ready to publish fast and end user who want many functionalities. Using again the shopping app example the company want to start selling fast in order to make profit but the end user wont use the app if there arent the needed functionalities. we again need to find the right way in the middle. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349177,
      "meta": {},
      "text": "Functionality vs. Usability:\nFahrzeuge werden immer digitaler. Es werden die bisher vorhandenen Knöpfe zusammengefasst und über ein großes Display wiedergegeben. Hier läuft man auf Gefahr, dass wichtige und oft benutzte Funktionen schwieriger aufzurufen sind, da man in einem schlechten Fall sich durch mehrere Untermenüs durchklicken muss und somit die Aufgaben, die man vorher schnell über einem Knopf erledigen konnte (Bsp. Lautstärkeregelung) nun zeitaufwändiger sind. Ein Ansatz wäre, dass man genau diese oft benutzten Funktionen entweder schnell ohne mehrere Untermenüs erreichbar programmiert, oder man diese wieder auf Knöpfe zuteilt. \n\nCost vs. Reusability: \nViele Cafés machen gerade den Umstieg von Pappbechern zu Getränken auf Tassen aus Glas, die mit Pfand wieder zurückgegeben werden können. Zwar ist dieser Schritt sowohl für den Cafébesitzer kostenaufwändiger - da er im Einkauf von diesen mehr bezahlen muss - als auch für die Kunden, die mehr für einen Kaffee oder etc. bezahlen müssen. Von Vorteil ist aber, dass diese Tassen deutlich häufiger verwendet werden können als die üblichen Becher, da Tassen erst mit dem Bruch unbenutzbar sind. \n\nRapid Development vs. Functionality: \nBei fast jedem Softwareauftrag kommt es zu der Frage, in welcher Zeit das Projekt fertig gestellt werden sollte. Für den Kunden ist es natürlich besser, wenn das finale Produkt so schnell wie möglich abgefertigt wird. Allerdings muss man bedenken, dass mit schnellerer Bearbeitung andere Bereiche eventuell daran leiden müssen. Ein Punkt wäre die Funktionalität. Falls das Produkt sehr schnell beendet werden muss, könnte es dazu führen, dass nicht alle Funktionen, die der Auftraggeber gefordert hat, implementiert werden können. \n",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1447581,
      "meta": {},
      "text": "1. Rapid development vs Robustness: most of the time the systems should be developed in no time or have a fixed time scedule in which the system should be done. Oten times developers are rushed or dont have enough time to fix each and every bug or issue within a system and there are probably always going to be errors or bugs within a system and there is never \"enough time\" to fix them all.\n2. Reuseability vs Runtime efficiency: Developers want to uses previous code or patterns or systems they know or made, because not only is it faster to implement but it might also be better documented or the behaviour might be well know. But old and well known systems/algorithms/code might not always be the most performant/effective/fastest. To make it as fast/reliable/good as possible you might have to addapt things even when using existing structures. But thus means that reuseability of the things you created might not always be given.\n3. Low cost vs. functionality: Its always in the clients interest to lower the cost of an system. this always contradicts or limits all other goals of the developer or the user. You could pick the functionality and say that with a given budget you can only make a limited amountor set of functionality into a system and can not make it the jack of all traids. (Technically you could but then other goals would be weakened e.g. # of errors)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1642110,
      "meta": {},
      "text": "Three typical design trade-offs in SE:\n* Functionality vs. usability: adding more functionality to product might not always be beneficial. It could overwhelm the user with functions which would make the software hard to use and hard to learn. \n* Backward compatibility vs. readability: those are two properties that really improve the quality of the code. However they don't go hand in hand together: The more readable the code is, the less backward compatible it is and vice versa. Thus you don't get benefit of both for free, you are forced to compromise and balance. \n* Cost vs. robustness: building a robust system requires a lot of testing and more development hours, which leads to much more costs. There is no escape from this trade-off and the only solution is finding an optimal balance.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292089,
      "meta": {},
      "text": "In software engineering, design goals often conflict with each other. For example, a client might prefer rapid development and low cost, developers usually prefer reusability and adaptability while end users value ease of learning and fault tolerance. To derive a feasible solution satisfying the goals of the client, developer and end user, software engineers have to incorporate certain trade-offs when designing their system. Three typical design goal trade-offs in the context of software engineering are \"cost vs. robustness\", \"efficiency vs. portability\" and \"rapid development vs. functionality\". \n\nThe first design goal trade-off \"cost vs. robustness\" typically leads to conflict between client and end user. In competitive markets, clients strive for the cheapest solution to minimize costs and achieve higher profits. End users on the other hand want to use a system that reliably copes with errors and faulty inputs. However, designing a robust system is resource-intensive, therefore leading to higher costs for the client.\nAnother design trade-off is \"efficiency vs. portability\". End users typically want a system to be both portable and efficient. Developers value portability, clients prefer efficiency, which they will have to discuss. Developers might argue that a portable product, while being less efficient, can be used in different system architectures. Clients want efficiency to ensure a swift runtime. \nFinally, \"rapid development vs. functionality\" is a trade-off between end users and clients. End users will want their product to work as intended, while clients want to achieve the earliest possible market entry through quick development time limiting functionality.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292580,
      "meta": {},
      "text": "Design goal tradeoffs are not only highly relevant in our lives, but also in software development.\nFirst I want to talk about Functionality and usability.  In software development, developers hope to add many new functions to a certain software, but when users actually use them, they often only care about the functions they want to use.  But when the feature squeeze prevents users from finding what they want, customers switch software.  For example, Alipay, a subsidiary of Alibaba, was initially designed with a Facebook-like feature for sharing pictures.  But in the end, Alipay choses to study only the payment method.\nSecondly I want to talk about Rapid development and functionality.  In the early stages of many software development, developers need to prioritize whether a software will be used for a long time or to be widely used in a short period of time.  At this time, it is necessary to choose some software applications.  Like the Corona-Warn app.  Because it is dealing with a sudden epidemic, it needs to be developed in a short period of time.  There are not many functions in this software, but it is only developed to detect whether users carry viruses.\nFinally, let me talk about Cost and reusability.  In software development, developers also need to consider the cost and whether users can still use the software.  When the software is not complicated and there is no need for subsequent use, the cost will be low. On the contrary, the cost will be high and the practicability will be high.  For example, in China's Wechatapp, there is also a small program for checking health codes due to the epidemic.  But it also includes functions to check local weather and news.  When the epidemic is over, users can also use this applet to watch news.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1299070,
      "meta": {},
      "text": "1. Design Goal Trade Off:\n\tRapid development vs minimum # of errors:\n\t\nIm Fall einer spontan auftretenden Marklücke starten oft mehrere Firmen gleichzeitig den Entwicklungsprozess um diese zu bedienen. Eine kurze Entwicklungszeit und damit ein schnellerer Markteintritt gegenüber der Konkurrenz ist somit entscheidend für den wirtschaftlichen Erfolg. Dem entgegen steht das Ziel der Fehlerminimierung, welche aufgrund der vielen Test und Nachbesserungen einen hohen Zeitaufwand fordert. Somit ist eine Abwägung mit Tradeoff zwischen den beiden Zielen zu finden. Beispiel hierfür sind verschiedene \"Coronapps\", welche kurz nach Beginn der Pandemie eine Kontaktnachverfolgung ermöglichten. Hierbei traten insbesondere in den ersten Versionen einige Fehler aufgrund der kurzen Entwicklungszeit auf.\n\n2. Design Goal Trade Off:\n\tImplementation as EDGE application or cloud service:\n\nEine Implementierung als Cloud Service hat den Vorteil, dass das Endgerät des Nutzers meist keine hohen Hardwareanforderungen erfüllen muss und Updates einfacher zentral eingespielt werden können. Gleichzeit können hohe Echtzeitanforderungen oft nur mit einer EDGE-Umsetzung realisiert werden. \nBeispiel hierfür die Auswertung der Sprache bei Sprachassistenten wie Siri oder Alexa. Da hier die neuronalen Netze sehr komplex sind, wird ein Hybridansatz mit Feature-Extraction on edge und höherweriger Auswertung in der Cloud gewählt.\n\n3. Design Goal Trade Off:\n\tBackward Compatibility vs LeanDesign:\nEine sehr weit in die Vergangenheit reichende Abwärtskompatibilität und Funktionsunterstützung für einige wenige Kunden hindert oftmals das effiziente Implementieren von neuen Designkonzepten. \nFalls ein automatisiertes Lagerverwaltungssystem beispielsweise sehr viele veraltete Schnittstellen bedienen können muss, welche stets an die neuesten Datenschutzverordnungen angepasst werden muss, bläht dies das System unnötig auf und erhöht zudem den Wartungsaufwand.\n\t",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1320266,
      "meta": {},
      "text": "Trade-offs:\n\n1. Rapid development vs. Functionality\nIf a system can be developed rapidly, the Functionality will be reduced and the functionalities could have only basic functionalities. Such as Bumpers. Bumpers does not have many functions. Many games today could be developed in such a rapidly way because they have the same functionalities (collect things and getting bigger and win the game).\nA game with many functionalities could usually be developed during years.\n\n2.  Efficiency vs. portability\nFavoring efficiency results in nonportable code, while selecting portability often results in software whose performance is unsatisfactory.\n\"Hardware\" will always be a problem. Any time a program takes advantage of special hardware capabilities, it becomes at once more efficient and less portable. If I write a game with Unity and it works like Cyber Punk 2077, but now my client want it to be more portability and want it on BlueJ. That might not work because I am using the Grafik Design from another software and its hard to port the whole thing in BlueJ.\n\n3.Cost vs. Robustness\nRobstness describes the ability of a system to maintain a function.\nIf a system has good robustness, the cost of it will not be low (because of the testing, developing an so on). A good software such as amazon with many functionalities must have a large developerteam and a large maintain team for their software- So it wont be much errors or failed builds when you want to buy something on amazon. Amazon will always check your information first before you send the order, to avoid any mistakes. But a small website will always have some errors if you are trying to upload a file which is not supported.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1345651,
      "meta": {},
      "text": "The three sides design goal trade-offs of software engineering are Client-, End-User-, and Development goals. \nThe customer wants his application to be ready as soon as possible, and as cheaply as possible. The end user wants an application that he can use intuitively and does not have to \"learn\" how it works.\nThe developer wants to take time to plan the project well and implement it as bug free as possible.\nThe goals of each party are usually in conflict, because a good implementation takes time and therefore costs more money. \nIf the developer does not have enough time, it is also not possible to code additional functionalities that improve the user experience.  \n\nThe customer wants his application to be ready as quickly as possible, and as cheaply as possible. The end user wants an application that he can use intuitively and does not have to \"learn\" how it works.\nThe developer wants to take time to plan the project well and implement it as bug free as possible.\nThe goals of each party are usually in conflict, because a good implementation takes time and therefore costs more money. \nIf the developer does not have enough time, it is also not possible to code additional functionalities that the users can use.\n",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1345928,
      "meta": {},
      "text": "sometimes established design goals can lead to an impasse: a situation will arise where one design goal must be sacrificed in order to achieve another. When problems of this nature present themselves, the developer team must make a trade-off, and decide which goal is more important.",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1422393,
      "meta": {},
      "text": "First of all, there would be functionality against usability. If you take Adobe Photoshop for instance, there are thousands of different functionalities, grouped in plenty of menus and hidden between each other. If you know how to use Photoshop, of course the functionality would be great, but in general the usability suffers under the mass of functions.\nFurthermore, there is cost versus robustness. Developing a highly secure and robust operating system like Windows is connected with very high costs. At the same moment, less robust software - for example little self-written projects - are often not that robust and vulnerable to attacks.\nLast but not least there is the trade-off between backward compatibility and readibility. When you decide to support older versions of for example operating systems, so your backward compatibility is quite high, you will often have to use different interfaces and commands for the older systems while using modern interfaces for the current versions. Your code would be longer and less readable for sure, because often you have to differ between different versions of the operating system.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1296541,
      "meta": {},
      "text": "1. One typical trade-off is the consideration between cost of development and the robustness of the system. E.g. if a bank wants software developers to develop a very robust system that does not fail or produce any lacks of security by crashing as a result of wrong user inputs. It is essential for the bank not to produce security lacks but it will cost the developers much more time to develop and also very important here, testing the program and simulating such situations. The more time it costs the developer the more money it will cost the bank to get the program developed.\n\n2. Another trade-off lies between the time of developing a program and its functionality. E.g. a startup in the mobility sector is in a fast growing stage of its evolution and needs new software in order to meet the ever growing amount of user inquiries. Now the developers must develop the program very fast but this of course comes at the cost of functionality because usually a program gets developed in multiple stages and iterations but in this case the time does not allow this so the startup must limit its requirements to a minimum.\n\n3. The last trade-off that is often times there is the consideration between functionality and usability. E.g. a pharmaceutical company needs a new software that controls and automates a new production plant where lots of functionality is needed. Here, of course the usability might get inconsistent at the beginning due to the high amount of functions the program contains. The usability will get better after a few more iterations of the product.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1298284,
      "meta": {},
      "text": "1. Cost vs. Robustness\nWährend der Client (TUM) möglichst wenig Geld bezahlen möchte für die Entwicklung der App, möchte der End User (Studenten) eine App haben, welche einwandfrei funktioniert und nicht abstürzt bei zu viel Belastung. Somit ist nach höheren Kapazitäten der Server gefragt, was mehr Geld kosten würde.\n2. Rapid development vs. Functionality \nWährend der Client (Windows) möglichst schnell die App auf den Markt bringen möchte und somit eine kurze Entwicklungszeit einplant, will der End User (Kunden) eine technisch raffinierte Software haben die sehr viele Funktionen hat und alles vorhanden ist, was gewünscht ist.\n3. Functionality vs. Usability\nDer End User (Student) möchte alle seine Vorlesungen und Tutorien auf einer Seite angezeigt bekommen, aber in einer geordneten Reihe. Es soll also benutzerfreundlich sein und nicht hart zu verstehen.",
      "score": 41.7,
      "language": "GERMAN"
    },
    {
      "id": 1319583,
      "meta": {},
      "text": "1. Functionality vs usability: In any design, though we are going to design as many as functions, but sometime, users only use a few functions available. \n eg: In Iphone, there are many functions, but sometimes users of iphones even don't know all of these functions.\n\n2. Cost vs robustness: There is a direct relationship between them. When we want to decrease the cost, robustness will be reduced and vice versa. \neg: If we hire a developer for low cost who is not much qualified, the robustness of the features of the system will be reduced.\n\n3. Cost vs reusability: There is a direct relationship between them. When we want to decrease the cost, reusability also will be reduced and vice versa. \neg: If we model the association between two classes with one-to-one multiplicity, it has low cost tests, not very reusable, but when we want to move  from one-to-one multiplicity to a many-to-many multiplicity, additional coding and testing costs will be incurred. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1331188,
      "meta": {},
      "text": "1)Functionality vs Usability: An action game which is so detailed that just to hit a punch you need to press at least 3 buttons. This much functionality isn't required and just makes the game a pain to play.\n2)Efficiency v portability: Making a game run perfectly on one particular console/medium however the game runs really poorly on other platforms.\n3)Backward compatibility v readability: really backward compatible programs are unfortunately hard to read and sometimes not that efficient. A game which could run on windows vista will be most likely really hard to understand as pure code.",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1334404,
      "meta": {},
      "text": "Low Cost v Functionality/Usability: \nSimple, you cant have everything in your software you could possibly want and simultaneously have it cost next to nothing to produce/maintain. Every feature you want can increase cost significantly (depending on the feature). So... choose wisely.\n\nPortability v Runtime Efficiency:\nYou have to invest development time if you want the software to run on all systems, which might leave optimization for specific systems in the dust. A good example I know would be Cyberpunk 2077. Had they not ported it to PS4/XBox One it could have run much better on PS5/XBox Series X (since they would have had more time to optimize these versions over porting the game). What we got is... Well, the launch version of Cyberpunk 2077. \n\nRapid Development v Robustness:\nTesting code takes time. Runtime testing takes time. Quality control takes time.\nI should know.\nAnd there are dozens of examples of software that falls to this... tight deadlines, no time to fix or even detect bugs/errors/faults, which has them unhandled when the end user gets the product.\nAgain with the games, but many AAA games especially launch with basically game-breaking bugs or balance issues nowadays, a common reason for this being; Christmas. And that publishers dont want to miss the X-mas market, thus shortening deadlines which leads to these issues. (Not to say all AAA games are \"bad\" in that regard.)",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1340417,
      "meta": {},
      "text": "1.Rapid development vs. functionality.For example, the corona testing center is in urgent need of a software that can record the test results of the tested person. For the testing center, it is more important to be able to put it into use immediately than to have a sound software function. When designing the system, the core requirement of \"recording data\" needs to be placed in the first place. The rest of the functions will be improved according to time\n2.Functionality vs. usability.A game raised the requirement for users to be able to control their own game background music. If the designer has both \"control the volume of the left audio\" and \"control the volume of the right audio\" in the system design, it will be complicated and inconvenient to use, and can be replaced by \"control the overall volume\".\n3.Cost vs. reusability.A company needs to design multiple pieces of software with some similar functionality, and if each piece of software is designed and implemented individually, each piece of software doesn't need to cost a lot. But if the similar functions are designed together, it will cost some money, but at the same time save the design time of each software with the function, and the company needs to make a decision.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1345872,
      "meta": {},
      "text": "Functionality vs. efficiency\nThe client's request should be handled completely and correctly as demanded, but they should also be processed quickly and efficiently, which does not always go hand in hand. For example if the client requests the exact result of the factorial of a large number in a mathematical system, the efficiency is compromised.\n\nRapid development vs. functionality\nDeveloping a project quickly can sometimes affect the fulfilment of all the functionalities. For example a project may have a due date, however not all the functionality can be fulfilled in the given time, so we have to decide between on time but not complete or complete but late.\n\nMinimum numbers of errors vs. Rapid development\nThe client usually wants their product to be developed quickly, but this can clash with achieving a minimum numbers of errors. For instance the developers do not have enough time to test the product or they can be stressed about the deadline.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1412070,
      "meta": {},
      "text": "Rapid development vs. functionality: The app was produced in under 4 months, but had to release it with some functions missing.\n\nCost vs. robustness: The app exceeded the budget of 50k Euros by 20k Euros, but the app can now handle 4 times as much user interactions at the same time.\n\nFunctionality vs. usability: this photoediting app has over 700 different filters and many many more features, but they are listed in a big list, the user cannot see what each filter does so he has to try everything out.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1522363,
      "meta": {},
      "text": "1. rapid developement vs. minimum amount of errors\nThe clients wish to keep the developement time as short as possible and the developers goal to avoid errors conflict each other. Putting focus on the rapid developement leads to less precision of the developers in order to be able to deliver the required system until the deadline. On the other hand, in order to keep the amount of errors low, more time is needed so the developers can work precise and avoid errors.\n\n2. User-friendliness vs. functionality\nAnother example is the users expectation of the software to be user-friendly and functional at the same time. \nPutting the focus on the functionality of the system, there will be a big amount of functions for the user which also have to be placed in the user interface of the system. A high amount of functions could lead to a cluttered and confusing user interface. This is a problem considering the design goal of the system to be user-friendly. The big amount of functions the system offers could lead to confusion of the user, make the system less comprehensible and hard to interact with because it takes more time and effort of the user in order to find a specific function than it would take in a less functional system.\n\n3. Robustness vs. rapid developement\nThe robustness of a system can be achieved an increased by proper testing in the developement phase. When keeping the developement time short, the developers have less time for testing because the main goal is creating and providing the required system to the client until the deadline. If the developers have less time for  testing their software, some important test cases may be missed, which results in less robustness of the system. The other way round, in order to make the system robust, it takes more time to think about important test cases, testing the software and if necessary adapt the software. This results in a longer developement time.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1583738,
      "meta": {},
      "text": "If a development team is forced to find a middle way between various opposing aspects, many bugs and flaws are bound to happen: Let's take a look at the video game \"Cyberpunk 2077\". It was released on 10 December 2020 on Windows, PS4, XBOX One and Google Stadia. Next-gen console releases followed later. Directly upon release, several major flaws on the console versions have been found: The game was lagging a lot with severe drops in frame rate. This was so much of an issue that the game even got temporarily removed from the PlayStation store, while the devolping studio, CD Projekt Red, tried to fix the issues. This wouldn't have happened in the first place, if there wouln't have been this jarring conflict between rapid development (client's interest) and minimum amount of errors (developer's interest), i.e. if the release date for the consoles would have been postponed.\nAnother conflict of interest is the one between reusability (developer's interest) and usability (end user interest): Many German universities have developed their application websites using the same software/framework. Thus, the different requirements (no mail-in documents needed, some documents needed, in-person enrollment required etc.) are very poorly reflected in the standard user interface, which makes the entire software very unintuitive. Completely new implementations for every university (like at TUM) are preferrable.\nThere's also a stark difference between ease of use (end user's preference) and well-defined interfaces (developers preference): A great example for this is Apple's 3D Touch. It offered an innovative way of \"secondary clicks\" by applying more pressure on iPhone screens, hence offering the developers an entirely new way of user input. But it was quite hard to discover for most everyday users, so the feature was deprecated by Apple on hardware and software level.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1606657,
      "meta": {},
      "text": "1. TUM wants to develop a new university app and wants to make it as reliable as possible. However, as they have only a budget of a few thousand € the app has to be developed by students because they are very cheap. As students still have to learn a lot, they make many mistakes in the development process and it is not uncommon for the newly developed app to crash very often e.g. being very unreliable.\n\n2. Remedy is a ticket management platform with almost unlimited use cases and huge functionality. On the contrary however the user interface is a cluttered mess and the average user would just be lost without a week long course on all functions and buttons. Here I am speaking of the trade off between usability and functionality.\n\n3. The new DKB app got developed very fast as they were losing a lot of ground to their competitors which had apps with much better usability compared to the old DKB app. This rapid development however meant, that many functionalities of the old app were missing for quite a while as it needed several iterations to finally have a product with almost all functionality of the old app.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1629811,
      "meta": {},
      "text": "Effeciency vs. portability:\n\nEfficiency: Wenn ein Produkt nur langsam auf Benutzereingaben reagiert oder keine effizienten Problemlösungen ermöglicht, muss es durch ein besseres Produkt ersetzt werden. \n\nPortability: Es sollte möglich sein, das System  auf mehreren Plattformen einzusetzen. Wenn nötig, auch leicht auf eine neue Architektur übertragen werden können.\n\nReusabilty vs. Cost: \n\nReusabilty: Die einzelnen Teile des System sollten so erstellt werden, dass wie theoretisch auf ein anderes System. übertragen werden. können, wenn die gleichen Funktionen benötigt werden. Das heißt, eine Wiederverwendung sollte möglich sein. \n\nCost: Doch wie viel Geld will man für so ein System überhaupt ausgeben? Meistens hat man. ein beschränktes Budget, welches spezifisch für. ein Projekt ist. Solche wiederverwendbaren Systeme erfordern mehr Geld. Ist man bereit so viel auszugeben? oder denkt man sich umso günstiger, desto besser?\n\nRapid development vs. Functionality:\n\nRapid development: Man hat eine bestimmte Deadline gegeben. Das heißt, das System sollte bis dahin so gut es geht vervollständigt sein. \n\nFunctionality: Das System soll genau das wiedergeben, was vom Client erwünscht ist. ALLE Funktionen sollen problemlos laufen, sodass man sich auf dein neu entwickeltes Projekt auch wirklich stützen kann. Problem ist: will schafft man es in der gegebenen Zeit ein. perfekt funktionsfähiges Projekt zu entwickeln?",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1291557,
      "meta": {},
      "text": "First typical trade-off is “functionality against usability”. We have to decide whether we want to have many various detailed buttons, functions or settings in our application to get the most accurate results or if we want it to keep it simple, much less precise but reduce the risk of an over-cluttered app that is hard to navigate through.\n\nOther design trade-off is “cost vs reusability”. Client usually wishes to keep the budget as low as possible – that would mean a quick production of a code that is probably only going to be usable in that product. On the other hand, we could create a more universal, reusable code, a framework, which we could use on multiple projects. Developing it though will take a lot of planning and time, hence it is going to be more costly.\n\nLastly, efficiency vs portability. The dilemma lies in the issue that if we want to have the most efficient program possible, we should work as close to the computer hardware as possible to get the best results from that certain architecture. But the problem is going to be that such programme is not going to be portable and usable on a different system, e. g. working on Linux distribution vs Windows vs macOS … and various mobile devices.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291875,
      "meta": {},
      "text": "1. functionality vs. usability\nA big tradeoff in design goals is balancing functionality against usability. In this case, you have to decide whether you want a lot of features and capabilities in your product, or whether you want the product to have a good user experience. Often this is a contradiction, as more complex features degrade usability and, for example, you need more clicks to perform a task. For example, the user interface of Amazon prime video offers many functions to watch movies/series, whereas the usability suffers from it and everything is sometimes very buggy.\n\n2. cost vs. reusability\nAnother trade-off is cost and reusability. You can often reuse code in multiple projects in the form of libraries. This helps save costs and time, and is sufficient in most cases. However, this also limits the product, since it depends on the library. But if you create a new template only for a specific product, then it is definitely more expensive at first, but you have no limits and dependencies.\n\n3. rapid develompent vs functionality\nA third tradeoff is rapid development versus functionality. Often extensive functionality is complicated and requires a lot of time to implement and deliver. This leads to a slowdown in development. So it is important to balance functionality and development time. This is also related to the first trade-off. For example, the dark mode of Artemis is an additional feature of the platform, which was not implemented in the rapid development, because other functions were in the foreground and these were weighed against each other.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1297828,
      "meta": {},
      "text": "Trade-off 1: Cost vs. robustness\nThe possibility for a design trade-off between cost and robustness is often pretty obivious as a higher robustness, be it higher fault tolerance, more detailed processes for every scenario, stronger of more hardware resources or improved data security usually comes with additional cost for software development, mainteance or physical hardware. If for example used data should always be available and correctly stored, additional hardware database as well as a software that manages the data flow between available databases have to be implemented.\nTrade-off 2: Rapid development vs. functionality\nIt makes sense, that the more functionalities/features have to be developed and the more complex each of them is, the higher the complexity of the whole system, their interfaces and connections and therefore the longer the source code, making the development time in turn longer. If for example a SAP system needs only one interface to the production management system, it takes way less time to connect the two. If a connection is also needed, to sales data, HR data and several more interfaces, the interface/system design takes much longer\nTrade-off 3: Functionality vs. usability\nThe more features a system uses, the harder it is for a user to navigate in the user interface. If a game for example can be played by only tilting your phone it is pretty easy to use and fast to learn. On the other hand, a game on a computer that uses the input of a keyboard and mouse that is each translated into different outcomes is much harder to learn and understand to use correctly ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1314390,
      "meta": {},
      "text": "Rapid development vs. functionality:\n- The client requests a software, which must be ready in about 2 months. This produces a really thight scedule for the software engeneering team and important phases like intensive testing may come short, which could possibly lead to a programm lacking functionality.\n\nCost vs. reusability:\n- A client has the option between two companys who both made an offer to code their programm. The price differs a lot, but the one company is known to produce working products, which fullfill all the requirements, but some bugs could sometimes creep into the code. The other company's price is largely bigger, but always delivers programms without any issues and which can adapt to any difficulties. Which one does the client choose?\n\nFunctionality vs. usability:\n- The most important requirement for end users of a programm is to intuitivly navigate to any function, which they might need to acces. When he always needs to search everywhere and wastes a lot of time on this, he might be dissapointed. On the other hand, when you lower the amount of functions the programm has, the end user may be dissapointed the programm doesn't have this or that feature. \n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344298,
      "meta": {},
      "text": "The most central design goal trade off would be cost <-> anything. If you try to keep the cost as low as possible, you will have to be satisfied with less functionality, less robustness, less usability, and so on. This is because any development costs time and money. For example if you hire a software developer to create a mobile game in one week, because that is all that's possible with your budget, you have to limit all the other requirements. It will be less functional, usable and secure.\n\nIf you try to make software very efficient, it will be less portable. A great example for that would be the current development in the phone and electronics market. Apple's M1 Chip, Googles Tensor Chip and Samsung's Exynos chip, all of them develop their own processor for their own devices to make the battery last longer, run smoother and increase security. Obviously the portability is limited by their own devices. The Snapdragon chipset, which most of these companies used before, was the most portable and powerful processor before, but lack of customization limited the software the companies developed for their devices.\n\nThe more functionality you include in your software system, the less usable it gets. It will clutter all your GUI menus and the way the user interacts with them. If they have to read through 30 buttons when trying to change an audio setting in a mobile game, they will get annoyed and will probably delete the game.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344606,
      "meta": {},
      "text": "Funtcionality vs Usability\n\nIf a game for example has to be as smooth as possible in terms of usability this could limit its functionality. For example, if the usability design goal requires a game to be able to be started using only a certain number of clicks, this also impacts the functionality of the game as the menu cannot display options that would require the user to use more than three clicks.\n\n\nCost vs. Robustness\n\nA game in terms of robustness should not be able to be hacked o tampered with easily. In general, this would mean that the game has to be bug tested continously and be next to perfect. This would lead to enhanced costs since the development of the program has to include a perfect system design in terms of security.\n\nRapid Development vs Functionality\n\nWhen a team designs a specific game and is under time pressure this trade off happens. For example, Cyberpunk 2077 was released with core functionalities instead of all the features that were promised. The developers had to focus on the rapid development to meet the deadline and therefore had to cut on functionality.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344725,
      "meta": {},
      "text": "• Functionality vs usability\nIt is possible that supporting more functions may lead to the product being harder to use by the user. Requiring from the user to learn what a lot of commands or buttons do makes it harder for them to complete tasks. For example, a booking site/program that has different search bars for searching through destinations, hotels or rooms for renting might provide better search results but is hard to use.\n\n• Rapid Development vs Functionality\nRapid development might lead to less functionality of the product. Spending less time means that some functions cannot be implemented in the given time period. For example, it might be possible to develop a booking app that supports only booking hotels in order to ship it sooner or to spend additional time to make it possible for it to recommend restaurants and activities based on the chosen hotel and travellers reviews.\n\n• Cost vs reusability \nBuilding a project which costs less might lead to the code being unusable for the building of another project. Spending more resources on it can lead to it having better quality and being reusable. For example, it is possible to reuse a well done UI while changing just a few things of its design.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1400415,
      "meta": {},
      "text": "Backward compatibility vs. readability:\nIf you opt for backward compatibility you have to support deprecated and nearly unused features which still need to be in the sourcecode and accounted for when working on other parts of the project. Lets take a tax software as an example. The customers used to upload all their sales as an CSV file. However, a new feature enables them to link their sales software with the tax software. If now the calculation in the tax software changes this needs to be adjusted in both the CSV upload as well as the extension, making the code convoluted.\n\nFunctionality vs. usability:\nSomething is usable if and only if you have a limited number of options and if the consequences of these options are easily understood. This goes against having a great number of functions in your app. Lets take \"tradingdesk\" as an example. This trading software is functional displaying tons of information and letting you do virtually anything. However, it will takes time to learn because the UI is extremely cluttered and hard to understand with many options being similar to each other.\n\nRapid development vs. functionality:\nIn software development if you want to have your product fast the amount of functionality implemented will suffer from it. Take a travel agent website as an example. If a development team has a 2 week deadline for this website they will only be able to implement the basis and most important features like booking your tour online. However, additional fancy functionality like being able to reserve your plane/coach seat in a UI or previewing the hotel won't be added because there is not enough time.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1405325,
      "meta": {},
      "text": "The first trade-off is functionality and usability. Let's say you are coding an online calculator. Either it's very usable with a few buttons like 0-9 and +;-; etc. or you can add many more buttons for further functionality like sin() cos() etc. These additions would make the calculator more functional but less usable for the average user.\nThe second trade-off is cost and robustness. \n\n\n\n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1437285,
      "meta": {},
      "text": "A design goal trade-off describes goals that conflict with each other.\nIn software engineering there are three view that have to be combined. The clients view and their goal, the end users view and the developers view. With three different goals and opinions it is hard to find one solution that works for all of them.\nA typical design trade-off is for example \"Functionality vs. Usability\". The developers may try to include as many functions as possible which makes the system more complex which leads to a harder usability for the end user.\nAnother trade-off could be \"Cost vs. Robustness\" which means that the client does not want to pay a lot for the software which leads to a vulnerable system.\nThe third example for a design trade-off is \"Rapid development vs. Functionality\". The client wants the system to be done within a certain time frame which is possible for the developers but they are not able to include special functions which leads to less functionality for the end user.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1441827,
      "meta": {},
      "text": "Rapid development vs functionality:\n\tTo implement a large number of features takes a lot of time. A rapidly developed system will almost always \n\tonly have the bare minimum of functionality. For example a booking service developed in a few days\n\twill most likely not have comfy features.\n\nCost vs. robustness:\n\tKeeping a system up and running constantly is by itself very expensive. For example to run any application\n\tthat runs on a server constantly there are server costs, maintainance costs, server space costs, energy costs...\n\nEfficiency vs portability:\n\tIn order to make an application as efficient as possible it has to be developed specificly for certain hardware.\n\tFor example a game that should run on any system certain compatability layers need to be implemented.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1503397,
      "meta": {},
      "text": "Functionality vs. Usability --> \nA system loses functionality the more it focuses on the user interface for example due to the simplification, functionality gets lost or all the effort that goes into the interface costs and runtime will increase and therefore other areas of the system will lack resources.\n\nCosts vs. Robustness-->\nThe more effort and costs are put in for example a code the more it can be assured that the code will be more robust so be less likely to have errors in it that cause it to fail in extreme cases. However, by assuring that all the code is robust so it is safe from intruders and that it will not fail in extreme cases to more it will cost as it will take more time to cover all the edge cases and there needs to be intense testing to assure that the code is robust which will increase the costs.\n\nCosts vs Reusability-->\nYou either have simple code, that is simple to write and cheap or code that is reusable. This is because if you take time and resources (costs9 into a code it can be used to cover multiple purposes and be reused by many functionalities, however, it is not simple and not cheap. It would also cost a lot of testing as it is an important part of the code as it covers multiple functionalities also increasing the cost. A cheap and simple code doesn`t cover a lot of functions and therefore doesn't need much or any testing, however, it is therefore only used for 1 functionality and not many.\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1633662,
      "meta": {},
      "text": "There can be a trade-off between how productive the system is (how high the throughput is) and the goal to minimize errors, for example in a banking system that should be available for many clients at the same time, if there are many processes running at the same, maybe also in different threads, it's more likely that errors occur because the  processes interfere with each other, which could be problematic because of data confidentiality of customers.\nIf there is high fault tolerance in a system, it could be a trade-off with the runtime of programs because they become more complex when checking for wrong input and handling it. For example, if users register on a website and have to enter their address, the input from the users is maybe not in the format the website expected and if the fault tolerance is higher, instead of telling the user that the input is wrong, it has to be more detailed when analyzing the input which could be more time-consuming.\nWhen there are many functionalities, there could be a trade-off with how easy it is to adapt the system to changes. For example, if on a social media app there are many different possibilities for how a user can interact with another profile (like sending reactions to posts or leaving comments), it's more effort to make all of them work when features like status updates, profile description or stories of profiles are changed or moved to a different part on the app.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292855,
      "meta": {},
      "text": "Functionality vs. usability:\nIf a software has too many functions, the GUI of the software can be a mess or very complex, which decrease the usability. For example, a user want to book a ticket for a concert. He gets the \"search\" page, which are full of options: searching by key words, artists, date, city, genre...... It'll cost a little time to find out the wanted option for him. It'll be easier, if there're only 1-2 options,.  However, if all functions can be known at a glance, which is positiv for usability, these functions must be only basic functions considering the convenience of using and the software is not very intelligent.\n\nCost vs. robustness\nFor robustness we need to focus on handling unexpected termination and unexpected actions. For example: A company can find those exceptions out by hiring a department of people to think out ways creatively to make the software break down and then IT-department optimizes the code to prevent the app from this exceptions or fix them. Hiring people certainly increases the development costs.\n\nRapid development vs. functionality:\nExample: I completed L04E02's code in 10 minutes and pushed it to Artemis. I passed only 5 of 12 tests with 7 issues. Then I spent 5 more minutes to find out where the problems were and improved my code. I passed all tests this time but with 4 issues. I worked on it again to fix the issues, in 5 minutes. To make my code perfect, I spent 20 minutes but I'd already passed all tests in 15 minutes.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1297885,
      "meta": {},
      "text": "Functionality vs. usability\n- A system might offer a high functionality, i.e. it offers a lot of different functions to the user that the system can perform. However, even though the resulting system might be highly functional there can be negative influences on the systems usability. For example, if TUMOnline would display all its individual functions (and perhaps even some additional not often used functions) as a list after logging in, it would be highly functional but not very usable. Only when mapping these individual functions into specific categories the system maintains a level of acceptable usability. \n\ncost vs. robustness\n- During development of a system that requires user input a development team can spend a certain amount of hours on identifying as many wrong user inputs as possible and implement a corresponding response behavior, which increases robustness. However, as every development hour leads to additional costs increasing robustness comes with a price.\n\ncost vs. reusability\n- Likewise a development team can spend a certain amount of hours on analysing the system and identifying parts of the future software systems that can be reused within the system or can even be reused for additions to the system in the future. However, this takes more time and therefore costs more than just implementing a solution to the specific problem of the current development effort and not caring about reusability. \n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344365,
      "meta": {},
      "text": "Low cost <-->(Code) Modifiability/Readability/Good documentation:\nFür den Client ist es meist wünschenswert möglichst geringe Kosten zu haben. Da Zeit aufgrund monatlicher Gehälter ziemlich teuer ist, wird Entwicklern meist ein begrenztes Maß dieser für die Entwicklung einzelner Features gegeben. Dies führt nicht selten dazu, dass der Code schlechter wird und damit weniger lesbar und somit auch schlechter modifizierbar. Auch die Dokumentation des Codes kann in solchen Momenten manchmal auf der Strecke bleiben.\nBeispiel: Firma Ziemens möchte ein neues Waschmaschinenprogramm entwickeln lassen. Die monatlichen Kosten für ein Entwicklerteam betragen 45.000€. Mehr als 100.000€ möchte Ziemens nicht ausgeben. Daher bleiben dem Team nur rund 2 Monate Zeit. Dies führt zu einer weniger ausführlichen Planung der Software, es bleibt weniger Zeit um über einzelne Features nachzudenken, die Dokumentation von nur intern verwendetem Code lässt das Team komplett sein.\n\nUser-friendliness/Simplicity <--> Efficiency/Functionality:\nFür neueinsteigende Enduser ist es meist angenehmer ein sehr simples UI zu haben, das mit zunächst nur wenigen Features ausgestattet ist. Zu viele Buttons und zu viel Text verwirrt oft. Dies führt aber dazu, dass die Anzahl an Funktionen begrenzt ist und weiterführende Funktionalität hinter Optionen wie \"Erweiterte Einstellungen\" versteckt werden muss - was wiederum die Effizienz verringert.\nBeispiel: Badobe möchte ein neues Designtool zum Zeichnen von Bildern mit digitalem Stift entwickeln. Dabei soll es viele nützliche Features geben. z.B. soll man schnell die Stiftdicke und das Stiftmuster ändern können. Die Anwendung zahlreicher (einstellbarer) Filter uvm. soll ebenfalls unterstützt werden. All diese Features sollen nun in einem einfachen und übersichtlichem UI zusammengefasst werden. Badobes Entwicklerteam einigt sich darauf stark verschachtelte Menüs zu entwickeln, ist sich dabei aber bewusst, dass dadurch die Effizienz leidet.\n\nBackward compatibilty <--> Adaptablity/Flexibility/Performance:\nFür viele Clients ist es von Vorteil, wenn ein Produkt rückwärtskompatibel ist, da dadurch nicht ständig neue teure (Software-/Hardware-)Systeme erworben werden müssen. Dadurch ist der Entwickler jedoch meist in der Entwicklung eines Produktes weniger frei. Er ist an das Interface des alten Systems gebunden.\nBeispiel: Die Firma Mindows möchte ein tolles neues OS entwickeln, das vollkommen des Darkmode unterstützt aber gleichzeitig Rückwärtskompatibilität bietet. Alte Legacy Programme bieten dafür jedoch eigentlich keine Schnittstelle, weshalb zusätzlicher (wenig performanter) Code von Nöten ist.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344455,
      "meta": {},
      "text": "Functionality vs. usability:\nA website that when opened displays the weather at the position where the user is currently at is very good usability. There is no way for the user to interact with the application in any complicated way and can see all information at first glance. However this website has very little functionality. E.g. the user has no way to see the weather anywhere else. However adding options for users to search for locations to look at the weather there makes the app harder to use as the user now needs to understand more about the application to be able to use it correctly. In this case more functionality leads to worse usability.\n\nEfficiency vs portability:\nWhen writing a software application (e.g. a compiler) for only a single computer architecture one can make use of very platform specific tricks to make the application run faster and smoother as certain things work a lot faster on some architectures than others. However using these platform specific speedups prevents the application from being portable to other platforms as the used tricks might not be possible on other platforms.\n\nCost vs. reliability\nWhen running a web application with a server backend if the app is only run on a single server if the server fails for any reason the whole website will be down. However, to run a server costs money so adding redundancy by running the server-side application on many servers (that can deal with single servers failing) increases the cost while the website is running (both server hardware and electricity cost money). Therefore having this extra amount of reliability adds to the cost of the system.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1345954,
      "meta": {},
      "text": "1.Usability vs Functionality : \nUsability means that users can use that interface easily. Functionality is the range of functions can be run on that interface. Users always want to have a user-friendly interface, for example, when man's going to a website, he wants it to be simple, beautifully designed with only few buttons, doesn't need to authenticate himself twice, etc. However with regard to functionality side, the website itself should be secured enough that it requires authentication from users, it must support different types of paying choices if it's a online market site and must link to others website as well. \n\n2.Cost vs Robustness \nCustomers don't want to spend too much money on creating, designing and maintaining a products and as long as their product works it's fine. However end users want the product they gets to runs smoothly, without being easily or too often crushed down, regularly getting maintained and updates. \nEg : A university wants a simple website for their students to use and get updates about modules and lectures etc. However the board doesn't want to spend too much money on that because they dont really make any profit from that website. There are always more students using it and the website needs frequent maintenance. Students as users want to have a stable website, which is accessible at all time and not often crushed down. \n\n3.Rapid development and functionality \nCustomers want their products to be rapidly developed and updated to save costs. However on functionality side it must be safe and secured, running stably and should not be constantly changing. \n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1365418,
      "meta": {},
      "text": "-Backward Compatibility vs. Readability\n\nBackward compatibility refers to a design that complies with previous versions of itself. This usually means that it can use the same data and equipment in a seamless manner. An example of backward compatibility is a mobile device that can display old image formats.\n\nThe ease with which software may be read and understood is known as readability. Making software more readable benefits its review and maintenance over its lifetime. An example of readability can be writing what each method does\n\n-Functionality vs. Usability\n\nUsability is the ease of use of an interface. A usability example is how easy it is to drive a car.\n\nFunctionality is the set of operations that an interface support. A functionality example is the operational and safety features a car has. \n\n-Cost vs. Reusability\n\nIn software engineering, cost estimation is primarily concerned with the expenses of the effort to develop and test the software; however, it can also involve requirements review, maintenance, training, and the purchase of additional equipment, servers, and software. For example, new expectations from the client can cause more costs. \n\nThe predicted reuse potential of a software component is referred to as software reusability. Software reuse not only improves productivity but also improves the quality and maintainability of software products. As a reusability example, we can say the reuse of existing code in order to develop a new function or software model. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1457713,
      "meta": {},
      "text": "1. Funktionalität vs. Nutzerfreundlichkeit:\n\tDie Fotobearbeitungssoftware Gimp hat zum Beispiel  mindestens genauso viele/ mehr Funktionen als \t \n        andere beliebte Programme wie Fotoshop . Doch die Navigation zu den jeweiligen Funktionen ist vor allem \n        für Anfänger sehr schwierig, verwirrend und nicht intuitiv.\n2. Funktionalität vs. schnelle Entwicklung:\n\tViele Computerspiele, die in letzter Zeit released werden, sind bei Herrausgabe meist nur teilweise fertig und \t\t \n        in den schlimmsten Fällen wie Cyberpunk oft nicht richtig spielbar. Dabei müssen die Entwickler oft sehr \n        strickte Deadlines einhalten und das Spiel zu einem festen zu bestimmten Erscheinungsdatum rausbringen.\n\tDurch kurzfristige Änderung des Spiels und einhalten der Deadlines werden Spiele dann oft in einer sehr\t\t \n       abgespeckten Version released.\n3. Kosten vs. Skalierbarkeit:\n\tDesweiteren werden viele Computerspiele vor Release beworben und müssen sich vor allem beim Launch auf \n        große Spielerzahlen vorbereiten, doch eine solche Skalierbarkeit der Spielerzahlen vernachlässigen viele \n       Entwickler, wodurch dann die Server überlastet sind und kein spielen mehr möglich ist\n",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1472438,
      "meta": {},
      "text": "1) Functionality vs. usability\nBumper: Die Funktionalität und Steuerung sind sehr simpel gehalten. Es geht zum einen darum sich nicht von einem der Computergesteuerten Fahrzeuge treffen zu lassen und zum anderen die Kollision zu gewinnen. Hierfür braucht es auch nur die einfache Steuerung mit der Maus. Würde man nun beispielsweise dem Nutzer die Möglichkeit geben aus 20 verschiedenen Fahrzeugen, mit 20 verschiedenen Waffen, 20 verschiedenen Skins etc. zu wählen, wäre das für den eigentlichen Zweck des Spiels viel zu übertrieben und nicht sinnvoll. Auf der anderen Seite wäre es nicht sinnvoll, eine komplexe Steuerung über bspw. die Tastatur zur ermöglichen, da dies die Nutzerfreundlichkeit reduziert.\n\n2) Backward compatibility vs. readability\nDie Xbox hat mit Ihrer neusten Konsole auch die Möglichkeit geschaffen alle alten Spiele der vorherigen Konsolen spielen zu können und dafür auch Software umgeschrieben um diese alten Spiele für die Konsole lesbar zu machen. Das aber nur als Beispiel. Was würde es bringen, ein Tool für seine Plattform (in diesem Beispiel die Xbox) zu schreiben, damit die Spiele der Entwickler von den Konsolen vorheriger Generationen auf den neueren laufen, wenn der Code für eben selbige Entwickler zu komplex und unverständlich ist. Man möchte ja eben möglichst viele alte Spieletitel anbieten können, um die Kunden der vorherigen Generation auch für die neue zu begeistern. Damit die Entwickler das ohne großen Kostenmehraufwand tun können, muss eben dieser Code einfach zu verstehen sein. \n\n3) Efficiency vs. portability\nEine Programm zum Aktienhandeln sollte möglichst schnell und effizient arbeiten, damit der Nutzer präzise Entscheidungen treffen kann. Ein solche Programm darf also nicht ewig laden, weil sonst dem Nutzer echtes Geld verloren gehen könnte. Muss aber auf der anderen Seite auch so entwickelt werden, dass auf möglichst verschiedenen technischen Ebenen läuft. Wenn der Nutzer die Sofware braucht, sollte sie so verfügbar sein, dass es verschiedenste Möglichkeiten gibt darauf zuzugreifen.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1656692,
      "meta": {},
      "text": "1. Functionality vs. usability: \nAdobe photoshop is supposed to offer a high number of functionalities for photo editing, which has implications on the usability. The program is often perceived as too complicated by new users. However, it offers all needed functionalities for professional photoediting. \n\n2. Cost vs. robustness:\nDrivers assistance systems of car manufacturers should be developed at low cost on the one hand in order to become not too expensive so that no customers buy the systems. At the same time the systems need to be robust to a high number of edge cases in the traffic situations. This trade-off poses significant challenges to developers of driver assistance systems.\n\n\n3. Rapid development vs. functionality: \nA startup is developing a software solution (e.g. a SaaS for CRM) but has limited resources in the beginning. It aims to develop the system rapidly in order to outperform competitors and get fast results. But this limits the possible functionalities that can be implemented.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291899,
      "meta": {},
      "text": "One typical design goal trade-off is functionality vs. usability.\nThe problem here is that if you have a program with many functions, it is very hard to make it easy to use.\nThe more functionality you implement in a program, the harder it gets to make the program user-friendly and easy to use. For example, if you have a program with 200 functions that a user can use, you have to make a button for every function, and then you have 200 buttons in your program, and it gets very unclear, and it is very hard for the user to find the correct button.\n\nAnother typical design goal trade-off is cost vs. reusability. If you make a low cost program that is only designed for one specific thing, it is hard to reuse this program for other problems. For example, if you make an online shop on low cost and hard code every picture, magic number or price the shop can't be used for another project easily because it would be very hard to re-code everything.\n\nThe third typical design goal trade-off is backward compatibility vs. readability. For example, if you have a program that should also work with older versions of the program you have to let the functions in your code that work with the old data structure, for example. This leads to very long (and unnecessary) code that is only used to ensure backward compatibility and not needed for the latest version of the program.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1313278,
      "meta": {},
      "text": "1. Functionality vs Usability -> CampusTUM is the platform for suscribing courses for the semester. The platform has multiple functions for applying different classes, seeing your grades and other important things, but its not very usable at the first sight because there are so many things you can do.\n\n2. Cost vs Robustness -> If you want to implement an software at low price you probably can't spend that much money on testing therefore the app is not likely to be robust against errors and bugs. If you spend much money you can fix many bugs via testing. \n\n3. Rapid development vs functionality -> Corona Warnapp was quickly implemented to protect people from covid cases in their area and letting them know they could be affected. Unfortunately the app didn't fullfill its potential because it was created to quick without considering important aspects such as bucks like wrong alarms.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1331259,
      "meta": {},
      "text": "1. Functionality vs. usability \nWhen you first look at a classical IDEA such as IntelliJ it can be overwhelming with all the functionalities. The functionality is great but it is not intuitive to use. \n\n2. Rapid development vs. functionality \nIf you have a close deadline at which your project has to be finished you don't focus on every single detail. Your main goal is to get the most important functionalities. If you would have had more time you would have included more functionalities. \n\n3. Cost vs. robustness \nIf you want your system to run for with almost 100% of the time you have to use multiple servers which adds additional cost but strengthens the robustness of your system. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1331761,
      "meta": {},
      "text": "Functionality vs. usability\nsteht oft in Konflikt wenn zu viel Funktionalität gefordert ist und in einem entsprechend begrenztes Interface untergebracht werden muss. Bietet ein System zu viele Funktionen kann es schnell unübersichtlich werden, wo die wichtigen Dinge die der Nutzer für sich in diesem Moment braucht/finden möchte zu finden sind. Jede Funktion muss ja aufrufbar sein oder der Nutzer muss damit meist zumindest interagieren können. Im Falle eines grafischen Interface sieht das aber nicht nur gequetscht aus sondern sorgt auch dafür dass nichts auffindbar ist da alles in Untermenüs oder an anderen Stellen aufgrund der Vielzahl untergebracht werden muss. Umgekehrt gilt also wenn man ein System besonders Nutzerfreundlich gestalten möchte muss es simpel und intuitiv sein. Dabei gilt es sich deshalb auf die wichtigsten Funktionen zu beschränken.\nBeispiel: Bei TUMOnline wurde Funktionalität über Nutzbarkeit gestellt, weshalb das Interface zumindest für wenig vertraute zu nächst sehr überwältigend wirken kann. Viele Unterseiten, viele Icons und Funktionen ohne nähere Erklärung. \nArtemis hingegen baut auf Nutzbarkeit und erlaubt es mir hingegen nicht einmal meine Kurse aus dem letzten Semester zu sehen solange ich dessen ID und URL nicht brute force um die Startseite übersichtlich zu halten.\n\nBackward compatibility vs. readability\nWenn man ältere Funktionen oder Schnittstellen beibehalten möchte bleibt meist der alte code oder zumindest aktuell eigentlich unnötiger code mit zurück im Projekt. Dies kann die Lesbarkeit des codes stark beeinflussen, da alter code dann meist verstreut über das ganze system zu finden ist und auch teils noch an neuere code Segmente anbindet was ebenso die Wartbarkeit erschwert. Möchte man folglich besonders lesbaren code, so sollte man Rückwärtskompatiblität und den damit verbundenen alten code in Grenzen halten. Ein guter Kompromiss auf beiden Seiten ist nicht abzulehnen, da oft ältere Funktionen auch schlicht weg noch nicht wegzudenken sind und weiterhin benötigt werden.\nBeispiel: Möchte man z.B. eine API Schnittstelle implementieren und daran im Nachhinein etwas ändern, ist das nur schwer möglich (besonders wenn keine Versionsnummer bei der Anfrage mitgeschickt wird), da sich nun andere Systeme auf das gegebene Format stützen. Findet man nun aber einen besseren Weg Anfragen zu formatieren oder aufzubauen der effizienter/übersichtlicher ist oder andere Vorteile bietet, so kann dieser (ausser man hat besondere Marktmacht, siehe Apple) nur hinzugefügt werden und der alte muss meist weiterhin beibehalten werden damit ältere Systeme weiterhin funktionieren. Dadurch kommt zusätzlicher Code hinzu der vermieden hätte werden können würde man den Support für den alten Weg direkt oder sehr zeitnah einstellen.\n\nEfficiency vs. portability\nMöchte ich einen Prozess/Funktion effizient gestalten so sollte diese meist einem Zweck folgen und diesen bestmöglich und mit so hoher Effizienz wie möglich ausführen. Wenn ich allerdings das ganze portabler gestalte und andere Arten der Verwendung mir offenhalte, so kann ich nicht auf einen Verwendungszweck optimieren sondern muss ein Mittelmaß finden, was alle gleichermaßen abdeckt und für alle Anwendungsfälle seinen Zweck einigermaßen effizient erfüllt.\nBeispiel: Sortierverfahren. Wendet man eins auf verschiedenste Datensätze an, kann es je nach Verfahren und Anordnung der Daten zu starken Performance unterschieden kommen. Daher verwendet man in der Praxis je nach Datensatz und Anwendungszweck meist mehrere/andere auch wenn das nicht sonderlich portabel ist und somit mehr Programmieraufwand von Nöten ist.",
      "score": 0,
      "language": "GERMAN"
    },
    {
      "id": 1335260,
      "meta": {},
      "text": "Design goals can often conflict with each other, therefore, we need to find a balance between them depending on the design goals. In the following lines, we will explain three typical design goal trade-offs.\n\nEfficiency vs. Portability: We can design an application to be as efficient as possible using specific technologies and low-level programming languages to enhance speed, memory usage, and performance among others, however, this would make the application perform poor with regard to portability, because there might be other platforms that do not support the same technologies.\n\nCost vs. robustness: if not many resources are given to develop a system, it is more probable that bugs and glitches happen due to a short, non-exhaustive testing process.\n\nFunctionality vs. Usability: we may want to implement a system with multiple functionalities so that it covers every action the user may want to perform, However, this is counterproductive if we also want to provide high usability. Thus, it is more recommendable to not overcharge a system with too many functionalities if usability is an important design goal.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344652,
      "meta": {},
      "text": "1. In a government appointment booking system, the end-user expects a user-friendly interface where they can book an appointment within a few clicks, however due to the low budget of the citizen's office, which is the client, they cannot provide this user-friendly interface.\n2. While developing an application for car sharing in Munich, the developers insist on having well-defined interfaces, however this increases the time to launch. Since the company owners want to launch the app within two weeks, the need for well-defined interfaces clashes with the client's need for rapid development.\n3.  When developing a photo editing platform, the developers are focused on creating a highly functional application. However, including too many editing and retouch tools has led to low ease of learning from the end-user perspective. They find the app too complicated and not intuitive to use.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1351861,
      "meta": {},
      "text": "A very obvious design goal trade-off is 'Functionality vs. Usability'. The more functionality a program or software offers the harder it will be for its user to navigate through the software and make use of all the offered functionalities. Every functionality needs to be reachable through the User Interface so the more functionalities the software contains the more complex the UI becomes. Take the Text Editor of Artemis and Microsoft Word for example. Artemis offers the most basic functionality: It lets you write text. No additional buttons, only a text box, very easy to use. Word on the other hand offers tens of thousands of functionalities that let you edit the text. Finding the ones you need is tough due to all those buttons in the UI.\n\n'Rapid Development vs. Functionality' is also quite obvious. Implementing functionality takes time. The more functionality is needed the longer it will take the developers to implement it. If you need the development to be as quick as possible your functionality wishlist should be rather short. Take the bumpers game for example: If multiple collisions should be selectable, multiple collisions have to be implemented. And those implementations take time (Creation of new Collision classes, new attributes, new methods).\n\nA third trade-off is 'Cost vs. Security'. Coming up with all the functionalities of the software and implementing them is one thing. Making the software as secure as possible the other. Every security measure comes with costs because of its development and implementation. Apple implementing algorithms into its search engine Safari that prevent most viruses from being downloaded cost lots and lots of money.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1356883,
      "meta": {},
      "text": "1.: Bugs vs Time\nBugs exist in every program, especially in more complicated ones. The process to find and prevent them can take a lot of time. You need to understand in which scenarios it arises to, then find the part of the code causing the issue and finally find a fix for the bug. These steps can take a long time. Many pieces of software get released before all their bugs are fixed to meet deadlines and then use user feedback to fix those bugs. Examples for such software are newly released games or updatesto existing software which then introduce new bugs. \n\n2.: Space vs. Performance\nTwo important metrics for an app are its performance and the space it requires compared to its complexity. \nAn example for this, albeit a few levels down the abstraction chain, is pre-computed values. The offer great performance but take up a lot of space. OLAP cubes use this technique, so that they can give you the required data when you need it.\n\n3.: Features vs Time\nA program which has more features than but is otherwise similar to its competition will usually outperform it. But the relevance of these aspects compared to the time it takes to implement them is a major aspect in software engineering. If it takes you a long time to implement a feature which users will rarely need, then it is probably not worth it. Imagine a text editor with an interface, whose style doesn't conform to the current \"standard\". The company behind it wants to change the interface to make the application more pleasant to look at. The development team advises against it due to the usually time-intensive process of designing a new interface most likely outweighing the benefits of a new look.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1389769,
      "meta": {},
      "text": "Cost vs reusability:\nAn easy program with low functionality is of course pretty easy to code. It often tempts to spaghetti code to finish the project as fast and efficient as possible. With additional functionality and new features it's really hard to implement them if the system was just cost oriented. In Bumpers at first the only requirements were an interface where you can steer a car with your mouse and play against other computer driven cars. This was easy and fast to implement and for this few requirements you wouldn't pay attention on the reusability of the program. But if you want extend the game by new features/maps, maybe even make it a multiplayer it's really hard to reuse the code efficiently.\n\nFunctionality vs Usability:\nThe less functions a program offers the easier it is to handle and understand it. If there are tons of different functions it's hard to keep an overview and understand/remember what each of the functions is doing. Between functionality and usability a sweet spot has to be determined in order to create a good program. In Bumpers there is just the main function of steering the car with your mouse. Therefore the game is easy to play and doesn't take long to understand and start playing.\n\nRapid Development vs Functionality:\nThe faster you want to implement a system the more the functionality suffers. With less functionality of course it's a lot easier and faster to code a program. In Bumpers the game at the beginning did just consist of some cars and driving one of them. This was possible to implement in less than a day, but the more functionality was added, the longer it took to develop everything.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1499635,
      "meta": {},
      "text": "Trade off 1: Functionality vs User-friendliness: \nThe more specific a programm ist and the more functional it is, the harder it is to understand what a program does and/or how it does something. Lets take Java-streams for example which are helpfull to operate on data-structures. Now a user who has basic knowledge about programming, but has never heard about streams decides that he wants to look up an implementation on how to solve a specific algorithm. After a long search he can only find implementations with streams altough it is not necessary to do it with them. So streams provide a better functionality but reduce User-friendliness.\n\nTrade off 2: Costs vs Robustness: \nThe safer you want your programm to be, the more expensive its going to be. You need to invest time and money in potential safety hazards provided by people who want to get into the system of a Program. For example you have to invest into Anti-Malware software to make a programm safer.\n\nTrade off 3: Efficiency vs. Portability:\nIt is clear that a computers processor has a lot more efficency than that of a phone. So if u want you want your Program to run fast in a specific environment you have to neglect portability of it. For example video games are  made for each console spcific beacause you cannot ensure that if its Efficient on the PC its also going to be efficient on an XBOX. ",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1655094,
      "meta": {},
      "text": "1. Functionality vs. usability: The system which has many functionalities can be difficult to learn for users. For example, building the software for managing all database of the manufacturers requires many functionalities and employees should learn it by taking internal or external courses.\n\n2. Rapid development vs. functionality: when the customer wants complicated functionality but gives tight deadline for that, the software can be delivered in time but not complete or complete but late for the date. \n\n3. Cost vs. robustness: The system should be tested many times for high robustness but it costs more. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1660720,
      "meta": {},
      "text": "Functionality vs. Ease of learning\nexample: Photoshop has great functionality, but at the same time it's hard to learn to use Photoshop.\n\nFunctionality vs. Fault tolerance\nexample: the more car types I'd like to implement in Bumpers, the more possible errors occurs.\n\nCost vs. Portability\nexample: If the Bumpers game should run both in Andorid and Windows, the cost of coding and testing will increase.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291274,
      "meta": {},
      "text": "Design goals are a collection of nonfunctional requirements, which is an important part of the end-system. But because three sides, the client, the developers and the end-users are part of or have to be considered in the development, the most important requirements can be different for each side. As a result of that design goal trade offs have to be established. \n1. Functionality vs Usability: The complexity of a system grows, if it gets more and more new functions. Therefore the user interface can also grow to look more complex than before. If the features are important, the client wants to show them off in the menu for example. As a trade off the user has a harder time navigating, if there are more buttons to press and menus to navigate. A solution has to be found.\n2.  Availability vs Cost: The client wants the system to run all the time on different servers, while one server is on downtime. That makes the system always available, but also means he has to invest in these servers. As a result it has to be decided if it's more important to keep the system always running or keep the costs lower.\n3.  Adaptability vs Safety: The end-users want the system to be tolerant to faults and unwanted incidents, but also for it to adapt to a changing system. If it grows more adaptable to different things, the chances of surprising incidents in these new environments also grows, which makes it a trade off.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292150,
      "meta": {},
      "text": "1/ Functionality vs Usability: Usability and functionality are often seen as a design tradeoff. While making the System Design one must chosen at the expense of the other because they cannot both be fulfilled at the same time. For example in a Photoshop software the tradeoff between them considers the popularity of functions. For example, short-cuts and effects that only few people in a specific field use may be buried in a hierarchy of menus. In this case the sacrifice has been made in favor of the usability.\n2/Cost vs. Robustness: When making a decision about a product or a project, the first point that should be considered is the Cost, because based on that alone a lot of things will be done differently. For example if the Client is ready to invest alot of money in a new Gaming-Platform, it is then a must that the Platform ist robust, espacially when millions of Players login at the same Time. In order for the Quality to be high the Costs have to be high too.\n3/Rapid development vs. Functionality: Anyone who will be managing a project will probably have to make a decision between delivering at high speed with full functionalities, or with high cost: As the saying goes, you can only pick two. This leaves a choice between functionality and delivery speed, which often comes down to a decision about testing, as it takes alot of time. So the client recieves his product in no time but barely tested, and this is the result of his decision at the beginning.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344111,
      "meta": {},
      "text": "Efficiency vs. portability:\nWenn man eine Anwendung entwickeln möchte, die auf mehreren Platformen gleichzeitig Laufen soll, so gibt es Grundsätzlich zwei Möglichkeiten: Man schreibt das Programm für jede Platform selber und neu, wodurch die Effizienz dieser Anwendung auf allen Platformen bestmöglich gewährleistet ist, jedoch die Effizienz der Entwicklung nicht. \nUm zweiteres aus dem Weg zu gehen, könnte man sich Beispielsweise auf bestimmt Sprachen und/oder FrameWorks entscheiden, die auf allen benötigten Platformen laufen (bsp. react-native, flutter), jedoch verlieren damit eine gewisse Kontrolle über jede einzelen Platform, wodurch die benötigte Effizienz der Anwendung nicht mehr bestmöglich Gewährleistet ist.   \n\nFunctionality vs. usability: \nFalls ein System mit vielen Funktionen benötigt/bevorzugt wird, kann es sehr schnell passieren, dass die Usability drunter leidet. Angenommen man möchte eine Anwendung entwickeln mit der man Webseiten erstellen kann. Das Ziel ist es, dass mithilfe dieser Anwendung auch jede komplexe erstellbar ist, wodurch aber die  usability (vorallem für unerfahrene Nutzer) extrem veringert wird, da diese mit Einstellungsmöglichkeiten überflutet werden.\n\nRapid development vs. functionality:\nWenn ein System schnell fertig werden muss, muss natürlich die Funktionalität anfangs auch noch eingeschränkt sein, da die Entwicklung für jede zusätzliche Funktionalität extra Entwicklungszeit in Anspruch genommen werden muss. So kann es Beispielsweise gut sein, dass die Entwicklung eines neuen Charakters für ein z.B ein Spiel mehrer Tage oder Wochen in anspruch nimmt.",
      "score": 91.7,
      "language": "GERMAN"
    },
    {
      "id": 1355517,
      "meta": {},
      "text": "Functionality vs. usability: \nProviding an interface with too many options can provide additional functionality, but comes at the cost of losing functionality. If the player of the Bumpers Game would have to configure every car (player and system) before the game starts, the additional functionality comes at the cost of the usability.\n\n\nCost vs. robustness:\nTo guarantee that a server continues to provide services to users, additional backup servers can be implemented for eventual failure of the main server. This increases the robustness, but each server comes with additional costs. A online gaming website for example now has to decide with what trade-off between costs (buying additional servers or server capacity) and robustness (risking a website overflow) they are willing to life. \n\n\nRapid development vs. functionality: \nImplementing additional functionality needs more time (for example trough adding another sprint). Now the client can decide to have rapid development of the software or more functionality. In the Bumpers Game for example, implementing more care types or more collision types need additional time even though they are not elemental for a basic working version of the game. Therefore, a trade-of between adding functionality and having a rapid development happens. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1458592,
      "meta": {},
      "text": "Functionality vs. usability:\ndevelopers usually want to add more features/functions, but they also want to keep it easy to use.\nAn example for this, where functionality took the upper hand is the MMORPG Eve Online. It is an incredibly complex game and has many different ways it can be played. It also is on the market for almost 20 years and therefore got new freatures continually added. The insane amount of stuff to do often overwhelms new players. There is a high functionality, but it comes with the trade-off of having low usability.\n\n Efficiency vs. portability:\ndeveloping software for a specific hardware enables it to be more efficient. However, it might no longer be portable. The classic example would be higher and lower programming languages.\nLower programming languages, like C work closer to maschine code and can be more efficient. However, often times they do not work on other systems. higher development languages, like Java work on most maschines, but are less efficient. So they trade functionality for usability.\n\nBackward compatibility vs. readability:\nWhen changing an already existing software you want to make sure, that other things, that are dependend on the software still work with the new version. That often causes legacy code, that is hard to read to remain in the code base untouched. A developer at Toyota removed a global integer variable in the code. He thought it was never used and wanted to make the code simpler(readable). However, it was indeed still used and it caused many adjacent systems to crash.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291343,
      "meta": {},
      "text": "The first typical design goal trade-off is functionality versus usability. It will often lead to a conflict, because a good usability of a program is not always the best solution if you consider functionality. \nFor example an app that is developed for productivity can in fact deteriorate the program if the functionalities are not useful and confusing.\n \nRapid development versus functionality is also a typical design goal trade-off. It is pretty obvious that if the developers have less time to implement features and functionalities, either the quantity or the quality of the projects functionalities will be low.\n\nThe third design goal trade-off, developer teams have do deal with is cost versus robustness. Less available money to pay the developers will mostly lead to less robustness of the software. Less cost means less developers or less time to develop the project, so it is possible that there are still bugs in the program.\n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291863,
      "meta": {},
      "text": "The client usually wants to keep the costs as low as possible. In contrast to that, the developers want to write essentially \"good code\". That means code that is reusable, adaptable and robust. But the developer needs time to implement those, which costs money. In the long term investing this makes sense because when the code is reusable, adaptable and robust it probably also runs with hardly any errors and is maintainable. But it takes longer time which stands in contrast to rapid development, and also it is more expensive.\n\nAnother tradeoff is backward compatibility vs. readability. When software is written for newer hardware it often has to be backwards compatible to run on older machines, swell. But this often leads to complex code and long documentations, because the older machines might for example have fewer cores. That means the software can't work exactly the same on the two different machines. Making sure that it actually works on older machines can lead to less readable code.\n\nBoth the client and the end user want the runtime to be as efficient as possible. The developer might prefer portability to runtime. An example for that will be the languages in which the code is written: interpreted languages like Python are likely to be written faster, and also they can run on any machine as they are being interpreted. On the other side there are the compiled languages like C which run faster.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292379,
      "meta": {},
      "text": "Cost vs Robustness:\n\tredundant servers are more expensive to run but are less likely to fail.\nRapid development vs functionality:\n\tit takes longer to implement a software with a diverse functionality than one that is \t\t\t\t\t \n\tonly implementing a few functionalities.\nFunctionality vs usability:\n\tif an application has many functions it becomes harder to use. (e.g. Linux [don't hate \t\t\t\t\t\t\t\t\t \n \tme for this :| ])",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292565,
      "meta": {},
      "text": "1. A typical design goal trade-off is between functionality and usability. It means that the more functions a system has, the more complicated it gets. For the user it can then be very difficult to understand the system and it will take a longer time to learn how to use it. On the other hand, the more functions are provided, the more someone can do with the application. For example, microsoft teams was very confusing for me in the beginning. There were so many functions. You had the chat, but not just chats with people, also a chat for every meeting that you have had. Then there are teams and in every team you have an individual file system. And this file system is connected to Onedrive and the calender is connected to Outlook... for me it was very confusing in the beginning.\n\n2. Cost vs. Robustness means, that the more money you put into creating a system, the better it can develop. For example you could test it very extensively, find mistakes and fix them. You could use good technology and techniques to make it very secure and robust. But that costs money and time, which makes the price for the product and for the end user expensive.\n\n3. Rapid development vs. functionality: With rapid development you get less or weaker functionality. If someting is made in only a short amount of time, developers can only implement the really needed functionality. For example, when we had to build a lego bridge in the eist-tutorium, we didn't have a lot of time and so we just tried to fulfill the requirements. With more time we could have made the bridge pretty, good accessible with a stairway, a path for pedestrians and one for bicycles. But usually there is a deadline for a project and you have to find a balance between developing it fast and still making a good product.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292746,
      "meta": {},
      "text": "In general there are 6 typed of typical design goal trade-offs, like: \n1. Functionality / Usability \n2. Cost/ Robustness\n3. Efficiency  / Portability \n4. Rapid development / functionality \n5. Cost / Reusability \n6. Backward compatibility / Readability  \n\nIn this exercise is asked to explain 3 of them. I have chosen 1, 2, 3.\n\n1. It is very important to keep the interface basic. People are already used to the usual interface and they will spend a lot of time to figure out what's what, so I can even abandon it halfway or not start at all. Therefore, to prevent this from happening, it is better to keep it simple.\n\n2. Here you need to know the finance of the project. We can write nice and smart one-to-one code with little test effort, but we can't reuse it. Or we can switch to multi to multi, where we have to code more and give money for additional tests. It all depends on the purpose of the project. Obviously, for quick projects, a one-to-one option would be better.\n\n3. Trivial, here you just need to make sure that the software system does not have time due to the large number of visitors at the same time and correctly distribute them among the servers.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1309860,
      "meta": {},
      "text": "\n1) Functionality vs. Usability: This conflict emerges because having a lot of functions requires you to have a full user interface and demands from the user to learn all those functionalities. On the other side, software that is rather based on usability often can’t be that functional, because it can’t overwhelm the user with hard to remember and hard to find functionalities. A great example of that is Git, a software that allows to efficiently use version control for software development, but isn’t intuitive and usable at all. \n2) Cost & Reusability:\nThis conflict emerges because having high reusable software requires great and clean development of the software, what causes higher costs. On the other side, having a cheap development won’t allow you to put a lot of work into designing a software with reusable components. For example, developing a database only for storing data about student names is easier and cheaper to build than a database whose architecture can be used for different use cases like storing exams.\n3) Efficiency & Portability:\nEfficiency requires developing a software that is perfectly adopted to the device it is running on. Since you can't adapt the software's architecture perfectly to any device type, you have to choose between high performance or high portability. Video games that run only on one console are often more performant than video games like Fortnite that run on basically any machine, because the former has chosen performance over portability.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344143,
      "meta": {},
      "text": "cost (e.g. time) vs robustness\nDas Testen des Codes ist in vielen Fällen umständlich und zeitaufwending. Zudem nicht Grundlos ein eigener Bereich der Softwareentwicklung. Da Umfangreiche Testfälle jedoch unabdingbar für Robusten Code sind führt dies zu hohen kosten. \nDie Erfahrung mit JUNIT hat mir gezeigt dass Sinnvolle Cases oft nicht einfach sind. Je häufiger und je mehr Szenarien ich jedoch bei selbst einfacherer Methoden angewandt habe, desto erfolgreicher lief mein Programm. Insbesondere ein Programm zum verifizieren verschiedener Daten und der Einordnung in Schaltjahre hat mir die Wichtigkeit bewiesen die in meinen Fall mit horrenden (Zeit-)Kosten verbunden war aber zu einem robusten Programm geführt hat. \n\n\nEfficenty vs. Portability\nUm ein Programm Plattformunabhängig laufen zu lassen bedarf es oft spezieller Programmiersprachen aber auch anderer Herangehensweisen wenn es um Systemzugriffe geht. Dies geht oft zu lasten der Geschwindigkeit und sorgt für geringere Effektivität. \nMeiner Erfahrung nach hat sich die Sprache Java als deutlich langsamer erwiesen als vergleichbar auf einer nicht virtuellen Maschine laufende. Bietet dies zwar oben genannte Vorteile gibt es doch erhebliche Nachteile\n\nFunctionality vs Usability \nEin typisches Ziel ist es möglichst viele Funktionen bereitzustellen. Leider wächst mit dem Umfang eines Systems auch der Anwenbarkeit und die möglcihkeit das System in kurzer Zeit zu verstehen. Ein Typisches bespiel kommt aus dem Bereich der Spiele Entwicklung. Viele Studios wollen Spielern komplexe Anwendungen uns viele mögichkeiten bieten, vergessen aber dass die Hemmschwelle für neueinsteiger wächst. Nicht selten sind gute Projekte an diesem Fehler gescheitert oder zumindest nicht so erfolgreich gewesen wie erwartet. \n\n\n\n\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344639,
      "meta": {},
      "text": "cost vs robustness:\nDadurch, dass man nicht allzu viel Budget reinstecken kann, könnte z. B. die Robustheit des Programms einbüßen müssen. So könnte es sein, dass falsch eingegebene Daten falsch verarbeitet werden. Wäre dies z. B. bei einer Bank der Fall, könnte es bei einer Überweisungen zu Problemen führen in Bezug auf Abtrennung von Euro/Cent mit Punkt/Komma.\n\nbackward compability vs readability:\nDadurch, dass etwas abwärtskompatibel sein soll kann es sein, dass man Code benutzt, der nicht gängig ist bzw. sonderbar und man den normalerweise so nicht benutzen würde, sodass die Leserlichkeit des Codes darunter leidet.\n\nrapid development vs funtionality:\nEs ist klar, dass bei schneller Entwicklung von Software, die Funktionalität normalerweise einbüßen muss. Als Beispiel kann man dafür auch Spiele nehmen, die dann mit der Zeit immer mehr Funktionen bekommen in Form von Updates oder DLCs.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1361395,
      "meta": {},
      "text": "1) Efficiency vs. code understanding: As a part of the Realtime graphics lecture I had to implement a terrain generator. I've used the most straightforward approach, with a lot of if-statements, however it was clear what this code does and what was the whole process of the algorithm. The generator in general was relatively slow. However, I'm planning to implement in the way, when both of these aspets are balanced.\n\n2) Efficiency vs. portability: Sometimes, difference in platform architectures and designs can lead to a loss of features and efficiency drops during the process of portability. Minecraft is a good example here: after the release of Minecraft Pocket Edition, developers had to reduce the World to 256x256 size in comparison to the infinite World on PC platforms. This decision has been made exactly because of programming and technical limitations of mobile platforms. However, infinte World fature has been added a couple of updates later.\n\n3) Functionality vs. usability: There's a vast majority of complex systems with a number of powerful features, however exactly this complexity makes it really hard to understand how the program works and it takes some time to \"master\" it. Let's look at Maya: it is an extremely powerful program and one of the leading tools in 3D Graphics. But to implement some high-level assets, it's required to read documentation and get used to the tools.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1506917,
      "meta": {},
      "text": "Backward compatibility vs. good documentation:\nwith backward comtapibility there is a software or hardware system that has interfaces and data from previous models of the system, which may be hard to document for the customer.\n\nRapid development vs Minimum # of errors:\nIf there is not enough time to finish the system, there may be miscommunication with the customer. The quality of the system may also decrease which can cause some errors in the system, since there is no time to test all of the functions.\n\nCost vs. robustness\nIf the customer wants a robust system, the developer would need time to test errors and to try different possible scenarios. Time means money, so the system would cost more, since the developer needs more time to develop it.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1637223,
      "meta": {},
      "text": "Rapid development from the costumer side vs minimum number of errors from the developer side: the demanded rapid development can cause that the developers have less time for testing and errors detection.\n\nLow cost desired by the costumer vs robustness of the program:  the developers cannot work on enhancing the strenght of the program when they do not have enough money to pay developers or pay physical resources (computers, working place)  \n\nBackward compatibility vs. Flexibility: making a program compatible with their previous versions can cause that this program cannot adapt to the newest technologies or platforms. ",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1663272,
      "meta": {},
      "text": "Reliability: The system is always ",
      "score": 0,
      "language": null
    },
    {
      "id": 1292087,
      "meta": {},
      "text": "1. Cost vs. Robustness\nDa die Produktioinskosten eines Produktes möglichst gering gehalten werden sollten, kommt dies oft in Konflikt mit der Stabilität des Produktes. Je nach Produkt muss man also einen guten Weg finden, der die Herrstellungskosten gering genug hält und zudem noch eine ausreichende Stabilität des Produktes liefert. Dieser mittelweg variiert aber je nach Produkt. Will ich mir beispielsweise eine Handyhülle kaufen, gibt es sehr stabile und sichere Hüllen, die dafür aber mehr kosten, es gibt aber auch sehr dünne, flexible Hüllen, die günstiger sind.\n\n2. Cost vs. Reusability\nWie immer werden auch hier die Herstellungskosten versucht zu möglichst gering zu halten, während dadurch die Wiederverwendung leidet. Besteck aus Plastik und Pappe kann zum Beispiel sehr leicht und Kostengünstig hergestellt werden, dafür aber nur einmal verwendet werden. Bei Besteck aus Edelstahl verhält sich dies anders, denn das kann sehr oft verwendet werden, ist aber auch deutlich teurer zum Herstellen und hat deshalb auf dem markt auch einen erhöhten Preis.\n\n3. Rapid development vs. Functionality\nNatürlich soll das neue Produkt möglichst schnell entwickelt werden, auch um Personalkosten einzusparen, allerdings braucht man auh genug Zeit zum Testen des neuen Produkts um zu sehen ob es auch genauso funktioniert, wie es soll. Bei Raketen ist es beispielsweise sehr wichtig, dass diese richtig funktionieren. Daher ist der Herstellungsprozess eher langsam, es wird sehr viel getestet und sobald ein Test fehlschlägt, muss dieser wiederholt werden, bis er erfolgreich ist. Dies kann den Herstellungsprozess noch weiter verlängern.\n",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1292631,
      "meta": {},
      "text": "#1 Rapid Development vs. Modularity\nIn Rapid Development wird wenig bis gar keine Abstraktion verwendet und viele Funktionalitäten werden fest codiert. Daher wird es sehr viel schwieriger das Produkt in Zukunft zu erweitern. Zum Beispiel wenn man eine App zum Verkauf von exklusiv nur Fruchtsäften schreibt und es hardcodet, dann wird es später komplizierter das Sortiment um z.B.: Milchgetränke oder andere Produkte zu erweitern.\n\n#2 Functionality vs. Usability\nEin großes MMORPG soll attraktiv für viele Spieler sein, nicht nur \"Hardcore Gamer\", sondern auch Gelegenheitsspieler, die sich nicht so gut mit dem Genre auskennen. Daher muss man bedenken, dass man z.B. Funktionalitäten im Gameplay, wie Skills, Erklärungen von Bossen, etc. , nicht alle auf einmal dem Spieler heranführt, sondern nach und nach. Denn ein MMORPG, das den Spieler nach dem Spielstart sofort mit tausenden Informationen über Skills, Funktionen etc. überrollt, wäre nicht benutzerfreundlich.\n\n#3 Safety vs. Performance\nWenn man viel Sicherheit in einem System haben möchte, leidet die Performance aufgrund der vielen Checks und Verschlüsselungen. Zum Beispiel wenn Datenbankzugriffe mehrmals validiert werden und die Kommunikation zur Datenbank zusätzlich stark verschlüsselt werden muss, dann kostet das zusätzliche computation time.\nBei einem Onlinegame zum Beispiel, dass die Integrität der Daten gesichert wird, denn es wäre ärgerlich, wenn beim nächsten Einloggen der Fortschritt weg ist. \n",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1301078,
      "meta": {},
      "text": "\n\nI would like to start with the trade-off cost vs. robustness. To keep the costs as low as possible is self-evident.\nBut on the other hand one also wants the software to be as robust as possible. Therefore one has to think of all possible user inputs which could occur that could make the system collapse. Finding these inputs and scenarios requires time as well as delivering solutions to these issues. Time is money. For example when you have to deliver a software system for bank accounts you have to consider the case that certain datatypes have a maximum value. Making the system robust to this requires time and therefore money.\nSecondly I would like to further explain the trade-off functionality vs. usability. Of course one wants his software to deliver as many functions as possible. But you have to consider that this goes at stake of usability. In terms of usability less is more. The user interface should be very easy and intuitive to handle. For example an app that shows 100 buttons of different functionalities in the main menu will not appeal to the user as it is too complex to find the function he is searching for.\nUltimately I am going to explain the trade-off rapid development vs. functionality. Delivering functionality requires time, delivering more functionality requires more time. For example if you want me to program a matrix calculator for you, then it would take more time to finish the project if you instructed me to also deliver the function \"matrix multiplication\" additional to \"matrix addition\".\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1317024,
      "meta": {},
      "text": "functionality vs. usability\nUsablilty in this specific case, is the ease with which a programmer can use methods provided by the architecture. Functionality on the other hand is the amount of complex methods the architecture supports.\nA RISC architecture offers a lot of useablility and therefore less functionality -> It supports a few simple methods that are easy to use. A CISC architectur on the other hand comes with less useability, but much more functionality -> Many methods, that can execute more complex operations. Harder to learn what methods are viable and what they do. -> tradeoff\n\n\ncost vs. robustness\nTo archieve robustness in an application it is mandatory to test it. Than more robustness a developer wants to archieve than more he has to test his code (raising exponentially). Good testing takes a lot of ressources (time, more developers, higher qualified developers), which increases the cost of a project.\nWhen developing an app for bank customers, the end user wants an app that is as robust as possible. The bank wants the app to be cost efficient and robust at the same time, to save money and satisfy their customers. \n-> tradeoff\n\nefficiency vs. portability\nIf company A owns one single dedicated computer, code running on this machine can be optimized just for that one computer and its components (high efficiency, low portability). But for another company B, that doesnt have that specific computers, but rather many different computers the code will be less efficient or maybe even useless, because it is only optimized for that one computer. Company B would prefer to have portable code that runs on many different computers (no matter what os or components it has).\n-> tradeoff less efficiency, but more portablility",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1332809,
      "meta": {},
      "text": "Ein typischer design ziel \"trade-off\" ist Funktionalität vs. Benutzerfreundlichkeit. \nHier gilt es abzuwägen ob man eher sehr viele verschiedene und komplexe Funktionen dem Nutzer anbieten möchte und dadurch eine sehr hohe Funktionalität erreich oder das Endresultat einfach für Benutzer halten möchte und sich auf wenige klare Funktionen beschränkt.\nEin Beispiel ist ein typischer Fahrkartenautomat. Hier könnte man einerseits eine hohe Funktionalität bieten also z.B. für jeden Fahrgast ein individuelles Ticket anbieten  ,wie oft man umsteigen möchte und wie lange diese Zeit höchtstens Dauern sollte und so rseits wird der Ticketautomat dadurch sehr kompliziert und für z.B. für Erstbenutzer schwierig zu bediuenen.\nweiter. Durch diese ganzen Funktionen wird einerseits den Nutzern viele verschiedene Optionen geboten ein individuelles Ticket für Ihre Fahrt zu kaufen und damit theoretisch genau nach den Gastbedürfnissen angepasst aber andere\nEin weiterer Desing ziel trade-off ist eine sehr schnelle Entwicklung vs. eine hohe Funktionalität. \nHier kann man wieder den Ticketautomaten heranziehen. Einerseits könnte man sehr schnell einen funktionstüchtigen Automaten programmieren, der z.B. nur ein Tagesticket und ein Kurzstreckenticket für alte und junge Leute anbietet und nicht mehr funktionen hat als die Auswahl und Bezahlung. Dies bedeutet aber auch, dass man nur diese wenigen Funktionen einbauen kann, denn z.B. durch eine Fahrtenverbindungsanzeige mit interaktiver Karte, würde deutlich länger dauern. Dafür aber eine höhere Funktionalität.\n\nAuch ein trade off ist Kosten vs. Robustness. \nUm z.b. ein spiel robust gegenüber\n\n",
      "score": 66.7,
      "language": null
    },
    {
      "id": 1344153,
      "meta": {},
      "text": "1. Functionality vs. Usability: A choice has to be made between how many functions can be added to a system and how easy it is to use it. For example, a piece of industrial machinery can do a lot of various things and can be customized with many parts, but only a specialized technician can operate it. On the other side, we have a hairdryer that has few functions but almost anyone can use it.\n2. Cost vs. Reusability: A typical trade-off is between the cost and the reusability of a system. Cheaper production cost means the product mostly has a one-time use. To be able to reuse the product, it has to be made with higher quality material e.g. batteries. The single-use batteries are far cheaper than rechargeable ones because they only have to release the stored electrical energy, while the other ones have to be able to be newly recharged multiple times.\n3. Efficiency vs. portability: Another typical trade-off is between the efficiency and the portability of a system. More efficient machines for example are bulkier and focus on power consumption or raw output, while the portable versions can be carried around or repurposed to another place. The most obvious example are desktop computers and laptops. Desktop computers are bulkier but generally more powerful than laptops. On the other side, laptops can be carried and used pretty much anywhere at the cost of efficiency. To be able to have the same processing power as a desktop PC you have to pay 3 to 5 times as much for a laptop because everything has to be made portable and compact.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344287,
      "meta": {},
      "text": "Schnelle Entwicklung vs. Funktionalität: \nDer Auftraggeber will natürlich, dass sein Produkt schnell entwickelt wird, da Zeit viel Geld kostet. Nintendo sollte seine Fans mit neuen Spielen nicht allzulange warten lassen, denn sonst verliert man als Käufer das Interesse. Der Entwickler hingegen will natürlich ein Produkt entwickeln, dass eine ansprechende Funktionalität hat. Diese ausgearbeitete Funktionalität entsteht aber erst mit der Zeit, also braucht der Entwickler mehr Zeit. Ein Spiel welches Nintendo dann rausbringt, dass nur eine handvoll Funktionalitäten anbietet, gefällt den Käufern nicht und schwächt das Geschäft.\n\nFunktionalität vs. Benutzerfreundlichkeit:\nBei einem Ticketautomaten für den öffentlichen Nahverkehr hat man eine hohe Komplexität mit viel Funktionalität, da es viele Ticketmöglichkeiten gibt. Für den Benutze hingegen ist das alles sehr unübersichtlich, da es sehr viele Möglichkeiten gibt, die man anklicken kann\n\n\nAbwärtskompatibilität vs. Lesbarkeit:\nDer Auftraggeber möchte die Abwärtskompatibilität aufrecht erhalten, weil man sein neues Produkt, dann auch noch auf den alten Systemen laufen lassen kann ohne Probleme zu bekommen. Intel zum Beispiel hat sehr viel Wert darauf gelegt, dass man auf der neuen 64 bit Architekutur auch noch die Programme mit der 32 bit Architektur laufen lassen kann.  Für den Entwickler heisst das natürlich, dass der Code um einiges komplizierter wird, da man auf dem alten bestehendem System aufbauen muss oder es intergriern muss. Dies macht den Code um einiges komplizierter.  ",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344726,
      "meta": {},
      "text": "Usability vs Functionality: some systems like image modifying apps, which contain too many functions that can be difficult for the end-user to use. On the other hand, choosing Usability over functionality the image modifying apps may lose some of the advanced techniques and then in the end the number of end-users will decrease. Therefore, all functionalities must be included and also clear to use with the help of tutorial videos.\n\nRapid development vs minimum of errors: some clients request that the product should be ready in a short amount of time but this case will lead to a lot of errors due to a lack of testing of the end product which will lead to bugs or even a low availability. Choosing a minimum of errors will cost more time to finish the product \nand this will may cause an avoidance from some clients who are in need of this product as soon as possible. \n\nCost vs. robustness: The example is the platform Freelance where services are ready to be purchased. Favoring the cost over robustness the final product will be less able to maintain the functionality whenever an incident happens because the developer will not spend too much time to make it perfect. Otherwise, when the priority goes to robustness the costs will be higher but the developer will spend more time on maintaining the product's robustness.\n\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1348912,
      "meta": {},
      "text": "- 3 typical design goal tradeoffs: \n  - cost vs robustness: this is encountered quite a lot in daily life. The more robust a software is, the more it costs. \n  - rapid development vs functionality: the more functionalities a software need to have, the longer it takes to develop it. \n  - functionality and usability: a game that has plenty of complex functionalities is likely less attractive to non-experienced and children players. ",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1349047,
      "meta": {},
      "text": "A typical design goal trade-off is the one concerning functionality vs. usability. While it is desirable to offer a maximum of functions its is still very important to maintain usability and clarity. Humans are easily overwhelmed when presented too many options or functionality. One example for this could be Adobe Photoshop. It offers a huge amount of functionality but for some users the clarity and usability might suffer a little bit because of all those options. The trade-off was decided more towards the functionality side (which in this case might also be the right thing).\n\nAnother typical conflict is rapid development vs. functionality. The wish to develop newer solutions or newer products faster and in declining intervals can lead to a lack of new functionality and added value. In the smartphone branch, this can often be seen when the next newest model gets released with very few groundbreaking new software features compared to the predecessor. \n\nA third typical conflict might be rapid development vs. reliability. Similar to the second trade-off the pressure (from stake- and shareholders) on developers is sometimes very high although a reliable solution is not yet ready.\nThe example of games engineering often shows this trade-off. Some studios tend to give in to the pressure to release a game (because of markting announcements) when actually it still needs a bit more time. This often leads to very bad reliability issues and dissatisfaction of the paying players who were looking forward to a rather bug-free experience. (e.g. CD Projekt Red with Cyberpunk 2077)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349100,
      "meta": {},
      "text": "1. Cost vs. robustness\nExplanation:  Cost and robustness is a typical design goal trade-off because cost is higher when we need great robustness. If we want lower cost, we will spend less money on the robustness of the software if we don't reduce the functionality.\nExample: When a computer system has great robustness, for example can handle the wrong input of users, client need to spend more money. But if we need to cut the cost, we have to put the construction of it aside and lose the robustness.\n\n2. Rapid development vs. functionality\nExplanation: If developers want less period of development, they have to decide which functions will be kept and what can't be realize in a certain period of time.\nExample: If developers want to have a new function, for example the software can enable the local computer to connect with another one, they need to spend time on that, but if they don't develop it, it will lose functionality.\n\n3. Cost vs. reusability\nExplanation: If we need reusability, we should spend money to improve its reusability. If we don't need high reusability, we will save money.\nExample: If we require the developers to develop the reusability of a software, we need the effort of the developers and developers also need money to develop it, we will pay them for development of reusability, but if clients don't require that, the money will be saved, which leads to lower cost.    ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1416661,
      "meta": {},
      "text": "I want to buy a clothes. A good quality clothes is expensive and a cheap clothes may not be good quality and may break down after a few wears. At this point I should consider which aspect affects me more, the trade-off between cost and robustness.\n\nDesigning a game that can be written with just some simple code will not achieve much and will be difficult to improve later on. But if the design is complex from the start, the cost of time and effort can become very high. Rapid development vs. functionality.\n\nThere are many different kinds of maps, from large world maps to small city maps, and the use of the type of map varies according to the needs. Maps with a large viewable area often lack detail, while maps with a high level of detail have a small area. Functionality vs. usability",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1459426,
      "meta": {},
      "text": "Functionality vs. usability is a typical design goal trade-off. When too many functions are provided in the same system, the usability decreases. I have the experience of using a moblie application with thousands of functions, most of which are useless functions for me. The meaningful functions are buried deep under other functions. Too many functions enlarge the size of the application and the complex interaction between functions delays the performance.\n\nRapid development vs. functionality is another typical design goal trade-off. When multiple functionalities are implemented, the interactions between these functions may increase, and the development will be slowed down. When I was solving PGDP Homeworks in last semester, I found an obvious positive correlation between my working hours and the size of the problem statement, which relates to the amount of functionalities. \n\nCost vs. robustness is another typical design goal trade-off. In order to improve the robustness of a program, we need to consider more about edge cases, possible errors and expections, which leads to higher coding and testing cost. When I was coding for the PGDP homework last semester, coding for the functionalities under normal situation didn't take me too much time. However, it usually takes me more time to handle edge cases and possible rare failures. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1290925,
      "meta": {},
      "text": " Kosten vs. Robustheit (cost vs. robustness) :\nWenn Sie Ihr geschriebenes Programm nicht auf mögliche Randfälle testen (niedrige Testkosten), könnte das Programm Fehler aufweisen und möglicherweise nicht korrekt funktionieren. Wenn Sie also mehr Kosten für das Testen aufwenden, könnte das Programm robuster arbeiten.\n\nKosten vs. Wiederverwendbarkeit (cost vs. reusability):\nWiederverwendbarkeit ist die Verwendung von bestehendem Code in irgendeiner Form innerhalb des Entwicklungsprozesses von Softwareprodukten. Um Code zu schreiben, der wiederverwendet werden kann, muss mehr Zeit und Mühe investiert und somit mehr Geld ausgegeben werden. Da Unternehmen versuchen, die Kosten auf ein Minimum zu reduzieren, setzen sie die Programmierer oft unter Druck, eine Software schnell fertig zu schreiben. Dies führt zu schlechtem Code, der für den nächsten Softwareentwicklungsprozess nicht wiederverwendet werden kann. \n\n Funktionalität vs. Nutzbarkeit (Functionality vs. usability):\nDie entwickelte Software sollte, über bestimmte Funktionen verfügen, die für den Nutzer leicht und schnell abrufbar sind. Zudem sollte die Benutzeroberfläche der Software nicht zu komplex und kompliziert gestaltet sein, da Sie für verschiedene Nutzertypen (auch Nutzer die, die Software zum ersten Mal verwenden) ausgelegt sein sollte. Als Softwareentwickler muss man also die Balance zwischen Komplexität und Verständlichkeit finden, um eine möglichst erfolgreiche Software zu entwickeln.\nWenn eine Software zu Komplex gestaltet ist, kann es dazu kommen, dass die Endnutzer sich nicht damit auseinandersetzen wollen und die Software als \"nicht nutzbar\" abgestempelt wird.\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1291139,
      "meta": {},
      "text": "The first design goal trade-off is the design goal of a customer to have low cost for the production of the system, but as well functionability and a rapid development of the system. The customer wants to have a good product fast at low cost. \nAnother trade-off might be as well the rapid development of the product versus the documentation of the developing process. Since the documentation takes time, but is necessary for the developing process, the rapidity of the developing process is affected by the diligence of the documentation.\nThe third trade-off is the ease of learning the customer wants versus the functionality the customer and the client want the system to fullfill. Customers usually want applications to be easy and intuitive in their usage, but might want them to offer a high range of functions as well. The one comes at the cost of the other.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291403,
      "meta": {},
      "text": "1. Efficiency vs Portability\nAs the name says, we often need to choose, if we want the most efficient model of the system, so that it has a fast response, the most options, etc. That usually comes with a lot more advanced hardware. We can also do things a bit smaller, more portable version. We often see that on our computers. Strong PC \"from NASA\" have the best specs and offer a huge range of options to use, but they're only good for home-use. If we need a more portable version, that's more on-the-go, the less efficient one which you can take everywhere, laptops are the best choice.\n\n2. Cost vs Reusability\nWhen you have to choose if you want a cheaper version of a product, but you can use just once, or one that you can reuse but that may cost more. For example, the traditional cigarettes may cost a lot less to produce, but once they were smoked, you cannot use them again. Meanwhile if you opt for a version that can be reused again after, like e-cigarettes, it will cost a lot more.\n\n3. Functionality vs Usability\nHere we decide if we want a system that has a bunch of different functions and properties, or we would rather have a less advanced one, with less funcions. Just like coffee machines. Most people usually use them only for espresso or americano, completely forgetting about all of the other useful functionalities like warming milk etc.",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292175,
      "meta": {},
      "text": "Rapid development vs. Functionality\nFor example in the Bumpers Game we have a deadline of one week, so we have to implement the sprints in a short time. Hence there is a trade-off between rapid development vs. functionality, as we do not have time to implement extra functionalities, e.g. Special effects when there is a collision. We have to implement only the necessary functionalities. \n\nCost vs. robustness\nThe Bumpers Game is implemented by students, hence the professor doesn't need to pay them, as the students are doing it as a part of their homework. However, as they are still students, there are errors in the end product. The students forgot to think about what happens when the player uses the keyboard instead of the mouse to steer the cars.  That could have been prevented if the professor would have paid a lot of money for experienced developers. So there is a tradeoff between low costs for human resources and robustness.\n\nEfficiency vs. portability\nImagine the game would have been only developed for iOS. If we would implement it also for Android, the portability would be better. However, the efficiency would be worse, as the way how data of the player is accessed would change which would lead to longer runtime",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1294281,
      "meta": {},
      "text": "1. Funktionalität vs. Benutzbarkeit \nWenn es sehr viele Funktionen gibt, leidet die Benutzbarkeit, da eine App dann beispielsweise unübersichtlich wird. \n2. Kosten vs. Robustheit\nHier liegt die Abwägung darin, wie viel Geld investiert werden soll um eine Robustheit des Systems zu ermöglichen. Sobald zu wenig investiert wird kann das System aufgrund zu geringer Robustheit kaputt gehen, was erneut zu Kosten führen kann. Auf der anderen Seite möchte man auch nicht von Anfang an zu viel Geld in eine Robustheit investiert, wenn sie nicht benötigt wird.\n3. Effizienz vs. Portabilität\nHöhere Portabilität führt zu zusätzlichem Aufwand, was im Widerspruch zu Effizienz steht. Folglich muss man abwägen was bei seiner Problemstellung wichtiger ist und demnach einen geeigneten Kompromiss für das Problem finden.",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1310094,
      "meta": {},
      "text": "During Software Engineering one may try to achieve all the design goals, however some of them conflict with each other. Examples are:\n1.Functionality and Usability: The more functionalities a system has the harder it will be to navigate it and find the specific feature you are looking for. An example for this is a system that only has 4 functionalities will only need four buttons on the main menu, but a system with 100 buttons will need either 100 buttons on the main menu or a nested interface, which makes navigating it very difficult, which reduces usability.\n2. Cost and Robustness: To make sure a system is robust a lot of test are needed and a lot of time spent coding the system or bug fixing the system to remove potential errors. This increases the costs by a lot since a lot of time and effort are spent on this task. For example a system were no edge cases are tested only need a few tests to be run, but if you wish to achieve maximum robustness, every possible input and edge case has to be tested at least once, which takes a lot of time and money.\n3. Rapid Development and Functionality: Many Customers wish their product to be done fast, however to achieve more functionality the developer team needs more time to create those functionalities. For example there is a huge speed difference between creating a restaurant finder with only a list, and a restaurant finder with integrated map, since the integration of the map takes more time.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1313089,
      "meta": {},
      "text": "A common trad-off is functionality vs. usability and my favourite example for this is Adobe Photoshop, compared to something like Paint.NET or GIMP. While the latter are easy to pick and almost anyone can edit pictures with them, they only allow relatively simple actions and additional plugins are often poorly optimised. In contrast, Photoshop is near incomprehensible when starting out, but once the user has invested enough time into learning the software, they can achieve unparalleled efficiency and amazing results. The question here remains, wether the software is made for professionals who have the time to invest into the software, or if the target demographic is more casual.\nEfficiency vs. portability is a common trade-off in game development lately, with the mobile gaming market being a large market, even compared to computer and consoles. Wanting to expand into said market however requires, that the game is toned down in graphics and gameplay, so that it runs on most phones, which in turn reduces the efficiency on more powerful platforms. An example for this is the remaster of Final Fantasy: Crystal Chronicles, which was barely improved at all, so that it runs on mobile devices.\nAlso prevalent in game development is the Rapid development vs functionality trade-off, most noticable in series like Call of Duty or Fifa, where a new game is released almost or every year, but the game is barely expanded upon, to be able to sell a new game every year.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1334889,
      "meta": {},
      "text": "Cost vs. Robustness is one of the most common and easy-to-understand concepts among design goal trade-offs. For example, you are deploying your application to a cloud machine billing you $500 per month. In order to increase robustness, you can duplicate that machine and put a load balancer between them. This both increases performance and if one of the machines other one covers the system meanwhile increasing availability hence robustness. However, this doubles the cost and creates extra maintainability costs.\n\nOne of the current trends rising along with the increase in mobile users is usability. You can add as many as functions you want. However, fitting those in a User Interface which enjoyable to use and easy to learn is a hard task. For example, you can manage almost anything about school on campus.tum.de however it is really hard to find the actions you want to take. Even with categories and search options, there are many applications and every application has many tabs and actions. So canpus.tum.de favored functionality rather than usability.\n\nRapid development vs. functionality debate is a popular one. You can gather more data, make more analyses, and prepare more functionalities but this results in longer and longer development time and fewer deliverables. Solutions like agile development are created to trickle down this trade-off. You can isolate functionalities and continuously deliver when they are ready. However this doe not remove the trade-off completely.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1336485,
      "meta": {},
      "text": "One of the more important design goal trade-offs is functionality and usability. This means that a software must find a sweet spot between having many features and its ease of use. Usability means the ease of use of an interface, whereas here functionality means the set of operations that an interface implements and supports. Having too many functionalities within one interface can be more difficult to learn and therefore less usable. This also increases the program's learning curve, making it user-unfriendly and unattractive.\n\nAnother tradeoff would be portability vs. efficiency. A portable software means a software product designed to be easily moved from one computing environment to another, while an efficient software means a software that has a strong performance. This is a design goal tradeoff, because optimizing a software on one specific environment through taking full advantage of the underlying hardware and caching memories tends to limit its portability, which in turn limits its potential marketability and also makes it harder to operate on any other environment by making it dependent on the one specific environment.\n\nAnother typical design goal trade-off is cost vs. robustness. Robustness here indicates the ability of a computer system to cope with errors and unusual conditions during execution. Creating a robust software with good integrity, that conforms to standards is typically associated with higher endured  expenses and costs. A maintainable software is also one that is constantly updated with better, more efficient techniques that requires stronger tech and better support, which is also associated with higher costs.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1344707,
      "meta": {},
      "text": "Backwards compatibility vs. Modifiability\nDer Client hat ein Interesse daran, dass die Software abwärtskompatibel ist. So können ältere Programmversionen zusammen mit neuen Versionen in einem Produktionsumfeld eingesetzt werden. Das Rollout kann somit schrittweise erfolgen und auch Endgeräte, deren Betriebssystem neue Softwareversionen möglicherweise nicht mehr unterstützt, können weiterhin betrieben werden. Für den Entwickler bedeutet das Mehraufwand und Einschränkungen. Sein Ziel ist die leichte Modifizierbarkeit von Software, die eingeschränkt wird, wenn beispielsweise Schnittstellen aufgrund von alten Programmversionen nicht verändert werden dürfen. Außerdem muss jeder Release zusätzlich in einer Umgebung mit alten Softwareversionen getestet werden.\n\nRapid development vs. Low cost\nDer Client wünscht meist eine schnellstmögliche Entwicklung der Software, da sobald die Anforderung entsteht, meistens schon ein Bedarf nach neuer Software herrscht. Gleichzeitig sollen jedoch die Kosten niedrig gehalten werden. Dies widerspricht der Tatsache, dass der Bedarf nach vielen kurzfristig verfügbaren Entwickler-Ressourcen die Kosten erhöht.\n\nRapid development vs. Low number of errors\nUm die Anzahl der Fehler zu reduzieren, sind ausgiebige Tests der fertigen Software notwendig. Dabei müssen viele verschiedene Anwendungsfälle bedacht werden, um das Verhalten der Software im Produktionsumfeld widerzuspiegeln und etwaige Fehler bemerken und beheben zu können. Dies erfordert einen hohen zeitlichen Aufwand, was dem Ziel einer kurzen Entwicklungszeit entgegensteht. Oft wird Software vor der Auslieferung dann nur unzureichend getestet, um den Liefertermin einzuhalten.\n",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1362126,
      "meta": {},
      "text": "Das erste Tradeoff, welches thematisiert wird, ist zwischen der Funktionalität eines Programms im Vergleich zur Entwicklungsdauer eben jenes Programms. Ist beispielsweise die Deadline bis zur Auslieferung des Programms schon sehr bald, so bleibt eben nur wenig Zeit viel zusätzliche Funktionen in das Programm einzubauen, da jede neue Funktion ja auch getestet und auch bugfrei sein sollte. Soll ein Spiel einer Firma beispielsweise in nur einem Jahr entwickelt werden, kann dieses natürlcih nur eine geringere Zahl an Funktionen (z.B. große Open World) als ein Spiel welches über 5 Jahre lang entwickelt wird.\n\nDas zweite Tradeoff ist zwischen den Kosten eines Programms und der Reusability des Programms. \nImplementiert ein Team beispielsweise die Physik eines Balles in einem Sportspiel, kann diese mit wenig Budget und somit auch begrenzter Enticklungszeit nur auf die für das Spiel notwendige Fälle bedacht entwickelt werden und so nicht mehr unbedingt in anderen Spielen wiederverwendet werden.\n\nDas letzte Tradeoff ist zwischen den Kosten und der Robustheit eines Programms. \nUm die Robustheit eines Programms, beispielsweise einer Nachrichtenwebsite, zu garantieren, ist natürlich ausgiebiges Testen der Software sowie auch das Abfangen vieler Randfälle etc. notwendig. Da dies alles Entwicklungszeit benötigt, in welcher auch die Entwickler bezahlt werden müssen, verursachtd dies natürlich zusätzliche Kosten.",
      "score": 75,
      "language": "GERMAN"
    },
    {
      "id": 1411702,
      "meta": {},
      "text": "Trade offs can happen anytime in design goal, especially, when some goals or principles contrast each other. For instance, cost vs reusability, rapid development vs functionality, functionality vs usability.\n\nRapid development vs functionality\nIn rapid development, process is done without any specific planning. Prioritized are development tasks that should be done in a short time, whereas functionality defines the functions that software must perform. For example, a client requires that a software must  have concrete functions and must be  completed in  2 weeks. In this case, we should find trade off because to develop a software product in such  short time with specific functionalities is tough. Either we should ask for more time, or give up on some functions.\n\nFunctionality vs usability\nFor example, a restaurant wants you to design a website, with such functions: Customers are able to make a reservation for desired date and time, after which, menu and overall number of reservations and free places in- and otside of restaurant for desired date should be shown and all customers should not have difficulties in order to access all this. \n\nCost vs reusability\nFor instance, a grocery store asks you to make some changes on their current website. They already have a general product catalogue, however, now they want seperate sections for \"discounted\", \"last pieces\", \"1+1\", \"new\" products with descripton of which goods and campaigns are in which branch currently available and they require that cost should not be high (approx. not more than 150 euros). In order to meet requiremets, additional coding and testing are unavoidably, which often result in high costs and exceds budget.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1432248,
      "meta": {},
      "text": "Firstly, there is a trade-off between functionality and usability. There are many different options and functions in software engineering depending on the software. For example, there is a need for software that needs many functions, like a physics simulator. Then it needs functions with many different parameters, options, and states.\nBut as the functionality of such a simulator grows, concurrently, complexity also rises. This makes it difficult to get the hang of the software. This implicates low usability as it is very hard to learn and use.\nSecondly, there is a very common trade-off between cost and reusability. Certainly, there are as many good software as bad ones. Depending on how much a client is willing to pay for something, the result will differ.\nIf there is not enough budget, then developers won't dedicate much of their time to thinking and making the software. The result will be an \"it will do just fine\". They won't take their time outlining the software structure because of the cost. Since there is no structure, the software will not be reusable as such but may need a lot of recoding to reuse some parts of it. But, if there is enough budget, then many possibilities will open up. There will be for example proper sprints, software outlining, and thinking on maintainability. A bigger project (cost) is lengthy and therefore also needs to be better structured, so reusability is a given in this case. The software will be reliable and maintainable.\nLastly, there is a trade-off between efficiency and portability. Software is mostly divided into platform-dependent and platform-independent. For example, software written in C for a specific Linux system will perform better on that exact machine and will be even better if optimized later on. But the downside of such software is the fact, that it only runs that smooth on that specific processor. If it is put into a different computer, then it will perform much worse. Then, if the software is written in Java, which uses JVM as a compiler, it will always be the same independent of the machine as it is all compiled virtually. But since it goes through one more step and needs to be interpreted first and then compiled, it runs much slower than an optimized software in C.\nSo here it goes, there is either more efficiency than portability or the other way around. But it is impossible to have both.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1445761,
      "meta": {},
      "text": "Functionality vs. usability\n  If you have a thousand functions in one place, the system clearly looses on usability.\n\nCost vs. reusability\n  Writing a program \"quick-and-dirty\" can significantly lower the initial cost,\n  but will lower quality and structure too, resulting in less reusablilty and maintainability  \n\nEfficiency vs. portability\n  Code written in C is often faster than Java, but can decrease portability.\n  Code written in Java is highly portable, but might not be that fast.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1634667,
      "meta": {},
      "text": "Note: this is from my last years homework: \n\nFirst design goal Trade-Off: The Client does not want to spend too much money on the software project (low costs). With less money, the developer does not use the maximum potential and time to develop the software the result the software is not as good as it might have been with more money in terms of the usage for the user e.g. in functionality or outlay, e.g. The customer of the Bumpers game set the cost of the project to a maximum of, e.g. 1.000€. Due to the cost limitation, the expensive developers are only able to implement the game with one car type, and one cohesion. There are no further functionalities implemented due to cost and therefore time limitations (remember \"time is money\"). The end user will not have much fun playing the game, the usability is low. \n\nSecond design goal Trade-Off: When it comes to developing software it takes time but there is a trade off between the functionality and the development duration. E.g. The customer wants the software to be as good as possible so that it can be sold well. The Developing team knows developing good software takes a certain amount of time. The more time the team has, the better the functionalities, reusability, adaptability etc. can be. The customer knows that a friend is bringing out a similar software in two years. Therefore the customer gives the team 1 year to develop this software to be first on the market. The software is finished after 1 year but is not very good since it does not have any special functionalities, the security of the software is not very good, sometimes the software crashes, etc. His friend brings out his software are 2 years and it is perfect, everybody who bough the customers software changes to the other because it is user-friendlier, the ease of learning is good for newbies and the functionalities are better than in the customer's software. \n\nThird design goal Trade-Off: Another trade-off is between usability and functionality. The more features/functions a software contains the less easiness in the usability. If the software has more functions it could make it difficult for the user to use the software easily i.e. the more operations are possible the more difficult it is for the end-user to use the software. Anna has no time to learn difficult systems she just wants software that she can install, is self-explanatory, and works without any further settings. So she buys a software solution for her online shop in order to improve the customer service and facilitate working processes for her employees. She wants to use the software and notices that the software offers so many different ways to add customers to the system for example or unuseful settings. Due to all these different functionalities, buttons and settings, etc Anna is overwhelmed and therefore just stays with the old email customer service. ",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1659666,
      "meta": {},
      "text": "Functionality vs. usability\nFor the user, the more functions a software has means the more difficult it is to use. The less usability of the software. If better and higher usability is needed, then certain functions must be discarded（off）.\nEfficiency vs. portability\nPortability in software development represents whether the software is used in different environments. The need for high portability will definitely affect the efficiency of software development. In order to make software highly portable, programmers need to make the application interfaces abstract and modular.\n\nRapid development vs. functionality \nFor example, a software project has a defined delivery date by which all functionality is required to be completed. However, sometimes it is not possible to complete all required functionality by the specified delivery date. The trade-off, in this case, is between the required functionality and the required schedule: is the system on time but not all the functionality completed, or is all the functionality completed but not developed fast enough?\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291699,
      "meta": {},
      "text": "1. functionality vs. usability\nAn application with too many functions might have an user unfriendly GUI, because it has to contain lots of buttons associated with those functionalities. Consequently, The usability of the app will decrease.\n2. cost vs. robustness\nLow cost is a design goal which simply conflicts with all of the quality requirements. The developers won't do it well if they are not paid well : (\n3. rapid development vs. maintainability\nIf the manager limits the development in a very short period, the developers won't have time to write good (readable) codes. If they want to add functions later, they have to deal with incomprehensible codes. Therefore, the maintenance will be difficult.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344116,
      "meta": {},
      "text": "To start off, functionality vs. usability is a very common design goal trade off. Whilst Functionality means how much function a system can provide, usability describes how good a system is to use, how easy it is for users to \"find their way\". \nAlot of functions may sound good and promising at first - but for new users this can be a huge issue. Only a few functions are much easier to handle and to understand. Its important to find a good and balanced solution for this. \nOne example could be how easy but still functional the notes app on the Iphone is designed. Its basicly just one big white paper where users can type their thoughts. Not really anything more but the basic function is given. Makes it very easy and intuitive. \n\nCost vs. robustness is the next design goal trade off. The software should be as robust as possible - no errors, bugs, etc. But is should also be as cheap as possible. \nA good example for this could be any banking/finance app. The development of the Paypal app should be of course as cheap as possible - but possible errors could damage the whole image of the company. Of course its also a big security issue when the app is not robust enough.\n\nEfficiency vs. portability, efficiency means how efficent a software is to do certain tasks or just run in general. portability describes how easy a software can adapt to different circumstances, different data types, etc.\nFor different programming languages there are different IDE's - no one would code python in intellij. Reason for this is to have a higher \"efficiency\", those software programs chose a deduction of the portability.\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344731,
      "meta": {},
      "text": "1- Cost vs Robustness\n    Assume you write a program that can cope with errors during execution and with erroneous inputs. However, \n    achieving this requires additional coding and testing costs.\n2- Efficiency vs. portability\n    In order to make our computer program run on all other platforms.  Making it potable requires more memory, \n    additional coding, and more time to run this program, which has a bad effect on the efficiency of the \n    program. \n3- Backward compatibility vs. readability\n     Making a new latest game compatible with the latest version of Xbox as well as the oldest version requires \n     additional coding and make it complex to read the code. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1440840,
      "meta": {},
      "text": "1. Viel Funktionalität vs. Einfach zu lernen:\n\tDer trade-off kommt zu stand, dadurch, dass ein Programm, dass sehr viele Funktionalitäten zur \n \tVerfügung stellt für Anfänger schwer zu erlernen/ schwer zu benutzen ist. Das kommt dadurch, dass man \n \tbei der Erstverwendung  sich mit dem Großteil eines Programms vertaut machen muss, um es Effizient \t \n \tnutzen zu können. Durch die große Anzahl der Funktionen dauert die Lernphase lange, dass Programm \t\t\t\t\t\t\t\t \n  \tist für Anfänger schwer zu bedienen.\n\tBsp. Das Programm \"Blender\" verfügt über eine sehr große Anzahl an Funktionalitäten. \n \tDementsprechend dauert es lange bis man es benutzen kann. \n\n2.  Entwicklungskosten vs. Portierbarkeit\n\tDie Entwicklung eines Programmes, dass auf beispielsweise mehreren Betriebssystemen laufen soll \t \t \t \n \tkostet Geld und Zeit,  durch den zusätzlichen Entwicklungs- und Testaufwand. Sind die \n \tEntwicklungskosten beschränkt,\tkann ein  Programm womöglich nur für ein Betriebssystem entwickelt \t\t \n \tund getestet werden. Dadurch wird die Portabilität eines Programms eingeschenkt.  \n\n3. Entwicklungszeit vs. Funktionalität\n\tIst die Entwicklungszeit für ein Produkt beschränkt und die Entwickler Anzahl wird nicht erhöht, so \n \tkönnen dementsprechend nur eine bestimmte Anzahl an Funktionen implementiert werden. Wird \n \tbeispielsweise die Entwicklungszeit für ein Programm verringert, so haben die Entwickler weniger Zeit \t \n \teine Vielzahl von Funktionen zu entwickeln und der Umfang an Funktionalität eines Produkt nimmt ab.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1468110,
      "meta": {},
      "text": "There are many design goal trade-offs. I would like to tell about three of them, namely reusability, robustness and scalability.\n\nThe first one to describe is reusability. This means the ability to reuse something already done. In the context of software engineering it is very important to make the code so clean and precise that other people (that are going to reuse your code) will not have ant problem to change things in that and understand it. For instance, it is important to avoid duplicated and not understandable code so that the other software developer has no difficulties by changing things in code.\n\nRobustness of the program is also a very important aspect. The software has to be robust and likely at low cost. For example, there has to be in best case no unexpected errors while using the program but in the same time the product is designed in the way so that it keeps working smoothly.\n\nScalability is the third one. It is also required that the design of the product is implemented for any amount of users. For example, the system has to work for 100 users as well as for 1000 users. The product will hopefully become more popular and the adaptation for a bigger group of users is thus also important.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1608667,
      "meta": {},
      "text": "1) \tRapid development vs. Reliability:\n\n\tIf developers are not given enough time to finish the software, it may end up faulty. \n\tExample:\tYou are developing a video game, but the time frame given for production is too short. To finish \t\t\n\tit in time, the development is rushed, which leads to multiple errors during the process and a half finished \t\n\tproduct with multiple bugs. \n\n2) \tFunctionality vs cost:\n\n\tIn software engineering, you have to weigh up between costs and functionalities. The more functions you \t\t\t\n\twant to implement, the more expensive the development process will become. \n\tExample: You want to implement a multiplayer into your game. Are you able to afford the additional costs \t\t\n\tof needed expenses like new servers?\n\n3) \tFunctionality vs runtime efficiency:\n\n\tA software with many functionalities may become very overloaded and thus lead to a slow and frustrating \n\texperience for the end user.\n\tExample: You are developing a powerful IDE, but are adding far too many functionalities. Because of that, \t\t\n\tyour software is very slow while starting up or while running the code.\n\n\t",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291701,
      "meta": {},
      "text": "Rapid development vs. functionality\nSoftware development, if done well, takes time.  When time is limited, not all desired functionalities may be feasible or implementable.\nFor instance, I took part in UnternehmerTUM's TechChallenge last year, and the goal was to improve digital communication in hospitals. Naturally, there are various ways this could be done, and countless functionalities that would improve the final product. However, due to the limited time (a few weeks), creating a holistic solution simply was not feasible. Thus, my team and I focussed on the development of only a few core functionalities.\n\nFunctionality vs. usability\nA key element of usability is learnability.  Naturally, a user will need longer to learn how to use a software with 100 features than one with 1 feature.\nHowever, only 1 feature may be too few to be valuable to the user. In last year's team exercise, the goal was to develop a simple game along the lines of a 1978 arcade classic (Space Invaders). Let's say the game only has one feature: moving left. To be succinct, the game would be useless and not entertaining. However, introducing 100 functionalities would make the game too complex to be understood quickly and, for example, violate the \"Keep it simple, stupid (KISS)\" principle.\n\nCost vs. robustness\nPreparing a software for all edge cases takes time and resources and will therefore not always be done in the beginning.\nFor example, my full name contains five separate words and a German Umlaut, and while I was registering to vote in the USA, the online signup system would sometimes crash.\n\nATTENTION: I took EIST last year, but sadly did not pass the final exam, and am therefore reusing my answer from last year (with some tweaks). Kind regards, Giulietta",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1293623,
      "meta": {},
      "text": "\nCost vs. robustness: While the client tries to develop a project at the lowest possible cost, it is of great advantage to the user if the system is robust. These two goals are contradictory in the sense that it is hardly possible to develop a system with low costs that can reasonably handle and process all errors .Because you need a lot of resources and time, which are both limited by the money factor.\n\nEfficiency vs. portability: While efficiency is very important to the client and the end user, portability is important to the user as well as the developer. These two goals are difficult to implement simultaneously, since a particular algorithm, a particular system always runs fastest on a specific device or a group of devices with similar architecture. Therefore, it is virtually impossible to make a system portable and efficient for all users (on different devices) at the same time.\n\nRapid development vs. functionality: While the client is concerned that a system be implemented as quickly as possible, the end user wants the functionality of the system to be as good as possible. It is logical that a system that is developed in a very short time does not provide the best possible functionality for the problem. From the user's point of view, such a system will never satisfy all users, so these goals are somewhat at odds with each other. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1297578,
      "meta": {},
      "text": "VIM is a notorious text editor with a plethora of functionalities especially compared to other text editors. Functionalities include instantly jumping to specific lines, words and relative positions in a text. To work efficiently, however, users must be able to quickly recall hundreds of input key combinations. There are notorious cases where users found themselves unable to quit VIM as they didn't knowing the ':q' quit command. This clearly showcases that VIM developers traded off much of the software's usability against pure functionality. \n\nThe gaming industry often applies rapid development to attract potential customers by trading off functionalities. Companies on steam often publish early beta versions of their games which intend to give players a glimpse of what's to come. The software usually still contains a substantial amount of bugs and a limited set of functionalities. By giving player's early access, they are essentially testing and funding the project. This method, however, runs the risk of giving the players a false early impression as perhaps they don't share the same vision as the developers.\n\nIncreasing the robustness of software systems always increases the cost. Clients and product owners want to hold down costs as much as possible, while users demand robust systems. Achieving a sufficient level of robustness involves a substantial amount of testing, which in turn involves costs in terms of development time or real-world testing. It is for instance essential that hospitals and other medical institutions are able to access patient records even in time of a power shortage or a similar disaster. Developers must simulate disasters to make sure that the software is working properly and for example install additional costly servers or emergency power. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1302323,
      "meta": {},
      "text": "Trade-offs are not only a crucial part of software engineering, but in every other area in our life. There is never a perfect solution to a problem, thus the ability to compromise plays a very important role and indicates the quality of the outcome.\nExample 1: Which architectural model solution is the most suitable for the already existing architecture?\nScenarios and models should be developed and compared to the existing architecture. Thereupon the engineers should evaluate all possible solutions based on different factors and chose what their find the most suitable. This decision can be very difficult, since multiple architectures might fit, but some might focus on point A whereas another have a stronger focus on point B.\n\nExample 2: A System is required to fulfill two different performance requirements: a fast execution of specific actions and a large storage space for customer data. \nSeveral different solutions, each with different impact on the performance of the system, were presented. One solution had an extremely fast execution time, but unfortunately a lower data storage space. Whereas another solution had a better storage space, but wasn’t that string in its execution time. \n\nExample 3: When should you stop testing?\nYou can never be sure your program is 100% correct, no matter how long you test. Therefore, it is important to discuss when the system is stable enough to present it to the customer. The longer you test, the higher the chance that the system does what it should do, but the more time and money it costs.\n",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1339397,
      "meta": {},
      "text": "Cost vs. Robustness \nExample: A low cost design may not check for different types of errors when the user enters a wrong input, which would follow to low robustness. But if the system has all functionalities and checks for errors, then the cost would increase.\n\nFunctionality vs. Usability\nExample: A large number of functions in an user interface can have hard learnability and would be difficult to use in user's perspective. On the other hand if the system has a few functions it won't be that useful to the users.\n\nCost vs. reusability\nExample: When a source code or a component of software system is being reused, the programers should make sure that everything is available and nothing is missing, because if not then the maintenance costs might be increased as the reused elements of the system may be incompatible with system changes.\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344621,
      "meta": {},
      "text": "1.: Functionality vs. usability describes the conflict between the ease of use for the user & the amount of operations available for the user. Focusing on functionality would mean: the system has so many functions, that it becomes uncomfortable/not as simple for the user to use anymore. For example: If we stacked our Bumpers Game with loads of different kind of game modes & new functionalities: -> a lot of variation, interesting to play, BUT not easy to use (player has to read through every different variation, maybe even scroll a lot to reach his desired gamemode)\n On the other hand, if there is only little functionality available: -> easy to use, BUT too bland for the user\n\n2. Cost vs. robustness describes the conflict between a cost (e.g. money of the client) & the robustness of a system (e.g. security against hacker attacks). When designing a more robust/stable system, the cost will increase, while if designed more cheaply, the system might be less reliable/robust. An example: Building a extremely secure system against hack-attacks (increase in robustness) means an increase in the cost (time + effort for developers, money for client)\n\n3. Rapid development vs. functionality is similar to functionality vs usability, but instead of usability it describes the conflict with the speed of development. When developing a system, the amount of functionality correlates with the amount spent to build the system. Example: A client wants a calculator, that only needs to be able to calculate \"+\" \"-\" \"*\" & \"/\". The time to develop this system is way shorter than the time needed to develop a detailed scientific calculator.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1426057,
      "meta": {},
      "text": "Functionality vs. usability: \nLet's say I'm implementing a game like bumpers  but a little different. Bumpers is very easy to play, nothing complicated, a game you can start by only clicking at most 3 buttons. But the game i'm implementing has a lot of settings you can adjust, e.g the volume of the music, how big the game window should be, which type of car you want, how it should look and how fast your car should drive, how many other cars you want in the game, etc.\nSo how useful is it to have so many options that you can't even decide what you want and spent so much time on the settings instead of playing the game?\n\n\nCost vs. robustness: \n A client only wants to spent very little money on developing a game. But the danger of that is a poorly programmed game that has a lot of bugs and errors and just looks horrible. So a decent implementation costs a decent amount of money. If a reqirement is wanting a robust game, it automatically leads to larger costs.\n\n\nRapid development vs. functionality: \nA similar case to the one before, a client wants a game but specifies a very short time limit until when it must be programmed. But implementing a game that works and runs flawlessly and also looks reasonably good takes time and can't just be done in a few days or weeks. So if the Team concentrates on implementing a game with a lot of functions, it won't be done in just 3 weeks. Functionality takes time, so wanting to be completely satisfied with both design goals is quite hard to achieve. One always has to suffer.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1469630,
      "meta": {},
      "text": "security <-> usability/user-friendlyness:\nIt would be safer to use session cookies or cookies with a max-age (that expires e.g. after a day), but the most users would find it annoying  to always log in into their account daily or everytime they closed the browser, so it should just be used by things were the security is even more important, for example for online banking.\n\naesthetic <-> usablity:\nIts nice to have a good looking webpage/app, but if the user cant instinctively find, what hes searching for (e.g. a too little exit button or hidden links to categorys that are advertised (but you cant click on links on them)) will annoy the user and he wont use this site/app.\n\nrapid development <-> functionality:\nIts no use being a ready on a destined dead-line, if the product will become because of the poor functionality a flop, if it could get much better with a little bit more time. Also if it has to be developed fast, there is a bigger chance of bugs, because the programmers act hectic.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1499227,
      "meta": {},
      "text": "Rapid development vs. functionality:\nIt is most of times good to be fast during the development.  By being rapid during the development you can for example discover unforeseen problems fast and might be able to steer against it. But on the other hand the functionality should not be to bad either. The fastest solution might be easy to code, but it could for example result in a slower algorithm.  An example for this would be a social media platform that reacts directly to how you rate videos and changes your recommendations in real time. If the algorithm works to slow the functionality might get bad, yet companies also have to develop fast. \n\nsecurity vs. usability:\nBoth security and usability are important but it might be for example very secure to ask a user of a chat service to re-authenticate every three hours and use two factor authentication, yet the user might get annoyed and switch to for which such a authentication is not necessary.\n\ncost vs. robustness:\nIt is good to reduce costs for obvious reasons. Also a system should be robust so that the customer can trust it and for example transactions on a bank account do not get lost unwanted. The hard thing is that it might not be possible to protect a system against every edge case that might happen because it gets to expensive.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1505279,
      "meta": {},
      "text": "Design goals often conflict with each other. that's why there are already typical design goal trade-offs. The first example I would like to name the cost vs. robustness. So, we all want to save some money and don't give a lot of money on additional coding and testing costs. Like in Bumpers, we don't want, that our right-for-left collision will work wrong, for example, the collision will be also from the bottom or left side. That will help to find the bugs and improve the code, which will work perfectly. But on the other side, we want, that our code will be robust to the wrong inputs when the user accidentally clicks not the left mouse button, but the right mouse button for the steering of the car. Another example from Bumpers - Is functionality vs. Usability. For the improving functionality, it is also possible to add more functions to the bumpers, like changing speed, deleting walls, and the possibility to steer more cars. It will be fine to have all these functions, but on the other side, it is not more usable. It is very hard for the player to lose attention during the game, so usability decrease. Rapid development vs. functionality is also a huge conflict. Developing the system at a high pace helps to reach the deadline and to save some costs on development. As an Example from Bumpers: quick development saves money and time but we will not have a right-for-left collision. Functionality decreases. Investing more time in Functionality, adding more collision types, speed changes, steering types, etc. decreases our rapidness and so on and so on.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1661436,
      "meta": {},
      "text": "Functionality vs Usability\n- usability describes the ease of use. functionality in a sense describes the number of operations possible\n- they don't go hand in hand because usability limits and simplifies functionality.\n- subway has that problem. the customisation options (functionality) overpowers the usability because there are just too many options to choose from and it gets very overwhelming.\n\nCost vs Robustness\n- cost is the monetary price of the software, robustness describes for example how well the program handles false inputs etc.\n- a game which had little budget will probably be subsceptible to bugs, glitches and exploits, whereas a game with a lot of budget, for example rainbow six siege, which is known for its very good anticheat, will be more robust but also way more expensive.\n\nRapid development vs Functionality\n- rapid development focuses on quick development or prototyping to lay the foundation of the software\n- therefore it focusses only on the integral parts of the software and goes against functionality\n- our first prototype of the eist project will for example have only a few functions like searching for restaurants and make a reservation, other functionalities like filtering etc are secondary and will come afterwards",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1663517,
      "meta": {},
      "text": "Design goals come from client, end user and developer. Since they all have different goals there are trade-offs between them.\n1. User-Friendliness vs. Low cost\nFor the end user it is critical to have a user friendly interface, for example being able to reach the extensions within the website and not having to use multiple websites. However, implementing this feature would increase the costs, which is not wanted by the client\n\n2. Functionality vs. Usability\nA system can offer thousands of functions however, memorising all these functions and putting into use is not practical for the end user. Increased amount of functions does not always mean increased usability\n\n3. Functionality vs. Ease of Learning\nJust like example 2, the more functions a system has does not mean that it is easy for the user to learn. \n\n\n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291344,
      "meta": {},
      "text": "Cost vs. robustness: Robustness is defined as a property for an application to be strong and in good condition. With limited budged the design of a robust system cannot be guaranteed, because time, money and results/performance are heavily bound to each other. They are also known as \"Magisches Dreieck\", where the change of one of the parameter can modify the whole project: e.g. by creating a crash save app (=robust), the work time (for optimization) will increase and the associated costs will also rise (pay employees for a longer time-period).\n\nFunctionality vs. usability: Many functionalities (=operations/options) mean a lot of options to choose from, in the menu. This will automatically decrease the usability (=ease of use), due to the high amount of options/settings. Mostly the software engineer needs to rethink which end user will use the application. If the user is advanced, many functionalities should be implemented, otherwise the usability is more important. For example a chat system has as target group of mostly unexperienced users. Extra functionalities, such as overlay settings for calls would be superfluous.\n\nRapid development vs. functionality: If you want to deploy your application faster, you have to defer some (mostly lavish) functionalities, since those, as a rule, take longer to develop. For example, if you want to deploy a workout app with animations for each exercise, you will most likely skip the implementation of the animations since they are  very time-consuming and can easily be replaced with pictures.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1318499,
      "meta": {},
      "text": "In my last internship, we made a data analyzer for a nontechnical team. The first trade off that I encountered during design is usability vs. functionality. Since the end users will be not so technical people, we must keep the application as easy to use as possible. But in this case we couldn't have wide range of analysis and parameters. After discussions, we decided to keep the parameters simple for the end users but at the end we had less number of parameters to analyse. \n\nAnother trade off is that, we had a relatively short time to implement the project. So we disccussed about if the analyzer should be usable by other teams of the company that has different systems, or just the targeted team. Because if we try to implement for all the teams of company and different systems, it will take more time. Unfortunately we had 1 month because of the policies. That's why we choose rapid development instead of portability.\n\nWe also discussed about efficiency vs. robustness. If you want your program to be execute properly even in edge cases, you shouldn't expect perfect efficiency. Because the more you try to make your program cover all cases, the more you write code and this reduces efficiency. In this case we choose robustness when we consider the end users. So at the end our data analyzer was not super fast, but it had lots of checks and error handling functions to keep the program safe.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1332171,
      "meta": {},
      "text": "Ein typischer design goal trade-off ist ein trade-off zwischen Kosten und Robustheit. So muss man eine Balance finden um das Produkt robust aber dennoch preislich bezahlbar zu gestalten. Zum Beispiel läuft ein teures Programm stabiler als ein billigeres da es beispielsweise selbstständige Cleaner eingebaut hat, wodurch das System nicht so häufig abstürzt. Trotzdem sollte das stabile Programm nicht zu teuer sein da es sonst niemand kaufen würde. \nEin anderer Fall, ist der trade-off zwischen Functionality und usability. Eine App soll zum Beispiel möglichst viele Funktionen haben, muss aber für den Nutzer trotzdem bedienungsfreundlich gestaltet werden. Gestaltet man so eine App, sollte man sich auf die wichtigsten Funktionen beschränken um den Nutzer nicht zu überfordern. Demnach sollte die App beispielsweise im Menü nur 5 verschiedene Auswahlmöglichkeiten haben, wodurch die Vielzahl der Funktionalität ggf. eingeschränkt wird, aber der Nutzer keine Bedienungsschwierigkeiten bekommt.\n\nEin dritter typischer trade-off ist Efficiency vs. portability. Ein Laptop sollte zum Beispiel nicht zu schwer und zu groß sein, da viele Nutzer ihn mit zur Arbeit oder Uni transportieren müssen. Trotzdem sollte die Leistungsfähigkeit keine Abstriche aufgrund der Größe machen. Der Ausgleich zwischen Leistung und Tragbarkeit z.b. Größe und Gewicht muss gut kalkuliert werden.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344164,
      "meta": {},
      "text": "1. design goal trade-off: Functionality vs. usability\nAn infamous example for this trade-off is the terminal text editor vim. While being extremely powerful and providing countless features, it is pretty advanced and complicated to use when compared to a simpler editor like nano. The big number of features and key bindings simply overwhelm users (especially newer ones), crowd the user interface and overall decrease the usability of the editor.\n\n2. design goal trade-off: Efficiency vs. portability\nThis trade-off comes to play e.g. when deciding which programming language to use for a particular software development project. Typically, programming languages that are close to the machine like C or C++ (so-called low-level programming languages) are more efficient. However, these provide less abstraction and have to be adapted to the specific operating system they are running on. Thus, they might not run as well or not at all on different machines leading to less portability. Higher-level programming languages like Java on the other hand are very portable but usually sacrifice a bit of efficiency/performance.\n\n3. design goal trade-off: Rapid development vs. functionality\nThe reasoning behind this trade-off is pretty straight-forward. The quicker software has to be developed the less time developers have to extend the functionality of the system. An example for this might be the \"Corona-Warn-App\" which had to be developed rapidly to react to the pandemic. However, as a result the application focused mainly on the necessary basic features. The functionality was then extended in later updates.\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344673,
      "meta": {},
      "text": "1. One trade-off is that of a fast developmend and delivery vs its functionality. The client says that he wants the product in a very short time. The software engineering team has to decide how many functionalities they can add, they decide which are the important ones and which ones are the ones that require the least amount of time compared to their importance.\n2. Another trade-off is security vs ease of use. For the big companies security is of course more important then ease of use but for the smaller it might be umgekehrt. In the bumpers app since it is a very small project the security doesnt play a lot of a role since ease off use is the top goal of this project. For a bank website for example multiple identifications are required since the data is very sensitive and this the wealth of a person we are talking about.\n3. Appearance vs usability. Both are very important. Sometimes the user neglects some small usability issues when they like the visual interface. In the bumpers example if you spend too much time on the visual interface you might miss something in the usability part for example movement could be made smoother if more time was spend on the functions and the game would be easier to learn and understand for new users.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1372662,
      "meta": {},
      "text": "Typical design goal trade-offs often occur due to a limited timeframe. Imagine for example TUM would approach you to write an app for the students which should be ready for the upcoming winter semester. However, the timeframe is way too small to be able to implement all functionalities. In consequence, we end up with one of the most common design goal trade-offs: The product is ready for release at the specified deadline, but only includes a small amount of the functionalities that we're originally required. In the example of the TUM app, TUM would also like to have a perfectly working software with strict security measures to be able to ensure data security to the students according to the DSGVO. However, since TUM does not generate any revenue from the app, the development cost should be comparatively low. In consequence, really thorough functionality tests and especially costly security tests might be skipped in favour of lower implementation costs, so you end up with a less robust product. The third common design goal trade-off has to do with costs again: TUM would also like the app to be able to be run in virtual realities since they expect the technology to take over within the next 15 years. However, no-one can predict what requirements will be there by that technology, such that future-proofing the software comes with high implementation costs. In consequence, there will be a trade-off, such that the app is save to run on all current systems for the next 5 years.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1428762,
      "meta": {},
      "text": "1)Functionality vs usability : \nIt's respecting what the software is supposed to do with ensuring that it is easy enough for the user to use the system.\nexample : A big company when designing a new phone with new futuristic features has to make sure that these features are correctly implemented while making sure it's presented in an understandable and not complicated way to the user.\n2) Cost vs re-usability :\nSystem would preferably be reusable without it indulging a lot of expenses.\nexample : Reusable coffee cups without spending too much on the material used.\n3) rapid development vs functionality :\nThe project has to be developed within the deadline and respect the initial time frame while at the same time providing the intended functionality.\nexample : developing an app with all the wanted features in a time crunch of 3 three months given by the client.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1432366,
      "meta": {},
      "text": "1. Safety vs. rapid development\nA software with data locally stored is faster to develop, especially when we can avoid synchronizing data with the one stored on the server or in the database.\nOn the other hand, if we want to avoid the possibilty of data manipulating it is crucial to synchronize such things. Having our data stored in the database guarded by encryption system is much, much safer.\n\n2. Cost vs. performance\nOur software requires us to provide a decent dedicated servers to keep the whole thing running, which generates costs - as well as further optimizations. In some cases that cost is too high and we accept the performance drops which saves us some euros.\nAgain though, if the performance is crucial for our client and end users or we expect more users in the near future - the performance is crucial and we have to both optimize the software even better.\n\n3. Functionality vs. usability\nDevelopers sometimes forget about the users perspective and whether the system is easy enough to understand and quickly adapt to it. People tend to prefer less functions but more clear to them, while the devs sometimes opt for as many functions as possible.\nLess functions but easy to read and find documentation or description seems to be a good balance. Even better if users can understand it on their own.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1437891,
      "meta": {},
      "text": "1) cost vs reliability :\nFor exemple hosting a system in many different regions comes at a cost since the data transfer is costly compared to single region availability.\n2)Rapid development vs. functionality: \ndeveloping applications rapidly definately has an impact on the funcionality of the system. Delivering fast also means missing some functionalities or having some flaws, this problem would be solved based on the constant feed back.\n3)Security vs usability: \nSecurity can come at the cost of some ease of use sometimes like for exemple chosing a password for an account with all the rules one has to follow to generate a valid password.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1506576,
      "meta": {},
      "text": "1: rapid development/functionality: a client asks a developer to have an android application for an online grocery store in one week. The developer will have to sacrifice whether a lot of the requirements that the system needs or do the job in longer period of time.\n2:efficiency/portability: the most efficient software are rarely portable such as video games that need highly performant computers to run efficiently .(most of the time, laptops are not really recommended for gaming)\n3:",
      "score": 33.3,
      "language": null
    },
    {
      "id": 1331862,
      "meta": {},
      "text": "1. Usability/Functionality\nWhen creating a product it is not always easy to balance usability and functionality. A large number of features in a single user interface can be inconvenient, making it more challenging to learn and use. Simply removing functions or burying them in obscure locations makes the interface less powerful. The trade-off should consider the importance of features. As an example, one can just imagine Photoshop toolbar: in this case functionality was obviously of a greater significance than a minimalistic interface.\n2. Efficiency/Portability\nWhen efficiency is prioritized over portability, nonportable code is developed, while selecting portability often results in software whose performance is unsatisfactory. An efficient software doesn't care about portability issues, taking advantage of the underlying hardware.  (source: https://flylib.com/books/en/2.506.1.28/1/)\nAlthough efficiency is important, the benefit of portability overweights in many systems. The cause is more financial than technical: in today's market, software that only runs on one architecture severely limits its relevance.\n3. Cost/Reusability \nA good project should be reusable, but it's not always profitable. Writing a general-purpose abstracted component takes much more time, and therefore more money. On the other hand, it is easier to maintain, as a reusable code will most probably be intuitive.\nAs an example, we can take a purchase of shoes of different price categories. In the case of expensive shoes, they will last longer, but the price may not be justified. \n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1334913,
      "meta": {},
      "text": "Cost vs. robustness:\nLets say you get an order to program an app that in some way has to do with online money transactions. It is a good idea to make the app as robust as possible so its not that easy to make it crash or even make it as hard as possible for one to even \"attack\" it purposely. The consequence will be that costs and effort in making the app as robust as possible will rise, so you basically have to accept that both design goals (robustness and low cost) are really hard to both fulfil.\n\nRapid development vs functionality:\nIf your client wants an app to be ready within a small amount of time, its likely that the app is not going to have a lot of complex functionality. A high amount of functionality means more testing and more developing which results in more time --> so these two design goals are also a typical example for trade offs in development.\n\nFunctionality vs usability:\nLets say you make an app for elderly people to for example learn more about modern technology, one design goal might be to design the app in a way so people with almost no knowledge of technology are still able to use it and not be overwhelmed by a lot of different options on the GUI, if you define good usability like that in this scenario it automatically means less functionality.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344156,
      "meta": {},
      "text": "Rapid development vs. Functionality:\nThe goal of rapid development is to come up with a prototype in a short amount of time. In order to achieve this it is often not possible to implement all the desired functionalities.\nIf you have to present a first prototype to a client it would be better to choose rapid development over functionality. Your first prototype of an app could only have the pssibility to log in to your account.\n\nEfficiency vs. portability:\nPortability results in more abstracted software while the best efficiency is achievied if the software is designed for a specific operating system/hardware.\nPortability is very important if the software will be used on different operating systems by the end-users .\nIf you know that the software will only be used on a specific operating system and hardware efficiency would of course be more important than portability.\n\nFunctionality vs. usability:\nFunctionality can have a negative impact on the usability of an application.\nIf you develop an application with a lot of features it can become confusing for the end-user and decrease the learnability and user-friendliness. To choose between these two you have to know your customers and their needs. For example if the application is for professionals functionality is more important than a simple UI and easy learnability.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344462,
      "meta": {},
      "text": "1) Functionality vs. usability: One of the biggest problems for Start-Ups or other companies is finding the perfect balance between adding enough features to keep the product interesting but also keeping the product lean enough so the target group can use it. F.e. when making a Camera App, you have to provide, foto, video, maybe slow-mo and pro mode, but the more features you add, the harder it is to make it possible to access all of it easily.\n\n2) Cost vs. robustness: Aswell as in Hard - and Software, this conflict describes the problem of resources (Cost) vs robustness (security, quality ...). If you build a wall, the more robust concrete will cost more, if you build an App, more developers or a longer period will yield a more robust result, but also make the process more costly.\n\n3) Efficiency vs. portability: To be most efficient, everybody or everything should do the one thing that they do best. The problem is, that when you want to make something portable, f.e. a Smartphone, I can't have all the things a computer has, because it needs to be smaller and lighter. That leads to compromises when it comes to choosing the different parts, and that leads to a lack of efficiency to make the device portable.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1347506,
      "meta": {},
      "text": "1.Cost vs. robustness\nIf a software product needs to have a strong robustness, then it is relatively expensive and high cost.  The ability of a system to maintain a function takes lots of time and money. But if a project only have little and limited budget, then its robustness will be definitely not that good.\nExample : A software engineering project has only limited budget.It is way less than it should be, because the client want to spend a low cost on this product. But there is a relatively high requirement for robustness. \n\n2.Rapid development vs. functionality\nRapid development is frequently asked and preferred by client , however it influences the functionality of the product. When the development only finished in a short time, the functionality could not be fully and well done.There must be some flaws in it.And a fully-developed functionality in a product needs lots of time to construct and finish. \nExample : A software engineering team is assigned with an emergency mission to build a full-function software for a client. The functionality requirement is strict in the project.But they only have 3 days to finish it. Only the structure designs and models should take 2 days for this specific software. \n\n3.Functionality vs. usability\nFunctionality is useful, but too much of it can cause complexity. The end users do not even know how to use it. It should be able to exit the product no more than 3 clicks, but because of too many functions, it may takes 20 clicks to exit it, therefore the usability is really bad.In this case the ease with which actors can use system functions is not good.\nExample : The developing team is asked to produce a product with diversified functions , which is already up to 100 different small functions . But the product should also have usability. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1377639,
      "meta": {},
      "text": "Cost vs Reusability\nIt is quite rare to find reusable software information with low costs. For example, I have a calculator program like WolframAlpha and I've made some reusable mathematical codes. For the codes to be implemented on a graphing program like GeoGebra, I need to make sure and  test it all over again so that it doesn't mess up the new program. More testing means more money. For something to be reusable, it is expensive and to make something reusable, the sacrifice would be budget.\n\nCost vs Robustness\nUsually, expensive softwares are robust. The more money put into the development of the software, the more capable it is to overcome challenges. For example, a one-man-made game which has a low budget usually has many bugs and therefore is not that robust. Compared to big game companies, like Nintendo, EA, Riot who spend more money, their games are more robust. Therefore, it can be called a trade-off. To make a software more robust, more money is needed.\n\nFunctionality vs Usability\nA good application might include many functionalities. Imagine a travel application has many functionalities like map navigation, ticket reservation, accomodation reservation, attraction search and filter, and many more. It would be amazing, but for people to learn how to use it, it's going to be very hard. That means to just reserve ticket, one might need more than 4 clicks. It takes longer to become familiar with the interface. That's a trade-off.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1490131,
      "meta": {},
      "text": "1) Functionality vs. usability\nEine Anwedung sollte viele Funktionen und Möglichkeiten für den Nutzer bieten. Das birgt allerdings die Gefahr, dass es unübersichtlich für den Nutzer wird. Für viele Funktionen benötigt man z.B. viele Buttons. Das macht es unübersichtlich und schwer verständlich.\nMan muss also einen Mittelweg finden, sodass der Nutzer viel machen kann aber die Anwendung trotzdem einfach zu bedienen ist.\n2) Cost vs. robustness\nEin wichtiges Element ist die Stabilität einer Anwendung. Z.B. für Facebook ist es wichtig, dass die Server nicht ausfallen daher nutzen sie mehrere Server um sich abzusicher. Das kostet natürlich auch mehr Geld (Wartung etc.).\nFür kleinere Firmen könnte das zu einem Problem werden, wenn sie nicht so viel Geld dafür haben. Hier muss man abwägen, wie man die Robustheit hinbekommt mit dem vorhandenen Budget.\n3) Rapid development vs. functionality\nDie meisten Auftraggeber wollen natürlich dass ihr Projekt schnell entwickelt wird. Allerdings will man natürlich auch viele Funktionen und vor allem eine gut funktionierende functionallity haben. Dies benötig aber Zeit um das fehlerfrei umzusetzen. Jetzt muss man wieder abwägen, wie lange man auf das Produkt warten kann und wie viele und wie gut die Funktionalität sein soll.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1331253,
      "meta": {},
      "text": "Memory space vs. response time: There is a design trade-off when deciding whether to priotize a fast response time or meeting memory space constraints. For example, when the Bumpers game is working to slow, more memory space can be expended to speed it up. On the other hand, when the costs of speed are to high and memory space constraints are not met, data can be compressed, which will of course slow down the game.\n\n\nDelivery time vs. functionality: When the bumpers game development is taking more time than expected and the SCRUM team runs behind schedule, it must be decided whether less functionality of the software will be delivered or the deadline will be postponed, in order to deliver full functionality. In the example, it is possible that a in-game special collision type idea will be dropped, in order to meet the deadline vs. the deadline will be extended to include the feature.\n\nDelivery time vs. resources: When the project development is running behind schedule, it can be beneficial to include more staff resources (developers) on the project to speed up the delivery. For example, one additional developer will be added to the Bumpers SCRUM team. However, with more members in the project team, the cost of development will increase and it must be weighed against the additional productivity, because new members require time to achieve their full potential (training, project on-boarding, etc.).",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1335802,
      "meta": {},
      "text": "Rapid development vs. functionality: Either you develop the system as fast as you could but you have to minimize the functionality or you focus on the functionality so your system does have extra functionality to help the user with the system. For example you only implement the given methods based on the requirements so you are done within one week or you implement some additional functions so the given methods are faster or the user has a better experience.\nCost vs. robustness: Its a trade-off for how stable is your system with the given user input or the given input of another system vs how much money does it cost to make the system more robust. So you either have to pay more money to strengthen the system or your system could collapse at some point.\nFunctionality vs. usability: It is something like how many function does one system have vs how the customer for example is able to use it. Your system can have a lot of different functions but additional functions lead to more code that leads to more complicated code that leads to other people might not understand your code anymore. But usability alone leads to more easier functions so one may not get the best result without a lot of functionality.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344059,
      "meta": {},
      "text": "1. Cost vs. robustness\nAn example would be how much time and money is spent in the first 12 months of the software development on making sure that the software meets high standards of performance and is able to cope with errors during execution and cope with wrong inputs. It may make more sense on building a great user experience that will bring revenues. It is difficult to demonstrate performance and hence win clients that way. The cost of a software system can be measured by the effort required to develop a software system.\n \n2. Rapid development vs. functionality\nThe trade off is more around the methodology of development. Does the team use agile scrum development techniques with quick feedback cycles or does the team have long cycle of development based on very detailed product functional requirements? The end objective is to build functionality that meets user expectations and actually improves the product.\nDeveloping a production prototype (last step before mass production) is a trade-off between both, as it should be done fast but also show its functional capabilities.\n \n3. Efficiency vs. portability\nThat is a huge trade off. In the cloud-based software space it is often more efficient to develop the software on a single cloud platform like Azur or AWS. Portability, which is the possibility to use the same software in different environments, can be a big advantage but requires a great deal effort as supporting different cloud based platforms represents a huge effort. ",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344170,
      "meta": {},
      "text": "Sometimes design goals can be in conflict of each other, that is why design goal trade-offs are typical in sofware engineering. In order to have at least one of the design goals achieved, the development team must compromise and in cases give up some of the design goals\n\n1. Cost vs. robustness\nIn order to have a stable software product, a lot of testing is required. But too much testing could lead to higher development costs. Which is why software development teams need to decide what level of stability considered as \"stable enough\".\n\n2. Functionality vs. usability\nToo many functions in a sofware could compromise the usability of the product. Too many functions in for example a university app could make it hard for the user to learn all these functions and keep the functions in mind. They could forget about the existence of such functions after a while and use only 10% of the available functionalities, that are most frequently used by them.\n\n3. Rapid development vs. functionality\nImplementing a functionality takes time and effort. When too many complicated functions are being developed it costs a lot of time and time costs a lot of money. On the other hand, not all requirements of end-users may be met when rapid development favored. When making an app for events in a short-term, being on time is essential. At the same time, the developers may have to give up some functions to stay in the given timeframe.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344669,
      "meta": {},
      "text": "- Cost vs reusability:\n\tWriting good code takes time and therefore costs money for the companies. The less money is spent on a project, the less the code's quality is gonna be. Bad code is not gonna have proper distribution of classes and methods and is gonna be really difficult to understand for other programmers. This means that if the code needs to be modified later on, it is going to be really difficult to do so.\n\n- Functionality vs usability:\n\tWhen giving the user more options to work with, it is going to be more difficult to understand what button does what. When simplifying a complex program by removing functionalities and operations the user has access to, the usability gets increased and the program is a lot clearer and easier to understand.\n\n- Rapid development vs functionality:\t\n\tThe less time developers have to design a software, the less functionalities it is gonna have. If you would like to create a computer game and give the development team 6 months of time to deliver a finished product, it is going to be nowhere close to a game developed over the course of 5 years with multiple development and test cycles.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1348247,
      "meta": {},
      "text": "The probably most typical design goal trade-off is a conflict between a client wishing for a product at low cost and the functionality of the systems, which increases the cost of the system development. Another example is a trade-off of functionality vs. usability: many functionalities should be available, but the layout should be kept as simple as possible and easy to learn. The last example is a conflict between rapid development and again the low cost of system development.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1351822,
      "meta": {},
      "text": "One typical design goal trade-off is fast development vs. functionality. Often the customer wants a lot of different functionalities in his system, but wants you to code it in a limited time frame. This will often conflict, because of course you need more time to add more functionalities and at some point there is just no way to add more functionalities in the time given and thus they either need to be cut or the deadline needs to be extended.\n\nAnother design goal trade-off would be the trade-off between functionality and usability. Adding more functions to a program is often asked by customers and experienced users, but it will often conflict with usability, because new users will be overwhelmed by the amount of functionalities. The other way around experienced users will at some point request more features as the basic ones are not enough anymore.\n\nA third one would be the trade-off between the efficiency of a system and portability. If you want to make a program more efficient for one system you will loose functionality in terms of portability as different systems require different types of efficiency improvements. For example trying to improve efficiency in one operating system will decrease your portability into another operating system as it gets more and more specialized in this operating system.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1654759,
      "meta": {},
      "text": "One design trade of is functionality vs. usability.  Microsoft Excel provides a massive amount of functionality for the users spanning from simple data formating to professional macro development. Because of this massive amount the levels of list menus in the application are very vast & often not very user friendly to keep an overview. Therefore usability is only given for very experienced users being able to retrieve known functions in the menu jungle. Inexperienced users doing time consuming tasks manually even often omit simple prebuild solutions like pivot table column summaries due to the massive functionality overload potentially leading to pure software avoidance. On the contrary, a functionality limitation to have less-leveled menus would destroy the vast application possibilites of Excel.\n\nAnother design trade off is cost vs. robustness. For an online banking application it is very important that the software is robust in terms of handling  user inputs regarding user authentification PIN or banking account IBAN numbers for transfers. Here the software needs to be robust to refuse system entry for wrong authentification and to check IBAN numbers for number format consistency and account existence. In cases of invalid inputs the system should not break but alert the user in an appropriate way. But this kind of backup and security functionalities always come with additional programming effort resulting in higher development cost.  \n\nA third trade of is rapid development vs. functionality. Usually ERP systems can come in different application versions regarding provided functionalities & adaptedness to customer processes. While the standard software version of Oracle ERP can be delivered fast & be implemented in a short term project, this will only provide standardized basic process functionalities. If the company wants a highly adapted ERP system tailored to its internal process structure, a lot of customizing spanning over different ERP modules involving much organisational reconciliation is necessary. This specialisation hampers the possible use of rapid prototyping and leads to a software development project's delivery spanning over several years. \n\n(taken and adapted from own submission last year H04E03)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290837,
      "meta": {},
      "text": "1) Cost vs. Robustness concerns how costly one application can turn out to be with respect to how \"far-reaching\" are some of the app's functionalities. For example, at an early stage startup, its Minimum Viable Product (MVP) might have user interface responsiveness implemented for one type of screen only (say Computers). Hence, the app's interface does not cover all edges cases of screen sizes that one user might be accessing their product via (e.g. Smartphone screen).\n\n2) Cost vs. Reusability concerns how costly one application can turn out to be with respect to how reusable are the functionalities of the same app. Consider the same MVP as before, now assume it uses a very primitive stack which was very cheap to build upon. Now, imagine that they want to expand and finally implement an Integration to a specific system via an API. Unfortunatly, the same stack is not compatible with the target system. Hence, very few app components will be reused.\n\n3) Functionality vs. Usability concerns how is the user experireince \"damaged / dispersed\" over the number of functionalities an application has. Consider the same MVP as before, imagine that their app has a navigation bar with 10 different use cases buttons, but 3 of these are actually a subset of a fourth use case and 1 is not used by any of the user groups. So why not, display these 3 use cases in a dropdown button, making the navigation bar more friendly with 7 buttons and maybe remove the one button whose functionality is at the moment useless?",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291946,
      "meta": {},
      "text": "1. functionality vs. usability -> apps with a lot of functionality are often more complex -> e.g. when you look at adobe photoshop for the first time you might be overwhelmed due to the huge amount of buttons and functionalities you could use, which leads to a bad usability\n\n2. cost vs. robustness -> cheaper products are often less robust -> e.g. a cheaper phone will often have less water resistance etc.\n\n3. rapid development vs. functionality -> a firm wants their system to be built very quickly, as they can start selling it earlier then. this can lead to the functionality (which is a crucial part of the system) to be worse and vice versa -> for example when you buy a car that just came onto the market, often there are a lot of technical difficulties in the beginning and the satnav etc. might not work properly yet",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292854,
      "meta": {},
      "text": "1. Rapid development vs. Functionality\n\nCompanies nowadays pay a lot of money for having a software developed for the purposes of the company. Moreover, demanding on short deadlines doesn't mean that the developed application will have the desired functionality. Meaning that firms expect fast delivery of a product in exchange of enormous amount of money. On the one hand, there is product that is fast developed, but on the other hand, there could be a lot of bugs and the functionality can be not as expected (as described in the problem statement) because of lack of time.\n\n2. Functionality vs. Usability\n\nSometimes companies demand a lot of features in a software they want. For example, a mobile application for TUM can have a wide functionality because each role in the uni (student, tutor, lector, staff) has different needs. However, if there are too many functions, the app can become unusable, meaning that the end user is going to need more than 5 clicks to finish his/her task. Moreover, it makes the software unmemorable and it wouldn't bring any satisfaction to the user. But on the other hand, the end user will be able to do a lot of useful tasks with this app.\n\n3. Efficiency vs. Portability\n\nNowadays if you have your software support various platforms with different operating systems, surely you're going to have a broader audience and more end users. For example, if I port a software from Windows to Linux there is possibility that the application will lose its efficiency, meaning that it would become harder to interact with if you are inexperienced. However, the company is going to have the advantage of having its software support two OSs.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1298863,
      "meta": {},
      "text": "Ein häufiges trade-off besteht auf Cost vs. Reusablity. Dabei will der Developer immer ein möglichst wieder verwendbaren Code schreiben, den er z.B. für andere Projekte dieser Art verwenden kann oder aber auch weiter daran im selben Projekt arbeiten kann. Der Client wiederum möchte aber möglichst billig ein Produkt erwerben, was den Developer dazu bringt, Code zu schreiben, der nicht wieder verwendbar ist, da es an Struktur und Lesbarkeit mangelt. \nZum Beispiel bei den alten Pokemonspielen hat zu wenig Geld für zu wenig Struktur gesorgt, sodass nur durch externe Hilfe neue Teile herausgebracht werden konnten, da der Code ansonsten zu durcheinander war, um darauf neue Features aufzubauen.\n\nÄhnlich verläuft es sich bei Cost vs. Robustness, wobei der Client wieder ein möglichst billig produziertes Produkt haben möchte. Dies führt dann aber meistens zu einem Mangel an Tests, die durchgeführt werden, sodass das Endprodukt fehleranfälliger ist.\nEin Beispiel hierbei wäre die Computerspielindustrie in der durch zu wenig Zeit und Geld Cyberpunk mit viel zu vielen Fehlern auf den Markt kam. Mit mehr Geld hätten die Entwickler erst alle Bugs fixen und dann das Spiel veröffentlichen können als andersherum wie es in der Realität passiert ist.\n\nEin weiteres trade-off besteht in Functionallity vs. Usability. Dabei soll ein System einerseits viele Dinge gleichzeitig bewerkstelligen, allerdings will der Nutzer dieses möglichst einfach verstehen und benutzen können.\nSo bietet z.B. das MOBA League of Legends sehr viele Features mit über 150 Champions mit je 5 Fähigkeiten, besitzt damit aber eine schreckliche Usability für neue Spieler, da es eine lange Zeit benötigt, um alles zu überblicken. \n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1383906,
      "meta": {},
      "text": "Everything is a Tradeoff in Software Engineering\n\nBackward compatibility vs. Minimum # of errors\nA new software product is considered backward compatible when it is able to read, write or view older formats. But with every update, there are new functionalities added and old ones changed. With every change, there is a possibility for an error. An example of this will be Windows: Windows 10/11 can run a lot of applications for Windows XP, but they often crash.\n\nUsability vs. functionality\nUsability and functionality are often seen as a trade-off in software design. Numerous features in one user interface can make it more complex, which makes the interfaces more difficult to learn and use. Removing features or moving them to obscure locations makes interfaces less powerful and useful. In many cases, the trade-off between usability and functionality takes into account the popularity of features. For example, with the Facebook desktop web application one can search for everything, change every setting or picture, post everything, but it is very far from intuitive.\n\nPortability vs. efficiency\nSoftware portability is the possibility to use the same software in different environments. But for every new environment, that is supported, additional logic will be implemented, and probably even alternative technologies will be added. This drastically reduces the efficiency of a software. If the development is for a specific system, the software can be build using the most optimized solutions suitable for this particular system. An example would be  macOS vs Windows - Windows works on every x86-64 and macOS is developed for a specific number of Apple models but can be much more efficient.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1400632,
      "meta": {},
      "text": "A typical design goal trade off in terms of software engineering is the relation between the two competing goals rapid development and functionality. Therefore, once a software project was developed rapidly there might potentially come up plenty of bugs. As a result the software needs to be maintained. Furthermore a rapid development might lead to poor documentation of the software/product. Consequently, firstly it is more difficult for the client/customer to use the product in a proper manner and secondly once bugs have been found in the software it is way more challenging for the developer to maintain the software correctly.\n\nAdditionally, another design trade off that has to be made is for efficiency and portability. It is possible to compile software for different operating systems and processors. However if this is the goal, on the respective operating systems and processors the software is certainly not as efficient as it could be, i.e. because of different architectures of the processors (CISC vs RISC).\n\nAnother design trade off is cost vs. reusability. If a product shall not be expensive, the development for the respective software should be cheap as well. As a result the quality of the software might be pretty poor, so the code used for the end product is more likely to be less reusable. Whereas if software is off high reusability, the quality is certainly better and potentially even other developers might want to reuse the code. However the cost for developing is certainly higher as it takes more time and developers in order to create such software.\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1424479,
      "meta": {},
      "text": "If a system has a lot of functions that are easily accessible, then it is functional for an experienced user but the usability for non-experts would drastically suffer. This is similar to how a specialized drag race car cannot be operated by an inexperienced person because of the vast range of functions there are. A normal car on the other hand can be operated by almost everyone because a lot of functionality got cut for usability.\n \nIf you want to make software run on old systems and standards, you would logically need to stick to those standards. But because such standards are usually deprecated and you would need to use special tricks to do things that are trivial, readability suffers a lot. An example for this would be HTML, over the years a lot of functions were added that really improved the readability of HTML, but because there are also people with older browsers, some web developers still stick to older (and less readable) standards.\n\nBuilding a program that is properly reusable (and scalable) usually takes more time than building a program that is just used for a single case and can't be applied for similar applications with some different parameters. This is due to the different structuring of programs that are made to be scalable, for example. An synchronizing software that allows people to take notes simultaneously in one document would be drastically different if it was build with the intention to support 10 people vs. to support 1000 people, even if the functionality stayed identical.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1290912,
      "meta": {},
      "text": "- Robustness vs maintainability: Handling every edge case often requires a lot of extra work that must be maintained well into the future. Especially development speed suffers when all risks must be handled\n- Accuracy and response time: When processing large data sets, it may be hard to return completely accurate data quickly. Sometimes, giving an estimate can be faster, but reduces precision (read: eventual consistency)\n- Cost vs control when outsourcing: While it may be faster and cheaper to use an external service provider, your team will not be in control when an incident happens, while being responsible for any issues that follow.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1310763,
      "meta": {},
      "text": "One trade-off would be usability and functionality. The problem is that with every function you add you have to place it in the program and often in the UI so it gets more and more difficult to keep everything simple. Especially if the UI seems too overloaded it is hard for the user to get along and to learn the program so the biggest challenge is to find a good UI design as a compromise of usability and functionality and really decide which function has to be in the final product and which not.\nAnother trade-off is efficiency vs. portability. The reason for that is that in order to develop performant and efficient software you have to know as much as possible about the environment that the software is supposed to run on to be able to adjust it to the technical circumstances. But this is not the case if you develop software that is supposed to be portable to many systems. So in order to achieve really efficient software you would have to develop it separately for every environment.\nThe third typical trade-off would be cost vs. robustness. To get a robust system you have to test your software a lot and put a lot of energy into improving the behaviour of the system in terms of edge case because thats where less robust software differs from robust one. But that's a very time and work consuming process which always brings additional cost.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1316592,
      "meta": {},
      "text": "Design goal trade-offs\n\nA typical design goal trade-off is rapid development vs. functionality. If a software should be developed in a short period of time, it cannot be guaranteed that it function as well as it should. This is connected to the high pressure for developers and less time for intense testing (as an example). This can be seen in new software like e.g. Amazon Prime, which even though there is a billion dollar company behind it, the website does not work as good as it should be (Possible reason: Competition with Netflix and co.).\n\nAnother design trade-off is backward compatibility vs. readability. If a software should be backwards compatible, there is a high chance that the readability decreases. Because it is in the nature of humans to make mistakes, there are and will be mistakes in every software program. And if you want to make a system backwards compatible, mistakes have to be continued or somehow solved, which is not always possible as it should be (Issues in readability). This can be seen in Windows systems, as for example you can not use every name as a folder name, due to mistakes in the past.\n\nAt last but not least we have a conflict between cost and robustness. If a client wants to decrease cost they have to make compromises in order to make the software still working. With the low price comes a low robustness against basically every point. This can be safety, as an example. A good example is a local pizza place's website I knew. The cost for the website should be held as low as possible, but after a short time the website got a victim to a hacker attack.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1335235,
      "meta": {},
      "text": "1. functionality vs. Usability ->Is the game Bumpers with 30 functions usable? such as start, pause, stop, change car, change music ...etc.\n\n2. Cost vs. Robustness -> high cost design checks all possibles errrors and vice versa, i can buy one copy of this game in cheaper price, but later it breaks that is mean, the game will not run for long time.\n\n3. Cost vs. Reusability -> when we use already some implemented codes in the Application of Bumpers, we can save costs.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1366616,
      "meta": {},
      "text": "You can add more fancy features to your product, but that can drive up the price. You need some extraodanry parts in your product to stand out from the competition, but the more feartures you have the more expensive it can get.\n\nrapid development and low cost are a design trade off, because if you wanna develop something fast you have to pay more Peple to work on it or the people who working on the project want a higher wage for doing more in little time.\n\n",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1424175,
      "meta": {},
      "text": "There are usually many different stakeholders for software. We can easily identify three different stakeholder groups; clients, end users and developers. These groups all have their own goals for the system and sometimes these goals can even be contradictory.\n\nOne obvious trade of between system goals could be duration of development of the project. Naturally customer wants to have system up and running as fast as possible. Developer probably wants to produce good system with as little errors as possible. Errors can not be avoided without sufficient testing. To minimize errors project probably will take more time to finish.\n\nDevelopers and end users can also have contradictory design goals. End user might appreciate functionalities that are really system specific whereas developer would like to have system that could at least partly be used in other projects. \n\nLastly also clients and end users can have design goals that produce trade-off situation in system design. End users usually want as user-friendly systems as possible. This can cause client expenses that clients naturally always want to minimize.\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1651654,
      "meta": {},
      "text": "1) Short Time vs. Maximum # of errors:\n\tIf a project has less time to be completed then developer might develop the software but it may contains many errors, which couldn't be tested due to short period of Time.\n\n2) Functionality vs. Ease of learning:\n\tIf a software has a large number of functionality then it might not be easy to remember all functionality of the system.\n\n3) Cost vs. Portability:\n\tIf a Client wants to run his/her Software in different Environment (Smartphone, Desktop etc) then it will cost him/her extra because it requires more time and efforts.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291232,
      "meta": {},
      "text": "1.cost vs robustness: robustness refers to the ability of a system to resist changes without adjusting its initial stable configuration. If the system is to be robust enough, then more testing is required to have an initial, stable configuration. For example: a project with 100 classes and 3GB of data that cannot be changed must have a huge amount of expenses.\n2.rapid development vs. functionality: When a system is to be developed rapidly, it is inevitable that there will be some undeveloped functionality. In order to develop a function that can interface well with other functions requires meeting discussions, model refinement, etc. These all take time. To ensure complete functionality, the development speed will be slightly slower. Example: A good, fully functional game takes 4-5 years or more of development time\n3.functionality vs usability: A fully functional thing is more difficult for users to use, and a less functional thing is easier to use. For example, when the rules of the game are simple, it is easier for players to get started, but when the game has too many functions, players will give up because of dazzling eyes（too hard to use). For example, most players can understand the gameplay of Minesweeper within five minutes.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1292041,
      "meta": {},
      "text": "Cost vs. Robustness makes a typical design goal tradeoff in software engineering. This is because thinking of all issues that may arise in a system while it is running is a very complex task, that takes a lot of thinking and testing. And due to that the time developers need to spend thinking and testing vastly increases which in turn drives up costs. And when this work is not done, the system will not be as robust, as if that work would have been done.\n\nEfficency and vs. Portability is also a typical design tradeoff as portable code, that was written in a portable language like java or python will never run as quickly, as code written in a language, that produces non-portable executables, like C or Rust, and   even those languages will not be as fast, as writing code in assembly specifically for a platform, which would be impossible to bring to another platform without doing a lot of extra work.\n\nBackwards Compability vs. Readability is a third typical design tradeoff. This is because backwards compatible code needs to contain at least parts of the old code, to do certain tasks exactly as the old code did it. As the two generations of code mix, there will be issues with formatting and naming conventions that are not completely compatible, and thus produce a mix of styles and functions that may also be there for the new and the old code, that makes it very hard to read.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292233,
      "meta": {},
      "text": "One typical design goal trade-off in the context of software engineering is the tradeoff between cost vs. reusability. An example for this trade-off might be the decision of a café if they want to use plastic coffee cups or only have the recup system in their coffee shops, or only have service for people with their own cups.\nThere you can see that the café has to decide if they want to take less cost but also don't have reusability or the other way around.\nA second typical design goal trade-off is functionality vs. usability. Photoshop might be a good example for the case that my mother wants to remove red eye lenses from a picture. Photoshop might be really functional because it has so many functions but for a person that has never used it it might be overwhelming to find the right tool for their purpose. Therefore it might be easier to use a tool in \"Fotos\" (in apple) to remove red eyes which might be more usable and less high functional.\nA third design goal trade-off is rapid development vs. functionality. An example was the road system in China  years ago when they built lots and lots of new roads but the population didn't have enough cars to fill those roads. Therefore there was rapid development in the road system but the functionality for the population was rather low because they couldn't really use it.  ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292497,
      "meta": {},
      "text": "-> Often functionality and usability are in conflict, since the human brain can handle just a limited amount of information at once and the \"usability\" is judged from the human point of view, more functions often mean that it becomes less clear for a human, which can lead to confusion and therefore a bad experience or usability. For example, imagine a calculator program that offers every existing mathematical operation. It would have a lot of functions but it wouldn't be very usable. Whereas a calculator as we know it doesn't have many functions, bus is probably more usable.\n-> Cost is a parameter that is in conflict with many others. And it makes sense, since typically to improve some other aspect one has to invest resources (money, time, etc.). One concrete example is the trade-off between cost and robustness. A system that is serving some changing number of clients has to be designed with a number of clients in mind. This means that when this number is surpassed the robustness of the system may be compromised. To avoid this, it has to be given more resources and thereby increasing the cost.\n-> Similar to the previous one, to increase functionality one has to invest resources. This means the resources, including time, are somewhat proportional to the functionality the system is set to have. A practical example is our EIST Project. To design and implement a system with more functionality we will have to invest more time to the project. And the same the other way around.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292818,
      "meta": {},
      "text": "Ein typischer design goal trade-off ist Kosten gegenüber Robustheit. Sowohl die Entwicklungskosten, als auch die Instandhaltungskosten eines Softwareprodukt werden davon beeinflusst wie Robust die Software sein soll und natürlich auch andersrum. Soll ein Endprodukt zum Beispiel besonders robust sein, so braucht es schon in der Entwicklung zusätzlichen (Arbeits-)Aufwand und dieser ist immer mit zusätzlichen Kosten verbunden. Zudem erfordert hohe Robustheit immer auch eine komplexe Grundstruktur, welche in diesem Beispiel höhere Kosten in der Wartung und Weiterentwicklung mit sich zieht. \nEin weiterer design goal trade-off ist Effizienz vs. Übertragbarkeit(portability). Denn wenn ein Code nur auf eine Plattform ausgerichtet ist, dann kann dieser genau auf die Spezifikationen der Plattform ausgerichtet werden und perfekt optimiert werden. Auf der anderen Seite wenn man Code für alle Plattformen schreiben muss, so muss man oft Kompromisse eingehen, welche die Effizienz des Codes negativ beeinflussen. Ein gutes Beispiel für diesen design goal trade off ist Android im Vergleich zu IOS. Android muss auf vielen verschiedenen Smartphones funktionieren, was Nachteile in der Effizienz mit sich bringt, während IOS genau für Apple-Geräte entwickelt und optimiert wird.\nAuch Entwicklungszeit(rapid development) gegenüber Funktionalität ist ein design goal trade off. Schließlich braucht es Arbeitszeit um Funktionalität jedlicher Art zu implementieren und wenn man etwas schnell entwickeln will dann leidet darunter die Anzahl und Qualität der Funktionalitäten. Genauso verhält es sich dann auch andersrum. Zum Beispiel wenn ein Softwareprodukt schnell auf den Markt kommen muss, weil der Konkurrent schon seins vorgestellt hat, dann leidet oftmals die Stabilität einzelner Funktionalitäten oder sogar des ganzen Systems.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1295150,
      "meta": {},
      "text": "One design goal that always comes up and has been mentioned indirectly in other lectures is efficiency versus portability. Big and complex systems are always better and more reliable but require more space losing on the portability side of things, while small systems are easier to store and manage while not packing that much of a punch compared to their counterparts. Another typical design goal tradeoff would be rapid development versus functionality. Of course every team of developers wants to finish their projects at the highest pace possible to please the client, but to be able to achieve that they would need to cut out certain functionalities. This tradeoffs only constraint that would limit the functionality is the time the developers have to finish the product. One last typical design goal would be functionality versus usability. Here the team working on the project has again to decide what to prioritise, creating an amazing system that has a lot of functions, settings and solves a lot of problems sounds amazing but bloating a system like this causes people who are not that familiar with it to not be able to use it, rendering it almost useless. On the other hand creating an extremely easy system that doesn't have much functionality isn't optimal either.\nWhat all of these tradeoffs have in common is that the team working on the project has to find a balance between each and every one of them depending on their circumstances.\n\n\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1314674,
      "meta": {},
      "text": "rapid development vs. functionality\n\n If you want to achieve a rapid development, it means your primary goal would be to deliver the product/software as fast as possible. This would result to perhaps not implementing extra features or not taking enough time to test the product (and potentially have some bugs). On the other hand  if you focus on the funcionality, you cant achieve a rapid development, as you would need to carefully test all functionalities, add extra features, or even redesign the software, so its funcionality would be increased. All these things are time-consuming and therefore your development would be slower.\n\n cost vs robustness\n\n If your primary concern is that you keep the development cost low, you would not spend much money on such things as testing (testing is expensive) or building your product in such a way it will be able to adapt to changes (e.x. very high/low temperatures). On the other hand if you focus on the robustness, you will need to execute many tests (bugs, wrong user input) and also think of many possible scenarios where your product would fail. Testing is expensive, as well as building a product that will still perform in unusual/extreme situations.\n\nefficiency vs portability\n\n If your primary concern is portability, you will have to design your software in a way, it can run on many operating systems and many different platforms. This reduces the efficiency, as you cant do any optimazations regarding the operating system and you cant take advantage of special hardware capabilities. Your code would be slower and not as efficient as code designed specifically for an operating system.\n\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344430,
      "meta": {},
      "text": "functionality vs usability:\nEine Anwendung leichter zu benutzen, wenn sie nicht zu viele Funktionalitäten hat. Beim designen von Software muss man sich also die Frage stellen, wie viel Funktionalität man einbauen möchte und wie wichtig einem die Benutzbarkeit ist. Diese zwei sachen sind gegensätzlich, beudetet dass das eine Ziel evtl dazu führt dass das andere nicht erreicht wird.\nBeipielhaft dafür ist eine IDE wie IntelliJ, es gibt unglaublich viele Funktionalitäten die man benutzen kann, jedoch ist vor allem zu Beginn die Benutzbarkeit nicht die Beste, da man sich überfördert fühlt.\n\nRapid development vs functionality\nWenn man beim entwickeln von Software nicht genügend Zeit hat kann es sein das man nicht alle gewünschten Funktionalitäten implementieren kann. \nEin Beispiel aus meiner eigenen Erfahrung kommt aus dem Semester Informatik in Pgdp, wo wir in ein paar Wochen eine einsetzbare Suchmaschine entwickeln wollen, um das zu schaffen mussten wir uns auf wesentlich Funktionalitäten konzentrieren.\n\nEfficiency vs portability:\nWenn ich ein Effizientes System bauen will muss ich vllt auf portabilität verzichten sein, portabilität im Sinne von: auf Geräten wie Smartphones laufen. Auch wieder ein Trade Off Szenerio, man muss sich wieder entscheiden wie wichtig einem diese beide Aspekte sind und dann die Balance finden.\nBeispielhaft in der Spieleentwicklung, wenn ein Unternehmen ein Spiel bauen viel dass mit hoher Perfomance schöne Bilder rendern kann, dann muss es ziemlich wahrscheinlich darauf verzichten, dass das Spiel auch auf Smartphones laufen kann.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344737,
      "meta": {},
      "text": "Rapid development vs. functionality:\nThe client on the one hand wants the developer to develop his demanded software system fast so that he can use it or sell it. But on the other hand he also wants the system to work perfectly fine in the way he described it in the problem statement. E.g. A software system for an autonomous car needs to be developed fast due to competition, but also may need special features that others don't have or better developed features that detect possible collisions better.\n\nFunctionality vs. usability:\nSame as before described, the system needs to have all the features that where required by the customer.\nBut at the same time the system should be easy to use/ intuitive.\nE.g.: a client wants the developer to create a game and he wants the game to have a lot of features/functionalities. But with that many functionalities the user might be overwhelmed and thus it is hard to understand.\n\nCost vs. robustness\nThe client obviously wants his software system at low cost but also wants the system to e.g withstand wrong user input. E.g. when developing a social media platform the client is probably more likely to pay more money to have a robust system that breaks down seldomly and especially not when somebody makes wrong input.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344741,
      "meta": {},
      "text": "Functionality vs. usability: Adding more functions often makes it much more complex to understand the system. I need more time to explore all the functionalities. Therefore, it is important to identify which functions the user really needs. If after the analysis I still need to provide many features, care should be taken that the functions appear intuitive to the user. For example, through a good UX.\n\nCost vs. robustness: Sometimes software needs to be developed quickly and at low cost, so technical debt is taken on at the expense of robustness. This is a common procedure for testing software directly on the user. However, the \" mistakes \" should be corrected afterwards.\n\nCosts vs. reusability: For the reuse of classes, methods and interfaces may have to be adapted, which leads to higher costs in the development. ",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1346020,
      "meta": {},
      "text": "1. Functionality vs. usability:\nIf we imagine an online application that provides, for example, translations of Latin terms used in medicine, one could of course write all existing words in a list into the application. That would be functional. However, this is confusing and individual definitions are hard to find. Usability would be given, if we install a search field, whereby specific words can be searched for.\n\n2. Rapid development vs. functionality:\nA developer programs an online game in which cars crash into each other. The cars are controlled by the user via mouse, but there is no other way to steer the car, because the game had to be developed quickly. The user might prefer to steer by keyboard, which is not possible. Here the functionality suffers due to rapid development.\n\n3. Efficiency vs. portability:\nLet's assume we have an application that runs most efficiently on a Linux system and can also process user input fastest on Linux. So it is efficient to program the application only for Linux compatibility. However, this contradicts portability, since a user cannot use the program on a Mac, for example. Efficiency and portability get in each other's way.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1363183,
      "meta": {},
      "text": "1: Efficiency vs portability. In this trade-off, the issue is choosing between quality software versus a software that works with different technical architecture types. Let's take a game for example. A game which is designed for only one gaming platform (playstation for example) is expected to have superior software with more details and qualities, for it is easier to focus on one platform and adapt the software accordingly. But choosing portability on the other hand allows the game to be played by far more people, thus increasing the popularity and the revenue. But, it becomes harder to adapt the software to different platforms, thus the game ends up having less details and less quality.\n\n2: Functionality vs usability. A software which offers a lot of functionalities makes it harder and more complicated for the users to use the software. Choosing usability on the other hand forces the software to become easier to use, thus offering less functionalities. An example for that might be a photoshop software. As you offer more functionalities, users get confused and might prefer easier to use applications, but the photoshop opportunities increase. When you chose usability you can offer limited photoshop capability but it's more user friendly.\n\n3: Cost vs robustness. An example for this trade-off might be an exam system. Here, it is costly to allow a high number of students access the system all at once (improving the server), but it increases robustness and the system handles the conditions without malfunction. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1372173,
      "meta": {},
      "text": "1) Rapid development vs. functionality\nMost o the times, it is wanted from users/ customers that an application has a lot of functionalities, and by that not only necessities, but also nice little features, that polishes a program and enhanced from the basic functionalities, but with that is also a lot of time, money, energy and other resources connected, so you either launch a restaurant reservation app (for example) fast with basic features (of reservation) or take a long time to enhance a program to it's full capacity (with special things like restaurant recommendation).\n\n2) Functionality vs. usability\nBut with a lot of extra functions comes obvious complexity, in both, surface level usage like the GUI for users/ customers, but also internally (e.g. the programming). So a restaurant app with special things like restaurant recommendation, a chat platform, etc. has a lot more buttons and tabs, which can be confusing in the use of the app.\n\n3) Efficiency vs. portability\nA really efficient (e.g. fast in loading) app is one, that is completely autonomous, and not dependent on e.g. having to download extra things. For example if you have to download an mobile app for the restaurant reservation, because it is the only way to access the program, it isn't as portable when it is a website (where you can access it from everywhere and every device), but that might not be as efficient, in comparison when it is natively program for a mobile device.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1405428,
      "meta": {},
      "text": "The from the perspective of the client biggest design goal is low cost. And this is a goal which collides with almost any other design goal. For example a cheaply developed software is not likely to be rich in functionality. You can assume that if for example facebook wouldnt put so much time and ressources in developing new features to the app and constantly maintain it, it would have trouble staying on the top of the social media softwares. Another typical tradeoff is between ease of learning and functionality. Because a large number of functionalities limit the ability for a new user to get used to the software. A good example is photoshop, its a very powerful tool, but it takes a long time until you get all the different functionalities this app posseses and you are able to use it properly. Another important trade-off is between rapid developement and the number of errors. Because the number of errors can be reduced in first place by excessive testing, it takes a lot of time to make sure a program is unlikely to produce errors. On the other hand having errors can be very expensive too. For example during PGdP last semester when solving my tasks, in the beginning I wanted to finish as early as possible. But I underestimated how time consuming debugging is in comparison to writing good code with no room for errors. The same way a company may have more maintainance costs than developing costs.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1407527,
      "meta": {},
      "text": "Functionality vs. usability:\nOft geht ein effizientes System mit komplizierteren Strukturen und Anweisungen einher, um mehr und bessere Aufgaben erledigen zu können. Das perfekte Beispiel ist wohl Linux mit vielen zeitsparenden Befehlen im Vergleich zu intuitiveren, aber funktionsärmeren Betriebssystemen wie Windows. \nBackward compatibility vs. readability:\nSoftware auch noch für ältere Systeme nutzbar, oder ältere Programme für heutige Technologien effizient zu machen, führt meist zu schwer überschaubarem Code. So können neuere Befehle (Programmiersprachen) nicht genutzt werden oder eine Alternative muss geboten werden. Ein Beispiel hierfür ist der Umstieg von 32-bit zu 64-bit Architekturen und Programmen, welcher viel Code, extrem in Assembly, nahezu undurchschaubar machte. \nEfficiency vs. portability:\nEine Anwendung auf unterschiedlichen Geräten führt i.d.R. zu langsamerer Software, da unterschiedliche Hardware viele Optimierungen verkompliziert. Supercomputer sind hier ein Beispiel in Extremform, deren Software in der Form meist nirgends anders verwendet werden kann (+unterschiedliche Rechnerarchitekturen).\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1290822,
      "meta": {},
      "text": "Remark: I've reused my answer to this task from SS21.\n\nThe example used: a generic speech recognition software\n1.  Development time vs accuracy:\nFrom the perspective of the client and developer, if the client demands this product be delivered within a shorter time frame, the developer may not be able to do so without sacrificing the accuracy of the software. For the software to accurately detect speech (like Google Assistant), it needs to be trained on millions of good-quality data which takes a long time. Thus, accuracy may suffer if it's trained on small data sets and also if it's poor-quality data.\n\n2. Cost vs reliability:\nDepending on the client's criteria (i.e. complexity of the software, targeted end-user base), in order to ensure high reliability, the cost of the software may rise as many factors have to be taken into consideration i.e. variations when pronouncing a word, the speed at which the user is talking, accents of different people, filtering out background noise, etc.; and these take up time and money on the developer's end to implement correctly.\n\n3. Latency vs Usability:\nSpeech recognition that has low latency usually corresponds to good usability. If the speech recognition software has a significant time delay after the user's input request, it may not be suited for the user and is thus unusable as in this instance it takes up too much time.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291451,
      "meta": {},
      "text": "Cost vs. robustness: \nOften a low-cost system is less robust. A system should be robust. If the player in Bumpers wants to change his car type the system shouldn’t crash. Again the client has to decide between a robust system or a basic system. With more money the system is more robust.\n\nPortability vs. efficiency: \nA good system is usable on all kind of platforms like Windows, Mac. This is called portability. Efficiency is that the system responds fast to user input. It is important that the game Bumpers responds fast to user input. If the player wants to change the car type it should happen in seconds and everyone who wants to play should be able to download the game. Now we must decide between portability and efficiency. Which one is important respond time or efficiency? It can happen if we decide for portability that on some platforms game doesn’t respond fast to user input. \n\nFunctionality vs. usability\nAnother trade-off is functionality vs. usability. We have to decide if we want more functionalities or usability. The game Bumpers is self-explanatory because there are not many functionalities. Bumpers has only 4 functions. The end user doesn’t need a manual, the game is easy to play. Therefore, we can say the usability is high but the functionality is less. \n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292619,
      "meta": {},
      "text": "1. Customer want a new software in a short time, but the development team can not complete all goals in time. \n   So the customer and the client have to decide, which goals can be completed in that time frame.\n\n2. Achieving a usability and functionality balance for a website, so it is easy to interact with, but also has lots of\n    features to offer. The balance of both, will lead to more happy customers.\n\n3.  You want to design a program for an airplane autopilot. Your goal is to save as much money as you can, but \n     you also do not want to provide a program, which leads to error during runtime. So you have to find a tradeoff\n     for the most import safety aspects of your program and your max budget you can spend. ",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1335511,
      "meta": {},
      "text": "1) Cost vs. Robustness: Clients want the system to be developed for as cheap as possible, but this often means that the system is not robust, as low cost means most times low time invested in to the project. Example: A complex project which is developed for 100$ wont be robust, as the developer doesnt want to invest much time. \n\n2) Cost vs. Reusability: One-to-One multiplicity is easier to code, ergo it is cheaper than many-to-many multiplicity as additional coding means money. Example: It is easier to code the relationship between one student and only one course in comparison to many students and many courses. \n\n3) Functionality vs. Usability: If a system has many functions, it will be very likely more complicated and hard to use than a system with less functions, which is more usable. Example: A website with many functions, like \"Library of Babel\" is more functional but less usable as compared to the Website \"Strama Gmbh\"",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344126,
      "meta": {},
      "text": "Functionality vs. usability:\nMany programs e.g. Tinder only have a few functions. You can't do a lot with the application. But it isn't hard to learn these functions. It's often a conflict between functionality and usability, because the usability suffers due to lots of functionality. \nCost vs. robustness:\nRobustness is often really expensive. A simple example. Many producers of electronic devices dispense on a good and robust metal case and rather build with cheap and not that robust plastic. Almost every robust system is more expensive than a less robust system. These is is another typical goal trade-off.\nRapid development vs functionality:\nIf systems have to be build very quickly, the tend to be not that functional. Every new functionality costs time, so it is clear that this stands in conflict with each other. An Example: An Application has to be programmed in 5 week with Scrum. The sprints have a duration of 1 week and the developers manage to program 3 functionalities of the program backlog every week. The maximum functionalities are limited to 15 after such a short time period. If the developers would have had more time, the system would have more functionalities.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344604,
      "meta": {},
      "text": "While designing an software the developer shouldn't only consider his/her preferences but also what the client and the user wants. \n1- Cost vs Robustness: The client may prefer paying less to build the software to reduce the costs but the it might be really important for the end user that the software system is robust. Most of the time robustness come with an higher price. Using multiple classes and writing test cases to check different type of exceptions that might occur can higher up the costs, but once the system stops working it might cost more time and money to make it functional again.\n\n2- Rapid Development vs Functionality: The client may need an product within a month to compete with the other companies but the developer might not be able to have enough time to do the required testing to approve the product works as expected and is reliable.\n\n3- Functionality vs Usability: Can the user understand all the functionality and use them easily ? Additional functionality may make the software more complex and have an negative impact on the user-friendliness. Adding more features to the system might bring more technical problems and an additional need for the end user to call for an support.\n\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1403797,
      "meta": {},
      "text": "Cost vs. Robustness:\nThe more robust a system is, the more edge cases it can handle. Identifying, handling and testing for these edge cases is time consuming and expensive. Therefore it's more expensive to make a system more robust. An example for that would be a computer game. A lot of computer games strugle with bugs, that allow the player to reach places he shouldn't be able to. Stopping this is quite complicated and therfore expensive.\n\nBackward compatibility vs. Readability:\nMaking a system backward compatible, means to somehow write code, that allows older software or hardware to use the functionality of the system. This makes it harder to write simple code, because it may not be possible to use the full spectrum of new programming tools. An example for that would be, a program that needs to run on serveral operating systems.\n\nCost vs. Reusability:\nTo make code reusable, means to make it general and modular. This can be more complex, which means it's time consuming and therfore expensive. An example for that would be sorting algorithms. It may be easier to write a sorting algorithm, that just sorts an array alphabeticaly ascending than a method that has an parameter to chose how you want the method to sort your array.\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1425872,
      "meta": {},
      "text": "Three typical design goal trade-offs are:\n\nOur general example is a website, we are programming to sell customisable T-shirts.\n\nFunctionality vs. usability\nA very common trade of is Functionality vs. usability in this trade-off you need to consider wether you want to make the product as usefull for the user as possible or wether to scalle down the project making the product easiert to use for the user. In our example do you need 500 options to customise a T-shirt or won't 10 good ones be much more effective. An option to give the user initialy 10 and only on request more options could be a safe middle ground.\n\nCost vs. robustness\nAnother common trade of is Cost vs. robustness you need to carefully evaluate the money/time you put into making the product absolutely bug prof and the need for it to actually beeing fool prof. This is like all trade offs very dependent on the project. What parts of the T-shirt website do need to be secure? The most important thing in our example tat needs to be bug free is the payment process of course. The second most important thing needs to be the features. Website cosmetics can be implemented later and are not that important.\n\nBackward compatibility vs. readability\nThe last trade of I want to look at is the use of old functions for old users and the effectiveness and ease to use of the new website. You had a normal Tshirt website before. What parts of the functions of the original website do you want to keep. I would consider redoing everything web development is a constantly changing field and users are used to work with new designs and expect new designs. If our new design is easy to use the switch should only have benefits for the product. ",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344622,
      "meta": {},
      "text": "Typical software engineering goal trade-offs include:\n\n1.Functionality vs usability:\nWith rising functionality the complexity of a system automatically increases and the software becomes harder to use. For example when engineering software targeting professionals (for example a 3d animation software) you provide as much functionality as possible at the cost of usability because a new user will not be able to instantly comprehend all of the programs functions and therefore will not be able to use the software without learning how to use it.\n\n2.Portability vs efficiency\nPortability in this context means either being able to run on different machines or mediums or the size of the software.\nFor example when engineering software specifically for a specific system you can exploit the systems architecture to optimise the efficiency of your software. But if your software has to be able to run on many different systems it can not be specifically optimised. For example a software will have to run on a virtual machine which is far less efficient. The software will also often become much bigger in size as it has to include support for many different mediums.\n\n3.Cost vs robustness\nWhen engineering a low cost software it becomes more and more difficult to deliver a polished product as the main focus lies in just getting the necessary done. This means that there is not much time left to test and fix bugs in the system. The system therefore becomes less robust.\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1484638,
      "meta": {},
      "text": "1. Trade-off zwischen Kosten und Funktionalität: \nDer Enduser möchte eine App mit vielen verschiedenen Funktionalitäten haben, zum Beispiel dass man bei einer Chatplattform nicht nur texten, sondern auch Sprachnachrichten, Diktierfunktion, Videonachrichten, Gruppenanrufe,...  tätigen kann. Gleichzeitig möchte er aber seine Kosten gering halten und kaum/gar nix dafür zahlen. Dies stellt aber einen Trade-off dar, da der Entwickler Zeit und Wissen für neue Funktionalitäten investieren muss, was sich in den Kosten für den Nutzer widerspiegelt, da man grundsätzlich für mehr Funktionalitäten auch mehr zahlen muss und der Enduser sich zwischen mehr Funktionalitäten und geringeren Kosten entscheiden muss. \n\n2. Trade-off zwischen schneller Entwicklung und Sicherheit:\nBei der Erstellung möchte der Entwickler möglichst schnell eine Website entwickelt haben und so wenig Zeit wie möglich investieren, um schnell fertig zu werden. Trotzdem sollte die Website so sicher wie möglich sein und zum Beispiel geschützte Funktionen und berechtigungslimitierte Zugänge enthalten, um vor Hackern, Zugriffen von Unbefugten oder ähnliches zu schützen. Dies stellt einen Trade-off dar, da der Entwickler mehr Zeit investieren muss, wenn er die Website sicherer und geschützter machen möchte.  \n\n\n3. Trade-off zwischen Funktionalität und Benutzerfreundlichkeit:\nDer Endbenutzer möchte zum einen, dass ein Bildbearbeitungsprogramm benutzerfreundlich und einfach zu bedienen ist. So soll es grundlegende Funktionen bieten, wie Bilder zuschneiden, drehen, das Bild heller und dunkler bearbeiten, um die Übersichtlichkeit aufrechtzuerhalten. Der Enduser möchte aber gleichzeitig über mehr Funktionen verfügen, wie zum Beispiel Schatteneffekte, verschiedene Lichteffekte, Spiegelungen,... Wenn alle Funktionalitäten noch skalierbar sind und individuell anpassbar, dann wird die Benutzerfreundlichkeit verringert, da es zu viele (spezifische) Funktionen gibt und man schnell die Übersicht verliert. Dies stellt also auch einen Trade-off dar, da man zwischen vielen Funktionen und der Benutzerfreundlichkeit abwägen  \n\n\n//Siehe meine Abgabe vom letzten Jahr: https://artemis.ase.in.tum.de/courses/121/text-exercises/4162/participate/789117",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1292251,
      "meta": {},
      "text": "Functionality vs. usability: \nWhen developing a program with GUI the usability is a very important point. \n If a software offers too many functions  then the program is not self-explaining anymore, too complex and the user won't use it. So implementing too many functions affects the usability in a negative way. Sometimes there is a way of implementing a lot of functionality but creating the GUI simple, with hidden functions, like WORD, EXCEL and almost the whole Microsoft OFFICE Software Setup. In Word for example there are a lot of functions implemented but the user doesn't have to understand them all to create a document. \n\nCosts vs. reusability: \nWhen modeling a program the developer has to consider the efficient runtime of the software demanded. \n Therefore if an unlimited runtime is requested the developer is responsible for testing and bug-fixing or providing additional methods. This includes high codes, but therefore a very reusable code, which is easily expandable. The opposite would be a software build on low costs including a less complex code, causing a short-term runtime. For example if it is your task to construct an app for the TUM and every year new students join the app and you have to rewrite the code, because it was constructed on low costs. Of course this doesn't happen at TUM, therefore the actual application is created on high costs providing an endless runtime, including high reusability. \n\nCost vs. robustness: \nWhen creating a software there are of course different demands from the different stakeholders, which have influence on how the program is created in the end. \n In general the client wants to minimize the costs and the end user requires a robust system. Therefore it is the developers task to fulfill those requirements. When lowering the costs the robustness might suffer or more errors appear in the final software. For example the company paypal had a worldwide system outage for approximately 5 hours in 2009 which resulted in missing a total of 36 million dollars worth of transactions. \n\nSource for the last example: https://www.zdnet.com/pictures/the-10-scariest-cloud-outages-and-lessons-learned-from-them/9/",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1293579,
      "meta": {},
      "text": "- Rapid development vs. functionality:\n\tRapid development means developing software in the fastest time possible. This results in a lack of time for refactoring and reorganizing code for it to be clean and functional for new features. As the team adds new features in a hurry, the code will progressively get messier and more bug-prone, ultimately leading to less functional code. On the other hand, taking time to analyze the structure of the code and plan ahead of new features costs more time, but ensures long-term quality. An example would be a game developed for a long time where the developers invested time in a good story and bug-free gameplay, compared to a game where the developers were given a tight time window to release a game which ended up being almost unplayable.\n\n- Cost vs. robustness:\n\tCost impacts a various number of things when we talk about software development. First and foremost it dictates the quality and quantity of the team. Of course, better developers and a larger team will in most cases be able to produce better and more robust software. An example would be an experienced team working for a rich company, compared to an inexperienced team working for a start-up.\n\n- Functionality vs. usability:\n\tCreating an interface which provides lots of options to the end user and is clean at the same is a great challenge. Most of the time, bombarding a user with many functionalities results in confusion and a messy UI. An example would be a simple interface with a few buttons which is usable but lacks functionality, compared with a complex interface providing lots of options, but being difficult to grasp.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1305190,
      "meta": {},
      "text": "\nLow-cost VS Robustness\nOften the trade between a robust, well developed system and low cost for a client is difficult to balance. A robust system often require extensive testing, clean design(low coupling, high cohesion) and backup-solutions for fault-tolerance. This often requires more development time, and redundant system. This will normally have a tremendous impact on the cost of a system.\n\nRapid development  VS Ease of learning\nRapid development can go poorly together with ease of learning, as ease of learning will require a system that is carefully designed with user interfaces in mind. Such design often relies on extensive testing by users, multiple rounds of feedback and this takes time.\n\nBackward compatibility and Well-defined interfaces\nA system that is backward compatible is somehow locked to a previous interface's possibilities. If one wants to modify the code, one might not be able to touch the old things, and thus one must increase the size of the interface, which will make it less defined and messy!\n\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1312633,
      "meta": {},
      "text": "First I go into the conflict between functionality and usability. The clients often like to have a system offering a great amount of functionality and being easily and intuitively to use  at the same time. As an example let us consider we want to create a text editor. On the one hand we could keep it simple and focus only on crucial functionality resulting in a software with which you can only do typing and formatting in one color and fond like the text editor on Artemis (high usability, low functionality). On the other hand we could make up something complex like Word enabling you to draw tables, create diagrams inserting pictures and so on, provided you have figured out how to do this which can be challenging - low usability, high functionality. \nSecondly there is the trade-off between efficiency and portability. Highly efficient systems are usually not portable because their efficiency depends on the possibility of exploiting certain peculiarities of the underlying hardware differing from platform to platform. Portable systems are often designed in a higher level of abstraction which decreases performance because instructions have to pass different layers. An example is a program written in Java - high portability, low performance - and a program written in Assembler - low portability, high performance. \nLast but not least let us have a look on costs and robustness. Creating a robust program demands from you to drive a lot of tests leading inevitable to an increase of costs whereas untested programs which moreover are designed fast and carelessly a prone to have a lot of bugs. Think of your own programming experience and you have to agree that the program you coded fast in a few minutes is not as robust as a program you invested in a lot of time.  \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1332093,
      "meta": {},
      "text": "Functionality vs. Usability: \nThis trade of describes the problem of having a system with a lot of functions that is therefore not usable anymore. Looking at the bumpers game a good example would be to overload the system with customizability options that a simple not necessary, like giving the user the option to customize the background, the car, the music and the collision type. This would overwhelm a normal user and not ad any usability to the system.\n\nRapid development vs. Functionality:\nEvery software project has a time frame certain requirements need to be fulfilled. So for example if the given time frame to implement a multi player option for the bumpers game is two weeks, but the needed development time on the other hand side is 3 weeks, there will be an issue. So in the end the delivered product probably wont have the expected functionality. In this case the testing time could be to short and therefore the reliability of the multiplayer function unstable.  \n\nCost vs. Robustness:\nA system that is kept on a low budget could lead to critical errors related to user input. For example looking at an online shop. Every user has to enter an email address. Therefor the system should check the validity of the email. However if that check is not implemented due to costs, critical errors could occur. The system would not be able to deliver important notifications and and internal email delivery errors would occur. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1332233,
      "meta": {},
      "text": "1.cost vs robustness : a plan which has enough budget could be able to hire many developers to handle possible problems in every aspect. However, if budget is not enough, for example, if i want to design a system and i have no money to pay for any participant, then i of cause need to do all works by myself. Therefore, my system is very likely to be not excellent enough and would not work with some special boundary condition.\n2.functionality vs usability : IntelliJ has many functionalities but is hard to use at the first time, people normally need to learn how to use this software step by step. On the other side,Bumpers is very easy to play, but it just has few functionalities. As the number of functionalities increase, the cost of learning this software will also increase.\n3.functionality vs rapid development: Bumper is a easy development program for skillful developers and could be done with relatively short time, because it just has few functionalities; but if more functionalities is needed, then people need  more time for handle the hole system and relationships inside it. Otherwise they also need to implement these functionalities. Therefore, rapid development could only be realized with the decrease of functionalities.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344709,
      "meta": {},
      "text": "Cost vs Robustness:\nDesigning a robust system is a very time consuming process because the development cycle never ends and continuous feedback as well as testing is required. A good example would be an indie game. These are often developed by one or two people without the resources to test every aspect of the game and make it bug-free. This can often result in a game with a lot of bugs and feedback that cant really be implemented.\n\nRapid development vs functionality:\nWhen developing software with a lot of functionality like for example a large open world game the work load might rapidly increase and deadlines can no longer be held while still deploying a quality product. A good real world instance was the development of Cyberpunk 2077, where the promised many functionalities required multiple delays and finally resulted in an incomplete game (lacking functionality) with the cause being a demand for rapid development and meeting the deadline.\n\nEfficiency vs portability:\nIn order to design a portable system, tradeoffs like efficiency have to be made. To illustrate this, let's take a look at large network clusters like the internet. To serve multiple clients at once efficiently the system needs to be scaled up. More servers and performance are required. This results in a lack of portability. In the case of the internet, we are unable to move the large servers of Amazon, Google and others from their respective data centers. In that sense we sacrificed portability for efficiency. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1345932,
      "meta": {},
      "text": "1. One of the most crucial trade-offs is the conflict between efficiency and overall portability (different processors, operating systems, and so forth). For example, Assembler code is faster than all other \"ordinary\" programming languages (C, Java, etc.), but barely transferable to other machines. Therefore the more abstract, system unspecific, and processor-distanced you develop software, the slower it gets (as you lose efficiency in the trade-off of conformability to other systems).\n\n2. Specifically for larger (and older systems) the trade-off between backward compatibility and readability is a huge problem. For one, an iterated version of a designed software should be compatible with older versions - i.e. banking systems programmed in COBOL. On the other hand, with increasing the backward compatibility of software, you also append more and more code to the same software, thus making it harder to read and maintain at a certain point. As mentioned above, in the banking sector many systems need to be backward compatible with old software/hardware (e.g. ATMs) and thus their codebases become inflated to support said older versions -> decreasing readability.\n\n3. In general, robustness vs. cost is a dilemma every software project bears. Robustness refers to the ability of a software system to adapt to wrong inputs and to run smoothly no matter the circumstances - in short: qualitative and safe code. To get robust software, resources (cost being in form of time, money, etc.) need to be invested. For example, to get a running website is trivial, to protect the website from SQL Injections, XSS, DNS spoofing, and so forth is way harder and requires among other things time (thus it costs to make a website robust).",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1348784,
      "meta": {},
      "text": "Cost vs. robustness: If you want to build a robust system, which means the system should be able to cope with errors during execution, you need to build more complex system, you need to add more components. It increases the size of the system, code requirements, hardware requirements, and etc. so directly it increases the cost of the system.\n\nFunctionality vs. usability: When we add more functions to system, it will be difficult to use. For example, the simpler website, with few functions, is easy to use but when we add more functions it will be harder to use. Real example can be Discord, Discord has a lot of functions but learning all of the interfaces and functions from scratch is not easy.\n\nRapid development vs. functionality: If you want to add more functions to your system, it will be more complex. It will require more codes, more testing, more developers so you cannot implement the system rapidly.\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1349107,
      "meta": {},
      "text": "Functionality vs. usability\nA big amount of functionality can cause a hard way of using a software. If the team decides to implement many functions, they should always think, how to create a good and intuitive understandable connections between them all.  Many ways to use the program doesn’t mean a good usability, it can be hard to decide which function do you need at the moment. A good example is Unity. Unity offers a huge amount of functionality and opportunities to create your own game, but the usability is very low. You should have a lot of background knowledge about game development and Unity API. The most of interface functions are hidden and are not intuitive in usage.\n\nEfficiency vs. portability\nPortability means, that a software supports many devices, so on the development step should all of the functions be universal and prepared for multi-platform usage. But on the other side you can't use all of the features, that the specific platform can offer, and that means that you lose in efficiency of the program. For example, the mobile apps that were made specifically for IOS or Android are more efficient on the mother platform compared to the port version.\n\nRapid development vs. functionality\nA smaller amount of time for software development can cause a reducing of the program functionality. Team has choice to make an app quick, but without the most of functions or the bad implementation, or to make it slower, but implement all functions with a good quality. Cyberpunk is a good example for that. Team project red had not enough time to finish their game, but the marketing team didn’t want to wait. So the team decided to reduce the functionality to meet the deadline.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1363162,
      "meta": {},
      "text": "Functionality vs. Usability: \n\nIt can easily happen that a software developer puts a lot of different functions in to the program, so the functionality of the system rises. The problem is that the developer knows exactly which function for which purpose stands for but for the customer might be the software too complex, so the usability will fall. That's why it should be a common goal to balance these two aspects, so that the user experience will be desirable. \n\nRapid development vs. functionality: \n\nMost of the time the development team stands under time pressure and there is not enough time to make the software versatile, so the customer won't have enough options to choose from. This lead to the fact, that the functionality of the system falls and the user will use other softwares, which has several functionalities. \n\nCost vs. robustness: \n\nAmount of money invested in a project plays a huge role when it comes to robustness. If the team does not have enough money to pay for good developers, it can easily happen, that the software might be not well written, so the robustness falls. On the other hand, requires a more time to develop a software which has a high robustness. Time costs a lot of money for the company so there should be a healthy balance between these to aspects. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1640022,
      "meta": {},
      "text": "One design goal trade off is between cost efficiency and portability. An example for this is that it is not possible to create a software with the minimum amount of resources while at the same time the system should be portable onto many platforms. The reason for this is that if I want the software to run on diffrent platform I need extra effort to do so. Therefore I have to decide how much money I want to spend and accordingly on how easy it is to change platforms.\n\nA second trade off is in terms of good documentation and rapid development. The reason for this is pretty clear. Having a good documentation is taking time which can not be used to further develop the software. An example for this could be that at the beginning of a project the software is well documented, because the developers believe that a good documentation is important to later fix bugs. However with the deadline of the project coming closer the developers must focus to get to project done in time and therefore their primary object is rapid software development. \n\nThe last trade off that I want to mention is runtime efficiency and functionality. The more function a system gets the slower the slower it runs. An example for this would be a system that at the beginning is very fast and has little functionality. Now the developers and more functions that the client wishes. Now the data has to be processed longer and the runtime efficiency suffers ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292094,
      "meta": {},
      "text": "Functionality vs. usability: Functionality is the set of operations that are supported by an interface. Usability on the other hand is the ease of use of an interface. Having a large set of functions has its own advantages but it stands in conflict with usability. The more functions are available, the more complicated it is for the user. They get confused easily. An example would be the file explorer of Windows 10. Many functions are nested and hidden in the different \"menus\". Many users do not know about the existence of certain functions, or they get confused while looking for a certain function.\n\nCost vs. robustness: The term cost is self-explaining, but what means robustness? Robustness means that the program should not crash if the user puts in some unexpected command or makes some unexpected clicks. A conflict might be, that the customer expects maximum robustness for the lowest possible cost. To reach maximum robustness, it is necessary to spend more money. For example, the developer does not implement a wrong input handling and the user accidentally presses \"r\" on the keyboard. The system might not respond and crash because it does not know how to handle the input. This might be the result of keeping the cost low.\n\nRapid development vs. functionality: Rapid development means that the process from requirements elicitation to testing takes the least time possible. That might result in less functionality, as the developer does not have much time. Let us suppose that the developer has to implement a game in two weeks. He would not implement fancy features and the functionality will be only kept to a minimum.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1298350,
      "meta": {},
      "text": "Es kommt sehr häufig vor, dass verschiedene Desgin Goals in Konflikt zueinander stehen.\n\n1) Qualität vs. Zeit:\nHäufig kommt es vor, dass für ein Softwareprojekt nicht so viel Zeit zur Verfügung steht. Daher muss dann an der Qualität des Endproduktes gespart werden, um die Deadline einzuhalten. Beispielsweise erhält eine kleine Softwarefirma den Auftrag, ein neues Programm für einen Supermarkt zu schreiben, wofür sie insgesamt nur 4 Wochen Zeit haben, denn dann erhält der Supermarkt eine neue Maschine, die mittels einer neuen Software in das bisherige System integriert werden muss. Da die Softwarefirma nur eine sehr geringe Zeit hat, kann es sein, dass bei der Übergabe des Produkts noch Bugs im Code enthalten sind, die dann später in der realen Welt zu Problemen führen könnten.\n\n2) Kosten vs. Robustness:\nHier kann man eine Banking App betrachten, die sinnvollerweise sicher gegenüber Cyberangriffen sein sollte, da sonst Nutzer viel Geld verlieren könnten. Wenn bei einem solchen Projekt am Geld gespart wird, kann es passieren, dass grundlegende Sicherheitsmaßnahmen nicht integriert werden und somit das System sehr unstabil ist, d.h. nicht robust gegenüber Angriffen. Folglich muss man immer überlegen, ob es sinnvoller ist, etwas mehr Geld auszugeben, um dann letztendlich ein robustes Produkt zu erhalten oder an den Kosten zu sparen und dann später in der Praxis ein leichtes Ziel gegenüber Cyberangriffen zu sein.\n\n3) Funktionalität vs. Usability:\nEs ist häufig schwierig eine große Vielfalt an Funktionalität zu liefern und gleichzeitig eine sehr einfach Usability sicherzustellen, denn je mehr Buttons etc es gibt, desto schwieriger ist es für einen Neukunden, sich zurechtzufinden. Der Supermarktbesitzer möchte nun ein Touchscreen installieren, auf dem man den gesamten Bestand überblicken kann. Folglich ist es schwierig, auf dem Touchscreen zu navigieren, da es so viele Informationen darauf gibt, die alles unübersichtlich machen.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1333925,
      "meta": {},
      "text": "1. Functionality vs Usability: \nthe more features and functionalities a system has, the more it becomes difficult to use and to be accustomed to. For example, using photoshop, learning how it works and practicing all its features will take way a lot of time and will make it less usable and only for a specific number of people. On the other hand, the easiest a system looks, the less functions it has. It's the case of paint, which cannot be compared with photoshop in image processing.\n\n2. Rapid development vs Functionality:\nwhen a system requires way a lot of functions, it can't be done in a few weeks, since the developers are used to work with an almost constant development speed. On the opposite side, a rapid development will lead to the development of few functionalities. For example, Photoshop took 25 years to get to the stage, in which it is now, not few weeks.\n\n3. Efficiency vs Portability:\nGenerally, when a software can be used on multiple platforms, it should be able to communicate with a variety of hardware and/or OS. This is although not efficient at all, since the execution time increases, when the executable file can communicate with different CPUs through different Hardware-near Programming languages and since the memory differs from a computer to another. This is what explains why many games are Windows-compatible, and can't be used on MacOS, and new \"high performance requiring\" games not really portable in a windows 97 computer.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344398,
      "meta": {},
      "text": "One of the many design goal trade-offs we see in real world is functionality-against-usability. One should select one of these two design goals, as they contradict each other. As an example, people has to learn how to use professional tools like Adobe Photoshop, Final Cut Pro etc. , because of the sheer amount of functionality in them. So most of the daily-used apps limit their functionality to be more intuitive with their UIs (e.g Instagram, WhatsApp, Twitter etc.). Therefore, the app makers should choose one of these two goals, based on the purpose of the app.\n\nAn another example would be the efficiency vs portability. As a programmer should know, the most efficient way of writing code is writing hardware-level code, e.g. ASM, which are platform-dependent. So if one wants to write efficient code, making it portable will be really hard. To make it portable, one should write a write-once-run-everywhere code e.g in Java. But adding an interpreter + a compiler in your way to the hardware makes the code less efficient. (Real life example: computer games that should be efficient and can only run on Windows computers vs. WhatsApp, running on every system you like)\n\nThe last example is rapid development vs functionality. Sometimes, corporations want to release a software/game in a short period of time. That is possible, if the project doesn't require a lot of functionality. In cases it requires a lot of it, these development gets delayed. A great example of that is the rushed new game Cyberpunk 2077. Short of employees, they tried to rush an open world game, that has came with a lot of bugs.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344534,
      "meta": {},
      "text": "Functionality vs. Usability : During a development of  system, we would like to add as much as functionalities to the system but that does not mean our system is going to be user friendly. For example in a website when we see 20 different links and topics to click on, that does not make the website usable but confusing.\n\nCost vs. Robustness:  When we want to make our project as cheap as possible then we need to rist the robustness of our system. For example we are a coffee machine producer and we want to produce machines made of cheap material to decreace the cost but then probably the machines will not be very robust.\n\n\nRapid development vs. Functionality: When we want to develop a system in a short amount of time then we need to compromise the functionality of the system. For example in a couple of weeks we can develop a 2D Java Game but its functionalities will not be like the 3D games which are produced in couple of years.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1565519,
      "meta": {},
      "text": "A trade-off we have to deal with every day is that one between portability and performance.\nWhy don't we go every day with our really efficient Computers threw the day? Of course, because it's not portable (too heavy and no electricity). Therefore we got laptops or to think one step further mobile phones or smartwatches with better portability but as a trade-off less performance.\nThe biggest trade-off, in general, is the cost compared to almost every nonfunctional requirement.\nMore functionality needs more developers, more efficiency needs better hardware or better algorithms (improving these costs much time and therefore also money or really great developers with high salaries), and so on.\nAnother well-known trade-off is that one between (costs, ) time, and functionality. You will always obtain just two of that three. If you want to develop a computer game really fast you need many money to make the game nevertheless with grat graphics and so on or you just develop  your game with less money, but therefore with bad graphics and less functionality for example.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1630539,
      "meta": {},
      "text": "one of Typical design goal trade-offs is Functionality vs. usability, this for example is sometimes a very detailed user interface , user can find it hard too maneuver in to many diffrent options and that make it hard to choose what they need .\nAnother design goal trade-off is the Cost vs. robustness aspect , this for example if the team does not spend time or money on a load balancer for the application , in times of high usage the perfomence will drop drasticly. \nAnother design goal trade-off is the Efficiency vs. portability, this for example is seen in cloud migration, if the system is prfectly adjusted to the server environment of the team, many of that adjustment have then to be changed or deleted to make the projects work in the new environment .",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292073,
      "meta": {},
      "text": "1) Rapid development vs. functionality: If an application needs to be developed in a very short amount of time, the developers don´t have the time to implement a lot of extensive features. So the developers have to focus on the most important features first and then they probably don´t have the time for other secondary features left until the deadline. For example if an application would need 10 features to be good but the deadline is in a month, the developers may only be able to implement 5 of them.\n\n2) Cost vs. robustness: If enough money is available to create an application, Additional measures can be taken in order to increase the robustness of a product. This can be achieved by for example redirecting the user requests to a variety of servers in order to not overload a single server. This has also the advantage that the application can still be used if a single server can´t process any requests due to various reasons.\n\n3) Functionality vs usability: If a system provides a multitude of functions, the usability automatically decreases because all the functions have to be presented to the user which leads to a flood of control elements. Therefore the user needs a long time to learn how to properly use the application. Such an example would be photoshop, blender or software for architects. They provide a lot of functionality, but it is not easy to learn how to use them.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292738,
      "meta": {},
      "text": "rapid development vs. functionality:\nThe first typical design goal trade off in software engineering that is very present today is the one regarding rapid development vs. functionality of mobile games. Today there are a huge amount of very simple mobile games created because a lot of development companies want to create the next mobile game hit that gets on the top spots in the appstore just as fast as humanity has forgotten it again. For these companies it only matters to produce as many games as possible and as cheep as poosible in order to have a high chance of creating something that wents viral for a week or so. \n\ncost vs. robustness:\nFor rising software companies that provide some online infrastructure e.g. a search engine it is important to minimize the downtime of the software because that might scare away potentiall users. If a very robust system is needed there are a lot of additional costs for e.g. extra servers to balance the workload. As we all know servers are expensive that is why companies need to find the optimal trade of between paying only for extra ressources they actually need in order to maximize robustness and minimize cost.\n\nfunctionality vs. usability:\nI myself experience a design goal trade off of IntelliJ when I use IntelliJ on my older laptop. It can barely handle all opening the application at times because there are so many things it has to load due to the high number of features of IntelliJ. This makes the usability go down because the laptop gets very slow and laggy. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1330408,
      "meta": {},
      "text": "- schnelle Entwicklung vs. Funktionalität: In den allermeisten Fällen muss man eine kurze Entwicklungszeit gegen einen großen Funktionsumfang gegeneinander abwägen, da das implementieren und Testen von neuen Funktionen und Features viel Zeit in Anspruch nimmt/ nehmen kann. So habe ich mich bei der Entwicklung des Bumpers Game für mehr Funktionalität entschieden (die Möglichkeit, den Schwierigkeitsgrad und den Kollisionstyp auszuwählen) und habe dafür rund einen Tag länger gebraucht das Spiel zu entwickeln. In großen und komplexen Projekten bedeuten zusätzliche Funktionen meist mehrere Wochen zusätzliche Arbeit.\n\n- Funktionalität vs usability: Das Beispiel Funktionalität vs usability lässt sich am Beispiel von einfachen Online IDE's vs komplexen IDE's erklären. Während viele Online IDE's nur wenig Funktionen bereitstellen sind sie meist einfach zu benutzen, es gibt nur wenig Menüpunkte und Einstellungsmöglichkeiten. Daher sind Online IDE's meist besonders beginnerfreundlich. Im Gegensatz dazu sind IDE's wie Intellij, Eclipse, ... für Anfänger deutlich verwirrender und es ist anfangs schwerer, sich in den Einstellungen, Menüpunkten und Optionen zurechtzufinden. Stattdessen bieten sie einen deutlich größeren Funktionsumfang und sind daher für professionelle Entwickler unverzichtbar.\n\n- Efficiency vs portability: Entscheidet man sich beispielsweise in der Industrie eine Software nur für den Rasperry Pi 4 zu entwickeln, kann man alles exakt an die Gegebenheiten (Prozessortyp und Prozessorleistung, Arbeitsspeicher, Wärmeentwicklung, Anschlüsse, ...) des Rasperry Pi's anpassen und Optimierungen sogar auf Assemblerebene durchführen, wodurch das Programm sehr effizient ist, jedoch nicht portabel. Einscheidet man sich stattdessen für eine Software in Form einer Web App, kann man diese nahezu auf jedem Gerät ausführen (-> Portabel), sie ist aber bei weitem nicht so Effizient.\n",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1344571,
      "meta": {},
      "text": "Ein typischer Trade-Off besteht etwa zwischen den Design Goals Functionality und Ease of learning: Je mehr Funktionalität eine Anwendung hat, desto schwieriger ist es zu lernen, wie welches Feature verwendet werden kann. Beispiel: Wenn eine UI viele verschiedene Knöpfe hat, dauert es lange, sich zu merken, welcher Knopf welche Funktionalität aufruft.\n\nIm Widerspruch stehen auch Minimum # of errors und Rapid Devolopment: Je scheller der Development-Prozess sein muss, desto weniger Zeit bleibt, um alle Bugs zu finden. Zum Beispiel könnte ein Team so unter Zeitdruck geraten, dass keinerlei Testen mehr möglich ist, was zu häufigen Abstürzen und ungewollten Verhalten führen wird.\n\nDasselbe gilt auch für Minumum # of errors und Low cost: Je niedriger das Gesamtbudget ist, desto schneller müssen die Entwickler arbeiten und desto weniger können sie sich darauf konzentrieren, alle möglichen Fehlerfälle abzudecken. Zum Beispiel könnten dadurch Edge Cases unter den Tisch fallen, die sonst gefunden werden würden, was ebenfalls zu Systemabstürzen oder gar zu Sicherheitslücken wie Buffer Overflows führen kann.\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344733,
      "meta": {},
      "text": "There are different design goals the client, the end user and the developer want to achieve. The developper wants to reuse his code and wants to have a good structure with interfaces and facades. The client off course wants that the developpment cost are low and the end user wants that the system is stable. So there are design goal trade offs which mean that different goals are in conflict with each other. The client wants low cost and the developper not much errors. But if the client don't want to spend much money, the system must be implemented in low time which rises the probability to make mistakes. Another example is the functionality in contrast to the usability. For example a system for research purposes might give many functionality to calculate, shows different values for technical, medical or management purposes but it might be complex to use a gui with different functions to calculate sth, or to steer a rocket. Therefore, learning this gui for example very quickly might be difficult. Another trade-off is that the runtime efficiency is in contrast to the portability. To use your phone you can't use lots of RAM and hugh performance like a PC you aren't able to use outside your home.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1346434,
      "meta": {},
      "text": "The first trade off is functionality vs usability. That means that having a sophisticated functionality usually comes with suffering usability and vice versa. For Example if you design a mobile app for banking with several  functions like automatic transfer orders etc, it is difficult to implement all these features without keeping the app simple and easy to use for the client, as the user might be overwhelmed and doesn't understand how the app works.\n\nThe second trade off is cost vs robustness. This is a more obvious trade off, when you have a project with less budget, less time can be invested in developing and covering all edge cases, when the user interacts with the software. For instance, wrong inputs by the user will lead to unintended behaviour of the software. The other way round, if you spend more money for the project, you can hire more experienced developers who can also devote more time into the system development, making it more robust.\n\nThe third trade off is rapid development vs functionality. When you have only a very limited time to develop a system, you cannot build very sophisticated systems, as they require much time due to many components working together in the systems, which is tough to think of and to implement it. For example developing a autopilot for a car is a difficult project, as it takes many parameters and needs great functionality, which can't be developed rapidly.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1367821,
      "meta": {},
      "text": "I will use three examples to explain the design trade-off.\n1.Rapid development and functionality:\n\tAt first, we want to analysis all the functional requirement and make a big model for our website. But we soon realized that will cost a lot of time and many of us does not understand how to develop a website. So we choose some basic functional requirements and try to develop the alpha version of our website. The website will not have so many functionality at once, but all of us know more about the web-development.\n2.Reusability and Cost\n\tAt first, we want to make each web page a class and this class contain all the code, including RequestMapping, Business Logic, query in database and so on. But then we realised that the code is not reusable, we must write the samethings over and over again. So we made a trade-off. We made the code structure better but cost more time.\n3.Usability and Functionality\n\tAt the first of the UI design, we put a lot of buttons and information in the home page. But it is hard for user to understand so many words. So we make our design simple. This will make the website more usable. But less functionality is the trade-off.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1377384,
      "meta": {},
      "text": "The first design trade-off in the context of software engineering is:\nFunctionality vs Usability: it is important to figure out if adding too many features can hinder the user experience. It is not usable to add functionalities if you think that they are highly unlikely to be used. \nexample: It is useless to add extra features in a univeristy app like deatils of the campus locations, history, etc if the students have difficulty in finding the required things like their classrooms. \nCost vs robustness: it has to be made clear how robust the sytem should be in reagrds to the cost. For example it is not useful to test the system for edge cases and increase the cost of building and testing, when the customer only wants cheap model for prototype version. \nEfficiency vs. Portability: The system needs to be efficient and portable equally. For example, if a developer team focus more on making a game compatible with 3 different devices and the game lags or heats all of them it wouldn't be good. It would be better to develop a game for one platform first, which functions smoothly. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1407647,
      "meta": {},
      "text": "Oftentimes different design goals can conflict with each other just like all non-functional requirements in general. \n\nAn obvious contradiction in the solution domain happens, if you try to achieve a high server uptime so that users can access the services without any limitations. By having highly dependable servers that are online almost 100% of the time, updating the system, and testing new functions on them will be much more difficult since you have to keep them running at all times. So for example most online games have weekly server resets, where they can make changes and test them for 1 or 2 hours before the servers are again publicly available.\n\nAnother example occurs in authentication. On the one hand, it is a typical design goal to assure uncomplicated usability for your users, but you have to guarantee the security of their data. So having a two-factor-authentication system that is mandatory for everyone will lead to the loss of users because they don't want to invest time in the process, while it is less likely that user data is easily exploited. One solution would be to make 2FA optional.\n\nThirdly a common trade-off happens when deciding if you choose to rely on external services for hosting databases like Firebase, because oftentimes it appears to be cheaper and easier to administer, especially for smaller projects. However, you give up part of the control over your system and could potentially be confronted with unwanted changes in the future. Furthermore, the privacy of your user data cannot later be guaranteed, because there are third parties involved.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1415497,
      "meta": {},
      "text": "Fucntionality vs. Usability\nTypically the more functionalities an application offers, the better. After all one chooses to use an application mainly because of its functionality. That is actually not quite right: an application can easly have too much functionality. For instance, say we want to develop a painting app. If the app has 100 different tools, brushes etc. and shows them as ui elements or hides them in some menus, the app becomes useless, altough it has a wide variety of functions. So with more functionality, an app becomes more complex, which compromises the ease of use.\n\nBackward compatibility vs. functionality\nIn general backward compatability guarantees the largest target audience. Altough a very important feature, backward compatibility is not always a reasonable decision. For eg. in game development new technologies for rendering, physics and so on very often require new hardware (eg. grpahics card supporting ray tracing, dlss, ...) so its not possible to make all games compatible with all existing hardware. A compromise has to be made: what to support vs. what to offer.\n\nRapid development vs. everything else\nDuring rapid development most of the design goals suffer reduced quality and possibly higher overall costs. Real life example: because of the new 9 euro mvv tickets, a system for refund is rapidly (I assume) developed for students, who bought the 200 euro Isar Card and the semester ticket. This system must be delivered as soon as possible, so the quality of this system wont be exceptional, and despite that it will fulfill its goal.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1471956,
      "meta": {},
      "text": "One typical design goal trade-off is the the trade-off \"Cost vs. robustness\". For the product owner a priority is often the goal to keep the costs as low as possible. Therefore developers aren't allowed to write a lot of tests since the product owner does not want to \"waste\" any time in setting up a test environment.\nSince tests are crucial for robustness of the application, the robustness of the system suffers when the product owner wants to cut costs.\n\nAnother typical design goal trade-off is the the trade-off \"Efficiency vs. portability\". If the developer wants to optimize the code to run highly efficient on a specific device, the application might perform very well on that device. However on another type of devices it might not even run because the application is written exactly for a single type of devices.\nAn example for that trade-off is the Java Virtual Machine (Java language), which is runnable nearly on every type of device, but it comes with the costs that is not very efficient. In contrast to that is for example the language C, which is a highly performant programming language, but is not supported on every device type.\n\nA third typical design goal trade-off is the trade-off \"cost vs. reusability\". If for example the product owner wants to cut costs, the developers aren't allowed to invest a lot of time into clean code resulting in highly complicated architectures. Those architectures often have high coupling and low cohesion which is indeed not ideal.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1498017,
      "meta": {},
      "text": "1. Functionality vs Usability\nAn app might be versatile if it has many functionalities, but in the mean time it increases the learning curve for the end-users to understand how to use all these functionalities and potentially cause more confusion for the users, which is against user-friendliness.\n\n2. Cost vs Robustness\nIf the robustness is achieved, for example the back-up servers are provided to prevent the breakdowns, the cost also increases.\n\n3. Efficiency vs Portability\nIf the software is design to adapt in a single environment and network condition, it will be more eficient because it will not be bothered by the constraints of the other environment. If portability is considered, the software will be less efficient.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1296379,
      "meta": {},
      "text": "In software engineering one has to often make concessions when it comes to design goals. The different parties of an application(user, developer and end-client) have different design goals and not all of them are possible at once. \n\nThe first instance of such a trade-off could lie between functionality and usability. Usability is defined as \"the ease with actors can use system functions\". However, if a system has too many functions it would be very difficult to learn. For example, if an app has 100 available functions almost no user would be inclined or able to use these features.\n\nA second trade-off is the issue with cost and robustness. In regards to software engineering, robust software can handle a lot of errors and wrong input by the user. This however is not cheaply acquired. For instance, if I want to create a game application and the user has a lot of options to deviate from the \"normal\" game behaviour I would have to catch numerous edge cases, which therefore also requires more testing. This costs more time and more money.\n\nA third conflict, which is similar to the second trade-off, is rapid development vs functionality. If a software needs to be developed rapidly only a limited amount of functionality can be implemented. For example, if a company only has 4 days to develop an application, there will be few functions within the app, since creating new methods requires more testing which takes more time. \n\n  ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1304074,
      "meta": {},
      "text": "A first example for a design trade-off would be functionality vs usability. For example if want to develop an app with a lot of functions for the end user, i might get into some problems in terms of usability because my apps can get too crowded for the user. We all know app/websites etc. that offer a lot of stuff but are really hard to understand in the beginning. So as a developer i might cut some functionalities in order to keep a nice usability.\n\nAnother common trade-off is rapid development vs functionality. So i might have some ideas for my product and i would like to implement them in my end product but if i also want a rapid development i have ask myself some questions. Do i really want to invest more time in the implementation of some functionality or do i want to save the time in order to achieve a faster development? Do i want to rush implementation and risk some errors in my functionalities? So i think sometimes we have to make a compromise and for example just leave some functionality up for later or just give myself more time for the development in order to achieve a correct implementation.\n\nA third trade-off is the cost vs robustness. Everybody wants that their own product is on the one hand very robust against influences from the outside / the inside and on the other hand not that cost intensive. For example if i have a system like artemis that is responsible for exercise grading for a whole university where it is really important that my system is robust, because if it fails we might get into a lot of trouble. But we also want to keep our costs low as we have limited resources. Here we have to decide if we want to spare our resources and risk a potential danger or if we want to invest some costs into our system and ensure that it runs stable all the time.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1316155,
      "meta": {},
      "text": "Robustness vs. Costs:\nBei der Entwicklung eines Spiels muss entschieden werden, ob beispielsweise sämtliche falsche Eingabedaten und Verhaltensweisen des Spielers behandelt werden sollen oder ob man etwa einen Absturz des Spiels in einem solchen Fall bzw. ein eingeschränktes Spielverhalten bewusst in Kauf nimmt um den Aufwand einzuschränken, um Kosten zu sparen, jedoch damit auch die Robustheit des Spiels verringert.\nDie Aufrechterhaltung der Funktionalitäten einer Software stehen folglich im Zielkonflikt mit geringen Kosten für das Projekt. \n\nUsability vs. Functionality: \nEin Zeichenprogramm kann entweder ein Minimum an Funktionen haben und damit für Einsteiger sehr schnell zu erlernen und leicht zu bedienen sein oder sehr viele Funktionen anbieten, aber damit einen neuen Benutzer mit allen Menüs und Tools überfordern, sodass er letztendlich weniger erreicht als mit dem geringeren Funktionsumfang. Je einfacher das Programm in der Bedienung, desto weniger Funktionen können angeboten werden und je mehr Funktionen integriert werden, desto unübersichtlicher und schwieriger zu bedienen. Außerdem ist der Funktionsumfang zu groß, um sich alles merken zu können.  \n\nRapid development vs. Functionality:\nDieser Zielkonflikt zwischen einer raschen Entwicklung und dem Funktionsumfang meint, dass die Integration und Entwicklung von vielen Funktionalitäten der Software zeitintensiv ist und somit einer zügigen Entwicklung im Wege steht. Ein Beispiel ist die Corona-Warnapp, sie musste natürlich sehr schnell entwickelt werden, um der Pandemie entgegenzuwirken, ein großer Funktionsumfang war damit nicht vereinbar, weshalb sie zu Beginn nur ein Minimum an Funktionen lieferte. Erst mit der Zeit konnten weitere Funktionalitäten ergänzt werden. ",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1342521,
      "meta": {},
      "text": "When designing a software the development team sets a  couple of design goals trying to combine all that they, the client, and the end-user wants. It's natural that some design goals discord with each other or conflict.\nthere are always some design goal trade-offs and these are 3 Typical ones.\nCost vs. robustness:\nRobustness in software engineering is the ability of a system to handle errors during execution and its ability to recover when facing wrong and unexpected inputs.\nAnd by cost, it meant the cost estimation of the efforts and the time spent to develop and test the software. Since there is a huge quantity of possible input combinations,  testing requires much more time which costs more money.\n\nFunctionality and Usability:\n Functionality is the ensemble of operations that  are supported in one  interface .\nUsability is the ease of use of a software system.\nPutting a lot of functions in one user interface  makes  a system more functional.\nBut this can make it hard to learn and difficult to use.\n\nPortability vs efficiency:\nportability is the ability of a system to be used in different hardware and operating systems.\nAnd efficiency is the amount of time, people energy used to develop a software and how to use the smallest amount of it.\nTo make a software portable the development team may need to use different tools that they are used to, write more codes, or do another requirement of a specific operating system which conflicts with the purpose of efficiency.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1344167,
      "meta": {},
      "text": "Conflict ob objectives 1: Low cost vs. runtime efficiency\nLow costs and runtime efficiency are in conflict with each other, since efficient systems mean more development effort on the one hand, since more thought has to be given to the speed of processes, and on the other hand, it is also a question of infrastructure. For example, if you have multiple servers and can use a load balancer to distribute requests, server response times will be much faster. Buying and running these additional servers means more costs, so one conflicts with the other. An example of this conflict is developing a chat application with central servers.\n\nConflict of objectives 2: Rapid development vs. good documentation\nThe fast completion of a development project is in conflict with good documentation. If the application is to be finished as quickly as possible, the functionality of the application takes precedence, as without this the documentation is also useless. However, developing good documentation is time consuming, so development takes longer. An example is the development of an API for accessing Corona case numbers.\n\nConflict of objectives 3: Functionality vs. ease of learning\nEase of learning conflict with a lot of functionality. If the application should have many functions, this application is also more difficult to learn, because many functions mean more effort for the learner. An example is an online platform to buy stocks and bonds on the stock market.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349901,
      "meta": {},
      "text": "The first typical design goal trade-off is between the cost and robustness. The lower the costs are, the lower the robustness. By paying less for the development of your software one unfortunatly has to \"save\" code in other areas. An example for that would be the software loverobotics. The software was cheaply developed but had many huge errors and bugs if one entered false or faulty information into the input-areas. In this case it was so horrible that they shut down the software.\n\nThe second trade-off is between the efficienty and portability. An example could be the usage of IntelliJ. IntelliJ is usable on multiple platforms and can be easily installed to another architecture. Unfortunatly it is sometimes not that efficient because it does not give efficient solutions to special problems which come up.\n\nThe last trade-off is between rapid development and functionality. An example here would be the app called shyftplan which displays the work shifts of your employees. The development of the app was quite fast and the app was published after 3 Months of development. Unfortunatly it had many bugs and in the end was not a good product.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1655049,
      "meta": {},
      "text": "scalability vs maintainability\nWhen designing for example a social network, at one point you would have to come to a trade-off between maintainability and scalability. By running multiple instances of the server we can achieve a higher scale, but we loose a bit of maintainability (server upgrades, adiministration, etc.\n\ncode readability vs code performance\nin some programming languages, the code that is good to read, isn't always the fastest. Once we start pushing around bits, it can get hard to understand what the code is doing, although it might be fast. This can spawn a couple of issues later down the road. \n\nreuse of components vs rapid development\nwhen trying to build a application quickly, one is often lured into doing it in a \"dirty\" way. Static, hard coded components that aren't reusable. Anything else would require extra consideration, which would slow down the development",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291650,
      "meta": {},
      "text": "A game studio might think about cost and reusability when deciding on a game engine for new projects. While the price of Unity scales with the financial success of the company, Godot stays free. However, old assets, a production pipeline and developers associated with Unity cannot reuse their knowledge and might also need to retool. If the long term savings of using a free game engine outweigh Unity royalties a painful short term decision could be made.\n\nWhile end users value robustness of an application for doing daily work reliably, the client is concerned with future functions and features to gain more end users and grow their market share. The robustness of an application can be threatened, when the architecture focuses on flexibility to allow rapid implementation of new features. Without sufficient tests which mitigate bugs and application crashes, a flexible architecture is more open ended by design and therefore less dedicated to doing one main task right. Applications made for Iphones tend to perform more reliable and behave more consistently than their Android counterparts, in part due to the flexibility Android apps need. They need to work on different Android versions, edited by individual manufacturers, who use a variety of chips and even more screen sizes. Those in turn require custom scaling for the best experience. Apple can rely on a small number of screen sizes, predictable OS settings and more factors which tends to deliver higher robustness and calls for less flexibilty.\n\nTesla could be focused on rapid development of the UI, when the end user cares for user friendliness and does not welcome UI changes.",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1299831,
      "meta": {},
      "text": "A typical design goal trade-off is costs vs robustness. To make a functioning Sofware System robust or more robust u need to invest additional time and money for developers to test the system for every possible edge case and repair bugs in the code.\nAnother design trade-off is portability vs performance. If you have develop a Software System  in C and Optimize it this Software can get very efficient and fast. It has a very high performance but it is not portable and cant be used on other computer or  operating systems.\nA third design trade-off is usability vs functionality. If you overload a System with functionalities you system become more complex and harder to understand.It gets harder for the user to use it.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1304999,
      "meta": {},
      "text": "cost vs. robustness:\nWhen you work in a company that creates games, you as a developer want to make the game as robust as possible, meaning that the game does not crash when the user enters any wrong inputs or that the game can handle certain temperatures. This however takes a lot of time, and since clients rarely want to spend more money on development, you usually have to sacrifice some amount of robustness in order for low costs.\n\nbackward compatability vs readability: \nLet's say you and your team are working on a next generation gaming console, but your client wants that games from the older generation are still compatible on the new console. This means that some code used from the older generation console, which perhaps you haven't even worked on, will likely be reused again, meaning your code will fall off when it comes to readability. \n\nfunctionality vs. usability:\nWhen your working on a new social media app, you usually want your app to have many different functionalities, like chatting, posting, commenting, stories, a customizable profile and so on. However, having too many functionalities could lead to the end user struggling to figure out how to make use of them all. Thus the usability of your application needs to be valued equally to the functionalities you want to add.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1317268,
      "meta": {},
      "text": "Functionality vs. usability: \nTo much functionality can negatively impact the usability. For example if you program a calculator which has a button for every possible mathematical function you will have way to many buttons and it will take a long time until you will find the one you want to use.\n\nRapid development vs. functionality:\nRapid development can negatively impact the functionality. If you program a calculator in a very short time, you will not be able to add as many mathematical functions, as if you take more time for it.\n\nEfficiency vs. portability:\nPortability can negatively impact the efficiency. If you prgram a calculator which can run on multiple machines you won't be able to optimise it for a certain hardware and the calculations will be slower.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1488933,
      "meta": {},
      "text": "One of the most seen trade-offs in software engineering is the functionally vs usability trade-off. A very obvious example from the gaming branch is candy crush and star craft 2. When designing a strategy game rather simple and easy to manage you can reach a wider rancher of players. The simpler the game gets the more players might play the game. The problem with star craft 2 and the functionally overdrive is the same:” Does the user really want to invest this time into the software in order to use it sometimes?”. Another trade-off that is quite common is the cost vs. reusability trade-off. You can see this problem with Windows and Apple. Windows 11 is a system that is still based on the Windows NT system. Unlike apple, who started a very own and more developed as well as organized system as a foundation of the IOS we know today, windows still take’s everything they used in the past into the modern systems, which makes development as well as adjustments to the system very difficult. A third trade-off is the rapid development vs. functionality trade-off. For this trade-off I think a perfect example is Windows 8. Windows 8 should have been the successor of Windows 7 but the problem was that the system was not only completely sloppy designed but also full with bugs. The start menu often didn’t work, the windows explorer did his own things without touching and the processor performance was restricted. All these bugs and even more happened because Microsoft tried to rush the new system out instead of testing it out fully.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1298168,
      "meta": {},
      "text": "1) An example for a \"rapid development vs functionality\" trade-off in the context of Software Engineering can be found in the development of a company internal CRM. If the company does not have a CRM yet and is in desperate need of one, the system has to be developed as quickly as possible, to ensure the proper daily workflow. This rushed development can cause that there is not enough time for the team to implement several functions, e.g. integrations for other services.\n\n2) A Functionality vs Usability trade-off can be found when the amount of functions/possibilities a system offers, limit the usability of the software by its sheer volume. For example if in the Bumpers game, the PlayerCar had 100 different abilities the player has to control and use, it would be impossible to play, as a person would not be able to handle this many functions at once.\n\n\n3) A Cost vs Reusability trade-off appears when a system is designed only for a single use, to have low test costs and fewer coding efforts. This causes, that the components of the system code can not be reused for other systems, as they are only tested and programmed for the one single use case. The reusability suffers like this for example when developers create a computer game from scratch, but don't consider the usability of the software components in other environments, for example for another game. They would then have to start from scratch again with the next game.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1310549,
      "meta": {},
      "text": "A typical design goal trade-off is for example functionality and usability. An example for this trade-off would be when you want to have many features and complex functions in your software but then it's too complex and take too long to get comfortable as a user with the program. So the usability",
      "score": 16.7,
      "language": null
    },
    {
      "id": 1311177,
      "meta": {},
      "text": "1) schnelle Weiterentwicklung vs. Funktionalität\nZiel der heutigen Softwareentwicklung ist es sich möglichst schnell weiterzuentwickeln und den permanenten Veränderungen anzupassen um nicht vom Markt verdrängt zu werden. Allerdings kann durch zu schnelle Veränderungen der Code auf Dauer nicht sauber bleiben. Dies beeinträchtigt selbstverständlich die Funktionalität, da man durch den permanenten Wandel kaum Zeit hat einen Code einwandfrei und \"clean\" zu schreiben und zu gestalten (gerade auch da man wenig Zeit hat sich im Vorhinein Gedanken zu machen). So gesehen wird wenn man seine Priorität auf eine schnelle Weiterentwicklung setzt langfristig die Funktionalität aufs Spiel setzen.\n\n2) Kosten vs. Robustheit\nFür die meisten ist es selbstverständlich ein Ziel Software so Kostengering und -effizient zu halten. Allerdings schränkt das natürlich die Möglichkeiten der Entwicklung ein, sodass beispielsweise die Robustheit einer Software nicht sonderlich gut ausgebaut werden kann. Da es kostspielig ist eine Software von vielen Leuten gleichzeitig nutzen zu lassen wird dieser Punkt vernachlässigt wenn man auf seine Kosten achten möchte. Eine Software Robust zu halten kostet vor allem viel Zeit und Aufwand, nicht jeder hat die Möglichkeit/Priorität dafür zu zahlen und verzichtet auf den aufwendigen Ausbau zur robusten Software.\n\n3) Funktionalität vs. Benutzerfreundlichkeit\nUm die Funktionalität einer Software zu erweitern und permanent zu verbessern ist es unumgänglich viele neue \"features\" zu entwickeln. Allerdings ist es schwierig diese vielen \"features\" Benutzerfreundlich und immer noch übersichtlich für den Nutzer darzustellen. Schließlich möchte man den Benutzern mit einer Software viel anbieten und zur Verfügung stellen. Dabei ist es wie schon erwähnt einfach schwierig beispielsweise das Layout (eine Menüleiste) übersichtlich zu gestalten wenn man ein Riesen Angebot hat und auch anbieten und präsentieren möchte.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344424,
      "meta": {},
      "text": "1. Functionality vs. Usability: If a software has a lot of functionality, it usually becomes less usable for the end user (who has to handle all of the functionality). Simplifying the usage of the software in turn makes it more usable but less functional. Image, for example, a music streaming app. A usable version of this would have only very few UI buttons (play, pause, select music, skip) and thus, very basic functionality. One could instead add a lot of options to the user interface (like various audio quality settings to the extent that the user can specify a compression algorithm) and thus, increase funtionality. This would, however, clutter the UI and make the software less usable.\n\n2. Rapid developement vs. funtionality: This trade off is pretty self-explanatory as adding funktionality (obviously) increases developement time (because someone needs to code all the features). Take for example an online multiplayer game. One could quickly develope a version of the game with only one basic game mode or one could invest more developement time to develope multiple different (and more complex) gamemodes.\n\n3. Cost vs. Robustness: Robustness means that the software can handle various kinds of (potentially unintended) user inputs and situations. Many of these need to be taken care of individually during developement which increases devopement cost. Imagine a game where the player has multiple abilities. One could release a version where each ability by itself works fine but, once many abilities are used simultaneously, the game breaks. Separately handling all these combinations of abilities would fix this issue but would also increase developement cost.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344432,
      "meta": {},
      "text": "Functionality vs usability: When a certain part of a system is tasked with too many functionalities, it will often be less usable for the end user, because of speed, performance or visualization issues. For example, when an user-interface is tasked is supposed to have a lot of buttons, that provide different services, so that ecerything is acessible from the same spot, it can become cowded estheticly unlpleasant , chaotic and diffucult for users to use.\n\nRobustness vs cost: Robustness is very important for a reliable system. Achieving it however, can be very costly and incompatible witha low  budget. For example, implementing machinery that can tolerate very high temperatures will make sure the system will continue functioning, even if it overheats, but it will probably increase the cost as well. Therefore, it has to be added moderately and only within the range of expected temperatures.\n\nRapid development vs security: Most of the times, a client wants the system to be released as quickly as possible, so hey can start profiting from it sooner. This means, that Developers dont have endless time to make the system as secure as possible. However, a system without propper security measures is exposed to attacks and likely to be taken down. Therefore, the decision must be made, how much time is spent on security and when to stop devoloping to start profiting. When developing a bank system for example, security is crucial, however the system must be running for the bank to be able to recieve money. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1345550,
      "meta": {},
      "text": "There are three different types of design goals: customer, end user and developer. For the most part, these goals are distinct and overlap only in small aspects of what is most important to them. E.g. Maintainability is important for both client and developer, but the end user doesn't care. Maintainability is, for example, an easy-to-understand programming structure. The better the structure, the easier it is for new programmers to familiarize themselves with it and therefore are faster to start prgramming -> costs the client less.\n\nBecause there are three different types, compromises have to be made. Examples:\n1. The client wants to get the maximum profit with minimal investments, but with more money, user friendliness can be improved, for example, because specialized UI programmer is hired to improve the website.\n2. The client wants fast development, but that increases the risk of errors because the developers can test the code less, i.e. the two goals are opposed to each other. E.g. Marvel (client) suddenly wants an additional website with information about all MCU movies in a week, so that the viewers (end users) have a better overview.\n3. Flexibility (client) and robustness (end user) are also opposed to each other. For example, the client wants his plant-watering-product to work on all cell phones and also on all PC operating systems. Thus the programmers are busy running the main functions on everything, the system is not maturely programmed = less robust (quality < quantity).",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1349989,
      "meta": {},
      "text": "Das erste typische design goal Tradeoff, das ich hier ansprechen will, ist das Tradeoff functionality vs. usability.\nDas Tradeoff liegt nämlich darin, dass das system umso mehr Funktionen es haben soll auch immer komplexer wird. Ein konkretes Beispiel dafür wäre, wenn zum Beispiel das Bumpers game noch eine Funktion Sprung hätte, die es ermöglicht über andere Autos zu springen um einer Kollision zu entgehen. Das würde aber auch weitere Komplexität in das Spiel bringen und es schwerer machen das Auto zu steuern... Dadurch würde die usability eingeschränkt werden.\n\nDer zweite design goal Tradeoff wäre cost vs. robustness.\nDas bedeutet, desto weniger das System kosten soll, desto weniger robust ist es auch und umgekehrt.\nAngenommen es soll ein System kreiert werden, das anfällig für Angriffe drauf ist. Desto mehr Geld man investieren würde, desto weniger Lücken würde es geben, da diese Lücken mit Arbeit, die ja bezahlt werden muss geschlossen werden kann.\n\nDer dritte design goal Tradeoff wäre rapid development vs. functionality.\nDas bedeutet, desto schneller das System entwickelt werden soll, desto weniger Funktionen kann es haben und umgekehrt.\nDa entwickeln Zeit benötigt, kann wenig in einer kleinen Zeit implementiert werden und dadurch auch wenig Funktionalität und auch umgekehrt.\nEin Beispiel dafür wäre Eine Anwendung, mit der Fußballkarten verkauft werden können. Diese Anwendung kann dann auch Fußballkarten verkaufen, aber leider ist es nicht möglich ein Bild zu den jeweiligen Karten einzustellen, da es nicht genug Zeit gab um diese Funktionalität zu implementieren.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1354192,
      "meta": {},
      "text": "1. Delivery time vs maintenance cost\nIf the software needs to be delivered on a particular deadline but not all the tests are running through, that piece of software may be released on time with the trade-off of potential errors occurring on some edge cases. The end-user/customer may end up with (possibly rare) unwanted situations, but the software was released on schedule. Sometimes this can be the more expensive route than delivering the software off-schedule with all the tests working, because fixing and tracking down all the bugs at a much later time can be very time-consuming\n2. Time and budget vs documentation\nIf the source code requires solid documentation, then additional costs and a longer development time have to be taken into account. This can be a good investment for example if the whole system is already known to be working fine e.g. there haven't been many issues, feedback from users/the customer is positive, and all the requirements have been met, after which rigorous documentation can be worth it to increase the readability as well as the extensibility of the source code. However, focusing on documentation may not be a primary concern in the early stages of development, where fixing bugs and getting continuous feedback from users/the customer is much more important.\n3. Functionality vs usability\nThe customer may constantly require more functionality, thinking that this would lead to an improved and more extensive user experience. However, every added functionality also increases the complexity of the system, which may lead to an overly-complicated system, which in turn hinders the user experience. Therefore, the process of adding functionalities may be said to be following the law of diminishing returns. Simplicity is key.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1405220,
      "meta": {},
      "text": "Oft werden beispielsweise höhere Kosten für eine bessere Performance oder mehr Funktionalität eingetauscht. Brauchen die Entwickler mehr Zeit um die gesetzten design Goals einzuhalten so ist dies mit einem höheren Kostenaufwand verbunden. \n\nDie Entwicklungsfirma muss darüber entscheiden, ob bei einem wie oben beschrieben Fall weiterhin an den aktuellen design Goals festgehalten werden soll oder ob vielleicht an Funktionalität gespart werden sollte. So ist oft die Entwicklungszeit auch ein entscheidender Faktor. Tritt letzteres ein so tauscht man geringere Entwicklungskosten natürlich auch gegen Nutzer Zufriedenheit ein.\n\nEin weiterer Punkt wäre zum Beispiel ob ein Programm auch für ältere Architekturen abwärtskompatibel sein sollte. So könnte zum Beispiel Performance oder Lesbarkeit des Codes gegen diese eingetauscht werden.\n\n",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1442220,
      "meta": {},
      "text": "Example 1: \nYou could implement a cloud system for better usability for the end customer but on the other side with that comes high implementation and maintenance.\n\nExample 2:\nYou could implement new functions, like an online game modus in a game, that needs a lot of time or you just invent a few new levels in a game to get more player in a game and have a rapid development\n\nExample 3: \nIf you have for example invent a new game with cars that have their own superpowers but they have to many that they don't fit on the keyboard which is not really user friendly.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1554097,
      "meta": {},
      "text": "# cost vs. robustness\nLower budget can lead to a lower number of developers which in turn leads to less eyes on the code. Assuming time to develop is not unlimited, testing of existing code may suffer in favor of new features which are to be implemented until deadline xxx.\nTherefore lower cost of development often leads to less robust code.\nExample: many websites of small businesses with faulty contact forms etc.\n\n# backward compatibility vs. readability\nOver time, now pseudo-obsolete features of a software project may clutter the code base as it grows and new subsystems get added. Adding new features may also be cumbersome, if there are bizarre requirements due to backward compatibility.\nExample: legacy systems in the banking world written in COBOL\n\n# functionality vs. usability\nPrograms which cram lots of functionality into limited screen space often rely on complex macros, huge drop down lists etc. This directly contradicts the goal of easy to pick up and quick to master, visually pleasant software (usability).\nExample: Adobe After Effects vs. Windows Movie Maker",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290894,
      "meta": {},
      "text": "- Flexibility vs. Simplicity: Some systems need to have a lot of flexibility and scalability built into them because you know that your idea will grow to a bigger project. \n- Development Speed vs the agil mindset: Do you do something quick and dirty possibly impairing the speed of future development due to your hacky work producing new bugs later on? Or do you invest time up front to design proper interfaces, write tests and attend all the agile meetings that are required in a scrum process.\n- And finally for database load heavy applications a common trade off is the speed of reads vs. the speed of writes.\n\n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291567,
      "meta": {},
      "text": "I will use the Bumpers as the example:\n\n1. typical design goal trade-offs: Efficiency & portability:\nthe application of this game appears fast, less than 2 seconds. The game can also be downloaded to a USB.\nSo it is very efficient and portability.\n\n2. typical design goal trade-offs: Functionality & usability:\nBumpers has some functionality like Audioplayer, playmusik... it is also usable and there has not many function like 50 functions. we can also create some functions like play pop music, play classic music, but this is for Bumpers not useable. So we should balance functionality and useability at the same time.\n\n3. typical design goal trade-offs: cost & reusability:\nby Bumpers game there's a lot of cars start at the same time, when collisions happens, it will be stopped.\nthe game can directly start after game over if player click the button \"start the game\". This Game is reusability, and the cost of this system is also low, it need just for-schleife.\n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292011,
      "meta": {},
      "text": "The three design goal trade-offs that i would mention here are efficiency vs. portability, rapid development vs. functionality and backward compatibality vs. readability.\n\nEffiency and portability contrast against each other since efficient programs are usually not portable, which means it would not be available on multiple platforms. For instance, octave, which is an open source version of matlab with slightly different functionality is absolutely minimal and efficient. However, Octave is only available on pc whereas matlab, which is a much bigger program, support mobile devices and tablets with android or ios system.\n\nRapid development and functionalities is definitely a huge trade-off. If one wants to development a project as fast as possible, he or she should overlook complex functionalities and focus on the core one. Projects from hackathon, for instance, are most likely not going to be complete since the development process is extremely compact. Many projects with great ideas will be refined in a much longer and ampler time just to make sure that more functionalities are implemented.\n\nBackward compatibility and readability is another interesting trade-off. A typical example would be xbox. Xbox has a feature called backward compatible, which means that games from older generations of consoles can be played on the latest generation of console. However, the graphics of most games are not satisfying and the overall gameplay experience is not optimal. Most game companies, on the other hand, would remaster these older games and provide them with better graphics. They might not work on the older generation of console, but they provide gamers a much more enjoyable experience.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292706,
      "meta": {},
      "text": "Functionality vs. Usability:\nthese two design goals often times collide with each other because each additional functionality typically clutters an interface, so that it is less usable/intuitive. On the other hand, a very usable and easy to understand interface is often times very minimalistic and therefore doesnt provide many functionalities. \n\nCost vs. Robustness:\nthese design goals have to be weighed against each other, since handling all errors, edge-cases, extreme environments and making sure that the system maintains its function in all scenarios needs a lot of resources (time, money, personnel, etc.). This, in turn, pumps up the costs for the implmentation, whereas a lower development cost most likely comes with some edge cases not taken care of. \n\nRapid development vs. Functionality:\nthese design goals need to be traded off, since the development of suffisticated funcionalities, extra services, shortcuts, process improvements, additional features, etc. needs time to be implemented. Therefore, rapid development normally entails a less featurerich system.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1294883,
      "meta": {},
      "text": "Example 1:\n\tThe tradeoff between easy to learn and quick to use, when you already leaned it.\nThe Software Pro Tools by Avid is the industry standard in digital audio workstations.\nIt is a very powerful program, with which you can do almost anything technically possible when producing, mixing and mastering a song ore some other form of audio. Almost every pop song is produced with this software, because it is very fast to use, when you know, what you are doing.\nBut when you first try to lern it, the seemingly endless possibilities, you have at every window and Ui interface can be overwhelming and very difficult to learn. ( Logic Pro x did a better job at this)\n\nExample 2:\nThe tradeoff between safety and performance:\nWhen maintaining a database, the most important thing is, that you don't lose any data.\nThe way of achieving this goal is to have a lot of redundancy.\nA commonly used practice is, to only commit an operation to the database, if everything about this operation is finished and stored. \nThat takes a lot of time, because you have to copy the log file to your secure storage facility, before committing the operation and the storage units are, often times, the slowest part of a  operation.\nIf you didn't do this and ran everything in the system memory of the device, that handles all the operation requests, the database is lost, when a fire ore a power failure happens.\n\nExample 3:\nThe tradeoff between performance and portability.\nOn the M1 chips from apple, software written for that specific hardware runs very fast and power efficient.\nBut you can't, without major difficulties, run the same software on intel or amd based hardware.\n\n\n\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1329484,
      "meta": {},
      "text": "Efficiency vs. portability: Before starting to code an application the developers have to decide if they want it to have more performance, but less portable, or vice versa. It starts with the language they want to write it in. Java for example is very portable and reasonable fast, but using C++ would be a much better choice for performance. The problem there is, that it has to be compiled in a different manner for different types of systems.  \nBackward compatibility vs. readability: An example for this category could be the Intel x86-64 Architecture. It is backward compatible with x86-32 and even older generations, but probably is not that readable. The reason for that is that a lot of the old source code (decades old) is mixed with newer source code which makes it harder to read.\nFunctionality vs. usability: An application should be both, but often the line between putting a lot of functionality on the UI and it still being usable is blurred. This line shifts depending on who uses the application. Experienced users often prefer more functional applications over more usable ones. With newer users it's often the other way around. A good example for this trade-off are the editors VIM and nano. With VIM a user gets a lot more of functionality, but (at least in the beginning) it's harder to use than nano. Nano on the other hand behaves like a normal text editor but it lacks a lot of cool features, like builtin makros etc (-> slower editing).",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344415,
      "meta": {},
      "text": "I want to describe the 3 typical design goal trade-offs with one Example, the game-simulator Sims, namely to compare the Sims 3 and the Sims 4.\nFunctionality vs. usability:\nFor example, building a house. For example, building a house. In Sims 3 it was difficult, you had to choose different modes to put up a wall, and to choose a wallpaper. In Sims 4, this has been simplified, and now everything can be done in one mode. Sims 4 has simplified and now everything can be done at once. However, creating a small pond in the garden is no longer possible, as in The Sims 3. It was great functionality.\nRapid development vs. functionality:\nThe development of The Sims 4 came in 2012 and release in 2014. In compare to Sims 3, thats development started in 2006 and the release was in 2009. The Sims 4 development was one year faster, as the Sims 3. And thats is visible in the functionality. In Sims 3 was the complete open world, and in Sims 4 is closed world. You cannot move freely around the map, and each house is loaded separately.\nEfficiency vs. functionality:\nOne of the Sims 4 improvements was the fast loading of the game, but the game lost its travel-type functionality. In Sims 3, you could go to other countries, with interesting tasks and adventures. But due to this variety of functionality, the game took too long to load and bugs often occurred.\n\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1347960,
      "meta": {},
      "text": "Rapid development vs. fuctionality:\nHow fast a system should be developed heavily influences how much functionality the program has. \nIf the program has to be finished very fast, there's only time for the most important functionalties.\n\nBackward compatibility vs. readability:\nIn most cases it is very dificult to read code which is old and not well documented, so the readability suffers from the restricition of backward compatibilty\n\nEfficiency vs. portability:\nA portable program is mostly not that efficient like a fixed one. Certain features of the system can't be used as good they could be and thus, the program is more inefficient\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1482998,
      "meta": {},
      "text": "Performance vs Maintainability: \nWith programming there is almost always a way to make something faster, threading, parallelism in general, or plainly writing less code for the algorithm to execute. A great example are streams very often you could very well use streams to make a programm run faster as they run in parallel, however often times they can become hard to understand or read and hard to alter for future applications so for marginal improvements it might just not be worth it to use them.\n\nRapid development vs Robustness:\nWith projects there is almost always a deadline, however if the timeframe being set is just to marginal this may result in bad code or code that has not been tested well enough. Sure you have to be fast but if it does not work afterwards what did that bring you. The upside of the speed has to be weighed against the potential downside of mistakes occuring afterwards.\n\nAdaptability vs Rapid Development: \nAdaptability is a hard thing to achieve it takes a lot of time to design a more adaptable system, in addition you have to create a strong abstraction of a system and then as another step adapt it to your clients needs. This just takes a lot of time in general and can extends the design process and implementation process by a lot. You may for example need to do more or different testing to ensure that your system is adaptable to more and different use cases.\n\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1617064,
      "meta": {},
      "text": "A typical design goal trade-off would be cost vs robustness. The Client obviously wants the product to incur low costs in order to maximize profit, while the user wants the software to be robust. For example if a company creates a new software or a new game, certain edge cases should taken care of, but this is obviosly more costly. For example Bugs in games re very tidious for the user and often only exist because of cheap or unfinished programming.\n\nAnother trade off is rapid development vs functionality. For example if you have a new software that assigns working times, it should first be made sure of that the most simple and essential part of the programm works, before moving on to more complicated things like holidays.\n\nMy last design goal trade-off would be backward compatabilty and readability. Often when redevoloping, adding on to software or transfering data problems materialize, because software is not compatibel. For example in my sports club a new courtbooking plattform with many features is being integrated (booking courts, paying for food, and membership fee payment). THe problem is that the transfer of the data is very comliated because the old system was designed very poorly.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1290800,
      "meta": {},
      "text": "1. Functionality vs Usabilty: Ein System sollte immer so übersichtlich und so leicht zu benutzen sein wie möglich. Gleichzeitig sollte es auch so viele Funktionalitäten bieten wie möglich, doch je mehr \"Features\" zu einem System hinzugefügt werden desto unübersichtlicher wird die Benutzeroberfläche und desto verwirrender wird es einen einfachen weg für ein bestimmtes Ziel zu finden. Sollte ein System allerdings zu simple sein fehlen viele \"Features\", die das Leben des Nutzers vereinfachen würden. \nBeispiel:  Ein \"GUI\" welches übersät ist mit unzähligen \"Features\" wird unübersichtlich manchmal sogar nur schwer überhaupt nutzbar, sollte die grundlegendste Funktionalität durch viele unwichtigere Teile des Systems überschattet werden. \n\n2. Rapid Development vs Functionality: Ein System welches schnell entwickelt werden muss fehlen Zwangsweise viele der wichtigen \"Features\", welche das Entwicklerteam bei genügend zeit implementieren hätte können. \nBeispiel: Man sieht dieses Problem vor allem bei modernen Videospielen, alle neuen Großen Mehrspieler Titel  werden als \"Life Service Games\" Angekündigt, was so viel heißt wie: \"Wir haben es nicht geschafft alle nötigen Features zum Start des Spiels zu entwickeln und müssen sie durch Updates nachreichen.\" Dies wird insbesondere deutlich wenn Spiele nur einen Bruchteil der \"Features\" beinhalten die ihre direkten Vorgänger noch hatten (Halo infinite, Battelfield, Call of duty).  Zusätzlich kommen die meisten modernen Titel mit \"bugs\" und Fehler übersät auf den Markt, was oft sogar die grundlegendste Funktionalität des Systems in Gefahr bringt und es unbenutzbar machen kann. \n\n3.  Efficiency vs Portability: Um ein System Optimieren zu können und die größte Effizienz zu bekommen, muss oft nahe an der Hardware gearbeitet werden und das System genau auf dies Hardware oder ein Betriebssystem angepasst und optimiert werden.\nBeispiel:  Instagram hat dieses Konzept verstanden und veröffentlichte die Plattform 2010 für ios während android ein eigentlich viel größerer markt erst 2012 eine Version des Dienstes im Playstore zur Verfügung hatte. Die Entwickler entschieden sich eine effiziente Software für nur ein System zu entwickeln und dafür auf eine größere Zielgruppe zu verzichten. Es war ihnen nicht möglich sowohl \"Efficiency\" als auch \"Portability\" zu bekommen. ",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1294831,
      "meta": {},
      "text": "1. Functionality vs. usability\nI recently booked a ticket for a concert online. Throughout the whole process the website guided me through at least four other websites before I could pay etc. at the end it was functional because I bought the tickets but it was not user friendly because every time I was confused what they want from me\n\n2. Cost vs reusability\nWe developed a reservation software specifically for a restaurant. But it would be more reusable if this software could also be used for reservation at theaters cinema etc because basically the software needs to do the same thing for all of them. It is more costly but if more companys can use it you earn more.\n\n3. Rapid development vs functionality\n When developing a software of course its important to be fast but you have to ask yourself at what cost? Because if a software is developed fast but throughout the time many bugs and problems come up the fast development was not worth it",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1300856,
      "meta": {},
      "text": "Probably the most famous example for tradeoffs that have to be made is functionality vs. usability. This happens because usability comes from only having a limited amount of information presented to the user. However, having a product with many features comes with having lots of information that needs to be displayed. You can experience this problem when visting a city that is unkown to you and try to use the public transport services. Here the challenge is to present the many possibilities (and the ticket costs that come with it) of travelling to the end user in a manner that makes it easy to undestand.\n\nAnother tradeoff that has to be done is Efficiency vs. Portability. If you example create a python script that runs quick and efficient on your system, it might happen it doesn‘t run at your friends computer at all (be it because of missing libraries or hardcoded, OS-specific features).\n\nA huge problem with PGDP for many was that they simple felt like having not enough time to do the exercises completely. This is also happens on a larger scale and is a good example showing that you have to do a tradeoff between functionality and rapid development.",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1312361,
      "meta": {},
      "text": "- Functionality vs. usability (both user goals)\nFunctionality represents a set of functions that a system offers. \nThis is an added value for the system at the first glance. However, these operations shall be usable. Usability means the ease of use/ease of learning of these functions. Sometimes, a system contains unusable operations from user´s point of view. Some possible reasons: availability of to much functions or some functions require users to have advanced skills.\nFor example, mobile phones allow settings in developer mode to make changes. This function is unusable for users lacking the required skills for it.\n\n- Low costs (client goal) vs. robustness (user goal)\nDeveloping a software represents an investment (costs) that the client makes. As an homo economics he want the costs to be as low as possible. However, developing a robust system can go beyond the client estimated costs. For instance, after testing software and getting Feedbacks, developers might note that costs related improvements are necessary. E.g. purchasing additional licenses or materials or hiring new people with needed expertise, without which the product cannot be robust as expected.\n\n- Rapid development (client goal) vs. functionality (user goal) \nEven though software development happens under time constraint, a too rapid development might have limitations, e.g. omitted system operations. In other words, developers might lack the time to think about meaningful functions the system should have. For example, by developing an alien game rapidly developers might only focus on basic functions (shoot, move, etc.). But, they could come out with more interesting and creative interface operations that increase the user experience.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1317735,
      "meta": {},
      "text": "A great trade-off would be functionality vs. usability. It is selfexplaining, that there is a direct link between more functionality and harder to achieve usability. The less functions there are, the easier it is to present them in an easy to use way. Nowadays many big companies tend to prefer higher usability over functionality. One example would be Netflix, which had many more functions years ago. Nowadays there are very little functions, but it is easy to use. \n\nAnother big decision is the trade-off of back compatability and readability. For that a lot of programing languages can be good examples. C++ is almost completely back compatabil with C. That blew of the language a lot and nowadays there is for most things more than one way. This makes everything harder to read. An even more extrem example would be CMake, which tries to be back compatabil to older versions and has now so many different ways, that it is very hard to unterstand which functionality to use. \n\nAlso there is the trade off between cost and robustness. For a Software to be robust there is a high need of tests and infrastructure. There mustn't be any single point of failure. Of course these things cost a lot of money. Almost every big company that hosts software could be a good example. Even if they only have a downtime from 0.5% or less, would be a scandal for them. So they have to invest much more money in there robustness, than small companies.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344685,
      "meta": {},
      "text": "- Functionality vs. usability: the more functionalities a system has, the less usable it is for the users. \n- Cost vs. Robustness: when a system design costs not so much, it can't ensure the robustness of the system because there're maybe some errors being ignored by the system. \n- Efficiency vs. Portability: when a portable software is written, it's hard to take full advantage of a specific hardware or software architecture, which reduces the efficiency and performance.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1348734,
      "meta": {},
      "text": "Beispiel 1: \ngerade bei langwierigeren Software Projekten ist backward compatability sehr wichtig, da auch ältere Systeme noch unterstützt werden müssen. Das steht oft im Gegensatz zu guter Lesbarkeit.\nEin Beispiel hierfür sind zum Beispiel deprecated Methoden in Programmiersprachen. Ältere Software benutzt diese oft noch und daher müssen diese weiterhin unterstütz werden, sie führen aber zu Unsicherheit und clutter.\n\nBeispiel 2:\nbesonders bei SDKs von eher Nischenprodukten gibt es einen trade-off zwischen guter Dokumentation und Kosten. Nutzer und Entwickler würden sich sehr über eine ausformulierte Dokumentation über alle Klassen freuen, aus Kostengründen kann aber nur zu den Hauptklassen und der Grundfunktionalität eine wirkliche Dokumentation per Hand geschrieben werden. Der Rest wird meist über die Kommentare im Code auto-generiert, was oftmals nicht eindeutig ist.\n\nBeispiel 3:\nbei Projekten die sehr schnell fertig werden müssen gibt es oft einen Konflikt zwischen schneller Entwicklung und einer geringen Fehler anzahl. Wenn zum Beispiel beim start eines Projektes viel Funktionalität umrissen werden soll, und so sehr schnell viel neuer Code dazukommt, ist es fast unvermeidbar, dass sich Bugs in das Programm einschleichen.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1356318,
      "meta": {},
      "text": "When designing a system, different goals can often conflict with each other as different actors (client, developer, end user) will interact with the system, all having their own interests. \nAn example of a first very typical design goal trade off would be minimum number of errors versus rapid development. The goal of the client is often to get the software as quick as possible, to hire the developer for less time and therefore save money. But if the developer has too little time to develop his system, he will have less time to test his software and therefore he will spot less errors while designing.\nAnother typical design goal tradeoff is functionality versus efficiency. The system can either handle one client request at at time, but handle it in its entirety or the system can be designed to run multiple requests and threads at the same time, being more efficient. \nLast but not least another example of a typical design goal trade off is usability versus generality. This is a tradeoff between the goal of the end users and the goal of the developer. The developer typically wants to design his system to be usable on all platforms and in all formats, but the user doesn't care about any other platform other than his own and just wants to use the system in his own format in a very detailed and usable way.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1371454,
      "meta": {},
      "text": "1. rapid development vs. functionality: In an ideal world you would want your System to include a lot of functionality while at the same time being very fast to develop, but of course in reality these conflict each other, because for every functionality that you want to add to your System it also requires more time to develop and integrate it into the System. For example in Bumpers you might want to add a new car type to the game, which then the depending on the complexity adds maybe 5-15 min to the  development time.\n\n2. functionality vs. usability: New functionalities added to your system often require some kind of a new user interaction (button, tabs, text fields, ...) as well which makes the UI more complicated and difficult to use for each functionality you add. For example Professional Software like the Unreal Engine offers a lot of functionality but also has so many buttons for all kinds of things that it is very difficult for a new user to actually use the Programm. In contrast Whats App is very easy to understand and use that even unexperienced users like Grandparents can pick it up quite fast, but of course the functionality of the program is very limited in that u can mostly only write messages and send photos and videos to your contacts.\n\n3. Cost vs. robustness: With an Increase in robustness of your system the cost will increase because you either have to put more time into the software development or buy new parts for Servers to increase robustness.\nfor example: Google servers always have a backup of parts to increase robustness but of corse this adds to the costs of the System.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1372988,
      "meta": {},
      "text": "-Functionality vs. usability: Too complicated functions will increase the difficulty of using it. \nA chat software, with many functions, can listen to music and share video pictures, but users are not easy to learn in use, easy to make mistakes. Conflicts with user-friendly, easy-to-use, and effective goals\n\n-Cost vs. robustness: A design requires higher cost, that can check for errors and propose corrections\nImprove the application's ability to run under input errors, disk failures, network overloads, or intentional attacks without crashing or crashing But improving the robustness of the application will increase the cost and maintenance costs\n\n-Efficiency vs. portability: If the system is only designed for a  environment, it can be better matched, \nThe language of java is strict and standard.\nAfter making the Java program go through the compiler and JVM, the results obtained in different computer environments are the same (that is, good portability).\nAlthough c / c ++ is highly efficient, it is difficult to guarantee the same results in different operating environments, even serious errors. Relative to spending a lot of time to deal with c / c ++ errors",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1377828,
      "meta": {},
      "text": "Trade-off 1: Ease of learning vs. functionality\n\nHaving a lot of functionality would make the system harder to learn, since there are many more things to actually learn. Example: A Software like Paint 3D is much easier to learn compared to Photoshop, but Photoshop has a lot more functionality in it. Similarly, Blender is also hard to learn but is very powerful.\n\nTrade-off 2: Low cost vs. portability\n\nMaking a software that is availabile on multiple platforms costs a lot more compared to a software that is only available on one. For example, due to increasing costs, the developers of the video game Rocket League recently stopped supporting MacOS and Linux.\n\nTrade-off 3: Flexibility vs. number of errors\n\nHaving a very flexible software would make it hard to cover all the edge cases while testing and therefore could increase the number of bugs. An example of this would be the recently discovered and patched Log4Shell exploit.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1379182,
      "meta": {},
      "text": "Functionality, the amount and variety of different functions of a system, can conflict with usability, and the difficulty of how a user interacts with the system. An example could be a financial valuation tool, which can either be very dumbed down to be user-friendly or provide functionality for many different scenarios by requiring a myriad of inputs that are not understandable for laymen.\nRobustness and error handling can sometimes be very expensive in design. When a system needs to maintain its functionality in many different situations, this requires care and time by the programmers to design and think through. For example, when trying to make an open-world video game, there are a lot of different interactions between the player, NPCs, items, maps, etc. that are costly to control.\nLastly, rapid development in case of need can be conflicting with functionality. When a system needs to be delivered in a very short time horizon, it may lack detailed functions. For example, developing a covid-case forecast tool at the beginning of the pandemic was probably harder, as not all forecasting algorithms could have been tested on each small geographical subset or timeframe. So just getting a normal general algorithm done for one area, for a short-term forecast was probably a compromise that most developers used.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1392588,
      "meta": {},
      "text": "Rapid development vs. functionality: implementing 50 different (and working) functionalities takes much longer time than just implementing 10 funtions of the system. \n\nCost vs. robustness: Further, to implement a good system it needs to be tested to check for errors, e.g. pushing not used parts of the keyboard during the bumpers game. But testing needs time and, as it says, time is money for the client. Doing a faster development can have the consequence of more errors.\n\nEfficience vs. functionality: As more functions and extras bumpers has, like playing a melody, choosing one out of thousand optional cars, making you a coffee if you won,... as more runtime capacity the system needs and is less efficient.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1407034,
      "meta": {},
      "text": "Portability <-> Performance\nPortability is a desirable goal in software development. It is great if a piece of software can run cross-platform and under all circumstances. But it affects the performance of the program almost always. The developers should introduce a new layer for portability. During the runtime, the software needs to operate with that portability layer, which in turn makes the program slower. For example Java is meant to be a portable language. Java programs could be run anywhere but it comes with the JVM overhead, JVM is the portability layer and makes Java programs slower.\n\nAvailability <-> Efficiency and Maintainability\nToday, systems should be up almost all the time. This is also a meaningful design goal. But it comes with trade-offs. A system, that should be running 99.9% of the time consumes too much energy, since it is still working even when there is nothing to do. For example a website, which should still be served while nobody is currently visiting the website. Another trade-off is the maintainability. When a server is constantly running, it is hard to maintain the system, since there may be active users. It is impossible to shut down the server and make important changes.\n\nSecurity <-> Usability\nA software should be able to protect itself against intended attacks but it is hard to keep a program highly usable and pleasurable while taking security measures. Websites try to protect the server from DDoS attacks or automated posting by using CAPTCHA systems. It helps with the server security but makes the user experience worse, since the user has to complete puzzles every time they want to use the product.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1438149,
      "meta": {},
      "text": "Cost vs. Robustness: in Robustness you want the system to tolerate changes in the environment, but therefore you need more money. An example is that you installed a device which is supposed to measure the weather, but if there is a storm, the device should not break and for this the components must be qualitative and mostly quality costs money. \n\nRapid development vs. functionality: here you want to develop a system as fast as possible, but then you can't implement many functionalities. For example you want to develop a game called Bumpers, where you steer a car and your aim is to crash other cars. And if you develop this Game as quick as possible, you only can implement a few functions, like what happens when the user car crash an other car. But you will not have the time, to implement additional functions, which make the Game more attractive.\n\nCost vs. reusability: here you want to have low costs and you reach that by not testing so much and with a ease code. But in reusability you want to test much and you want to have additional coding, that you can use your system also in few years and not only at a Indefinite time interval. For example you build a app that does what you want, but you did not tested it so much (low costs) and after an indefinite time you notice that the app doesn't work anymore, because there where too much inputs and you did not tested the app on how much inputs it can have maximum.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1502475,
      "meta": {},
      "text": "Delivery time vs functionality: In the very beginning of bumpers, we created an extensive product backlog and worked on some items. We imagine that bumpers was a \"real\" software project ordered by a client and that he wanted it to be delivered in a rather short amount of time, which we consider to be too short to work out the entire product backlog. There are two options: We can either ask for a deadline extension or make a cut in functionality and not implement the entire product backlog.\n\nLow cost vs quality: The customer of bumpers would obviously prefer to spend as little money as possible. On Equally obvious, he wants the software to be high quality. Again, there are two options: Bumpers can be easily maintainable and extendable in the future by going for high quality. Or we just write dirty code and don't pay too much attention to quality standards, but safe money.\n\nPortability vs performance: If bumpers should run on all standard platforms, it can be implemented as a rather slow web applications accessible from all devices. If it should on computers with an x86 chip, we can implement an offline game that is optimized for said processor and runs way faster than any web application ever could.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1292761,
      "meta": {},
      "text": "Trade off 1:\n\tThe client wants to reduce the production costs, while the developpers want to create a fast application. With less \n\tmoney, the application can't be developped enough to get faster.\nTrade off 2:\n\tThe developers and the users could be interested in an open source project, the developers to reuse their work\n\tat other companies, the users because they would not be reliable on one company, \n\tThe client on the other hand wants to sell his product --> No open source.\nTrade off 3:\n\tThe users are interrested that the aplication works in different languages, but these costs time and money !!! \n\tClient is probably not interested in supporting rare languages like danish!!",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1312239,
      "meta": {},
      "text": "Functionality vs. usability:\nOn the one hand, many functions increase the number of usecases where a software can be used. However, this also increases the compexity (so the usability) and it requires a lot of knowledge to be able to work with the software. For example, Android can be personalisied but it is more complicated to deal with the software, whereas iOS is kept very simple but intuitive. Hence, Google focuses more on functionality whereas Apple focuses on usability.\n\nCost vs. reusability:\nCreating a software that can be used in multiple settings require more standardised interfaces and abstraction and hence, require more time for development, which increases the costs. Keeping the cost low would mean to provide the software only for one usecase, which is faster to develop, but it cannot be used in other scenarios. For example, a ERM system should work for multiple POS systems (Kassensysteme) and not only from one provider. However, this is also more expensive to develop.\n\nCost vs. robustness:\nRobustness becomes important if the users enters wrong input. There should be an error handling for such cases which increase the robustness. However, defining and implementing different error cases also increases the costs, because more development time is needed. For example, it should be checked that customers can only enter really birth dates in a registration form (so the correct format and no letters). This is important, because there might be calculations with the birthdate afterwards to calculate the age. If there is a invalid format, the software might crash because it cannot calculate with letters.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1316119,
      "meta": {},
      "text": "1) rapid development vs functionality: a smart phone may be one of the best-sellers because of its high functionality. Nowadays, people make all their works from their phones and a functional smart phone serves the purpose. Rapid development is also a need because with developments problems on the phones are solved and new functions are added to phone. Since implementing the development of many functions take longer time, rapid development and functionality may be given as an example of  thread offs in this context. \n\n2)functionality vs usability: Both of the options need a high level budget to be ensured by a developer. We  can give an app as an example. High functionality is an advantage for the client, since this qualification increases number of people using the app. On the other hand, usability is also a fact to increase number of people using the app because a higher capacity of the app to provide a condition for its users to perform the tasks safely, effectively, and efficiently is one of the expected qualification from an app. Overall, both sides are beneficial, but expensive.\n\n3) cost vs robustness: cheap producing price is a deal for the customer, while developers are give their priority to robustness. Software system may be an instance for it. Cheap cost are beneficial for the customer, especially when their budget is low because no matter how much money they have, they can get the software they want. On the other hand, robustness is also beneficial for the customer, but in a longer time. Software system can cope with the errors during execution, so consumers won't be victimized and client won't have to deal with the problems of the software. That's way there is a trade off between them.",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344098,
      "meta": {},
      "text": "-Functionality vs Usability:\n As a developer you may need to focus on the functionality because you have to create a system that performs complex tasks but as a client you'll focus on how it's easy for the users to use your system. For example it's very difficult to design a website to perform complex tasks while being easy to use enough for its intended users.So the question here is Does your website need to be more functional or usable? In order to optimize user happiness, a website must strike a balance between usability and fuctionality.\n-Efficiency vs. portability:\nEfficiency and portability are very important in the design.\nThe developer must make a difficult choice between portability and efficiency. It's an uncomfortable choice, though, because prioritizing efficiency leads to nonportable code, while choosing portability leads to software that performs poorly. So the developer should choose one of them in order to satisfy the client and his goals.\n-Rapid development vs. functionality:\nThe Rapid Application Development is a software development method that relies on prototyping rather than detailed design. So less emphasis is placed on planning and more emphasis is placed on development activities.This type of development will make the developer ignore a lot of functionalities(because he did not even model the problem statement)and that's why it's a tradeoff.  ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1348027,
      "meta": {},
      "text": "Functionallity vs Usability:\nEin Spiel kann eine große Menge an Einstellungen haben damit die Spieler ein möglichst individueles Spielerlebnis haben können. Jedoch wird mit mehr Funktionalitäten auch immer unübersichtlicher. Man muss sich entscheiden ob man dem Spieler möglichst viele Einstellungen freihalten möchte oder es lieber übersichtlich und simpel halten möchte.\n\nCost vs Robustness:\nDie Entwicklung einer sicheren und fehlerfreieren Software ist nicht sehr einfach, da man eine Menge beachten und testen muss. Möchte man z.b. einen Messenger entwickeln kann dieser entweder mit wenig Aufwand und Kosten dafür aber mehr Fehlern und Sicherheitslücken entwickelt werden oder oder mit mehr Kosten aber dafür mehr Sicherheit und Potenziell weniger Fehlern.\n\nRapid Development vs Functionality:\nEin Taschenrechner kann mit sehr wenigen Funktionalitäten recht schnell entwickelt werden. Möchte man jedoch einen Taschenrechner mit einer größeren Menge an Funktionalitäten haben muss man der Entwicklung auch mehr Zeit geben diese Funktionalitäten zu implementieren.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1447484,
      "meta": {},
      "text": "Die Design Goals bei einem Software Projekt können oft in einem Konflikt zu einander stehen. Dann spricht man von Design Trade Offs.\n\nRapid development vs. functionality \nEine schnelle Entwicklung und die Funktionalität sind zwei Design Goals die im zu einem Konflikt führen können, da aufwendige Funktionen eine komplexere Struktur erfordern und deswegen mehr Zeit beanspruchen. Entwickelt man Beispielsweise eine Suchmaschine, wird die Grundfunktion wahrscheinlich sehr schnell entwickelt sein, aber Sonderfunktionen wie die Suche nach bestimmten Kriterien oder der Ausschluss eines Wortes benötigen mehr Zeit.\n\n\nCost vs. Robustness\nWie bei anderen Projekten in Unternehmen sind auch bei Software Projekten die Kosten entscheidend. Man versucht das Produkt möglichst günstig zu entwickeln. Dies steht oft im Widerspruch zum Design Goal Robustness, da hier versucht wird, dass ein System auch einen falschen Input des Benutzers oder eine Veränderung der Umgebung verarbeiten können muss. Bei der Spielentwicklung kann vielleicht zu geringen Kosten ein Labyrinth Spiel entwickelt werden in dem der Spieler mit den Pfeiltasten laufen kann. Die Programmierung, dass alle anderen Tasten der Tastatur auch benutzt werden können ohne dass das System abstürzt führen zu deutlich mehr Arbeit und schaffen Robustness. Dafür werden auch die Kosten steigen.\n\n\nEfficency vs. Portabiltity\nEin weiteres typisches desgin goal trade-off ist die Effizenz und die Portabilität.\nWenn man beispielsweise eine Suchmaschinen App speziell für Apple entwickelt kann man sehr Hardware nah programmieren und hat eine hohe Effizienz. Soll diese App jedoch auch auf Windows und Android nutzbar sein, so muss die App etwas allgemeiner gehalten sein, damit die Portabilität gegeben ist. Diese Abstraktion führt jedoch zu einem Effizienzverlust und deswegen stehen die beiden Design goals im Konflitk zueinander.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1450609,
      "meta": {},
      "text": "Hey there! These are my answers to the task:\n\n1) Making an app less usable to implement more features. E.g. it might take more scrolling around and clicking in submenus to get to the desired feature, but overall there are more features.\n\n2) Avoiding to use specific colour palettes to make a website more accessible. E.g. not writing in bright colours on bright backgrounds so everyone can read the texts on a website.\n\n3) Using a less performant programming language/framework to make code more readable and decrease write time (the time it takes to write the program). E.g. writing a program in Python instead of C makes a code easier to read and faster to write.\n\nHave a nice day, friendly tutor!",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1474114,
      "meta": {},
      "text": "the most common design goal trade- off is to find the balance between the design goals that you want to archive while keeping the costs as low as possible. The costs proportionally correlate with the time spent by the developers working on the project so in order to keep the costs low there might need to be some trade offs in functionality, rubustness and efficiency.\n\nBackward compatibility can also be a reason to accept some trade offs: If the client wants the system to be compatible with a legacy system it will be at a bigger expense then just building a new system. \nMany banks still use old systems that are expensive and inefficient but offer a big range of functionality and contain important data that the client doesnt want to loose.\n\nEase of learning and functionality is also one of the very common design trade offs when it comes to the user experience. The more functionality a system can offer the more difficult it will be to learn.\nLooking at computer games you can differentiate bettwen a game like Pong that you can learn in 2 minutes but will get boring in 10 more minutes or a game like league of legends that takes a very long time to learn and is very confusing for beginners but also provides the player with an infinite amount of ways to play the game in a creative way\n\n\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1487683,
      "meta": {},
      "text": "It says: \"Use your own words and do not just copy the lecture slides\"\nBut it's LITERALLY the point of the lectures to teach me stuff and equip me with knowledge.\nSo the professor holds the lecture and when I'm supposed to do an exercise concerning that topic, I am NOT supposed to use what I learned during the lecture?\nI disagree, which is why I'm gonna list design trade-offs right from the lecture.\nThese are:\n\n• Functionality vs Usability\nWhen a software is very complex and has a lot of functionality it becomes harder to find your way through the salad of options to choose from. Therefore the software is harder to use.\nWhen a software is easily approachable and intuitive and it doesn't take long to learn how to use it, it might be an indicator that it is not a complex software with many functions.\n\n• Cost vs Reusability\nIf the software is easy to code and has low cost tests it probably isn't very reusable not very reusable.\nIf an expensive reusability structure is to be implemented to the software, it will become harder to code and therefore more expensive.\n\n• Cost vs Robustness\nThis one actually should be obvious. The more money and work you put into a software, the more stable it will ultimately be. The more you pay for security and encryption, the tougher it will be to hack and/or break it.\n\n• Efficiency vs Portability\nEfficient software doesn't waste CPU cycles. It takes full advantage of the hardware, often completely disregarding portability issues. It benefits on such features as graphics accelerators, cache memories, and floating-point instructions. However, an efficient software might not be able to run on a different machine with a different CPU than the one it was designed on. Portability, which is the possibility of running the software on many different machine architectures may need sacrificing the efficiency. \n\n• Rapid development vs Functionality\nPretty standard. The quicker you finish a product on which you worked very short, the less functionality it will have. On the other hand, the more functionality it's supposed to have the longer the development will take.\n\n• Backward compatibility vs Readability\nSoftware readability is a property that influences how easily a given piece of code can be read and understood. A software with high backward compatibility will have to run on older machines with outdated programming languages, therefore it becomes harder to maintain them.",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1507783,
      "meta": {},
      "text": "Cost vs robustness\nTo make a robust system one must add code which allow room for failure, which consecuenally makes the system more complex and therefore its development costs more.\nExample:  A House that is earthquake safe is more expensive than a regular one since the owner has to additionally invest in designs and technologies that guarantee the safety such as heavy shear walls and cross braces frames.\n\nrapid development vs functionality\nIf a system is meant to perform many different functionalities, its development is bound to be slow, since the implementation of each of the individual function requires time.\nAn application with two or three functions is much more likely to be developed faster than one with fifteen\n\nFunctionality vs. usability \nThe more functions/operations/services a system provides the more complicated it becomes therefore decreasing its usability.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1542362,
      "meta": {},
      "text": "- Functionality vs. usability - When a system isn't designed optimally, it might become unusable. This includes functionality - if the system has way too many functions it will become unusable as well.\n\n- Cost vs. robustness - With a bigger cost comes better quality and a more robust system, and the opposite - cheap software will cut corners at the expense of quality.\n\n- Rapid development vs. functionality - Rapid development of a system results in reduced functionality and vice versa.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1623513,
      "meta": {},
      "text": "three typical design goal trade-offs\n1 usability vs functionality\nif we design a flight system for Pilot to control the airplane ,We need to prioritize functionality and ensure that the aircraft is functional for operation and safe driving.\n2 cost vs robustness\nif we build a school system for administrators, teachers and students, we need to prioritize robustness,This is because once the system is in use, long periods of downtime and maintenance are not possible.\n3 efficiency vs portability\nif we build a system for administrators, teachers and students,we need to prioritize efficiency ,We need to consider that the school system will have a large number of users logged into the system at the same time and that the operating system will be effective.For school systems, we can leave other platforms other than the computer web side out of the equation for now.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292560,
      "meta": {},
      "text": "Functionality vs usability:\nMit diesem Trade-off haben viele System Designer zu kämpfen. Kein Wunder, dass Steve Jobs abgesahnt hat. Ein System, welches viele Funktionen hat, bringt eine gewisse Kompläxität mit sich. Dadurch sinkt die Benutzerfreundlichkeit. \nBeispielsweise ist Photoshop eine der besten Bildmanipulationsapplikationen, dennoch muss man gefühlt die Software studiert haben, um alle Funktionen zu kennen und richtig anzuwenden. Anders als beispielsweise die Bildbearbeitung bei Apps, wie Instagram, die durch simples Wischen Filter auf die Bilder legen. \n\nRapid development vs Flexibility:\nDie meisten schnell entwickelten Systeme sind alles andere als Flexibel einsätzbar. Beispielsweise habe ich für unser EIST Projekt innerhalb von 30min einen Scraper programmiert, der mir die Daten einer Wikipedia-Seite in eine CSV Datei schreibt. Ich habe natürlich nicht auf Flexibility geachtet, mit dem Wissen, dass ich, wenn ich die Daten habe, das Script wahrscheinlich nie wieder brauchen werde. Deshalb kann es nur für diese eine Wikipedia Seite verwendet werden, weil die CSS-Selecoren auf anderen Seiten wieder anders angeordnet sind.\n\nEfficiency vs Portability:\nEffiziente Systeme sind an ihre Umgebung angepasst. Eine Web-App, wie Microsoft Word 365 ist auf allen Endgeräten benutzbar, dennoch ist es deutlich einfacher und auch schneller das Dokument in der Desktop-App zu schreiben und zu bearbeiten. \n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1295017,
      "meta": {},
      "text": "Design goals are different, and some of them conflict with each other. In this case, trade-offs are made in order to make a  good product. Trade-offs are like: \n1- Functionality vs. usability: it's not easy to make a system that include a lot of details and expect it to be easy to use. \n Example: When you make a food App, if the app contains too much information, it would be hard to use, so you need to limit yourself with, for example, 5 clicks and after that the user can place his order. \n\n2- Cost vs. robustness : The more the system is safe  and handle the errors, the more money it costs.\n Example: if you want to make a simple motor with low cost. The problem is that when the temperature of the motor increases, the performance of it decreases, and it may stop working. To solve this, you need to insert a cooling system, which will cost you more money.\n\n3- Time & maintainability: In order to make a system maintainable, you need to invest more time developing it. \nExample: If a customer want to make an application as soon as possible, you can't make it maintainable, because building all of that future-proof stuff takes time. \n\n4- Performance vs. resource handling: It's very difficult to make a software with high speed and memory efficient in the same time. \n Example: If you want a very fast Video game, it takes a lot of memory and resources to make the user experience perfect. In this case, the size of the game will be too large. \n  ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1296929,
      "meta": {},
      "text": "1. Software maintainability vs. fast development\n\tIt is hard to build a clean architecture which is maintainable in the future when you have just limited time to develop the system. This leads to huge classes and with no sense of structure which might work in the sort term and is fast to develop but lacks maintainability which would profit the long term.\n\n2. Efficiency  vs. Maintainability\n\tThe fastest code is often the hardest to understand, maintain, expand and change. But it might be required if speed is more important.\n\n3. UI functionality vs. usability\n\tIt is hard to offer a bunch of functionality on a UI to the user without cramping it so much, that it gets overloaded and the user is so confused that the system isn't usable at all. On the other hand, all of the functionality might be required so a trade-off must be found.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1311196,
      "meta": {},
      "text": "usability vs. functionality:\nDer Konflikt zwischen Funktionalität und Nutzerfreundlichkeit zeichnet sich meist durch eine große Menge an Möglichkeiten aus, die auf Kosten der Übersichtlichkeit zu einer Steigerung der Optionsbandbreite beitragen. \nEs ist wichtig, diese beiden Aspekte in Einklang zu bringen, um dem Nutzer eine breite Palette dieser Möglichkeiten trotz gut struktierter und übersichtlicher Oberfläche zu bieten.\nSo lässt sich dies bereits als Beispiel an alltäglichen Haushaltsgegenständen abbilden. Während ein Staubsager saugen soll, und vielleicht noch unterschiedliche praktische Funktionen, wie Einstellungen bezüglich des Untergrunds (Teppich, Parkett) anbietet, so würde es der usability schaden, sollte statt dieser zwei Untergrundtypen auch noch zwischen Linoleum, Fliesen, Beton, Stahl, Gras, etc... differenziert werden.\n\nrapid development vs. functionality:\nZeitliche Faktoren in der Entwicklung sind nahezu immer ausschlaggebend für Qualität und Funktionalität des Endprodukts. Denn je länger an einem Produkt gearbeitet wird, desto mehr Zeit bleibt, bereits bestehende Funktionalität auszufeilen und neue zu integrieren. Sollte der Prozess jedoch zu schnell von statten gehen, so fehlt es dem Endresultat meist an wichtigen, wenn nicht sogar unerlässlichen Optionen. Solche Fehler sind beispielsweise oft in der Spieleindustrie zu sehen, in der Produkte verbuggt und unfertig auf den Markt geworfen werden, wie nicht zuletzt Cyberpunk2077.\n\n cost vs. robustness:\nUnsere Marktwirtschaft zielt darauf ab, Produkte anhand mehrerer Faktoren in eine preisliche Kategorie einzuordnen. Der größte Gesichtspunkt ist hierbei die Qualität. Nur hängt diese auch davon ab, wie viel Geld in ein Projekt investiert wird, und welche Möglichkeiten aus dieser Investition resultieren, das Endprodukt qualitativ hochwertig zu gestalten. So ist es beispielsweise nicht möglich ein AAA-Spiel mit wenig Budget zu erstellen, da es sonst qualitativ minderwertig und somit kein AAA-Spiel mehr wäre.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1330978,
      "meta": {},
      "text": "• Efficiency vs. portability \n\tThe trade-off here is the algorithmic optimisation of the software which is based on which machine and \n\toperating system the the finished application is expected to run. If the system only needs to run on \n\tDebian based systems, it can be perfectly optimised for Debian, however that might result in very poor \n\tperformance on windows systems or the software might not run at all. Therefore, one can't expect a \n\tportable software (running on a variety of machines and systems) to be as efficient as an optimised one. \n\teg. Video-games developed and optimised for windows which might only later be released for Mac or \n\twon't come to Mac at all.\n• Rapid development vs. functionality \n\tRapid development works best with an incremental process, because first program increments after a \t\n\tfew sprint can already be used and tested by the client. However, it is obvious that an unfinished \n\tprogram won't have full functionality. However, with every sprint functionality can be extended.\n\teg. Notability a not taking app which was really basic in 2019 is now largely functional and has the option \t\n\tto convert handwritten text to typing. These functionalities were one by one introduced through updates.\n• Cost vs. robustness \n\tTo essure robustness of a system a lot of testing and fixing has to be done. Testing takes time and is \n\tcostly, as well as the bug fixing itself. Therefore it is a lot more expensive to develop a very robust \n\tsystem. \n\teg. A chatbot which has to realise if the input is nonsense. The more recognition software is \t\nimplemented for that, the more expensive will the system be.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344106,
      "meta": {},
      "text": "Rapid development vs. functionality(/usability): \nE.g. if the programers don't have the time to think about their code or test more the client could easily end up with a hard to maintain, spaghetti-style code which will just need and even cost more time and money in the future because there wasn't enough time which the software developers desperatly need in order to analyse the clients need and have time for e.g. proper requirements elicitation. The client might end up with a system which has not the wanted functions because of a misunderstanding. \n\nCost vs. Reusability: \nIs about the lower the costs the lower (usually) the reusability. E.g. the client doesn't want to spend a lot of money on the system but with additional costs occuring (for more testing and coding) could come some advantages. Think about a system which could easily be modified to not only work to satisfy one need of a client but also another one. This system might need more work in terms of code testing/coding but could easily reused for many purposes (many-to-many multiplicity).\n\nFunctionality vs. usability: \nIs about what the system is suposed to do versus how easy the system functions are to use.  For example if you implement a lot of functions it might get very difficult for (new) users to understand the system and how it works, or it just might be too much information at once and your interface might be overcrowded and confusing. On the other hand many functions might be necessary for expert users in oder to work efficiently and fast.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1347781,
      "meta": {},
      "text": "➤ backward compatibility vs. low cost\nThe client may set \"backward compatibility\" as an attribute the software should fulfil, at the same time striving for cost-effective solutions. As such compatibility always goes along with more work (developers taking into account older versions of the product, re-designing aspects of the software to not collide with previous features, well-defined documentation considering the needs of backward-compatibility) on the implementation side which implicitly means higher costs.\n\n➤ the \"blinking twelve problem\" (functionality vs. user-friendliness)\nThe system's functionality generally is the main reason software products are created in the first place. Especially when the application is rather generic, i.e. the end-user very likely not of technical expertise, designing the GUI yet to be intuitive is a major roadblock. Typically, this leads to either reducing the amount of functionality the system provides to core elements in favour of ease of use, or the GUI ends up to be a convoluted place of seemingly complex interactions most \"beginner\"-users will only find mystifying.\n\n➤ rapid development (RAD) vs. robustness\nFocus on the development tasks rather than the planning phase is core to RAD, which is a popular model of choice among clients wishing for prototypes (working product instances) ASAP. This speed, though, inevitably goes hand in hand with \"backward engineering\" intricacies where the lack of \"design up front\" leads to more error-prone applications with insufficient risk reduction protection against unwanted incidents (robustness).",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1359332,
      "meta": {},
      "text": "(1) development speed vs. efficiency/optimization\nA finished, fully functional product will take longer if you are doing a lot of (micro) optimizations.\n(2) backward compatibility vs. efficiency\nFor example, creating an App for different (older) Android versions and maintaining those is hard as different APIs get introduced/deprecated with every version. So finding a common denominator, so to say, is difficult. That's why writing your own code to solve some problem, not making use of some of these APIs won't make it run as perfect as by using the available APIs and therefore takes efficiency at the cost of backwards compatibility.\n(3) rapid development vs. reusability\nWriting code is easy but writing good, reusable code is hard. So writing some module for a specific use case is fast, but finding a generic, extendable and reusable solution to a problem by abstracting away the right amount of logic is super hard and therefore takes time. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1401374,
      "meta": {},
      "text": "Cost vs. robustness:\nThe customer wants to keep the deployment costs low, while still wanting a robust app, which often is connected to more backup systems and thus higher costs\n\nEfficiency vs. portability:\nIf the customer wants support for various systems, it won't be possible to do as much optimization work for each in comparison to a situation where software is only built for one system, and it is possible to fully optimize the software for this system.\n\nRapid development vs. functionality:\nThe customer wants rapid development of the software and the end user wants a lot of functionality. If development doesn't progress as planned, one has to be cut back.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1429884,
      "meta": {},
      "text": "//TYPICAL DESIGN GOAL TRADE-OFFS WITH EXAMPLES//\n\n1-Functionality vs. Usability\n\nEXPLANATION: Usability is when something is easy to use for the user, and functionality can be seen like there are more features in an application/web site which makes it more useful for the user.\n\nEXAMPLE: For example i'm working on Instagram. If my only aim is to make this app usable, then maybe I wouldnt have added new features like adding stories, or saving pictures/photos to saved albums. But then again it wouldnt be as functional as it is now, as there are less features and is a too-simple of an application, where I only like the pictures people post. \n\n2-Efficiency vs. Portability\n\nEXPLANATION: Efficiency can be measured within various aspects, but the main idea is the useful output ratioed by the total input of the software and portability offers the software to be available in various platforms.\n\nEXAMPLE: If i focus on efficiency, then the portability won't be the case any longer and vice versa. An example can be a developer who tries to come up with the most efficient solution as possible and makes changes for the most efficient way. At the end the software will most likely not be available in different platforms, which can lead the customers unsatisfied.\n\n3-Cost vs. Robustness\n\nEXPLANATION: Costs can be seen like low-costs or higher costs. Robustness shows how the system deals with various errors or other things in general how strong it is in situations.\n\nEXAMPLE: If I'm a customer who is asking for a software with a low budget, then I cant expect the robustness of a million dollar project. When the costs increase, the robustness can also increase depending on other aspects as well. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1455922,
      "meta": {},
      "text": "Functionality vs. usability: We can build a lot of function in a system, but we need to think about their usability. Are they used by users often or rarely? Take Bumpers for example, we have already built choose car function in previous exercise, we can also make another 50 similar functions but it will make the interface more difficult learn to use. \n\nRapid development vs. functionality: With Rapid development, the prototype should be developed by a certain period, the model could be completed but with more time, more functionality could be built and make this model better.\n\nCost vs. reusability: 1-1 function is easy to build but it couldn't reuse by other code or test, for example, there's a game board interface in Bumpers and it can be accessed by users, but we can also let administrator to link to that board and test the code.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1496393,
      "meta": {},
      "text": "Ziemlich oft stehen sich Effizients und Wartbarkeit als Trade oft gegenüber. Effizienter Code, der möglichst optimiert ist (teils sogar noch mit Zuhilfenahme von Assembler Code) ist oft sehr schwer zu lesen und im Nachhinein zu verändern. Dagegen ist einfacher Code oft leicht zugänglich und später veränderbar. Ein Beispiel sind die Programmiersprachen Python und C. Python ist leichter lesbar, ist aber durch den zusätzlich gebrauchten Interpreter deutlich ineffizienter. C dagegen lässt sehr viele Optimierungen (sowohl für Speicher als auch Laufzeit) zu, ist aber schwerer lesbar. \n\nFunktionalität und Entwicklungszeit stehen sich ebenfalls gegenüber. Wenn man ein System sehr schnell designen muss/möchte, so gibt es in diesen meist Lücken, durch welche gefährliche Fehler auftreten können. Dagegen ist Code, der länger produziert und getestet wurde meist stabiler und vor Angriffen sicherer geschützt. Ein Beispiel sind meine Abgaben in PGDP vom letzten Semester. Die Funktionalität meines Codes war meist nur dann gewährleistet, wenn ich mir viel Zeit für das erstellen und testen genommen habe, dafür war jedoch auch eine längere Entwicklungszeit nötig.\n\nAußerdem stehen sich noch Graphik Design und Kosten (sowohl Effizients als auch finanziell) gegenüber. Wenn man ein System aufwendig designen möchte, so ist hierfür meist ein eigenes Graphik Team notwendig, was zu einem größeren Aufwand und zusätzlichen Kosten bei der Produktion führt. Darüber hinaus sind bspw. anmierte Spiele oft deutlich ineffizienter, da das Berechnen der Grafik eine langsame Laufzeit verursacht. \nWenn man das Spiel Bumpers beispielsweise mit realistischeren Autos  animieren möchte, so ist  mit viel Aufwand und wahrscheinlich langsamerer Ausführung zu rechnen.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1612633,
      "meta": {},
      "text": "The three most important design goal trade-offs in the context of software engineering are in my opinion time, development cost and software features. Firstly, time is a very valuable asset, that can be perceived int his context as something that not everyone can relate with. The concept of time saving is as old as ever, meaning that whoever is in charge off the app wants to work as much as possible focused on the product in order to avoid unnecessary time wasting and inconveniences for the potential consumer. Time can as a result be fragmented for the benefit of the developer. Secondly, the concept of developing and development cost must be taken very hardly into consideration and shortened as much as possible while still maintaining  the base and functionality for the potential shippable product. In order to this developer should do as much as they can with limited resources. The ones, that are in charge with this task should be able to keep the essence and features of the app, while being put under pressure to not spend money to generate a higher profit. So this development cost can still be played with with the developers that know to work with limited resources and still have a great product. Lastly, the software features are one of the, if not the most important aspect of the app. They are usually being divided at the very start into two groups: essential features and auxiliary features. Developers focus on implementing the essential features first in order to deliver to the clients request. The other extra features are than being discussed and if possible for the benefit the user, they are left out if not exceptionally needed in the context of the app.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1649359,
      "meta": {},
      "text": "1/ Functionality vs. Usability : The balance between the set of operations supported by a system and the ease of use of that same system is always seen as a design tradeoff. How many functionalities does the program contain and how efficient, effective, engaging, error tolerant and easy to learn is that program? For example: a flight control panel on a plane that has at least a hundred keys and operations that sometimes have to be executed at the same time. There's no doubt that the flight system's functionalities are top but without any room for documentation or user's guide, I'm afraid, using that control panel will take 4 hands and 4 years of studies at least.\n\n2/ Cost vs. Reusability : the cost and quality are the main concern of software engineering : to produce high quality software product with minimum cost. In this context, I believe, software reuse can save the cost and time of building a new product. The concept is present in our daily lives. That's why we're familiar with recycling, garbage sorting and code reuse is not that different, for example : Programming languages like Java, SQL, Libraries of generic components like Math Library, application frameworks... Over 90% of source code in new applications is reused code\n\n3/ Efficiency vs. reusability : Portability has always been something desirable in a product. Favoring efficiency results however in nonportable code, while selecting portability often results in software whose performance is unsatisfactory. There's no doubt that obtaining optimum performance from portable software requires a higher level of technical sophistication and that the user wants someting efficient and always available. Facebook is always available...\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1654669,
      "meta": {},
      "text": "One typical design trade-off is functionality versus usability. Vim for example has lots of features, however is only usable by experienced users. A simple text editor is usable by everyone but lacks advanced features for text editing.\nAnother trade-off is cost versus efficiency. Games usually strive for the best performance and thus are programmed very low lever, however since this is hardware dependent many games are only available on Windows. Normal desktop application however, that don't need this kind of high performance are usually made platform independent and thus can be offered on multiple operating systems.\nA third trade-on is cost versus robustness. Creating plenty of software tests, or better yet, a formal verification, is very time consuming (i.e. costly).",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292596,
      "meta": {},
      "text": " Functionality vs. usability:\nLet's take a simple soccer game as an example. One Game has 50 options for different shooting styles to use during the game, the other one has 2 only (\"flache\" + \"spannschuss\"). The second one is more usable because no one is able to use or decide between 50 different shooting options. More functionality leads to less usability and vice versa.\n\nRapid development vs. functionality\nLess time means less functionality, but client want functionality in the shortest amount of time. \"Timepressure\" \n\n\n\nEfficiency vs. portability\nFor example if one program is very efficient, because it's using tools of ios 10. If the same program is running on ios 11 it may be not as efficient anymore because it can't use the tools of ios 10 anymore. If the program wouldn't use those tools it would be less efficient but more portable.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1294861,
      "meta": {},
      "text": "During the implementation of a software system, design goals are often in conflict with one another. Below are 3 such instances.\nIf one of the developer's goals is to minimize the number of errors in the system, and the client would like the project to be completed with as low a cost as possible, then these two goals would be in conflict. Greater attention to possible errors in the system would require more working hours from the developers and thus more money would be spent on developer salaries.\n\nA second possible scenario where trade-offs need to be made may involve the developer team's desire to maximize the functionality of the system, and the client's desire to develop the system as quickly as possible. Additional functionality will inevitably take more time to implement, and so this would increase the time required for development. \n\nA final example I'd like to expand on is the trade-off between the client's desire to make the system backward compatible, possibly with older versions of the system, and a developer's desire to make the code as readable and simple as possible. Making the system backward compatible will inevitably require the developer to make concessions to the simplicity of his or her code. Attention will have to be paid to certain aspects of the older versions and thus make the implementation more complex and less readable.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1321392,
      "meta": {},
      "text": "Functionality vs. usability\nArtemis is an example, the simpler the Artemis is, the easier it is to use and it has more usability. But more buttons need to be added if it wants to become more complicated to suits more Functionality, which means also less usability. So there are not so many buttons on Artemis, the register button and the registered course is the main functionality of artemis, it finds a balance between functionality and usability.\nRapid development vs. functionality\nFor a simple spaceshooter game software, which i have developed. If i want more functionality, for example spaceshooter has a bonus system to change its bullet type and get shield, it takes me two more days to develop the system. With simple functionality save the develper a lot of time.\nCost vs. robustness\nFor example, a minecraft server with 2Ram costs 3 euro pro 30 days, while server with 4 Ram cost 6 euro, which shows a better server robustness lead to a higher cost.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1396095,
      "meta": {},
      "text": "\tCost vs. Reusability : A client wants a website for his medium-sized restaurant. Naturally he wants to pay as little as possible for the website, since he has his own expenses. The software engineer has built such websites in the past and wants to reuse his code from his previous projects, as coding a website from scratch takes a lot of time, testing, reevaluation and therefore higher cost. So, cost and reusability are in conflict with each other. \n\tRapid development vs functionality: A furniture maker cannot meet the demands from his foreign customers without a website, so he wants his furniture website to be ready in a month. The software engineer has to deliver the product on time, but there are too many functionalities such as online payment and 24/7 communication hotline on the website. So, the programmer has to ask to the client, if he would like to have less functionality, but in 1 month delivery or all the functionalities to be finished in 3 months. Therefore, each additional functionality costs additional development time, unless the same functionality is already ready in programmer's disposal.\n\tUsability vs Functionality: Joe, 75 years old, wants to send pocket-money to his grandchildren via online banking. He doesn't know how to transfer money from his phone. The online bank has 3 main categories, branching out to more specific functionalities on the homepage. In order to cut down on staff, the bank offers many functionalities on the app. Therefore, the sheer amount of functionalities is challenging lots of users and they have to go through lots of functionalities just to search what they are looking for on the app. So, the amount of functionalities can make things more complicated than they actually are, hence less usable.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1487014,
      "meta": {},
      "text": "•\tFunctionality vs usability – if an interface provides a large number of functionalities, it can become difficult for the user to learn how to use it. An example could be Spotify mobile app and its action buttons. The buttons “like”, “play” and “download” for an album or playlist are grouped one next to each other instead of spread out, making the experience intuitive and easy for the user. \n\n•\tRapid development vs functionality – if a project is at risk of being behind schedule, managers can take the decision of cutting functionalities to deliver on time or deliver all functionalities of the project at a later time than planned. An example can be a team developing a food delivery app, all of the functionalities planned are done but one: the chat feature the app would provide so customers could communicate with the delivery person. The project team and client can decide if delivering the project without this feature now or deliver 3 weeks behind schedule and wait for it to be developed. \n\n•\tSpace vs. Speed – the interface delivers a solution in less time using more space, or uses little space taking more time.  An example can be the decision in a project to have compressed or uncompressed data. Storing the data uncompressed would mean taking more space but less time to deliver. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290805,
      "meta": {},
      "text": "A typical design goal trade-off is Rapid development vs. Functionality. This means that if there is a short deadline, it is not possible to implement the a lot of features, because it takes time to think about, develop and test each functionality. If a product is rushed, it can lack promised features.\nAn example for this are the Bumpers in-class exercises, which had a time frame of 10 minutes. Because of that, the tasks were very simple, fast and easy to do (e. g. replacing game assets), because there would not be enough time to do more.\n\nAnother trade-off is Functionality vs. Usability. If more and more features are added, the user interface can become cluttered and the user might be overwhelmed by the amount of things he can do in the program. This means that for a program to be usable, it should have a simple functionality, but this contradicts wanting to have many features.\nAn example would be software by Adobe (for example Photoshop, etc.) or complex industry standard in general. They come with a lot of features, which are also required for professionals, but this makes it extremely difficult to learn at first, making it very hard to use for beginners.\n\nEfficiency vs. Portability is another trade-off. Portability means being able to run the program seamlessly on many platforms, but a program tailored to a specific architecture can often be more performant.\nA program written in Java (e. g. Bumpers) is often slower because of the overhead of the Java virtual machine, whereas making it in x86 Assembly or C++ would be faster, but would only run on that specific processor.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1293624,
      "meta": {},
      "text": "Trade-off #1: Rapid development vs. robustness\n----------------------------------------------------------------------\nDeveloping robust software requires extensive testing and considering multiple edge cases. In case there is high time pressure on the team, it might not be possible to test the software towards a lot of scenarios. This can lead to unexpected down times because certain cases were not considered during development. An example would be the development of a central server application within just three days.\n\nTrade-off #2: Rapid development vs. functionality\n---------------------------------------------------------------------------\nIn order to avoid unexpected behavior, the functionalities in a system need to be developed conscientiously. In an environment where there is no time to do so, the functionalities might not work as intended. That is why it is important to focus on a subset of functionalites rather than deploying a maximum amount of functionalities. An example is the addition of five new functionalities within a week. In addition, this might be overwhelming to the user.\n\nTrade-off #3: Functionality vs. ease of learning\n----------------------------------------------------------------------\nA system that has a lot of functionalities might be harder to learn for users, because the user might be overwhelmed by all the different funtionalities. An example for such systems are CAD systems (e.g. CATIA), commonly used in engineering. Because they are so powerful and can be used in so many engineering domains, it can be hard to use them without a lot of professional introduction.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1295280,
      "meta": {},
      "text": "1. One the client side a rapid development of the system could be wanted, as the client wants to be able to provide his users with new functionalities quickly. Especially in times of covid many companies wanted fast solutions to be able to manage their daily businesses online instead of in person. However oftentimes it is not possible to rush projects without leaving behind quality (and sufficient testing) of the project. Some functionalities might be missing if there is not enough time to implement them. \n\n2. On one hand, the end user would like to have a userfriendly system, that can be easily understood, therefore frequent changes of the system or even rapidly varying layouts of buttons and menues can be confusing. On the other hand the client might want to offer an adapting system, that is flexible enought to endure trends and changes in society and therefore changes have to be made.\n\n3. As a developer, you would want to write code that can be reused in other projects as it saves time and work to do so. To make this happen, one needs well defined interfaces and a thought-through system design with logic subsystems. Nonetheless oftentimes it is required to develop at low cost and hence, it is not possible to do the needed planning. The result might be messy code that had to be produced to stay within the budged while still fulfilling all the requirements. In this case, reusing parts of the unstructured code is way more difficult.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344259,
      "meta": {},
      "text": "1. Tradeoff between low cost and backward compatibility \n-> To make a system backward compatible and thereby guaranteeing that it will be compatible to existing systems requires extra work hours and extra knowledge. Obviously this will cause higher costs as you will have to pay Software engineers to work extra hours. A good example is the backwards compatiblity for games of older consoles. It is possible play games that were developed for older generations which requires software engineers to make the new generation compatible to these games.\n\n2. Tradeoff between rapid development and User friendliness \n-> To make a system user friendly, you have to put a lot of thought into how a user would interact with a system. This takes a lot of time, not only to develop that system but first and foremost integrating the feedback of customers over and over again. So if you focus on rapid development, the actual user friendliness might decrease. An example An example for that would be an only tax software. So process of doing taxes is really complicated. A rapidly developed platform might not guide the user through the process and thereby create a bad user experience.\n\n3. Tradeoff between ease of learning  and functionality\n-> The more different functionalities a system has, the more complex it will get. This will make it hard for the user to learn the way, the app functions. An example would be an app where the menu has 50 different features so the user will be overwhelmed by the functionalities.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344370,
      "meta": {},
      "text": "Der wahrscheinlich am häufigstende auftretende Interessenkonflikt im Bereich der Design Ziele ist der von Kosten  und Robustheit. Das ist wahrscheinlich der Grund für die hohe Fehleranfälligkeit einiger Videospiele, da Bugs in Videospielen meistens eher Belustigend sind und keine Ernsthafte Gefahr für den Videospieler darstellen entscheiden sich einige Game Studios dafür, sich Zeit und Geld in diesem Bereich zu sparen und dafür die Robustheit zu vernachlässigen.\nEin anderer häufig auftretender Interessenkonflikt ist Funktionalität und schnelle Entwicklung. Ein guts Beispiel dafür, wie man durch Begrenzte Zeit nicht alles schaffen kann wäre, wie man nach einem Scrum Sprint (meinstens) nicht alle Backlog Items abhaken kann. Umso mehr Scrum Sprints bzw. Zeit man investiert umso mehr Funktionalität kann man in das Produkt implementieren. Jedoch müssen sich Software Developer häufig an Deadlines halten, wodurch nicht immer alle gewünschten Funktionalitäten bzw. Backlog Items eingebaut werden können.\nEine weiterer Interessenkonflikt ist Funktionalität und Benutzerfreundlichkeit. Wenn ich auf eine Website gehe, diese aber mit Menüs, Links und Werbung überfüllt ist, und der eigentlichen Inhalt kaum sichtbar ist, dann verlasse ich diese Website auch wieder ziemlich schnell. Zusätzliche Funktionalität sollte nicht den unerfahrenen Benutzer verscheuchen, sondern den erfahrenen Benutzer belohnen.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1345540,
      "meta": {},
      "text": "One typical trade off is rapid development vs. functionality. This means that if you want fast results in application development progress, you typically have to step down in functionality because more functionality would cost more development time. An example would be a Startup making a new social network. If they want to release their social network as fast as possible so they can gain new users, they may are not able to release their friendship feature yet because it would cost a lot of time to develop.\n\nAnother design goal trade off is functionality vs. usability. If a software has a lot of functionality, it can become really confusing. E.g. consider the social network startup again. After creating multiple timelines on the home page for their users, scrolling through new posts may be really confusing afterwards if some posts are only shown in specific timelines.\n\nEfficiency vs. portability is another design goal trade off. To make an application really fast and efficient, certain platform-specific hacks and tricks can be applied to speed up the application. But because they are platform-specific, they may not be available on other platforms. To overcome this, abstraction layers are introduced, which make the application slower overall. A good example for this is python. The language itself is not really fast, but because python is run using its own interpreter, it can run everywhere where the interpreter can run, and therefore python applications can run on many different systems.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1360738,
      "meta": {},
      "text": "When developing a software, we might face a problem: one design goal must be sacrificed in order to achieve another. As an example, the client has requested a date which all functionality has be completed by that date. However, sometimes it cannot be achieved. The trade-off in this case is between required functionality and  rapid development. Besides, if the software product is successful, it will have to introduce to public. The more user they have at the same time, the higher risk that they meet downtime of system. And now the trade-off between scalability and availability has to be solved. Also the most common trade-off is between cost and robustness. As we all known, a higher budget can help to develop a higher quality software. And hence, the system is more able to maintain the function even under a extreme circumstances.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1389591,
      "meta": {},
      "text": "1)Rapid development vs. Functionality: To fullfill all the needed functionality the developer needs time because a specific amount of developers can only work with a \"specific speed\" and solve a specific amount of problems within specific time. (e.g. a developer team of 3 probably could not create completaly working adobe photoshop within a week, however they could create less complex photo editor with limited editing dunctions\n(e.g. view photos, make a collage, add vignette, blush, change colours into warmer/colder spectrum)) \n\n2) Rapid development vs costs: to make a rapid development possible the amount of developers could be increased in order to solve more requirements within short time. However this developers need salery which leads to increasing production costs which could be a disadvantage for the client.\n(e.g. to solve the first trade-off one might hire more developers so that they could implement more functionality within shorter time, but those extra workers would need salery. So the price of the project will increase and might be higher than the client would like to pay)\n\n3)Functionality vs. Usability: high functionality level makes the software more complex and difficult to understand. So it will be more difficult for the user to learn how to use the programm and to memories all the functions.\n(e.g.  Adobe photoshop is much more complex and difficult to understand and learn than some smartphone photo editor app because it alloweds much more functions)\n\n//based on my solution from EIST2021",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1441349,
      "meta": {},
      "text": "In dem Design Goal Trade-off \"Efficiency vs. portability\" geht es darum, dass ein Programm nicht performant und effizient laufen kann und gleichzeitig auch sehr portabel ist, also auf vielen Geräten funktioniert. Ein Beispiel hierfür sind die Programmiersprachen Java und C. Ein Programm in Java läuft so gut wie auf allen Computern, allerdings nicht so schnell wie ein Programm in C, welches allerdings lediglich nur für einen Computer/Architektur kompiliert wurde.\n\nIn dem Design Goal Trade-off \"Cost vs. robustness\" geht es darum, dass ein Programm nicht günstig sein, kein und auch gleichzeitig robust ist und sehr stabil läuft. Ein Beispiel hierfür ist, wenn einem Projekt kein sonderlich großes Budget zur Verfügung steht dann können auch keine Unit-Tests, Integration-Tests, End-to-End-Tests oder Ähnliches ausgeführt werden, wodurch sich einige Bugs in das Programm einschleichen können.\n\nIn dem Design Goal Trade-off \"Functionality vs. usability\" geht es darum, dass ein Programm nicht sehr funktional sein kann, aber auch gleichzeitig benutzerfreundlich vor allem für neue Benutzer. Ein Beispiel hierfür ist ein GUI-Programm, welches versucht, möglichst viele Funktionen und mit möglich wenig Klicks anzuzeigen. Dadurch ist es zwar sehr funktional, aber ein neuer Benutzer des Programms wird von diesen vielen UI-Elementen \"überschüttet\" und findet sich nicht in diesem zurecht, wodurch das Programm nicht benutzerfreundlich ist.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1444125,
      "meta": {},
      "text": "Runtime Efficiency vs Good Documentation: A more complex code with cutting some corners, pre calculations and heuristics might be more runtime efficient but harder to read and also document in a for the user understandable way. This might also impact the readability of the code for the developer, making the code harder to maintain.\n\nCost vs Portability: Making a product usable across multiple different platforms makes the product more costly to develop as it requires specialists with more knowledge about different platforms and programming languages, raising the requirements on the developing side and raising the costs of development.\n\nBackward compatibility vs Productivity: Making a product compatible with an older system might force the developers to restrain from using new technical possibilities and additional recourses, holding back the potential productivity as when compared to when the product would have been developed with only newer hardware and software in mind.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1454458,
      "meta": {},
      "text": "1. One typical design goal trade-off is cost vs. robustness. For the client, one of the main goals is to pay as less as possible for the software development process. On the other hand, for the stakeholder group end user, robustness is one of the main design goals that needs to be achieved. Robustness refers to the ability of a system to maintain a function when the user enters a wrong input or when there are changes in the system environment. As an example, robustness testing for quality and reliability is commonly used in software development processes in order to test the degree to which a system operates correctly when exceptional inputs or environmental conditions occur. Although robustness is very important, robustness testing is very costly and requires a lot of time, leading to the described trade-off. \n\n2. Another typical design goal trade-off is rapid development vs. functionality. For the client \"ordering\" the software, a rapid development is one of the main design goals, as this stakeholder group needs the software and would like to use it as fast as possible. In contrast to that, for the end user, a high functionality is a major design goal and refers to what the software is actually supposed to do with regards to external interfaces, the actors. To achieve a functional system, the different steps involved in the software development process need to be iteratively conducted and thus, take some time. Also, the interaction of the software with its different external actors needs to be extensively developed as well as defined. Thus, when trying to achieve both design goals simultaneously, the named trade-off results.\n\n3. Finally, the last typical design goal trade-off is efficiency vs. reusability. Whereas for end users, an efficient system, that once it is learned, is fast to use, is one of the main design goals (sub goal of nonfunctional requirement usability), for developers, a reusable system is very important, meaning that by using reusable, proven \"off-the-shelf\" components for the development process, high quality as well as fastly developed systems are achieved. Unluckily, code reuse might not always lead to easy understandable and learnable systems for the actual end users, decreasing the efficiency design goal this stakeholder group has. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1464590,
      "meta": {},
      "text": "Design goals are mainly the nonfunctional requirements, however, sometimes there could be disputes between design goals, which are called design goal trade-offs.\n\n1. Investors and founders of a new Idea want to enter the market rapidly. Therefore, they want to have rapid development from app developers for their new app.  However, the very high pace more than needed for the development can cause problems. For example, the app could not be as functional as other competitive apps.\n\n2. A bag producer could use non-resistant and non-durable materials for their bags in order to escape from high costs. However, that could lead to troubles with the reusability of the bag. Because of those cheap materials, bags could be dysfunctional compared to other bags.\n\n3. The laptops with high RAM and CPU can work with higher efficiency. Nonetheless, this makes the weight of the laptop higher and could strict the portability function. Therefore a conflict between efficiency and portability occurred.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1339283,
      "meta": {},
      "text": "Functionality vs. usability\nA very easy example is that \"Whatsapp\", which doesn't have so many functionalities as Facebook, like posting a picture that all friends can see. It is simply very easy to use. As a starter, if I only want to chat with my friends individually, I would like to choose Whatsapp.\n\nEfficiency vs. portability\nFor example, a laptop vs. a desktop, with the equal value, the laptop is easier to carry on, but it can not run some highly commanded software efficiently, like big FPS games. For a desktop, for example, making a game background with Unity is easy.\n\nCost and reusability\nThere is a very easy Example, disposable cup vs. glass cup. A disposable cup is very cheap, it cost even nothing in a clinic or a hotel. But it is not reusable like the glass cup.\n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1633667,
      "meta": {},
      "text": "-Time-Reliability-Trade-off: In order to finish your project in a limited Time, you have to give up quality, because you i.e. dont have enough time to optimize the project until its perfect. The less Time you spend, the more qualities like Safety and Security suffers. A project that must be finished in between two weeks wont deliver a perfect software without errors.\n\n-Functionality-User-friendliness-Trade-off: If you work on a project, which is used by many people and should be easy understandable for everyone, you wont be able to implement many funtions. When there are too many informations in the software, the user cannot understand the whole system. There should only be functions, that are necsessary for the software or/and helpful for the user.\n\n-Cost-Supportability-Trade-off: A software, that is developed cheap will only fullfil the clients functional requirements, but it will be hard to adapt the software when it doesnt considers changes in the time it is used. You then have to spend more money to make a new, adjusted software.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1340115,
      "meta": {},
      "text": "1. Functionality vs. usability\nGenerally speaking, simple applications are easier to navigate and thus the usability is higher. Adding a lot of features to a software makes it more cluttered and harder for the developers to make it intuitive but fast to navigate. Thus it often requires more pages to fit all the content into the application.\n\n2. Cost vs. reusability\nSystems designs are easy to code and fast to produce for only one purpose. Especially for smaller projects, it makes software development easy (but not efficient). Making code reusable is an investment in the future of the project. It allows for faster development in the future and makes it easy to scale your project. Systems with items only designed for one purpose clutter the code and make it also less readable and adjustable.\n\n3. Rapid development vs. functionality\nIt's pretty obvious that programs that took less time to develop have less features, and are lacking functionality.\nSo it's often easy to lay the foundation and the basic systems needed for an application to work. But often the extra features that take time to develop, make a project pop out from the competition.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1344291,
      "meta": {},
      "text": "Cost vs Robustness\n- The more robustness is needed in a software, the more money has to be spent.\n-> NASA application safety and security-critical systems require thorough testing at each phase of the software development life cycle, from the system and high-level design to unit tests and integration testing, since little errors can risk human lives and huge financial losses.\n\nEase of learning vs Functionality\n- The more functionality there is in a software, the harder it is to learn to use a software\n-> Using professional IDEs for programming sometimes gets hard because of the huge amount of functionality they offer. So many new users are overwhelmed by the amount of settings and features they are offered. Easier IDEs have little amount of settings and are very easy to learn. Schools use simple IDEs like Bluej for learning students the programming language java, because it has not much functionality, but because of that, students can concentrate on learning the programming language than on learning how to use the IDE since it is so simple. \n\nRobustness vs runtime efficiency\n- The more robustness is need, the lesser runtime efficient software becomes\n-> In java f.e. to catch runtime exceptions like when writing to a file, you need to surround the code with try and catch, so the program doesn't crash when there is f.e. no storage left on the hard disk. This leads to more robustness, but the exception check requires time to perform.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1350803,
      "meta": {},
      "text": "Cost vs. robustness: \nThe client provides a limited budget for the software project which can harm the robustness of the software. This could arise if a project runs out of funding and, therefore, testing needs to be limited to the most important functionalities during program execution. Consequently, the developed software faces the risk that it can't deal with wrong user input. If the software, for example, provides a delivery service that is only offered within Germany and the user enters an Australian delivery address, the system should notify the user immediately, as it shouldn't process the order. \n \nCost vs. reusability: \nGiven capital restrictions in organisations, a budget limitation can negatively influence the reusability of software. Once the budget is reached, developers for example could potentially be staffed on new projects. Thus, lacking documentation of the project and its underlying functionality will limit the reusability of software components in new use-cases. This is highly problematic for scaling software projects across different use cases.\n\nFunctionality vs. usability: \nAn increasing functionality likely decreases the ease with which actors can use system functions. In the case of the Bumpers game, for example, adding more game features, such as choosing various different car or collision types before the game and showing multiple game parameters (e.g. speed, direction, etc.) during the game might decrease the usability categories learnability and efficiency of the game. Thus, a broader functionality harms the satisfaction and user experience of players.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1353398,
      "meta": {},
      "text": "Functionality vs Usability:\nWhen software has too many functionalities on the user interface, the usability will be bad, because the user needs more time to find the way how to use this software. But when the usability is bad, the user can't do enough things with this app, for example, a chat application from Tencent calls QQ,(like WhatsApp in Europe). At first, this APP wants to realize the functionality: chat, watch videos, play small games, etc. but for a chat application, that's too much. Many users just want to chat with each other and they don't need these functionalities which reduce the runtime efficiency and usability. But some users think this app is good because they can do so many things with this app.\n\nLow cost vs Runtime efficiency:\nLow cost means always that the software can't afford too many requests at the same time, that's mean the runtime efficiency is bad. For example, at a shopping festival in China, the biggest online-shopping company(they have a web application TaoBao) needs to handle more than 500 thousand trades in one second. At first, the server is down, until after some years they invest more in their server.\n\nCost vs robustness:\nTo get the high robustness the company pays more money. This point shows in some games, the game company always wants to let their game fast, funny, and costs not so much, but at the same time the player will find some bugs, some even can let the server down. Then need more cost to fix them, this seems like a circulation because the developer never knows what the player will do in their game.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1467955,
      "meta": {},
      "text": "1) Memory space vs. Runtime:\nIn order to make the runtime of a code shorter, the programmers might do some more coding, which will lead to the program needing more memory space. \n\nFor example: Using Look-Up-Tables for less cycles in the program cause more memory space to store these tables, but the program does in fact need less time.\n\n2) A second trade-off is to choose either adding more functionalities to the system or to finish it more quickly. Designing a bigger system and implementing it obviously takes more time than a smaller system with less functionalities, therefore the developers might need to not implement some functionalities in order to get the system up and running in a shorter time, if that is necessary.\n\nFor instance: An engineer who is developing a university app might not implement an additional message-sending functionality and finish the app in a shorter time.\n\n3) Another system trade-off would be to decide between adding more functionalities to the system or keeping it more simple and usable. More functionalities could of course make this software better and cover way more aspects than a system with less functionalities, but this would also make the software a more difficult system for the users to use. \n\nFor example: Microsoft Excel has lots of different functionalities that are very useful, but for a beginner who is trying to use them, it might seem overwhelming and the user might not be able to find a  functionality (for example making a new chart) very easily in all the functionalities.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1471270,
      "meta": {},
      "text": "-Functionality vs. Usability: Often times when building an application which has lots of functionality for example an image editing software, that it loses simplicity, it is less beginner friendly and more complex, thus being less user friendly. If you try to focus on the usability the amount of functionality you can include is very limited due to the interface being too cluttered otherwise.\n\n- Cost vs. Robustness: If the budget for the software design is not very high it might be the case that the software can not be tested enough for edge cases which might lead to bugs in the system. The software can  be made more robust with more testing and fixing bugs, which needs time and money.\n\n-Efficiency vs. Portability: Creating an application in Java makes it highly portable, because the application will be able to run on any platform with a jvm installed. The application is not going to be as efficient as it could have been if it was implemented in C which is more lowlevel but is platform dependent.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1290875,
      "meta": {},
      "text": "Functionality vs. usability:\nIf you have more functions available, the system becomes more confusing, because you have so much possibilities. Therefore the usability suffers, since by more functionality, the use of the software becomes more complicated. Conversely, the less functionality is implemented, the clearer the software is, the more usable it is.\nExample: A racing game with 100 settings (e.g. car, track, driver, ...) has a high functionality, but it can become confusing and the usability suffers. Instead, a game with fewer configuration options has more usability due to the simple handling, but less functionality.\n\nCost vs. robustness:\nThe more robust a system is, i.e. the more important the ability of a system to maintain a function, the more money you have to invest. If it is less important to have a robust system, which may be more susceptible to failure when changes occur in the environment, you will have lower costs.\nExample: Facebook has high costs to invest in its many servers. These are there, among other things, to handle the many user requests. The system is therefore very robust in the face of many user requests. If it were not so important to Facebook that the system is robust, it would have lower costs for the fewer servers. \n\n\nRapid development vs. functionality:\nIf systems are to be developed rapidly, less functionality can be implemented. Conversely, software with more functionality needs more time to be developed, because more needs to be implemented.\nExample: Bumpers needs much longer to be developed, if there should be several gamemodes. If development should be as fast as possible, it is likely to implement only one gamemode. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1331438,
      "meta": {},
      "text": "1. Cost vs. robustness\nIn order to maintain high robustness, better hardware or more time is often needed which means it will require higher cost. This conflicts with the low cost design goal. For example, more work is needed to prevent error on the system when users enter wrong input but the extra work will increase the cost.\n\n2. Functionality vs. usability\nHaving a large number of function in one interface can be confused to users and decrease the usability of the software. For example, an online shopping website contains a lot of functionality at a single page can confuse customers and it is difficult for them to find the useful information. \n\n3. Rapid development vs. functionality\nImplementing all the functionalities requires a lot of time and this contradicts with rapid development. For example, a new application needs to be developed in a short period of time in order to capture the new market trend, it may not have enough time to develop all the functionalities and only implementing the necessary features first. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344313,
      "meta": {},
      "text": "1) Functionality Vs Usability:\nDies ist meiner Meinung nach einer der wichtigsten Trade Offs in der Welt der Softwareentwicklung. Man muss die Funktionalität der Software mit ihrer Usability/Benutzerfreundlichkeit abwiegen. Während es z.B. eine Gruppe von Kunden gibt die am liebsten alles selber modifizieren wollen und den Drang verspüren eine große Kontrolle über die eigene Software zu haben, neigen andere Kunden eher zu einer einfach und verständlich aufgebauten Software die leicht zu benutzen ist und keine unnötig komplexen Sachen hat. Ein gutes Beispiel für Software die eher Richtig Funktionalität ausgerichtet ist sind Entwicklungsumgebungen. Eclipse erscheint von außen aus dem Sichtpunkt eines normalen Menschen sehr verwirrend und kompliziert ausgebaut, doch in der Zielgruppe die Eclipse benutz liegt das Interesse natürlich wegen der komplexen Welt der Programmierung viel mehr in der Möglichkeit, mit Eclipse sehr viele verschiedene Sachen machen zu können als dass es sehr einfach und aus wenig Funktionalität aufgebaut ist. Ein Gegenbeispiel dazu wäre z.B. eine Pizza-Delivery App, die Zielgruppe die diese App benutz kennt sich im Durchschnitt nicht wirklich mit der modernen Technologie aus, deswegen haben die kein Interesse daran dass man in der App die Farbe, die Anzahl an angezeigten Pizzen pro Seite oder die letzen 20 Bestellungen im JSON-Format exportieren kann, sondern viel mehr dass es relativ einfach und verständlich ist wie man eine Pizza bestellen kann und man sich nicht durch 10 verschiedene Optionen Klicken muss bis man die Pizza endlich bestellen kann.\n2) Cost Vs. Reusability:\nMan muss die Kosten der Software mit ihrer Wiederverwendbarkeit abwiegen. Während es auf einer Seite für den Kunden z.B. viel attraktiver erscheinen mag wenn die Osten entsprechend tief sind, ist es für das Entwicklungsteam meistens ein Vorteil wenn sie die Software so implementieren dass man die zu einem späteren Zeitpunkt wieder benutzen kann. Auf längerer Sicht kann es sogar sein dass für den Kunden die Kosten doch kleiner sind als hätte er anfänglich das Billigere Softwareprodukt genommen was dann aber letztendlich unter dem Strich teurer war nachdem er seine Software erweitert hat. Für eine große Supermarktkette wie Aldi würde es z.B. mehr Sinn machen von vorne herein auf Wiederverwendbarkeit zu setzen, falls sie sich z.B. dazu entschließen ihren online Shop auch auf Getränke auszuweiten oder in einer ihrer Unterkette den Shop einzusetzten, würde es ihnen im Nachsinne viel billiger kommen weil die existierende Software auf Wiederverwendbarkeit ausgelegt ist und bereits gut getestet wurde. Ein Gegenbeispiel dazu wäre z.B. die Website eines kleinen Hofes die Informationen über Ziegenkämme gibt. Hier würde es sowohl für den Kunden als auch für das Entwicklungsteam keinen großen Sinn haben die Software auf Reusability aufzusetzen, da man so eine Software eher sehr unwahrscheinlich nochmal brauchen wird und der Kunde die vermutlich nicht so oft updaten wird da sich sein Geschäft nicht wirklich darauf basiert.\n3) Efficeny Vs. Portability:\nMan muss die Effizienz der Software mit ihrer Portabilität abwiegen. Für Eingen Kunden kann die Effizienz der Software sehr wichtig sein, wie z.B. für Autohersteller wie Tesla. Sie haben ein internes Entwicklungsteam das versucht möglichst effizienten Code zu schrieben der sehr Plattform spezifisch ist. Die Sensordaten sollen nämlich so schnell wie möglich verarbeitet werden, es ist dabei aber egal dass sie Software dann nicht auf ein anders Auto wie z.B. ein Maserati läuft da dies nicht in ihrem Interesse liegt. Ein Kunde wie z.B. ein Pizzaliefrungsdienst hat hingegen kein großes Interesse dabei ob die eigene App 2 oder 3 Sekunden zum starten braucht, sie sollte zwar natürlich benutzerfreundlich sein und nicht laggen doch nicht wie beim vorherigen Teslabeispiel die Daten innerhalb von wenigen Millisekunden verarbeiten. Deswegen hat sich der Kunde gemeinsam mit dem Entwicklungsteam auch dazu entschieden eine Cross-Plattform App wie Flutter zu verwenden, die zwar nicht so effizient ist wie eine native App, aber jedoch Gleichzeitg auf Android als auch auf iOS ohne große Veränderungen laufen kann. Dadurch kann er sich Entwicklungskosten sparen und vernachlässigt dafür ein bisschen Effizienz die er sowieso nicht wirklich braucht.\n\n",
      "score": 100,
      "language": null
    },
    {
      "id": 1350262,
      "meta": {},
      "text": "Starting with Functionality vs. usability as  Typical design goal trade-off . \nas the system should has multiple functions and options so it can satisfy all the user's needs but at the same time, the usability of the system should be easy and clear enough so that user doesn't find difficulties dealing with it . given an example of a professional tv remote , it has many buttons, many functionalities allowing the user to fully control the tv, but it would not be so easy for them to get used to the remote or even get to know all the functionalities of every button and option because it is so complicated. \nthen we have Cost vs. robustness which represents the cost of the model and its quality. The cost and the quality should be in balance . if you find a cheap model, it means that hours and efforts of developping the system weren't enough to make it as robust as possible. For example buying a product from a seller in ebay and with a cheap cost , we should expect the product to be low quality and it may only work for a short time. \nand last Efficiency vs. portability . Efficiency usually means that waste is avoided. Waste in software development involves defects, waits, overproduction, unused creativity but Portability also  saves time and mental overhead for anyone involved in moving new versions of the software across environments. thats why it is a conflict between Efficiency and portability . for example for gaming,  using a computer with a powerful central processing unit is better and more efficient . But taking it around with you is a problem, and in this case using a laptop  is definetely easier and faster. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1391042,
      "meta": {},
      "text": "The first design goal trade-off is the functionality versus the required time plan of a software project. Normally, a project has a set delivery date and is expected to fulfill all the functionalities that were specified (product backlog). Nevertheless, sometimes it's not possible to fulfill all functionalities before the deadline. One example is our EIST team project, e.g. on the deadline of 22.02.22 we are missing FR9 9 which is the calendar function of the lecture system.\n\nA second design goal trade-off is the functionality of a system versus its usability. Often times a client wishes to have hundreds of functionalities in an application but that comes at cost of the usability as it can be very hard for an end-user to navigate through all these functionalities in an application without \"getting lost\". One  example is the flight system from the EIST team project: When we add more functionalities, e.g. a rental car/hotel/trip/restaurant booking option, the system can quickly become crowded and the usability for the end-user is impaired. \n\nA third trade-off in this context is efficiency versus portability. Meaning that if you program something specifically for one hardware system it will run more efficiently there, however, this could come at the cost of less/non-portability. One example is the development of a game. If you develop it specifically for PlayStation5, it will run very efficiently (less computing power) on this hardware system but if you want more portability, meaning that the game should also run on NintendoSwitch, this comes at the cost of efficiency. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1487831,
      "meta": {},
      "text": "Usability vs Functionality\nMS paint shows the most basic ways of image manipulation with very easy to use interface.\nAdobe photoshop on the other hand, may hardly be used intuitively, but offers a very wide spectrum of possibilities for image manipulation.\n\nCost vs Robustness\nRobustness in software development usually means that a lot of work and time was spent on perfecting the system to make it more reliable, which results in a higher cost of production.\n\nRapid development vs Functionality\nPretty much self explanotary. The more functional is the system, the more time should be spent on making it so.\nThe less time spent on the system, the more sacrifices in terms of functionality should be made.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1547528,
      "meta": {},
      "text": "Rapid development vs. runtime efficiency: Many clients can want to have an rapid development and have the product in a short time, but it causes often problems with runtime efficienty. For developing an efficient system, the developers need time, so rapid development and runtime efficiency stands against each other in that trade off.\n\nLow Cost vs. Reliability; Of course clients wants to have costs as low as posible. But creating a reliable system bzw. product, needs money. You need tools, a good developer team etc. which is against low cost.\n\nFunctionality vs. Ease of learning: \"The more functionalities you have, the complex is the sytem\"! It is often a clear fact. Having many funtionalities bzw. a system which can make many things(have many functions) makes it harder to learn system, because there are more things to learn. So functionality and ease of learning stands against each other in this trade off.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1317571,
      "meta": {},
      "text": "- One common trade-off is the one between maintainability and performance, since highly optimised code is not very readable and therefore not very maintainable either. On the other hand does code which looks very good and clean with (human-optimised) structure not perform as good as it could.\n\n- Another trade-off is the decision between platform independence or full control. It is nearly impossible to make one codebase run without adjustments on all important platform while keeping the ability to have full control over a said platform. In a game for example, you need to optimise for a specific system, so you cannot make a typical multiplatform-program.\n\n- A third tradeoff is just a general tradeoff between the tools you use. There are many tools available with great functionality, but no tool has all the functionality of all the others combined. There will be slight differences and advantages or disadvantages for each and every tool. One IDE (for example) might have more debugging features while another IDE is much faster and more fluid. ",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1317824,
      "meta": {},
      "text": "1. Rapid development vs. Functionality. New functionality means more code, more code means more time spent on writing, debugging, optimization and testing = with every new function the development time gets longer. For example, the action role-playing  game \"Cyberpunk 2077\" was meant to be the  largest land-based open-world game of its genre. That could be achieved through more functionality, which forced the team to make multiple delays and push the planned release forward (that were not enough). As a result, the game was released with bugs and  performance problems.\n2. Functionality vs. Usability. It is really hard to make the product (software) easy to understand and to use when it provides many functions, thus the risk of making a disorganized and confusing navigation grows. For example, a car navigation system that includes features that few drivers use. The features are included in menus such that they are complex with small touch areas that are difficult to use while driving.\n3 Cost vs. robustness. Robustness is the ability of a computer system to cope with errors during execution and cope with erroneous input.  Robustness can be achieved, for example, by constantly monitoring the environment to catch the errors during execution. However, that brings new development costs as it requires more work and additional software capacity. For example, lots of IT start-ups do not provide grate robustness of the system as the budget is limited, but as they grow and get more money for the project, getting more users as well, they start focusing on robustness.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1332383,
      "meta": {},
      "text": "The first one would be \"Cost vs. Robustness\", meaning that cheap things aren't always so robust. I.e. so usually paying more gets you a better product, like buying a more expensive computer which works faster and better due to more cores and threads. An other one is \"Portability vs. Effiency\" meaning sometimes a short not much damanding program when it comes to running on different plattforms is  better then a complicated and efficient program  that isn't portable, e.g. a very portable device/instrument is an USB stick which can be used on any compatible computer by simply plugging the storage device in. But also MS Windows is quite portable it can/is being used on many computers and laptops. The last one is \"Functionality vs. usability\", meaing that a software is quite user friendly meaning not to complicated, summerzied the ease of use and on the other hand the set of operations(Functionality). An example here would be again the Windows system it has many functionalities but is also extremely user friendly so even for not digital natives its quite easy to understand. ",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1338337,
      "meta": {},
      "text": "1. rapid development vs. functionality:\nWhile rapid development requires quick decisions and fast implementation, and the goal is to bring the ERP system alive as fast as possible, functionality might suffer when not enough time is invested to make the system function smoothly and properly. In contrast, functionality, takes time, as the developer needs to think of all functions needed, iterate and test and adapt functions or add new functions.  \n\n2. costs vs. reliability:\nThe system has the non-functional requirement of security and therefore to keep the player data such as payment details secure and secret. However, if not enough financial resources are invested, so that the security system is properly developed and further extended and updated, it might happen that a hacker can easily hack into the system e.g. steal payment details from Paypal or credit cards, general user data or passwords. Consequently, high security means also higher costs.\n\n3. costs vs. usability:\nWhen only few money is invested in software engineering, then the usability might suffer from that. The interface of a game might not be as intuitive and easy to learn as when more hours of programming (costs) are taken and consequently, it might then not be fast to learn. Also, the system might not be tested enough and recovery when errors occur takes very long so the game is not easy to use. The system interface might be not enjoyable but only basic as only few costs where invested in programming it to make it long nice and enjoyable.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344431,
      "meta": {},
      "text": "Functionality vs Usability : \n\tFunctionality is the things that the software can do, but Usability is on whether the user can understand and use these functions correctly. You can risk having too many functions in one place, but user will have difficulities understanding each of these functions and their uses. For example a game can only show the ,,Play'' , ,,Settings'' and ,,Exit'' button at the Main Menu. All Audio, Video and Controller Settings is placed in another page that is accessible with the Settings button on the Main Menu. Packing all these Settings in the Main Menu for example will lead to a crowded page which is confusing for the user.\n\nEfficiency vs Portability:\n\tEfficiency is how fast a program can do its job and portability is whether the software is available on different types of machines. For example a software can be made purely and specifically for one machine architecture and takes full advantages of the chosen hardware. It may run efficiently but it will risk portability because it reduces its potential in the market and only selected groups of people can use the software.\n\nRapid development vs. functionality:\n\tRapid development allow the fast development of the software, but it sacrifices functionality. For example because of the limited time of the software launch, a team may only select the key features of the product to be made, sacrificing the other functions which is not as important to the software.\n\n\n\t\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349182,
      "meta": {},
      "text": "Typical design goal trade-offs often occur because of the different goals of the main stakeholders, the client, the end user and the developer/maintainer. \n\nThe first example could be that the client or customer has low cost as a design goal while the end user expects the product to have a very high robustness and performance. It is difficult to achieve both these goals at the same time because high robustness and performance is often related to high costs. There a trade-off occurs.\n\nA second example could be that the client wants a rapid development of the product while the end use expects a lot of funtionalities from the same product. This often occurs in the real world in the gaming sector where publisher often just want to get the game on the market and ready to sell and therefore do not attach high importance to the funtionalities of the game. On the other hand the end user prefers a slower development if in return that means he receives a product with more functionalities.\n\nA third example could even occur from the end user alone who sets the design goals to having a lot of high functionalities while at the same time providing an easy usability of the product. Often times lot of functionalities lead to the product being overloaded and therefore harder to use or less intuitive which directly counteracts the goal of high usability.\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1367433,
      "meta": {},
      "text": "Ein typischer trade-off wäre  rapid developement vs functionality. Das bedeutet das zum Preis der Funktionalität das Produkt schneller fertiggestellt werden kann bzw. mit einer längeren Entwicklungszeit mehr und ausgereifte Funktionalitäten angeboten werden können. Beispielsweise kann das Entwicklerteam einer App aufgrund einer zu frühen Deadline ein Feature weglassen oder eine eingebaute Suchmaschine nicht so effizient wie erhofft gestalten.\n\nEin weiterer trade-off wäre functionality vs usabilty. Im Prinzip ist es das Einbüßen der Nutzbarkeit und des Verständnis des Nutzers für ein sehr vielseitiges Produkt mit vielen Anwendungsmöglichkeiten. Zum Beispiel kann ein Spieler von der Anzahl an möglichen Autotypen überwältigt werden weswegen er im Endeffekt nur die selben paar Autos immer wieder benutzt, ähnlich wie bei einem Restaurantservice der sehr viele Restaurants anbietet und man von der Auswahl eventuell abgeschreckt wird und bestellt was man kennt.\n\nEin letztes wäre backward compatability vs readabilty. Kurzgesagt der Austausch von Lesbarkeit des Programms für eine hohe Kompatibilität mit anderen Geräten. Backward compatability fordert eine gewisse Abstraktion des Codes da wir uns nicht auf systemspezifische Umstände verlassen können. Beispielsweise kann der Code für ein Playstation Spiel welches das Touchpad auf dem Controller der PS4 miteinbezieht nur schwer für die letztere Generation der Controller ohne Touchpad umsetzbar sein. Code auf welchem es egal ist welcher Controller genutzt wird beschreibt eben nicht genau die Tasten und Eingaben uns ist somit für den Leser etwas schwerer zu entziffern.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1410449,
      "meta": {},
      "text": "1) functionality vs. usability\nA typical trade-off is the functionality a client wants of his system vs. the usability for a end user. Photoshop is a very powerful tool to edit pictures, taken with a digital camera. There are so much tools and buttons you can click on and changing settings, that this is not easy to use any more. But in the end you can change the background, erase objects and so much more.\n\n2) efficiency vs. portability\nEverybody who has a mobile device wants its battery to last as long as possible. In order to that, operations of a system needs to be as efficient as possible. Imagine the battery is empty after calling somebody via video call, talking just 20 minutes. But on the other hand, there is just more than one operating system and architecture, so you can decide to optimize the video call just for e.g android, or offering the system via virtual machines, which are less efficient, being available for android, iOS and windows. \n\n3) cost vs. robustness\nTo make a system robust against wrong inputs of users, testing is the key. Testing a system is very difficult and takes its' time, because the number of wrong user inputs is just endless. No you can decide if your software is build for stupid people and nearly nothing can go wrong or if you accept the risk of a crash of your system by saving money.\n\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1425404,
      "meta": {},
      "text": "Cost vs reusability: Trying to keep the cost as low as possible can affect the reusability of the system as the development will only focus on the necessary functionalities without taking into account future updates or functionalities that could reuse similar code. For example, the development team might have to write less code and use fewer resources to create software, this will lower the cost. This software however will not be agile and usable for other similar projects.\n\nRapid development vs functionality: Producing the software as fast as possible can limit its functionality as not every requirement will be able to be added and also tested, the shorter the development is. An example here would be the game Metin2 which was produced within a few months but lagged in functionalities compared to other games at the time. \n\nFunctionality vs usability: The more functions an application has, the harder it will be for the user to use it. Functionality in turn creates a need for manuals and tutorials. A good example are low/non-coding visualization solutions which offer a huge array of functionalities but are very complex to use due to this plethora of functionalities.  \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1659882,
      "meta": {},
      "text": "In our lecture system project, we had to balance performance or rather memory usage and ease of use for developers when assessing the problem of storing calendar events. First, we decided that it would make sense to implement an event class storing everything, including description, start and end time, and amount of repetitions. We quickly decided that in order not to need to parse the single events every time for the web server to display, it would be better to sacrifice memory usage for ease of use for us developers, and store each e.g. weekly-specific event additionally.\n\nAnother thing that needs to often be decided on is a balance between general quality, cost and performance especially. This can also be applied to our lecture project, the performance of the system is not important at all due to little gain - only being the 0.3 grading bonus - so instead, we want the implementation to be as functional as possible, while sacrificing performance for the low cost and also low time frame, also considering the project of lower importance compared to regular university stuff.\n\nOften, usability also interferes with performance - while it would be the most efficient to use a webpage only containing text, no images and no big graphical magic, it would make the user experience much worse. Instead, the developers try to develop an easy to use system, which should be at any cost of performance.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1290916,
      "meta": {},
      "text": "All examples refer to the TUM Roomfinder app: \n\n1. cost vs. robustness \nThe university as a client wants to spend as little money as possible on it, however it wants the app to be as robust as possible, so students can't book 2 rooms at the same time for example(The system has to check that a student can't book a room when he already booked one). To avoid these small errors, the programmers need more time and this means higher costs.\n\n2.  Functionality vs. user-friendliness \nThe TUM wants the app to have all kinds of functions like booking rooms, seeing room availability, seeing room information (which building etc.), all this only as a TUM member... .However, they also want the app to be very user-friendly, so that you can easily find your way around and book rooms within a few minutes, without the hassle of entering annoying data like your matriculation number etc.. , can book. But the more functions are added, the more confusing it becomes.\n\n3. rapid development vs. minimum of errors \nThe university wants to have an app programmed within the semester break, so that it is usable at the beginning of the next semester, but the app should be implemented cleanly, so that no or as few as possible errors appear. However, in order to make the app as error-free as possible, a lot of testing has to be done, which takes time.\n\nThis is my solution from the last year.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291576,
      "meta": {},
      "text": "1. Functionality vs. usability\nThe trade-offs of functionality and usability is obvious. Functionality requires the system has as many functions as possible(?). Many functions makes system better but complexer. And as we known, usability will precisely define how each function work. It also make the system complex further. These two requirements make the system more complex and hard to realize or we can say implement.\n2. Efficiency vs. portability\nIn general, a system has higher efficiency when it is only implemented in only one platform compared with in many platforms. Because when we design a system only with one platform, we just use the framework of this platform. But when we need to realize the portability, we need to assemble frameworks of other platforms to our system, this will lead to bad compatibility and thus, greatly reduced the efficiency.\n3. Cost vs. robustness\nIn general case, we want to reduce the cost by assuming a perfect environment for the system running. And robustness is just in the opposite site part of our low cost desire. Robustness always requires our system in an error case, and this undoubtly will increase the cost when we design more functions to avoid the error which robustness requires.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291739,
      "meta": {},
      "text": "Some IDEs such as Pycharm and IntelliJ contains lots of functionalities in the menu above the software panel due to that the client wants to make the IDE powerful enough. But for the user, especially the programming beginner, too many functionalities make the software hard to use at the beginning (functionality vs. usability).\n\nAnother example is the enterprise management software. Sometimes a company doesn't want to spend too much money on it so the cost is required to keep in a low level. The lower cost the company wants to pay, the less work developers will do, thus the less time deveploers will spend time on it. If the company wants to upgraded the software easily later on, it requires a good system design which has low coupling and high cohesion, and it takes time to develop. Then the cost will also increase with the develop time. (maintainablilty vs. cost)\n\nGame players expect that their favourate games will be released as soon as possible, but on the developers' side, it's rather difficult to ensure the quality of a game which is developed in a short period of time. Some games were even released with lots of bugs, which didn't meet players' expections.(rapid development vs. robustness)",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291925,
      "meta": {},
      "text": "Cost vs Robustness: if the developer considers every possible error-source that can harm the system it becomes very time consuming and thus expensive for the customer. On the other hand, if the development is supposed to be cheap, the developer it can only focus on the main error sources. \n\nCost vs Reusablility:  if the developer focuses on the generalizability of the code, that it can easily be put in another context, it becomes very time consuming and thus expensive for the customer. On the other hand, if the development is supposed to be cheap, the developer manufactures a code that is very specific and tailored to the current project\n\nFunctionability vs. usabilty: if the developer focuses on providing a variety of detailed functionalities, at some point the system gets unclear and confusing for the user. On the other hand, if the system is extemly easy to use and neatly, chances are high that only a few functionalities are provided. ",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292588,
      "meta": {},
      "text": "1) Functionality vs. Usability: Functionality refers to the set of functions/ tasks that can be performed by the system. Usability refers to the quality and ease with which a user can use the product. Increasing the functionality generally makes the UI more cluttered and difficult to use, while removing/ nesting functions within other functions makes the UI better and more easily comprehensible. Example - Cockpit of an Airplane. Each element of a cockpit is necessary for the plane's operation. It is difficult to understand everything and takes pilots months of training. Removing elements of the cockpit would make it easier for pilots to use it, but potentially obscure critical functions.\n\n2) Cost vs Robustness: Cost refers to resources spent in developing a system, like time and money. Robustness is the ability of a system to function normally in face of problems like changes in environment. Making a system more robust requires greater testing, evaluation and a more thorough assessment. However, this requires greater amount of time from the developers and engineers. For example, an airplane can face 1000s of issues. To make it safe against ANY unwanted issues would require far greater resources, right from plane design to construction to maintenance.\n\n3) Rapid development vs. functionality: Rapid development refers to the speed with which a system can be operationalized ( and deployed) (functionality defined in (1) ). If we want to develop greater functionality, the development time will naturally increase. For example, startups make this tradeoff while developing their MVP. They want to launch something as quick as possible, so they strip down their product to only the most essential functionalities, postponing more complex functionalities for later.\n    ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1293664,
      "meta": {},
      "text": "1. \tRapid development vs. Functionality:\n\tJedes neue Feature benötigt Zeit für die Implementation. Wenn sich zum Beispiel mein EIST-Team bei dem\n\tTeamprojekt (Flight-system) dazu entscheidet einen optionalen Movieplayer für onboard entertainment\n\teinzubauen, muss den Code dafür jemand schreiben und jemand müsste videos, die man verwendet\n\theraussuchen. Das kostet Zeit.\n\n2.\tRuntime efficiency vs. Readability/Maintainability\n\tEin Beispiel hierfür sind Loops fester Größe. Da diese inefficient sind, kann man sie manuell (wie es auch der\n \tC-Compiler bei gesetztem -Ofast Flag macht) aufrollen. Das heißt, dass man statt einen Loop zu schreiben, die \n\tAnweisungen welche normalerweise innerhalb des Loops wären, so oft wie nötig einfach untereinander schreibt.\n\tDies schadet der Maintainability und Readability. Genauso schadet es oft der Performance eine höhere einfacher\n\tzu verstehende Programmiersprache zu verwenden staat zum Beispiel Assembly.\n\n3.\tLow Cost vs. Reliability\n\tReliability hängt sowohl von Software als auch Hardware ab. Die Hardwareseite wird oft durch mehrere\n\tredundante Server, die untereinander Zustände austauschen geregelt. Mehr Server kosten extra. Diese\n\tZustandsaustausche, müssen von Software geregelt werden, wofür wider Developer eingestellt werden müssen,\n\twas zusätzlich Kosten verursacht. Dies alles muss 24/7 gewartet und überprüft werden, was - you guessed it- \n\tKosten verursacht.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1297507,
      "meta": {},
      "text": "1. readability and modifiability vs functionality\nI build an app that needs to process multiple data of multiple users so it needs to be fast. To make it fast, I need to make a lot more of classes and functions to support a faster algorithm. The code becomes harder to read and modify\n\n2. cost vs robustness\nI build an app that needs to be hidden behind a login page. As a result, I need to spend more time building the app, to make sure that unauthenticated users cannot access the hidden pages. I need to also build the redirection functionality or announcement etc. More robust app will usually result in more cost needed.\n\n3.  cost vs reusability vs performance\nI build a general function to get items from a database. But at this app, the items that are called from the database are large and complex. If I use this general function, then way more items will be called than I need, so it will reduce the speed of the app. Because I want a fast app, I cannot reuse this general function and have to make a new one specific for this items. I need to obviously spend more time building this new function",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1298584,
      "meta": {},
      "text": "Es kann einen trade-off zwischen Kosteneffizienz und Genauigkeit geben. Ein Programm kann u.U. billiger sein, wenn es die reale Welt weniger genau abbildet. Ein Beispiel wäre eine Bank, die intern nur eine Form von Konto für ihre Kunden kennt und keine Unterschiede sonst macht. Dadurch kann man sich bei der Softwareentwicklung Geld sparen, die Wirklichkeit wird allerdings nicht mehr genau abgebildet. \n\nZudem kann es einen trade-off zwischen Effizienz und Portability geben. Ein Programm kann stark für eine Plattform optimiert werden, ist dann aber z.B. nur auf dieser Plattform verfügbar und auf sonst keiner anderen. Ein Beispiel dazu wäre RollerCoaster Tycoon, welches ausschließlich in x86-Assembler programmiert wurde und deswegen nicht auf anderen Plattformen benutzt werden kann, dafür aber sehr sehr effizient ist/war.\n\nZuletzt kann es einen trade-off zwischen Size (Code-Size) und Readability geben. Kurzer Code ist nicht immer besser. Manchmal ist es sinnvoller, eine eigene Methode oder Klasse einzuführen, um den Code für andere Programmierer verständlicher zu machen. Ein Beispiel hierfür wären sinnvolle Variablennamen: man kann allen Variablen theoretisch nur einen oder wenige Buchstaben als Namen lesen. Der Nachteil dabei ist dann aber, dass ein neuer Programmier auf den ersten Blick nicht versteht, was diese Variable bedeutet. Besser sind verständliche, aber auch längere Namen, die die Code-Size vergrößern, wie z.B. carCount statt c.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1335969,
      "meta": {},
      "text": "One design goal trade off in the context of software engineering would be efficiency vs portability. It is often the case that some projects need to run on different machines or different operating systems. If that is the case then more often than not these systems lose out on efficiency as these different platforms provide different functionalities and thus developers need their code to be adaptive for every environment, which takes up the efficiency.\nAn example for this would be Java. If one uses Java for a project then the software can run on nearly every platform. But the trade off is that Java is a rather slow language compared to other languages because it needs to translate the code into byte code first and the execute it in the JVM.\n\nAn other trade off in software engineering would be rapid development vs functionality. If a product has to be brought to the market very quickly, the developers often don't have the time to implement a whole range of features.\nIf the developers only have on week for example, the client cannot expect that the product already contains every feature he asked for. \n\nThe third trade off would be backwards compatibility vs readability. Once a project gets larger and new versions get released, some user want to have backwards compatibility, else they would have to redo all of their work for the new version. But if developers support backwards compatibility, the code base gets polluted because you different codes for different systems.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1336909,
      "meta": {},
      "text": "1. Functionality vs. usability:  when the software contains more functionality, it will become harder for the user to use. Example: A calculator with more function like Matrix operations, complex number or differentiation and integration. \n2. Cost vs. robustness: a system which is more robust costs more. Example: A software which can be used on low performance computer is usually more expensive to develop than a software which can only operate on high performance computer with the same functions.\n3. Rapid development vs. functionality: a system with more functions can only be developed slower than those with fewer functions. Example: a small app which displays map of a certain area can be developed in a small period of time, but a bigger app which contains extra functions such as search for places and search for paths requires more time to develop.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344311,
      "meta": {},
      "text": "Rapid development vs low cost :\nevery client wants to sell their products as soon as possible, so they can get more income in a short time. The problem is, if the client wants more variety of product to be sell in a short time, then the client must also be willing to spend money more, because the development of a software, in particular the testing part, costs amount of money. But if the client spends more, then the goal to get more income might be not achieved.\n\nRuntime efficiency vs user-friendliness:\nTo achieve an efficient runtime, that the program for example should be written on a \"hardware\" programming language, such as c. With it one's can achieve a high program performance. The problem is, usually the \"hardware\" programming language doesn't offer an interface, that is user friendly. This because, such interface could prevent the efficiency of the performance.\n\nease of learning vs rapid development :\nIf a program is developed to rapidly, it is possible that there are some aspects of the program that could be changed. This can have an impact on how  easy to learn to use the program. For example, if a program was launched yesterday and since then there are a lot of development but also changes in the program, then it is possible, that the user must re-learn how to use the program, because the program of yesterday might be not the same as the one today.  \n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1623327,
      "meta": {},
      "text": "1. Efficiency vs portability: Writing software in low-level languages like C makes it possible to reach high efficiency on certain system architectures. However, it might be hard to adapt this software to other system architectures.\n2. Rapid development vs functionality: Implementing functionalities takes time - if time is very limited, only core functionalities can be implemented. If a client wants to have his project finished in 3 weeks and the product backlog still contains 100 items, a trade-off has to be found.\n3. Cost vs reusability: Making sure that a certain software package works in lots of different contexts may take significantly more time than focussing on just one context - so costs will increase.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291989,
      "meta": {},
      "text": "Functionality vs Usability: By implementing great functionality, the usability might be horrible due to excessiveness. For example, Facebook page has dozens of clickable items, which become excessive during short time interaction with the interface. For example, a user has to go through at least 5 facebook sub-pages in order to update mail-notifications for certain groups. Such information is hard to access because facebook wants to offer a huge amount of entertaining functionality, so developers probably had to fit a lot in just one group page. \n\nCost vs. robustness: The costs for the software development can be proportionally measured with it’s so-called strength. If the client decides to cut budget for the robustness of the system, this might lead to problems with the ability to tolerate problems that might affect the system’s functional body.\n\nRapid development vs. functionality: if the framework allotted for working on the system is limited, this may lead to the fact that the developers simply do not have enough time to develop a full-fledged functionality of the system. For example, covid apps, which were developed in a kind of hurry, didn’t implement that much of functionality, so the user has to download other multiple apps in order to collect schnell-tests results, having digital certificate and book appointment for the doctor. \n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1296940,
      "meta": {},
      "text": "First trade-off is functionality vs usability. Even if the costumer sometimes tends to think that the more people can do on the app the more they are going to use it. In the other hand actually most of the users use apps in which they get their work done as quick as possible and in an easy way. Nobody would want to use an app which has hundreds of functionalities because one have to learn first how to use those functionalities. In this century it is much more precious to spare time and get the work done quickly rather then searching for a way to get their work done and waste time. For example Instagram is such an easy app  with millions of users around the world with just some basic functionalities. It is mostly used by influencers making advertisements through stories which takes less than 5 seconds. Instagram doesn't remind you the birthday of your followers while Facebook does. Meanwhile Facebook's popularity is debatable.\n\nSecond trade-off is costs vs. robustness. Costumer would usually would want to get the software on the lowest budged possible. But while developing a program on low budged not many tests as wanted could be done which leads to unchecked errors when the end user enters wrong data. For the developer it is important that quantity of errors are at the bare minimum or non so that the software can serve a smooth user experience. Let's think of a database app made on a low budged and end users experiencing difficulties. Costumer needs the developers once more to revise and improve the software which would cost once more money. So making sure at the beginning that enough tests have been made on a reasonable budged is prominent.\n\nThird trade-off is efficiency vs. portability. Many too many multiplicities between classes has additional coding and testing costs. In order to reduce costs and ensure modifiability, adaptability too many multiplicities between classes should be avoided. Think of a high school with a teaching policy with tablets. They have a deal with a tablet brand which supports android apps. So the customer in this case high school would require that their app should be portable and also been accessible on devices which supports iOS because even if they have a deal with a brand doesn't mean there won't be students who've different tablets already and don't want to buy a new one when starting to school.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1298358,
      "meta": {},
      "text": "1.Rapid development vs. functionality\nWhen we want to develop a university app, if we only need the app to be able to view courses, then it can be developed quickly, but when we need the app to be able to implement other functions such as registering for courses, commenting, etc., the development time will be extended.\n\n2.Cost vs. reusability\nWhen we want to develop a university app, if we only need to use it among TUM students, then we only need to develop features related to TUM courses, but when we need the app to be applicable in other schools as well, additional costs are needed to develop the corresponding adapters.\n\n3.Cost vs. robustness\nIf we need to develop an app for a university then there is a low cost to consider, but when we need to develop a related app for a bank, there is a requirement for robustness and the cost can increase accordingly\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1313938,
      "meta": {},
      "text": "1) Functionality vs. usability\nExample: When people use the app Deutsche Bank to transfer money, they must input their own \"Filiale\", \"Kontonummer\", \"Unterkonto\" and \"PIN\" all correctly to identify themselves. Then they must input correct IBAN and name of the person who they want to transfer money to. To guarantee transfer's security, the app will also jump to another app photoTAN to get correct CAPTCHA and then jump back. People must check everything again at last.\nFrom this example, we can find that the security is given priority and the ease of use sacrifices. A lot of functions are added to the software which make it difficult to use, but the security is improved. Removing these functions can makes it easier to use, but the security decreases. \n\n2) Cost vs. reusability\nExample: A software library was set up so that many common operations, formats and information can be reused. But it also causes additional coding, testing and maintance costs.\nTo improve reusability, additional coding and maintance are always necessary, which leads to more cost. \n\n3) Rapid development vs. functionality\nExample: Assume a software which enables people to book tickets. If the app only needs the function of booking, the development needs 10 days. If the app also wants price comparison of different merchants, the development needs more than a month.\nMore functions of a software means additional coding and more time for development. Rapid development has to abandon a few functions sometimes.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1329197,
      "meta": {},
      "text": "Exampe 1: cost VS. robustness\nIf the software used was cheap, it is often error-prone. \nFor example, when making an online purchase, it must be checked beforehand whether the specified payment data exists. If this is not checked, the customer can simply enter arbitrary information and gets his products \"for free\" while the seller is stuck with the costs.\nThus, the seller accepts financial losses, but on the other hand has saved money regarding the software.\n\n\nExample 2: cost VS reusability \nIf one already has software that searches a data set for a particular feature, it is usually cheaper and easier to modify this software slightly for the new requirements in order to continue using it. \nFor example, a software actually only filters the weather and returns the average with respect to certain criteria (rain percentage, sunshine hours).\nWith slight modifications, the software can also do this for e.g. cities, countries, or months.\n\n\nExample 3: Functionality VS usability\nIf a software has significantly more functions than needed, this limits the user-friendliness, since it will confuse the individual user, who usually only needs certain functions, since the offer is not tailored to the \"personal\" needs. \nFor example, if the user actually only calculates with vectors and their functions, it makes little sense if he first has to naviagate through all the angle calculations to get to his working area.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1335301,
      "meta": {},
      "text": "1. Rapid development vs. functionality:\nThe client's expectancy of a fast implementation in contrast to the need for multiple extra functionalities that the end-user fancies. Naturally, every functionality needs time to be implemented. Thus the more requirements the client has the longer the software development process. The problem is that for the client, the project often needs to be finished really fast e.g. when they need the application in order to organize an event that is taking place in 2 months. Thus they have to let go of features in order to make the implementation feasible in the desired timeframe.\n\n2. Cost vs. robustness\nDeveloping the software in a solid and robust way with a minimum number of errors is crucial for the usage of software. Therefore developers need to invest a lot of time in security issues, testing of functionalities, code reviewing and technologies so that the system is working even if errors occur during the runtime. Especially when the software deals with critical functions such as the cooling system of an atomic reactor it is really important that the system is not too sensitive and can handle unforeseen situations e.g. hot temperatures or electricity shortages. Unfortunately, those measures increasing the robustness of a system are usually accompanied by high extra costs.\n\n3. Cost vs. reusability\nThe conflict between low costs desired by the client and high reusability. For the developers, it is beneficial to code a program so that subparts can be reused for other applications. Therefore they need to code in a way that enables low cohesion and modular code parts to create a library of methods and subsystems which saves time for later development projects. This rather general type of coding requires extra effort and is thus more expensive for the client.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1336341,
      "meta": {},
      "text": "1. Cost and robustness\nRobustness means that the system can continue working even in some extreme cases. For example if I want to design a searching system for my own use, finding out the frequency of some words from the works of Shakespeare, I can do this myself, create a very tender software which will crashes for a single unintended input. But if this software is for the whole university, I have to hire a professional team, need someone to maintain this software from time to time, ensuring it still works when 100 people using it at the same time. So robustness costs more money and more time.\n\n2. Functionality and usability\nIf a software supports plenty of functions, it also costs more time to learn and remember those functions. A really good example is TumOnline. I can register for courses, download documents, view my grades on it. But it is very confusing when I logged in it at the first time. I have to carefully find the function I want. In contrast, the Campus App I installed on my mobilephone is rather usable. I can easily find what I need. However, I can not download the documents or register for a exam on it.\n\n3. Backward compatibility and readability\nA typical example is Python3. We all know that python3 is not backward compatible. If it were, some confusions might appear. \" print 'Hello world!' \" is not allowed in python3, which makes the code more readable. When we updates a software, we do not simply add some functions on it, but change some functions. And it is really often we updates it for many times. If we accept everything from the older versions, we will make the code and the model much more complicated and hard to read.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344095,
      "meta": {},
      "text": "DESIGN GOAL TRADE OFFS\nOne typical trade off would be the degree of Portability and Costs. If for exemple in  a software project the team want to achieve a high degree of portability, it has to take into account that the more complex developing will also lead to more costs.\n\nAnother tradeoff would be between flexibility and rapid developing time. If the team for exemple want to achieve a system, which supports a big variety of end-devices, it must take into account additional developing time. \n\nAnother exemple would be the tradeoff between costs and the robustness of a system. For exemple if a hardware should handle huge temperature differences, the development will cost more then if the team only try to design a  hardware, with no fluctuating temperture. \n\n. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1346619,
      "meta": {},
      "text": "1. Functionality vs. time shortage\nIn case of a time frame that is to short to implement all the NFRs that were thought of, some of them \t\tmight have to be written out or be implemented in updates etc. but not the first version.\n2. Efficiency vs. readability\nIt is possible that the code and models get more cryptic and hard to read in favor of optimizing the efficiency of the program or system\n3. Cost vs. time (vs. quality)\nTo keep costs down, the time frame should be held as short as possible which can again lead to fewer functions implemented etc.. While sometimes higher costs have to be dealt with, as to make sure there is enough time to work on the project",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1349207,
      "meta": {},
      "text": "Cost vs. robustness: Der Faktor Kosten ist bei einer Software (und allgemein) immer ein wichtiger Faktor. Man möchte so billig wie möglich das beste Produkt bekommen. Wenn die Kosten zu sehr gekürzt werden, dann kann es passieren, dass das System schnell nicht mehr Funktioniert, wenn man es nicht so benutzt wie man sollte. Zum Beispiel, man implementiert ein Login für ein System, um sich Kosten/Zeit zu sparen, überprüft man die Eingaben des Users nicht. Nun ist es möglich, dass der User eine SQL-Injektion macht und die komplette Datenbank unbrauchbar macht. \n\nEfficiency vs. Portability: Um Systeme heutzutage Portable zu machen werden Interpretiert Sprachen verwendet, damit kann ein Programm unabhängig auf so gut wie allen Systemen laufen (Java, Python, ...). Ein Problem haben diese Sprachen im Gegensatz zu C, C++, etc. die Ausführung dauert länger. Jetzt kommt es darauf an, ob es wichtig ist, ob die Eingabe in 1s oder in 0.1s verarbeitet wird. Zum Beispiel, Programme, die ein Benutzer verwenden sollte, oft portabel sein, da diverse User das Programm nutzen.   \n\nCost vs. reusability: Wenn man bei der Programmierung achtet eine hohe reusability zu bekommen bedeutet das im Schluss, dass der Aufwand steigt ergo die Kosten. Wobei aber die Kosten nur im aktuellen Projekt steigern und in anderen mit dem reuse gesenkt werden. Wenn man zum Beispiel einen Webshop so designt, dass dieser für diverse Kunden wiederverwenden kann, dann wird die erstmalige Entwicklung höhere Kosten haben, welche sich aber in der Zukunft auszahlen werden. Problematisch ist es, wenn man in Zeit/Kosten begrenzt ist, dann ist es nicht möglich. Und da man so gut wie immer in den Kosten begrenzt ist, wird/sollte man einen Mittelweg gehen, damit man sich sukzessiv annähert.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1350237,
      "meta": {},
      "text": "1. The first trade-off that probably comes to mind is the discordance between the functionality and the usability. In this specific case that means weather it is good to improve functionality, if the applications usability suffers in the proccess, as e.g. you need far more actions to get to the menu or to end a transaction.\n2. A further typical trade-off are the costs and the robustness, as the application can be distributed at a lower price (client interest), but e.g. at the cost of the robustness (end-user interest) for less money is available to cover the possible wrong user inputs  or changes in the environment.\n3. And of course the dissension between rapid development and the functionality. The client wants the application to be created and finished as fast as possible, whereas the end user is (more) focused on haveing the functionality expanded as far as possible, without reducing other aspects.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1365461,
      "meta": {},
      "text": "1- Design goal trade-offs \n\tAesthetic v.s. Usability\nWhen users encounter a visually pleasing interface, they are more forgiving of small usability flaws. For most users, ease of use is the second plan since, like in other aspects of life, individuals tend to choose what is aesthetically appealing to them.\n\n For example, I prefer to use a more visually appealing application, even if it is more difficult to use than other applications. The \"Notion\" program, which I use as a planner on a regular basis, is complex and beyond my needs, but it is highly stylish and elegant.\n\n2- Design goal trade-offs \n\tCost vs. robustness\nTypically, building a production process involves significant constraints, such as balancing production costs and robustness. The key objective is to reduce production costs while improving robustness and performance. The pricing of a product is critical for both the producer and the consumer, but when it comes to the quality of the good and robust state of a product, many various thoughts may occur. Because, overall, the benefits of resilience outweigh the benefits of low wages.\n\nRegardless of the price, I always prefer things with higher quality and a longer lifespan. For example, all the electronic instruments I use in my daily life are highly resilient.\n\n\n3- Design goal trade-offs \n\tRapid development vs. functionality\n\nRapid development means developing informational content quickly and efficiently and it is a particularly important criterion for the Developer, End-User, and the Client. However, this can have an impact on the product's functionality. All other factors are secondary to the product's functioning and usage. \n\nFor example, rather than reaching my hand a week ago, I would prefer that a product be built, and its usefulness be expanded in that week.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1395073,
      "meta": {},
      "text": "\tUser friendliness vs backward compatibility:\nUser friendliness is hard to accomplish in systems, designed with backward compatibility in mind. Over the last decades software in many fields has greatly improved and became easier to use. Older systems often use structures or logics, that differ greatly from their modern equivalents, and therefor they often seem bizarre and are hard to understand for a person, who is used to modern software. Implementing backward compatibility inevitably confronts the user with this old and possibly outdated systems, decreasing user friendliness. Many programs written for no longer existing operating systems will be hard to use in modern systems, requiring the use of virtual machines or other complicated tricks.\n\n\tRapid development vs minimum number of errors:\nFast development always leads to a higher number of errors, due to haste in the coding process or not enough time spent on testing and debugging. There are multiple examples for computer games, that became infamous for their huge amount of bugs , all because of too short time schedules imposed by company leadership.\n\n\n\tEase of learning vs functionality:\nOften the ease, with which a user can learn a system clashes directly with functionality. The more functionalities a system has, the more complicated and harder to learn it becomes. This effect can be mitigated by good documentation. A graphics design system simply cannot be intuitively if its functionalities account for all possibilities, that are available with modern graphical capabilities of computers.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1411310,
      "meta": {},
      "text": "1) As the system on which software run varies greatly, software desing has to balance effieciency with portability. To make a software efficient, developers have to use the strengths of  some specific hardware to find better performing algorithms on that hardware. For example, if you develop a game, using a powerful graphic card asa basis would enable high performance, however it wouldnt be portable. Portable means that software can run on a lot of systems like java.\n\n2) If the budget for the software is short, developers may have to neglect a clear structure and detailed documentation altogether,which in turn would quite sharply reduce the reusabilty of the system,as new developers would struggle to understand millions of lines of code. For example, bumpers game lack detailed documentation,which made adding new functionality to the game quite hard and i thus didnt even bother with it. But nevertheless, it was low cost, probably.\n\n3) If developers add lots of  functionality without thinking about the user experience, it would reduce the overall usability of the software,since users cant even understand how the software works. For example, using hashcat was quite difficult for me at first,since i wasnt used to working with command line,but i hear it is quite powerful.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292033,
      "meta": {},
      "text": "\tIt makes sense that most design goals conflict with a low-priced product, one of them being the goal of designing a faul-tolerant product. For example, a fault-tolerant chat app requires a lot of user testing, plus time from the development team, which eventually translates to a higher product cost.\n\tHowever there are other design goals trade-offs that don't have anything to do with cost, like the usual conflict between user-friendliness and robustness. This conflict can be noticed in almost any system, because eventually it can be hard to include user-friendliness while keeping the system robust. A good example is a tabletop game's instruction manual. It is designed to be as user-friendly as possible, that means that it has to be easy to understand and short, but a robust instruction manual should also cover all edge-cases and explain everything in detail.\n\tAnd a last example is the trade-off of backwards compatibility and modifiability. It can be harder to modify a software that is backwards-compatible because any new modification must also be backwards-compatible and fit the old constraints. An example would be any system that works on an old framework. This means that the integration of newer libraries have to be compatible with the old framework, which can be hard if no support is provided.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1292197,
      "meta": {},
      "text": "Trade-offs:\n1. Functionality vs. usability:\nThe company wants the software contain as more functions as possible, in order to attract more user. But in contract, under the concept of usability, the users expect it as user friendly, simple and intuitive.\n\n2. Cost vs. reusability:\nDevelopers want to reduce the cost of software development, but low-cost, simple code is often difficult to reuse. Because code generality and good architecture are neglected.\n\n3. Cost vs. robustness\nRobust systems need to be highly fault tolerant and cope with extreme situations. This can lead to higher cost of solutions.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344064,
      "meta": {},
      "text": "Efficiency vs portability:\nThe client wants a product to run on windows, linux and macos whilst still having a great performance. As the client doesnt want to spend that much time and money for the product, he will have to prioritize efficiency or portability over the other. \nE.g. videogames being released on multiple platforms in cost of poor performance.\n\nCost vs. robustnes:\nDepending on the needs of the client a product has to be made more cost intensive or less robust.\nE.g. a bank needs a programm to correctly handle multiple transactions at once. As they cannot allow themselfs to make any mistake or correct failures by the programm, that programm has to be as robust as possible, and therefore very expensive.\n\nRapid developement vs functionality\nA client wants to release and sell a product as fast as possible, whilst having a complete software with a lot of funcitonality.\nE.g. a video game being released to early with limited features and therefore less enjoiment in playing.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344119,
      "meta": {},
      "text": "One of the 8 issues with when it comes to system design are design goal issues. They are influenced by the nonfunctional requirements. Issues occur because the goals often conflict with each other.\n\nFor example, one type of a design goal is the robustness of a system which is wanted by the end user. This conflicts with the goal of the client to minimize the cost of the system because the developers need more time to implement code that handles wrong input from the user and when the developers work longer they cost more money. \n\nAnother typical design goal trade-off is rapid development which is again wanted by the client and functionality which is wanted by the end user because the quicker you have to develop a system the less time you have to implement certain functions which negatively impacts the functionality of the system. \n\nA third conflict stems from the trade-off between backward compatibility which is one of the goals of the client and readability which is sought after by the developers. If the developers have to make the new software compatible with older systems or the current version of an external system (e.g. databases) to enable interoperability and integrate the systems with each other, this results in less readability of the code because it cannot be implemented from scratch but has to be adapted to older versions of code that already exist, hence the simplicity in logic or the structure of the code are compromised.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344610,
      "meta": {},
      "text": "Rapid development vs. Functionality: Rapid development means that the product should be ready by the deadline. Since little time is spent on testing, the product is not bug-free or not quite complete. The result is less functionality than expected. On the other hand, if the focus is on functionality, the product may not be ready on time due to the amount of time spent, even though it is bug-free. So these goals are in conflict with each other.\n\nEfficiency vs. Portability: The product should respond quickly to user input, otherwise the customer will not be satisfied with the product. On the other hand, not all end users use the same operating system, so a product should be portable, i.e., it should be usable on all systems. However, these goals are in conflict with each other. For example, if different servers for different systems have conflicting requirements, the time it takes for the product to process input is reduced, making the product less efficient, while being non-portable makes it more efficient.\n\nCost vs. Robustness: Robustness means that the product should be able to tolerate errors from the client and server. This involves additional coding and testing that costs the client money. Either the product costs more so that the necessary tests are performed, or the product is not able to tolerate incorrect input because wrong inputs  are not covered enough by cheap tests and therefore the system is not reliable. So product being cheaper makes it less reliable and product being expensive makes it more reliable.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344650,
      "meta": {},
      "text": "1.\tFunctionality vs. usability: \nIt should be great if a software provides multiple functions. However, the learnability, efficiency, memorability and usability would decrease if there are too many functions. For example, if the bumpers game has so many functions that each key on the keyboard represents a single action, players will spend plenty of time memorizing all the actions, which will make them lose interest in continuing to play the game because of the bad experience and poor usability of the game. \n2.\tRapid development vs. functionality: \nIt usually takes long to develop functional software because coding and rounds of modifications are necessary to ensure that every feature works correctly, which makes rapid development unrealistic. \nFor example, when I try to accomplish an assignment of Artemis, writing the code would take me a long time, and modifying the code to make it work might take days. If I didn't want to spend that much time on this assignment, I would have to submit a less than satisfactory assignment. \n3.\tCost vs. reusability\nThe advantages of using reusable code are obvious. But for developers, it would cause more cost to write reusable code, because it takes more time coding and testing to adapt the same code to different environments. For example, we have already done two maze-solving homework, if I want to reuse the first code in the second maze, I need to think about how to adapt the same code to two different frameworks, which might take even longer than writing a new one. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1350209,
      "meta": {},
      "text": "Cost vs. Robustness: Having 10 servers instead of 2 means less trouble in case one needs to be updated or crashes, however, it also means 5 times the cost. Having redundancies is very important but can be very expensive, which is why a suitable compromise needs to be determined.\n\nFunctionality vs. Usability: An MVV ticket machine with all available tickets on the front page would never require more than one click to select the correct ticket, however, the cluttering of the screen would cause people not familiar with the system to take minutes to read through all options. On the other hand, a pilots cockpit is not very intuitive, however critical situations cannot require clicking through 5 navigation menus to get to the right option. Therefore, a practical user interface needs to be developed specifically for the corresponding software and circumstances.\n\nRapid development vs. functionality: Having only one week to develop Bumpers may ensure implementing basic functionality, but causes clean code, writing a good documentation and extensive testing to be neglected. As a result, bugs may occur and are hard to fix because no-one can read the code - thus, limiting functionality. Therefore, development should not be rushed too much to ensure a higher quality.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1379626,
      "meta": {},
      "text": "One typical design trade-off is the trade-off between functionality and usability. The more functions you add to your system the complicater it gets. And this is a loss in usability.\n\nAnother typical trade-off is between Cost and robustness. The robuster your hardware should be the more you have to pay for such good hardware.\n\nA third typical trade-off is between Cost and reusability. If you would like to have a system you can reuse you have to care more about how clean your system is. For that you have to spend more time on working on your product and this leeds to more Costs. ",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1401307,
      "meta": {},
      "text": "Cost vs. Reusability: To minimize the cost, we tend to reduce the use of resources and time to make it, so that it's easier and more cost-friendly. as a consequence that will lead to one use only. On the contrary, to increase the usability of the system, we need more intense planning and consideration, and it will understandably lead to a higher cost.\nEx.: A Fashion company wants to make a low-cost, easy-to-code website, but at the same time, it's difficult for them to use the website for every other season because fashion is at least split into four seasons.\n\nCost vs. Robustness: Similar to the explanation before, to cut the cost of making it, we tend to make it briskly, without enormous testing to find the shortfall of the system, and that will lead to a decrease in the robustness. Vice versa with intense testing, to find the shortcomings of the system, testing with different devices, etc will need more time and resources, and that will clearly higher the cost.\nEx.: A developer makes a simple, low-cost game but the game is gonna crash if the device temperatures go up to 45 degrees celsius.\n\nRapid developments vs Functionality: A simple system with less functionality, tend to be useful in a specific type of environment. If we want to increase the use of the system in different environments/ devices, we should increase the functionality, so that it's up to date with the software of that environment. Naturally with more functionality, will be supporting more rapid developments.\nEx.: By developing an advanced game within a week doesn't lead to a lot of special features compared to developing it over one month\n\n(Examples taken for my last year's own answer)\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1401494,
      "meta": {},
      "text": "\"Cost vs. robustness\":\nKosten und Robusheit stehen deswegen oefters im Widerspruch, da das Testen von Software mit einem hohen finanziellen Aufwand verbunden ist und man beim Testen abstriche machen kann ohne, dass der Kunde dies unmittelbar merkt.  Denn wenn der Hersteller einer Software zur Auslieferung versprochene Funktionen nicht implementiert hat merkt der Kunde dies sofort. Wenn der Hersteller allerdings Software ausliefert die jegliche geforderte Funktionalitaet bietet ist der Kunde erstmal zufrieden. Dass die Software z.B. manchmal abstuerzt wird er erst speater bemerken, wenn die Software eine Weile benutzt hat.\n\n\"Efficiency vs. portability\"\nEffizienz und Portabilitaet schliessen sich oftmals zumindest zu einem gewissen Grad aus. Denn Software die portabel sein soll muss meist etwas abstrakter implementiert sein und ist dadurch weiter von der Hardware \"entfernt\". Mit dieser Abstraktion geht fast immer auch ein erhoeter Verwaltungsaufwand einher welcher das Programm langsamer und dadurch weniger effizient macht. Ein Beispiel fuer eine portable Sprache ist Java.\nDadurch , dass Javacode nicht direkt in Machinencode compiliert wird ist Java generell langsamer als C++.\nEntscheidet man sich nun aufgrund der Portabilitaet Java fuer die implementierung zu benutzen verliert man schon wegen dieser Entscheidung sehr viel an Effizienz als wenn man es alternativ in C++ implementiert haette.\n\n\n\" Rapid development vs. functionality\"\nSchnelle Entwicklung und Funktionalitaet stehen oft im Konflikt, da es viel Zeit benoetigt um unfangreiche Funktionalitaet zu implementieren.  Wenn zum Beispiel die Anforderung besteht , dass eine Anwendung innerhalb von 2 Wochen fertig implementiert ist, ist es nicht Sinnvoll viel Funktionalitaet halbfertig zu implementieren. Was man stattdessen macht ,ist wenig Funktionalitaet fertig zu implementieren\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1403671,
      "meta": {},
      "text": "1. Functionality vs. Usability\nMehr und komplexere Funktionalität  -> Benutzerfreundlichkeit des Programms wird reduziert. Das liegt daran, dass dann im User-Interface mehr Bedienelemente angezeigt werden müssen. Dadurch fällt es dem Benutzer schwerer, sich zurechtzufinden und sich mit allen Möglichkeiten des Programms vertraut zu machen.\nBeispiel: Videobearbeitungs-Programme iMovie (sehr benutzerfreundlich) und Permiere Pro (viel Funktionalität). In iMovies finden sich Anfänger schnell zurecht, da alle wichtigen Buttons sind groß und einfach zu finden sind und alle Aktionen mit wenigen Mausklicks erledigt werden können. Premiere-Pro ist dagegen weniger benutzerfreundlich. Die Einarbeitungszeit ist größer und selbst simple Aktionen (wie z. B. das Video exportieren) haben deutlich mehr Einstellungsmöglichkeiten -> mehr Funktionalität, weniger benutzerfreundlich\n\n2. Efficiency/Performance vs. Portability\nWenn ein Programm möglichst effizient laufen soll, dann muss dieses an die Stärken von Hardware und Betriebssystem angepasst werden. Folge: Das Programm ist nicht mehr mit jeder Hardware / jedem Betriebssystem kompatibel.\nBeispiel: Viele Computer-Spiele verwenden, um möglichst effizient zu laufen, DirectX, was aber nur auf Windows verfügbar ist. Dadurch laufen die Spiele zwar effizient, funktionieren aber auf anderen Betriebssystemen (z. B. MacOS) nicht. Sie sind also weniger portabel. (Umgekehrt: wenig optimierte, in Hochsprachen geschriebene Spiele sind langsamer, dafür auf allen Betriebssystemen verfügbar.)\n\n3. Backward Compatibility vs. Readability\nIn Programmen, die weit rückwärts kompatibel sein müssen, gibt es z. B. Redundanzen, die notwendig sind, damit früher entwickelte Programme/Features, die noch Gebrauch von alten Funktionen machen, weiterhin funktionieren. Das verschlechtert aber die Lesbarkeit des Codes.\nBeispiel: In der Java-Standardbibliothek ist beispielsweise der Konstruktor von \"Date\" als depreciated (veraltet) markiert, da er durch eine Funktion in der Klasse \"Calendar\" ersetzt wurde. Dennoch ist dieser Konstruktor für die Rückwärtskompatibilität noch vorhanden -> schlechtere Lesbarkeit",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1421419,
      "meta": {},
      "text": "Ein design goal trad-off den man eine gehen muss, ist der zwischen efficiency und portability. Man kann ein weiten Weg kommen bei der Effizienz, wenn man die passenden Algorithmen auswählt. Um aber wirklich alles raus zu hohlen muss man den Code auf die Hardware anpassen auf der er letztendlich mal läuft. Einer der Bottlenecks der Performance von Code sind die Speicherzugriffe. Wenn man hier das Hardware Prefetching des jeweiligen Prozessors gut ausnutzt können starke Perfomance Verbesserungen erreicht werden. Allerdings unterscheiden sich die Algorithmen von Hersteller zu Hersteller daher wird der Code weniger Portable.\n\nEin weiterer trade off den man abwägen muss ist die Entwicklungszeit und die Funktionalitäten die man bekommt. Softwareentwicklung wird oft in so genannten Sprints organisiert in denen immer neue Features programmiert werden. Beispielsweise wurde bei dem Spiel Bumpers im ersten Sprint das Spiel überhaupt erstmal zum laufen gebracht. Im Zweiten wurden dann neue Features wie das Auswählen der Kollisionsart hinzugefügt. Es gilt generell je mehr Zeit man für ein Projekt bekommt desto mehr Funktionalitäten kann man einbauen.\n\nFunktionalität steht auch noch mit einem anderen Zeil im Konflikt und zwar der Benutzerfreundlichkeit. Es ist einfacher und übersichtlicher für den User, wenn er weniger Auswahlmöglichkeiten hat. Bei einem Programm wie Photoshop kann man das sehr gut sehen hier hat der User sehr viele Funktionalitäten geboten auf kosten der usability für einen nicht professionellen Nutzer.\n ",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1451539,
      "meta": {},
      "text": "Rapid development vs functionality \nThis is something I experienced in my own. I attended the BPG Class and we decided to develop an app. Meaning we had to present the app in the final presentation we had limited time. We got through the development stages quite quick. But comming to an end we realized that there were many fratures that were not easy to find in the App because we did not think the design properly throu. So in the end we had a running app, that was quite hard to use, because the user could not find all the features.\n\nCost vs reusability\nMost of the time something gets better when you put more efford into something. More time means more labour costs. A good example are the flood of \"trash\" Minigames you can find in the AppStore. They are very simple and are made to be cheap. Thats why there is a very high Output of Apps but these apps only run for a very short time till noone wants to play the game anymore because of bad functionality.\n\nFunctionality vs usability \nA very good example for that are calculators. A normal calculator we use in Uni has a tone of different features you only can find, if you know exactly where to look. I often find my selfe using the internet to solve a graph eventhou my calculator could do that for me. But there are soo many functions that I dont know where to start looking ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1651333,
      "meta": {},
      "text": "Cost vs. Robustness: Client wants the software project to be as low cost as possible, but a cheap project is usally not very robust.\nFunctionality vs. usability/user-friendliness/ease of learning: a software can be functional and met all the functional requirements, but it can be very user- unfriendly, it may have a very complicated user interface, and is hard to learn/use. \nCost vs. reusability: The cost of one time project,which is not very reusible, is low because of  it's easy to code and have low test costs. But moving from classes with one-to one multiplicity to many-to many multiplicity, there are more coding and testing required, which results in more costs",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291251,
      "meta": {},
      "text": "1. Functionality vs. usability\nIf a software has too many functions, the software becomes complicated. For example, there are many pages to switch between. As we known, that is not friendly and easy for the user to learn a such software.  Then with high and complex Function, The usability of the software will be somewhat reduced.\n\n2. Cost vs. robustness\nWhen a developer develops a software, they want the software to last as long as possible, and not always have failures and bugs during the subsequent user's use. Then a solid and secure system requires a large number of sophisticated algorithms to support, then the development process will naturally increase the cost of spending. Not only the cost of the code itself, but also, for example, the need to hire more developers.\n\n3. Effiency vs. portability\nHigh efficiency often leads to non-portable code, while choosing portability can make the software less performant. Because high efficiency means that it will take advantage of hardware features that are unique to some platforms, such as unique cache memory for some systems. Portability means that it can run on different hardware platforms, so it is contradictory.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1300580,
      "meta": {},
      "text": "Design goal trade-offs arise when a design goal, that is to be implemented, negatively affects the implementation of a separate design goal. \n\nAn example of a design goal trade-off, would be the implementation of a hyper performant program, which has a low runtime and a low amount of memory required to run the program. The design goal trade-off, arises when you consider this in conjunction with the design goal of low-power requirements for the program to run and the requirement of the program not taxing the cpu hyper-aggresively, which would contribute to long-term cpu degradation.\n\nAnother example of a design goal trade-off, would be the concurrency between the two design goals: Costs vs Product-Performance. Elaborating on this, when a client as always, tries to reduce his costs, one way he may do this is by hiring a smaller team of developers. While this is more cost-efficient, it has the trade-off that the final implementation of the project, will be less qualitative, and by extension generally less performant as a product, as the team, has less human-capital at its disposal, both qualitatively and quantitatively, to implement the final system design. \n\nA final example of a design goal trade-off, would be the concurrency between runtime-performance (how fast the programm executes), and memory-management (the amount of memory a programm uses). If a client wants a programm to run at a very high speed, whilst implementing a particular algorithm, he will have to take into account that as he optimizes runtime-efficiency, he won't be able to optimize, the amount of memory the program requires at the same rate. In fact, as one optimizes code for a lower amount of cpu cycles, it leads to inherently larger memory requirements.\n\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1313929,
      "meta": {},
      "text": "A very common design goal trade-off is between functionality and usability, where these two seem to, for the most part, be opposite sides of a spectrum whereas your program increases in functionality it becomes harder and harder to use, or if u increase the usability of your program it becomes less and less usable. This can be seen for example in Linux vs Windows. Where Windows is more usable than Linux but Linux has higher functionality and this is only to name one of many like IOS vs Android. Another such example of trade-offs is backward compatibility and security. For example, you have something like Windows 10 which has backward compatibility with all previous windows versions and as such can run programs that were made for previous versions but this makes the current Windows more vulnerable to security breaches as it has some reliance on old and outdated software, but if you have an os which is very secure it most likely is not backward-compatible with previous versions or very compatible with other things at all. Lastly, we have rapid development vs functionality, which is very common in software engineering where the less time you take to develop software the less functional it is but if it is very functional it mos likely to a long time to develop.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1334054,
      "meta": {},
      "text": "typical design goal trade-off:\n1. functionality vs. usability \nSometimes, if we want to let a software application have functions and options as many as possible, it may be challenging to use because there may be too much redundancy left that users may not need. Then it achieved the functionality of this design goal but lose its usability users have difficulty learning how to use all these functions. For example, the OA office software is a have different functions to manage the documents and materials, but it is also very complicated, so the users may choose another software like WPS. \n\n2. cost vs. robustness:\nFor software, we want to achieve the robustness of an application which means if users enter a wrong input but the application can still maintain its function. However, it is sometimes costly for the system to check and handle the error input. For example, if a game company want to save money and reduce cost, they don't set up the maintenance department to check the robustness of the game, then the game may have some bugs with the wrong input or can not run with other devices. \n\n3. efficiency vs. portability \nIn order to make software application development more efficient, the developers may use the tools and work in their familiar environment. But the applications can not maybe be implemented on all platforms or systems. An example could be Windows and macOS. For MacOs the developer uses the Xcode which is not in Windows, so this kind of implementation of the application achieves efficiency but not portability. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344423,
      "meta": {},
      "text": "Functionality vs. usability:\nIn Bumpers möchte man vielleicht mehrere Arten von Kollisionen und Autos implementieren. Werden es aber zu viele, die dann auch noch alle Gleichzeitig das Spiel geschehen beeinflussen, kann es für den Benutzer unübersichtlich werden. Daher ist es sehr wichtig nur so viele Funktionen wie nötig zu implementieren und es dabei für den Benutzer so einfach wie möglich zu halten. \n\nCost vs. Robustness:\nMöchte man seine Anwendung Robuster gegen beispielsweise falsche Benutzereingaben machen, erfordert das zusätzlichen Code und damit zusätzliche Arbeit und Kosten. Verzichtet man Andererseits komplett auf diese Vorsichtsmaßnahmen kann das die ganze Anwendung Funktionsunfähig machen. In Bumpers wäre so eine Eingabe, gegen die man die Anwendung schützen sollte beispielsweise das Steuern des Autos aus dem Bildschirm heraus. Hier wird eine zusätzliche Methode benötigt, die anhand Position des Autos bestimmt, ob es auf eine Wand trifft und falls das der Fall sein sollte, das Auto stoppt oder es von der Wand abprallen lässt.\n\nEfficiency vs. Portability: \nEine Anwendung möglichst Effizient zu gestalten erfordert normalerweise Spezialisierung auf eine ganz bestimmte Umgebung aus Hardware und Betriebssystem. Um also eine Anwendung auf mit möglichst vielen Umgebungen Kompatibel zu machen, erfordert eine allgemein gehaltene Implementierung, die wiederum die Effizienz verringert. Bumpers sollte beispielsweise mit Java implementiert werden, wodurch eine Ausführung auf Smartphones erstmal nicht möglich wäre.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1405525,
      "meta": {},
      "text": "(1) Cost vs. reusability: In a recent project, we developed a web crawler to consolidate and enrich data automatically to augment the research team's effectiveness through quickly available data. While some workflows initially seemed to be similar, and reusability seemed to be a no brainer, it turned out to be way more different than initially expected. Thus, the standard interface for the research team became significantly more complex, and the project became significantly more expensive to ensure the reusability of the different elements, especially also for future workflows.\n\n(2) Functionality vs. usability: In the very same web crawler project, we initially tried to identify all workflows. However, in co-development with the IT team, we prioritized usability and reduced the functionality to enable efficient training of new research team members within an intuitive front-end.\n\n(3) Rapid development vs. functionality: Again, in the web crawler project, we initially had a very tight schedule from the management. However, in this timeframe, we could only develop around 1/3 of the initially defined functions with the given resources, as a version 1 that is rapidly developed was more important than full functionality from the beginning.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1436305,
      "meta": {},
      "text": "Memory Usage vs Performance\nWhen interacting with the system certain method calls happen repeatedly. If the results of the method calls are cached the method doesn't have to be called again and the expecetd runtime of the process can be reduced to linear growth levels if results are often repeated. Howerver this performance comes at a steep cost. The memory used to save the results is unavailable to other processes. When running fast paced games a Hashmap with predetermined values can greatly increase the performance of the game, since the calculations don't have to be repeated. However the Ram usage is increased.\n\nCost vs Minimum Number of Errors\nWith a higher production time the developers can test their programs more often for more problems. But the inverse is true as well if the time to test  is reduced, less errors can be found and fixed. And Cost directly correlates  with the time given to the developers, since a companie has to be cost efficient. For Example the crunch time for game development can ruin a game's launch. Sometimes the developers deliver a game, which has barely been tested, to cut down on costs, but the at the cost of errors in game.\n\nFunctionality vs Usability\nThe goal of Functionality whishes for a system that has multiple functionalities, and can therefore satisfy the demand of the end user. However with more possible methods, the UI gets cluttered and less usable. For Example Microsoft Word has increased its functionalities over dozens of years, and has now reached a point, where certain functionalities are only findable per search bar.  ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1498829,
      "meta": {},
      "text": "1.Functionality vs. usability: um so mehr mein system kann umso benutzerunfreundlicher wird \n2.Cost vs. robustness: Umso niedriger die kosten umso instabiler mein system \n3.  Efficiency vs. portability: umso effizienter ein system umso komplexer demnach wird automatisch die Portierbarkeit schwieriger\n",
      "score": 8.3,
      "language": "GERMAN"
    },
    {
      "id": 1645451,
      "meta": {},
      "text": "Ein Client möchte, dass die Software möglichst günstig ist, aber Benutzer möchte die Software auch leicht benutzen können. Also muss man einen Kompromiss finden, wie man die Software günstig entwickeln kann sie aber dennoch noch gut zu bedienen ist. Wenn ein Software Projekt nicht so viel Geld zur Verfügung hat können evtl. auch nicht so viele Programmierer daran arbeiten, aber wenige alleine können einfach nicht so viel Leisten wie viele, die dann kleinere Bereiche lösen müssen und mehr Zeit in bestimmte Probleme investieren können.\n\nDer Endnutzer möchte aber auch dass die Software nicht nur gut zu benutzen ist, sondern auch gut funktioniert. Zum Beispiel könnte ein Flugsimulator Programm super aussehen und die GUIs leicht zu bedienen sein, aber das bringt nicht so viel, wenn sich das Flugzeug nicht Realitätstreu verhält. Bei dieser Software müsste im Vordergrund stehen, dass die Software richtig funktioniert und das Aussehen wäre erstmal zweitrangig.\n\nMan muss sich auch Gedanken darüber machen, ob man die Software sehr performant sein soll, oder ob man sie lieber überall mit hinnehmen will. Bei einem Computerspiel zum Beispiel wäre es wichtiger, dass es effizient läuft, damit viele Leute es Spielen können und nicht ganz so wichtig, dass man es von seinem USB-Sick aus starten kann und es überall mit hinnehemn kann.",
      "score": 58.3,
      "language": "GERMAN"
    },
    {
      "id": 1291760,
      "meta": {},
      "text": "Two design goals that can contradict each other are the goal of a fast run time and readable code. Software developers want to write code that is as readable as possible. On the other hand the client and the end users want to have a fast runtime because of better usability and better chances competitively. These goals could stand in each others way, for Example readable code can contain recursive functions but these are often slower than regular functions. The goal of faster runtime can also be conflicted with the clients wish of the lowest coast possible for the software. To optimize runtime of a software can be time consuming and could need experts in this branch. This can cost more expenses than planned because of more time spent or more developer involved. ",
      "score": 25,
      "language": null
    },
    {
      "id": 1296888,
      "meta": {},
      "text": "Cost vs. Robustness - to make sure that the system functions correctly in a tough environment (e.g. when invalid inputs were given) the developers have to work more thoroughly and put in more effort which leads to high costs in development.\n\nPortability vs. Localization - programs that are localized deeply in a specific software cannot be easily used in software other than the one in which it was created. For example, some programs developed for iOS cannot be easily transferred to Android.\n\nRapid development vs. efficiency - When clients want to have a product in a very short time the developers have to rush and create a system as soon as possible, this can lead to an inefficient system that has a lot of bugs and problems.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1300524,
      "meta": {},
      "text": "Functionality vs. usability:\n\nThe client always wants a software product that is easy to use while still meeting all the requirements which are requested from the developer. This is a typical trade-off problem. As the functionality increases, the usabilty proportionally decreases inevitably. For example, a client requests a new functionality to their cost accounting tool. It should be possible to create and store documents within the existing software. This increases the functionality of the software. Problem here is that the users need to be trained for the new module, otherwise the productivity and the original expected benefits of the new functionality go down because the users easily get confused by all the new buttons and tabs within the software they have been working for years.\n\nCost vs. robustness:\n\nRobust software means that the developers have enough time and resources to test every aspect and consider every possible edge case of the software. This is not of the client's interest. He wants to use the software as soon as possible. And the software should cost as less as possible. When a company introduces a new accounting system and the developers have been stressed to deliver it as fast as possible, the potential damage of an unexpected behaviour could be devastating to the company and could end up in more additional costs to fix the issue afterwards compared to letting the developers test it enough while work was still in progress.\n\nEfficiency vs. portability\n\nIt is really hard to develop software which offers the same performance on many different platforms. The functionality has to be reduced to the least common denominator. Possible advantages of certain platforms have to be ignored to maintain the portability. Adobe Software products are a good example for this. They run on Windows and MacOS devices. But when Apple first released the M1 architecture, the software had to be adapted to the new architecture to benefit from the increased performance compared to other systems. Now Adobe always has to support and update two completely different versions of the same software (e.g. Premiere)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1301690,
      "meta": {},
      "text": "1: Efficiency vs. portability: A software can either be efficient by being optimized for a certain piece of hardware (e.g. using special functions of a CPU, hardware acceleration for encoding/decoding video), or portable so that it runs on many different kinds of hardware (which offer different types of optimizations, but those can’t be used because they are different from each other). For example a game can either use special ray tracing features of a certain graphics card, or use a framework that doesn’t offer this but runs on other hardware too. \n\n2: Rapid development vs. functionality: Developing functionality takes time, so the more functionality a software needs to have, the longer it will take to create. If developers have a time limit, they can only do so much in that time. Example: if bumpers needs to be completed in the next 6 hours, it will not be possible to add realistic physics and animations in addition to the other requirements.\n\n3: Backward compatibility vs. readability: If software needs to be backwards compatible, there often needs to be more (complex) code for that, which makes the code harder to read. For example, in 2020 SwiftUI introduced a “Label” view that combines an image and text which auto-adapts to different Layouts or different. To recreate this functionality in an app that needs to be compatible with the previous version, a lot of extra layout code with nested if statements and modifiers will need to be added. (I did this in one of my apps :))",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1315314,
      "meta": {},
      "text": "1. Low cost vs Minimum amount of errors\nOne common design goal trade-off is Low cost vs Minimum amount of errors.\nOn one hand, the Client wants costs to be low on the other hand, the Developers want to have as few errors as possible. However, having both is impossible, because a low budget limits the Developers' income and therefore performance. You simply can't expect a highly reliable and functional program for under 100 euros, because the price-performance ratio is very similar across the market.\n\n2. Rapid development vs Robustness\nAnother common design goal trade-off is Rapid development vs Robustness. Of course, the Client wants the product to be ready as soon as possible, however, this contradicts Robustness. Robustness is created by extensive testing of edge cases and bug fixes. This is very time-consuming. Therefore, you need to tolerate deterioration in one aspect to improve the other. If you develop an app in under a week, the End-user will run into an issue at some point.\n\n3. Flexibility vs Reusability\nAlso, another common design goal trade-off is Flexibility vs Reusability. The Developers want to reuse parts of their existing code because it means less work and more time. This goal conflicts with Flexibility because the existing code might not fit the Client's goals. The code could be written for high performance on certain architectures and not for general purposes the Client most likely intended. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1315701,
      "meta": {},
      "text": "rapid development vs. functionality\nCorona Warn App is a recent example of a rapid development, which (at first at least) lacked functionality. It was only meant to help track contacts and meetingpoints with strangers, but missed for example the ability to save ones corona pass. Later that was added. This shows, that id you develop a system rapidly, it will lack functionality for atleast some time, as you dont have time to programm the extra things that would be nice to have-\n\n\nCost vs. robustness\nCosts increase with time spend on the project. That means the longer you work on a project the more it costs. So in software engineering, if you want a cheap solution, the probability that the programmer spends only as much time as it is needed for the system to work. But if you want the system to not only work with the basic requirements but also be robust/spend time on testing for example with wrong inputs, the programmer has to but additional time into the system.\n\n\nBackward compatibility vs. readability\nHaving a programm that works on multiple systems, can be compared to using a language. For example, the people now have truble reading the German from the 1700s. Which shows, that if a system has a high backwards compatibility, it has to be understood from many \"readers\" which do speak kind of the same but still different language. This leads to a less easy readability.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344345,
      "meta": {},
      "text": "1. Functionality vs. Usability\nThe more functionalities a system is required to have, the easier it is for it to get less usable and the more there is for the user to get used to, so the usability decreases. Getting rid of some of the essential functionalities in the name of making the system usable is also not a solution. \n--> Designing the functionalities of an app all at once on the same screen would not be optimized usability and would cause confusion for the user. A way of making the app more usable could be by categorizing the functionalities into smaller groups as much as possible and displaying each of them step by step. In this way the app would not have to make sacrifices of its functionalities while being usable. \n\n2. Rapid development vs. Functionality:\nRapid development focuses on developing the system as fast as possible by focusing more on the implementing and less on the planning. They contradict, because the more functionality a system should have, the more planning it requires and takes time to implement. \n-->A meal app that generates random meals from the collection would be faster to implement compered to one that takes the users preferences and patterns into account because it would require planning for certain algorithms. \n\n3. Cost vs. Robustness:\nFor robustness, the software should be able to handle unexpected scenarios, which means it would require more code and make it more expensive.\n--> A client demands the software to be cheap, so the software is not fully robust and it keeps crashing. \n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1391864,
      "meta": {},
      "text": "1. Rapid development vs. functionality:\nThis trade-off focuses on the question whether you want your system ready in short time have good functionality. For this trad-off. game developement is a great example. Every good game is delivered frequently with updates to keep the game fresh and enternaining. But as a company or game developer you typically have to device, if you want to deliver updates very frequently, but with little new content, maybe once or twice a month or release a big update once a year.\n\n2. Functionality vs usability: \nAs a developer you can decide whether you want your code to be written very specific with many funtions for many usecases and thus have very good functionality or to write the code more general but every line of code is used often (usability). \n\n3. Cost vs reusability:\nSimilar to functionality vs usability is the trade off of cost and reusability. It is very easy to write boilerplate spaghetti code with many copy and pasted elements. But this isn't reusable nor readable. But writing good code, where is easy to add new functionality and reuse the code often, the developer needs time. ",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1394544,
      "meta": {},
      "text": "One typical trade-off in software engineering is functionality vs. usability. For example, complex text editors such as vim feature a very wide range of functionalities but are very difficult to use especially for unexperienced users. On the other hand, simple text editors such as notepad are very easy and intuitive to use but they don't offer such a wide range of specific functionalities. So, it is hard to find a solution that is both functional and usable enough.\nAnother typical trade-off is efficiency vs. portability. For example, Java is well-known for being a highly portable programming language. This is achieved by converting the source code into java byte code. However, when Java was being developed, many people feared that this would severly affect its efficiency because of the extra step that was added in in the process. In fact, C (e.g)  requires a system-specific implementation but is normally more efficient than Java. Hence, you can't have both - you have to chose between high efficiency (specific to a certain system) and high portability (slower, but runs easily on different systems).\nAdditionally, a trade-off that is frequently encountered is good documentation vs. rapid development. Writing a documentation takes time and will inevitably slow down the development process. For example, NASA still use their Fortran code from the 70s. However, it was coded with little time (space race) and thus poorly documented. For this reason, they have big difficulties understanding the code and changing it in the present day (they even ran a competition to improve it!).",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1405092,
      "meta": {},
      "text": "Ein Trade-off ist beispielsweise zwischen Funktionalität und einer Minimierung der Anzahl an Fehlern. \nJe größer ein System in sich ist, desto größer ist die Wahrscheinlichkeit, dass Teile des Systems nicht mehr korrekt miteinander arbeiten. \n\nEin weiterer Trade-off ist zwischen einer schnellen Entwicklung und geringen Entwicklungskosten. In der Regel wächst mit Entwicklungsgeschwindigkeit auch Entwicklungskosten. Da zum schnelleren Umsetzten ein größeres Team an Entwicklern benötigt wird. \n\nLetzlich gibt es auch einen Trade-off zwischen schneller Entwicklung und der Fehlertoleranz. Durch eine verkürzte Entwicklungszeit kann ein System nicht genau getestet werden, wodurch nicht Edge Cases oder Falsche Eingaben im System richtig behandelt werden. \n",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1475318,
      "meta": {},
      "text": "Design trade-offs are a ordinary occurnce in software development as design goals are influencing and often counteracting eachother. Software developmers need to understand those dependencies and corrctly balance them out. \n\nHere are three concrete examples to clarify this in particular.\n\nOne of those examples would be the trade-off between the cost of a project and its implemented functionality. A set of functionalities need a minimum budget to be able to realize those, as it would for example not be possible to build a whole streaming platform with a budget of building a simple alarmclock. As we can see, in order to achieve both design goals, both need to be dosed correctly and balanced with each other.\n\nAnother good example would be the balance between the goal to develop the project rapidly and the goal to maintain the readability and the organization of the code. When trying to develop a project more quickly, it usually has a effect on the quality of the code, such as mentioned the readability, the stucture and the organization of the code, or even the functionality of the code. On the other hand, needless constrains for just the sake of clean code can inhibit and slow down the development speed. \n\nThe last example is the trade-off between the functionality and the usability of a system. As the functionality and also the complexity of the system increases, it is getting more difficult to represent those on a simple and intuitive User Interface. This balance also goes the other way around. \n\nAs we can see, almost every decision on a design goal comes with a trade-off or a consequence. Developers need to be aware of these impacts and scale the importance of the goals accordingly.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1660801,
      "meta": {},
      "text": "When we use Tiktok, everyone can be a client or end-user, we can choose what we want, it is flexible, and developers help us to find our requirements. It is also easy of learning, with many choices, but do not need to learn, we can choose the simple one, that we want. We can also be clients, developers allow us.",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1291459,
      "meta": {},
      "text": "1. Functionality and usablity. Ever tried switching to Linxu after Windows? Better yet iOS? Providing your software with vast and feature-rich environments is compelling, especially if you yourself are an advanced user. But many people aren't and it's a trade-off you have to consider, since it increases the learning curve for an average or newbie user.\n\n2. Efficiency vs. portability. Having a set hardware your enables the developer to create software in lower languages such as C, making it very efficient. However, if the product has to be supported on many devices of different kinds it will have to make its logic more general and higher, which would decreace the efficiency. For example we can compare old game engines which were made use of specific hardware features and quirks, to the modern and more general Unreal and Unity, which run on just about anything but require intricate knowledge to keep processes efficient enough for different machines.\n\n3.Backward compatibility vs. readability. If your software is running since the 60s, for example like some bank services or the CoD engine, you may not want to touch it so that it doesn't fall apart. And building it from ground up may be just too expensive. All of this makes the code less readable and harder to refactor. There's a reason why there are still some job openings for COBOL... Imagine all the legacy code...",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292538,
      "meta": {},
      "text": "1. Functionality vs. Usability. \nOn the one hand, you might want software that implements many functions. On the other hand, you still want your software not to be overwhelmed with functions, buttons, etc. to stay usable enough. \nFor example, a simple calculator that you would use in middle school is enough to perform basic math operations. There is no real learning curve, you just have to read the buttons and use them. In high school, using a scientific calculator, you would quickly be overwhelmed with all the functions it proposes, and mainly, how to access them, especially since they are often hidden in complicated sub-menus. The number of button presses to access a function might jump from 1 or 2 on the simple calculator to 5 or 6 on the scientific calculator. You might also not know where to find the specific function, so the number of button presses while searching for it would even further go up.\n\n2. Rapid development vs. functionality.\nDesigning the implementation of a function, actually implementing it, testing it, and merging it with the rest of the app, is a process that takes a while if you want to do it well and not have bugs. You also don't want a new function to take ages to go into production, to keep an advantage over your competitors. For example, the game Cyberpunk was released way too early. It was full of bugs, ran horribly on most systems, and was just an unpleasant experience. The management didn't give the devs enough time to implement the functions well, testing was neglected, and therefore, a lot of the functions were unfinished. As an opposite example, take major IOS updates for Apple devices. They don't get released often, but when they are, they add a lot of new functions that are very refined and bug-free.\n\n3. Cost vs. functionality.\nKeeping the cost low is very often one of the main design goals in a project. The problem with that is that you might hire a cheap workforce, that doesn't have the required skills. The software might end-up buggy, unfinished, and unpleasant to use. Another point is that keeping the costs low doesn't give you the required budget to implement a lot of functionality, if you want to have it bug-free and finished.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1293631,
      "meta": {},
      "text": "The first design tradeoff that one might face in software engineering is the fact that we often have to face off usability and functionality. For example is the software iMovie more than able to be used by someone who has never touched a video editing tool, however it is not as powerful & useful to a professional like Adobe Premier Pro & vice versa.\nAnother tradeoff would be cost and robustness. Depending on the budget of each software project, one still has to implement all the required functionalities, but one also has to keep in mind that there might be not enough budget left to fix bugs & problems that might occur in the first iterations & can therefore affect the quality of the end product. One example of this issue are the development of MVP's or Prototypes for Software Start-Ups.\nThe last tradeoff one might encounter is the rapid development & functionality aspect.\nWhen someone wants to bring a new software product to the market quickly, they are most of the time willing to sacrifice functional features that might take more development time.\nOne example of that would be the MVP development again. Startups focus only on necessary basic functions in order to get a product out in the market fast enough to collect feedback. ",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1296584,
      "meta": {},
      "text": "Usability vs  Functionality:  Usability is the ease of use of an interface. Functionality is the set of operations that a interface supports. A large number of functions in one user interface can be an annoyance that makes interfaces more difficult to learn and use. For example, obscure functions that few people use may be buried in a hierarchy of menus\nCost vs Reusability:  In software design, reusable code requires more work than normal code. Trying to always make everything reusable may lead to over-engineering. Developers should make it reusable if doing so will make its interface and / or its implementation easier to understand.\nPortability vs Efficiency:  favoring efficiency results in nonportable code, while selecting portability often results in software whose performance is unsatisfactory. Efficient software doesn't waste CPU cycles. It takes full advantage of the underlying hardware, often completely disregarding portability issues. But in today's computing environments, software that runs on only one architecture sharply limits its potential marketability.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1302582,
      "meta": {},
      "text": "efficiency vs. portability\nWenn ein Programm auf vielen verschiedenen Endgeräten laufen können soll, dann kann man bei der Implementierung nicht darauf bauen, dass diese alle gleich leistungsfähig sind oder das selbe Betriebssystem benutzen weshalb nicht alle Möglichkeiten, die die verschiedenen Hardware Geräte bieten, genutzt werden können, sodass nicht die maximale Effizienz erziehlt werden kann. \nBeispielsweise Final Fantasy VII REMAKE war für über ein Jahr Playstation (4 & später auch 5) exklusiv und wurde grundsätzlich für die Playstation entwickelt, optimiert und läuft dort flüssig, der PC Port des Spiels lief zumindest zu Release, trotz der Tatsache das gute PCs im Normalfall leistungsfähiger sind nicht so gut wie erhofft laut Kritiken.\n\nfunctionality vs. usability\nWenn eine Software sehr viele verschiedene Funktionen bietet kann der Endnutzer dadurch überfordert werden bzw die Nutzbarkeit für diesen deutlich erschwert sein, da er nicht damit vertraut ist & die Nutzung dadurch unintuitiv sein wird. \nBeispielsweise Xenoblade Chronicles 2s Kampfsystem besitzt sehr viele verschiedene Arten von kombinierbaren Kombo Möglichkeiten, die dem Spieler innerhalb weniger Spielstunden \"erklärt\" werden, deren Tutorials nicht im Nachhinein angeschaut werden können & den Spieler somit am Anfang einfach überwältigen und so die Benutzbarkeit dieser Features für den Spieler durch ihre Vielzahl erschwert werden.\n\ncost vs. robustness\nUm eine wirklich robuste, sichere Software, die möglichst allen potentiellen Gefahren standhält entwickeln zu können, müssen natürlich auch die finanziellen Resourcen entsprechend hoch angesetzt sein alleine schon um die Software ausgiebig auf viele verschiedene Arten von Gefahren testen zu können.\nFür die Datenbank einer Bank sollte die Wahl hierbei wohl eher auf eine möglichst sichere, gut getestete Software fallen, da eine Billigsoftware sicher nicht jede potentielle Sicherheitslücke beachten kann.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1311088,
      "meta": {},
      "text": "In software development each choice comes with a sacrifice.\nOne of the typical design trade-offs is portability vs. efficiency. While from a developers point of view high efficiency is desirable since no hardware resources are wasted, from an end user perspective portability is seen as more advantageous. There is no market for a maps application if it can run efficient on PC's but dosen't run at all on mobile devices. \nRapid development vs. functionality is another trade-off in software engineeering. While high functionality is always preferable there is not always enough time given by the client to implement the software as such. Also it is more costly to take your time to make your software functionable to the fullest. As a developer you always want to make your system as fuctionable as possible but sometimes the time frame is a hard constraint by the customer you are working for. This \nThere os also the sacrifice between cost and robustness of a system. A high robustness makes sure that the system is safe from attacks by third parties with malitious inentions. But high robustness is costly to implement since it has to be maintained and always adjusted to the highest and newest standarts. This is obviously very time and thus cost intensive. But a system that can be easily hacked is nothing less than useless.\n ",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1318060,
      "meta": {},
      "text": "Functionality vs. Usability: We want our system to include a big variety of functions. However, this means that the GUI could get overloaded with too many functions to overlook for the end-user. E.g. we want to include different power-ups and additional functionalities for our game. However, the more a player can do, the more it gets difficult to include it in the game in a assessable way. For example 'League of Legends' is much harder to learn than any 'Call of Duty' game. Noobs could lose the incentive to play.\n\nRapid development vs. functionality: The more functionalities we want to include the more time we need to implement them properly. E.g. including an online mode in bumpers would mean additional working hours we need to put into development even if we already implemented the base game.\n\nEfficiency vs. portability: Making an App that is universally compatible will hinder us from optimizing it for different operating systems or hardware. E.g. Apple predicted a 2 year transition time after introducing their new M1 chip because developers will need to optimize their apps for the new apple silicon even though the apps were already compatible but not efficient enough on the new M1 chip.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1383824,
      "meta": {},
      "text": "1. Functionality vs. usability \nWhen developing e.g. a text editor, you have to decide what functionality the text editor is supposed to offer. When offering a lot of functionality for the user the text editor becomes complex and more difficult for a new user to use. The other option would be to include less functionality, so that a new user easily can understand the very limited amount of features.\n\n2. Rapid development vs. functionality \nWhen developing a game, the game needs to be finished at a certain point (e.g. in order to be released before games from competitors). So time is limited. But when rapid development is required, it often results in a product with less functionality since there is no time left to develop that functionality. \n\n3. Cost vs. robustness \nAchieving robustness could lead to the need for more expencive materials. For instance, if a system has to be heat resistent, the materials that can handle temperatures up to 100 Celcius are more expencive than materials who aren't able to function properly at those high temperatures. \n\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1421818,
      "meta": {},
      "text": "Trade-off should be compromises and not sacrifices \n\nFunctionality vs. Performance - For example an autonomous client service system of an\n                                                  unversity should be able to handle requests from a client in \n                                                  their entirety, provide answers, links and additional \n                                                  information, store questions and respective answers for cache \n                                                  hashing/storing and provide the client with opportunity to rate \n                                                  the system, but alse handle those requests as quick as possible \n                                                  (in the matter of a second).\n\nLearnability vs. Security - For example an Online-Banking-App of the SSKM requires (when \n                                    available on the user device) biometrical login (fingerprint/ FaceId), \n                                    username and password and a two-factor identification via another app \n                                    on the user's mobile device. When an app is unavailable, the \n                                    authentication happens via Call/SMS code. The whole security process is \n                                    necessary for the safety of the user's personal data and finances, but \n                                    slows the login process, which makes the software less user-friendly and \n                                    more difficult to use.\n\nSatisfaction / user experience  vs. Usability - For example a restaurant reservation software \n                                                                       (similar to the one described in the problem \n                                                                       statement for the project) should present an  \n                                                                       attractive and interesting for the user's eye \n                                                                       Graphical User Interface. It should probably \n                                                                       include pictures of the restaurant, some dishes, \n                                                                       the information can be written in a beautiful \n                                                                       cursive fond, etc. On the other hand, though, it \n                                                                       has to be as simple as possible, as the target \n                                                                       group of users is extremely diverse and any \n                                                                       excessive complications in the interface could \n                                                                       make it inefficient and dissatisfactory. A software \n                                                                       should always be Usable before Beautiful.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1485749,
      "meta": {},
      "text": "I have developed a small app for public transport in Italy and will explain some trade-offs I faced using that app.\n\n1. Cost vs. Time and robustness\nIn order to implement a back-end you can search endlessly for the best provider that offers the least downtime and the best price, and of course you should have at least two instances up and running so that you avoid a single point of failure. But then how does the app know where to direct its requests to? You'd need a \"DNS\" for those requests that always knows what server is the least busy. But that in turn creates a SPF so you'd need to double down again. All of this drives cost and time up, hence you need to find just the sweet spot.\n\n2. Rapid development - Functionality\nI had lots and lots of ideads in mind, and still do, that could improve the functionality and finally the UE, but each feature comes with its development time. I decided to select the few features I considered the most vital ones, implement those, release the app and then slowly implement the other, less important, features by over the air updates. This strategy gives you a first prototype within a comparably low time span but it comes with the tradeoff of it not having all the planned features.\n\n3. Readability vs. portability\nUsing Flutter the efficiency does not suffer to much by running the same code on IOS and Android. But the readability of the sourcecode does. There is no separation of the two sources, everything is mixed together. This can lead to readability-issues.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292719,
      "meta": {},
      "text": "\tCost vs. Robustness: To make software more robust must be spent more resources as count of developers on it. That might be too expensive. For example it might expensive to test new programs additional, but it helps to avoid bugs.\n\tFunctionality vs.  Usability: If software would have more functions, it would be to use them. If I add to bumpers more methods and classes, it would be harder to understand the game.\n\tRapid development vs. functionality: if developers spend more time developing software, it is possible to implement more functions. If developers want to finish faster than it was planned,  they would make additional functions as simple as possible or would refuse them. If I want to add in Bumpers more creative methods and classes, then it would cost me more time.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1301486,
      "meta": {},
      "text": "Software Engineering cannot be described as having fixed goals when working on a project. There are no fixed guidelines set from the beginning, these can all change throughout the course of the project. Furthermore there are design trade offs, working within the set guidelines. These modular tradeoffs can be thought of as a slider between, e.g. Functionality vs. Usability or Cost vs. Robustness. This means that for a developer, one cannot maximize to the point of where a program needs the most expensive and best hardware to run said program. To add to the optimization of a program, there is also usually a set time frame, in which one must produce the best working end result. This can be a bit of struggle, as there is also a feeling that something can be tweaked to perfection. \n\nOur first point of discussion is, game graphics, under Cost vs. Reusability. The graphics of a game can be made spectacular, but these require the top of the line GPUs. To amend, these GPUs are more expensive, so not as available to the public which in turn might decrease sales aswell. The goal however is to have high sales. So the developer finds a middle ground, with scalability options for the graphic settings. \n\nAnother example is Functionality vs. Usability, given a menu with all the meals clumped and listed onto one page. This menu might be functional in the sense that it contains all items, but it isn't easy to read. \n\nOur last example is reusable code. Should one spend more time writing code that is reusable and might be used in the long run or one that is easier for the given task ahead.\n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1313309,
      "meta": {},
      "text": "Functionality vs. Usability:\n\nHighly sophisticated programs that allow the user to create something from scratch, like the music software ableton, which requires a lot of prior knowledge and is not very intuitive, are really functional as they provide tools for a creation process. This comes at a cost for usability: You usually can not use a program like that without proper training or instructions\n\nRapid Development vs. Functionality\n\nSometimes, a software is needed really urgently and the development is therefore put under a lot of pressure. This was for example the case for the Luca-App, designed to track virus spreading related to the Covid-19 pandemic. If I recall correctly, development was rushed and did not function upon release as intended, therefore a trade-off between development speed and functionality was perceivable.\n\nCost vs. Robustness\n\nSoftware development is an expensive process, as lots of working hours are put into testing and making the software fault-proof. This can be avoided, if the software is not holistically tested before release and therefore not robust. Although this lowers development cost, the robustness of the product suffers and can lower user satisfaction if there are lots of bugs, or even dangerous data leaks or loopholes",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1334944,
      "meta": {},
      "text": "Fuctionality and cost :  If many features or complex functions are required , it will cost more time and money .   To give a simple example about  bumpers game, if there are more functions (requirements )  required , i will spend more time on that project (more cost) . If this were a company project, perhaps this project have to pay  more for the employees .\n\nFunctionality and usability :  If more function are required , it could be more difficult for the user to learn how to use the lots of functions. For example the unity engine . People can do a lot of things with it ,but it also cost a lot of time to learn  its functions . \n  \nRobustness and cost : To make the program more robust , the developers have to test the system carefully to avoid errors and bugs . So it will cost more time and money to  this . Also i have to test a lot of times after finnishing the implementation of the bumpers game to check if there are anything wrong  during runtime of the game .",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1338065,
      "meta": {},
      "text": "1. Functionality vs. usability\nWenn wir ein Auto entwerfen, das nur das Gaspedal und die Bremse hat, dann kann der Benutzer sehr schnell lernen, wie man das Auto fährt. Die Nutzbarkeit ist sehr hoch. Aber es gibt keine Möglichkeit, ein solches Auto an viele Situationen anzupassen. Ein solches Auto könnte an mehr Situationen angepasst werden, wenn die Menschen während der Fahrt mehr Teile des Fahrzeugs steuern müssten. Aber die Nutzbarkeit nimmt ab. Das aktuelle Auto ist das Ergebnis dieses Kompromisses. Es gibt auch einen Kompromiss zwischen Funktionalität und Nutzbarkeit, da die Menschen zwischen einem manuellen und einem automatischen Auto wählen können.\n2. Rapid development vs. functionality\nWenn in der Internetbranche eine neue Funktion auftaucht, kann das Unternehmen, das sie als erstes entwickelt, einen Vorsprung gegenüber der Konkurrenz haben. Dies ist der Zeitpunkt, an dem eine rasche Entwicklung notwendig wird. Grundlegende Funktionen können zunächst entwickelt und dann auf den Markt gebracht werden. Sobald der Markt aufgeteilt ist, ist es an der Zeit, sich auf die Entwicklung von Funktionen zu konzentrieren.\n3. Cost vs. reusability\nWenn die Wiederverwendbarkeit des Codes verbessert werden soll, muss sich der Entwickler mehr Gedanken machen. Dies erfordert mehr Zeit. Dies führt zu höheren Kosten. Der Kompromiss besteht darin, dass wir die Wiederverwendbarkeit des Codes so weit wie möglich mit einem begrenzten Budget erhöhen. Das senkt die Kosten für die spätere Entwicklung. Die durchschnittlichen Kosten können kontrolliert werden.\n",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1344332,
      "meta": {},
      "text": "Efficiency vs. Portability:\n\tWhen writing code for an embedded system, for example a microwave, the trade off is often made in favor of efficiency, due to the limited system resources available. In this case code should be written with hardware specific instructions to use the resources as efficiently as possible. The resulting code will most likely have low portability, a characteristic which is not very important when creating specific functionality for specific hardware.\n\nRapid developement vs. Functionality:\n\tImplementing a lot of functionaliy in a system takes a lot of developement time, time which is often not available if a system needs to be developed rapidly. One can see this trade-off being made with every project developement which has to adhere to a strict deadline. A good concrete example would be the series of FIFA  Video Games developed by Electronic Arts. Due to each entry in the series having a developement time of approximately 2 hours, little to no new funtionality is added.\n\nFunctionality vs. Usability:\n\tFor an application to be sufficiently usable, it often needs to be somewhat simplified, as to not overwhelm the user the with functionality he may or may not be looking for. A great example for this trade off being made in favor of functionality is the Website campus.tum.de. Although every functionality required of such an online management website for an university is theoretically there, no user will ever be able to verify that, because he is overwhelmed by functionalities he does not need and can't find the ones he does. \n\n\n\t",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344670,
      "meta": {},
      "text": "1. Functionality vs Usability\n\tAs more functionalities are added to the system, it is naturally going to become more difficult to use. An example of this is when there is a rework in a tool/feature that was already present in the program. It might be difficult to easily access the feature.\n\n2. Cost vs Robustness\n\tWhen a system needs to be more robust, the cost of the system naturally goes up as well. A good example of this could be a server-based system where in order for the system to be more robust it needs multiple reliable servers which increases the cost.\n\n3. Efficiency vs Performance\n\tIf the system is efficient it means that it needs to cut back on performance. A good example of this could be in games. If a game is performance-intensive it will be less efficient than games that require less performance to run.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1346616,
      "meta": {},
      "text": "Low Cost conflicts with the quality of the product: Low Cost means less time to develop and also less testing to verify the code -> likely that bugs are overlooked and functionality needs to be patched afterwards. (Cyberpunk 2077 :) )\n\nBackwards Compability conflicts with Readability: The documentation grows with every version, because whenever a change is made instead of just updating the entry, the legacy version of the functionality needs to be kept in the manual. So after some time there will be multiple docs for the same instruction and the documentation will grow even bigger over time\n\nModifiability conflicts with performance: Modifiabilty requires a system to have low coupling and low cohesion so that the modules can be exchanged easily. However that means from the performance side you create bottlenecks because you need to access recources indirectly via the subsystem, because often there is no direct connection between resources of different subsystems (low coupling). For every operation a certain overhead is required which affects the performance.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1347045,
      "meta": {},
      "text": "1. Cost vs. maintainability\nThis design goal trade-off might be prevalent, especially during the development phase of a system. Of course, the engineers should write their code in such a way that it is easily understandable and that small changes shouldn't lead to a crash of the system. Nonetheless, these requirements cost more time, as developer have to plan and think about such problems and how to solve them. More time will in turn cost more money.\n\n2. Rapid development vs. smallest possible number of errors\nThis is a rather clear, but yet important trade-off to consider. Assuming that a project doesn't have an infinite amount of resources, rapid development will most often lead to a larger amount of errors in the program. This is due to the fact that most errors are identified in the testing phase, after all of the code has been written. Since a project which is being development with a strong time constraint will most likely need almost all time for the code to be written, there will be less time left for testing.\n\n3. Modifiability vs. fault tolerance\nIn the usual case, a high modifiability of a system means that developers can quickly make changes. The problem here is that a high modifiability usually leaves a system which is untested and can lead to more faults in the final system. In order to avoid more faults, the system should have a level of \"unmodifiability\" in order to avoid to many changes, which lead to faults.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1350425,
      "meta": {},
      "text": "Beim Design von Softwaresystemen spielt selbstverständlich die Funktionalität eine große Rolle. Gleichzeitig sollte die Anwendung für den Benutzer einfach zu verwenden sein. Beispielsweise ist es bei einem Computerspiel wünschenswert, dass es möglichst real ist und eine Spielfigur viele verschiedene Aktionen ausführen kann. Allerdings ist das Spiel für einen Anwender komplizierter zu steuern und die Intuitivität kann leicht verloren gehen.\n\nZwei weitere wichtige Faktoren für den Kunden eines Softwaresystems sind die Kosten und die Robustheit. Für ein widerstandsfähiges System muss mehr Aufwand bei der Entwicklung betrieben werden. Beispielsweise muss die Planung exakter sein und es müssen mehr Tests durchgeführt werden. Damit steigen aber selbstverständlich die Kosten. Es müssen also Kompromisse gemacht werden. \n\nAuch die Portabilität und die Effizienz stehen bei der Entwicklung eines Systems im Widerspruch zueinander. So ist es bei der Entwicklung von Apps für mobile Endgeräte wünschenswert, dass sie auf allen Plattformen verfügbar sind. Verwendet man eine plattformunabhängige Sprache geht jedoch die Effizienz verloren. Nicht alle Funktionalitäten für alle Plattformen können mit bestmöglicher Performance umgesetzt werden. Daher muss oft doch auf plattformspezifische Sprachen zurückgegriffen werden.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1427377,
      "meta": {},
      "text": "1. The most common place where design goal tradeoff happens are when budget and code quality collide. Code that is easy to maintain and easy to read takes a bit more to write. Also systems which are better structured take more time to be designed. Because of the common phrase \"time is money\" , managers usually have to make a compromise between the 2 aspects mentioned above. That is why firms sometimes compromise in the favor of more implemented features in less time, that are poorly written and hard to maintain.\n2. It often happens that software is still used on older machines, which means that the new updates of the software need to be backwards compatible. This makes the code really hard to read and maintain, because all the new features often need to have different branches that deal with problems from the different computers. To big operation system firms that have different views on this topic are Windows (whose software is 100% backwards compatible) and Apple (whose newest version of software is not supported for  devices that are ~10y old) . \n3. Often software engineers have to make a trade-off between the efficiency and portability of the code. This might come down to what programming language is used for the project. For example, java is compiled in java byte code which is portable across different machines. On the other end of the spectrum are languages like C, that after compilation are not portable on machines. The lack of portability in C helps the efficiency of the program, which runs significantly faster than the java code",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1473237,
      "meta": {},
      "text": "Rapid development vs. functionality -> If the program requires the use of functional programming and functionality often, then it will make rapid development tough because if an already existing function needs to be developed and changed to adapt to the developments. If the program relies heavily on the use of functions, it will make rapid development tough since output of a function or how it works would affect also other functions.\n\nCost vs. Robustness -> If we want our project to be more robust, its cost will have increase accordingly. For example, for a project that requires data storage in cloud before processing, the best practice that is likely to increase robustness would be storing data as it is in the original format and file extension at one place in the first step and then transforming data into parquet format which is a great practice for the majority of data operations. However, by doing so, there will be the cost of storage for these two different storage units in cloud, whereas, the data will be more robust to changes and operations to be applied on it.\n\nFunctionality vs. usability -> How usable the program is going to depend on the number of functions it contains. For example, if the program contains too many different functionalities, the user will need to get used to how to use these functions and it will kill the simplicity. However, a higher level of functionality will allow user to do more operations given the structure of the program.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1513202,
      "meta": {},
      "text": "Functionality vs. usability: LaTeX and Microsoft Word are two famous word processing softwares. Microsoft Word is easy to learn and easy to use. Almost everyone can write a document in Word by short learning about its tools. On the other hand, LaTeX is not easy to learn. Even programmers that are professional users of softwares need to invest time to learn how to use LaTeX. In the comparison between Word and LaTeX, we can say Word is the more usable software. But LaTeX provides many functionalities that Word cannot offer. Word suffers from scientific features like citation utility. In LaTeX, citations are handled by BibTeX. LaTeX also provides useful packages for writing formulas that are easy to write in the source file by the writer, which will be hidden from the reader after compiling.\n\nCost vs. reusability: Artemis is a website for interactive Learning. This website is used for multiple courses in the university. If it was only the EIST course that uses Artemis, there was not necessary to implement the current home page which allows the students to choose between their current courses, and users that use Artemis were limited to the number of students in the EIST course. But in fact, Artemis is being used for multiple courses in multiple semesters. Therefore more features should be developed and more requirements should be considered. It increases the cost of the software.\n\n\nCost vs. robustness: robustness is necessary for an online banking website, for example when a user wants to transfer 211.35 euros, the whole number part is 211 and the decimal part is 35 which comes after the decimal point. But in Germany, the user should put a comma instead of a decimal point. If an online banking website does not consider these wrong inputs, the user transfers 21135 euros instead of 211.35 euros. So the online banking website should be robust. This needs a lot of testing that increases the cost of software development. \n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292639,
      "meta": {},
      "text": "1. Cost vs. Reusability : This one of the few typical goal trade offs because when we want to increase the reusability, it's usually not possible without increasing the cost. If we decrease the cost, the reusability will also decrease. Also it goes that the lower the reusability is, the easier it is to implement.\nAn example of this would be spending large amounts of time coding something that works and can be reusable in future projects. This leads to it being more profitable and reusable but on the other side it would take a lot more time and money for the code to be produced.\n\n2. Efficiency vs. portability : When we want to make something portable, it is very likely it will fall off in efficiency. A good example would be a computer and a laptop. For the same price, a portable laptop will be way weaker than a computer. \n\n3. Functionality vs. usability : The more functions something has, the less usable it is. Something is usable when it's very simple, but when something is simple, it is usually not very functional. For example when creating a website, we want to find the perfect balance between these two because if the website has too many functions, the user will get confused and it will make it hard for them to use the website. On the other hand, if the website is way too simple, it's not going to be very functional meaning the user will not have the ability to do possibly  needed actions on the website. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292793,
      "meta": {},
      "text": "Maintainability - Runtime efficiency:\nDifferent algorithms can become really complicated. Often they are too complicated that a human can fully understand them (AI models). But even in our every development life we often have to choose between readability and therefor Maintainability. Every algorithm can be optimized but they often get really difficult to understand. For example a simple and readable program in C++ is nearly impossible to understand once the compile optimize die runtime efficiency for this exact program. \n\nPortability - Runtime Efficiency:\nA user wants a light program environment which does not use to much space. But on the other side they wand a fast and efficient application as well. This is a typical trad off in modern software development, because application speed and efficiency often can be increased with higher storage space usage. A good example for this is a look up table. This method can increase the speed of an application enormous but uses a lot of storage space at the same time.\n\nGood Documentation and quality of code - Low cost and rapid development:\nA good Documentation of an application can be very helpful. If a user instantly understands your service, it`s a huge  pro for your code. In addition if your application is very robust and fault tolerance it increases the user experience. But these kind of quality of life features come with a trade of. They are really difficult to develop. It take a lot of time to make sure your product has high quality standards. This increases the product cost and slows down the development process. A example for this is if a app updates its user interface 3 times in a short time period to increase usability it is really expensive to finance this.    ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292811,
      "meta": {},
      "text": "Cost vs robustness:\nRobustness describes the degree to which a system is able to maintain its function(s) while in certain environments or while the environment changes and also, its ability to function in the presence of wrong inputs from users. This means that development must take a lot more possible scenarios into consideration and implement preventive measurements so the system can deal with the aforementioned risks. In addition, quality control and testing will need to become more elaborate as well. As a result, the entire development process will become costly and time consuming compared to a similar system that doesn't have robustness as a design goal.\n\nFunctionality: vs usability:\nTypically, usability can be perceived as how fast a user is able to learn and use a software and how easy it is to remember it. Alternatively, a system with high usability could be very intuitive to use, for example due to very few buttons or very recognizable icons.\nOn the contrary, a lot of functionality could mean that a system becomes more difficult to use as there is more for the user to learn. And there could be a lot more buttons or shortcuts for those added functions. An example would be editing software.\n\nEfficiency vs portability:\nSoftware that is written for very specific hardware can be optimized in a way that it's efficient in terms of memory usage or how fast it finishes a task.\nMaking software more portable could come at a (slight) loss of this characteristic. For example to make sure that it runs CPUs with less registers, less cache or that do not support multi threading.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1302544,
      "meta": {},
      "text": "Kosten vs. Robustheit\nMit einer sorgfältige Programmierung gehen viele Kosten einher, weil das Testen vom Code zum Finden von Bugs und Fehlern meist viel Zeit von erfahrenen Programmierern braucht. Diese müssen entsprechend ihrer Fähigkeiten und ihrem Zeitaufwand bezahlt werden. Durch Einsparung der Kosten in der Entwicklung sinkt damit die Robustheit und steigt die Gefahr des Datenverlustes oder Hackerangriffen.\nComputerteile sind zurzeit, aufgrund von Transportengpässen, teuer, weswegen häufiger billige Bestandteile benutzt werden. Dadurch funktioniert Hard- und Software nicht so wie notwendig, wodurch ein Schaden entstehen kann.\n\nSchnelle Entwicklung vs. Funktionalität\nDurch die Globalisierung immer schneller werdende Entwicklung von  Technologien ist es überlebenswichtig sich schnell anpassen und weiterentwickeln zu können. Doch eine durchdachte und vollständige Programmierung von Funktionen erfordert Zeit, die oft nicht vorhanden ist. In Handyspielbranche findet man viele Spiele mit ähnlichen Funktionen, die einfach zu programmieren sind. Zum Beispiel Merge, Match3 oder Idle Tycoon Spiele, die immer auf dem Selben System basieren, aber mit anderer Grafik sind. Hier ist selten etwas innovatives oder Abwechslungsreiches zu finden, dafür gibt es sehr viele mit unterschiedlichsten Themen in kurzer Zeit.\n\nFunktionalität vs. Benutzbarkeit\nJe mehr Funktionalitäten es gibt desto unübersichtlicher wird dabei die Benutzeroberfläche, denn man braucht Zugang zu allen Funktionen, die ein Programm hat, heißt diese müssen irgendwo aufgelistet oder angeordnet sein. Zudem suchen unterschiedliche Menschen die Funktionalität an unterschiedlichen Stellen, weswegen es schwer wird alle leicht und intuitiv auffindbar für eine breite Masse an Menschen zu machen. Z.B. bei Fortnite mit dem Bau-Modus gibt es viele Optionen zum Bauen, Emotes zu zeigen, Shortcuts hinzuzufügen und insgesamt viele Tasten und Menüs die man verwenden kann oder auch muss. Weswegen vorallem Spieleinsteiger häufig Probleme haben sich zurecht zu finden.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1375676,
      "meta": {},
      "text": "1) Functionality vs. usability\n\tBy having a vast variety of functionalities, although more useful, it will be more complicated for the customers to use.  Lets take a website as an example. A website is deemed usable when the user can easily find the information they are searching for and easily learn how to use new features. However, if the website is too simple, it wont provide many options and different functions that the user may need. For this reason, finding a balance between functionality and usability is of great importance, so that both can be satisfied. \n2) Efficiency vs. portability\n\tIn case we want to make a product portable, it is almost impossible to not lose any efficiency along the way. An example for this would be wireless headphones. They do not include wire and do not need to be inserted into a device which makes their portability a lot better. However, wired headphones can be used without the need to wait and recharge them. Not only that, but the sound and quality of music is noticeably worse while using wireless headphones due to bluetooth connection they use. \n3) Cost vs. reusability\n\t Usually, increasing reusability means increasing the cost of the product on the market as well, as more expensive materials are used/more time is spent building them. Moreover, the lower the reusability, the easier it is to make it. An example would be spending more time on writing a code, which can later be used in another project. It would take a lot more time and money, but would be reusable and profitable in the future. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1415986,
      "meta": {},
      "text": "1. Functionality vs. usability\nThere is a trade-off between functionality and usability because a system with a lot of visible functions has high functionality and low usability whereas a system with few visible functions has high usability and low functionality. If a ticket machine displays all types of tickets available for purchase, this makes it very difficult and overwhelming to choose the correct ticket. A more practical solution would be to navigate to the tickets through menus, where the user can select their age range and travel distance accordingly. This will bury the functions but improve the usability of the system. \n\n2. Efficiency vs. portability\nThe ability to run a piece of software on different systems has a negative impact on its performance because programmers cannot take full advantage of specific functionality or features that a specific hardware might offer. Prioritizing efficiency during development leads to a product that is limited to a specific environment and not portable, which is not attractive for users. E.g. if you are developing a calculator app but this app only works on a specific version of a specific operating system, no user will be able to use the app after an update.\n\n3. Rapid development vs. functionality\nThe less time to develop a software, the fewer functions can be implemented. E.g. if you are once again developing a calculator app but have a very limited time frame, you will only be able to offer a few simple operations (addition, multiplication, ...). If the focus was on functionality rather than getting the product out as fast as possible, the app could have a lot more and complex functions (square roots, exponents, logarithm, ...). But as a trade-off the development will take much longer.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1416267,
      "meta": {},
      "text": "The more efficient a program is the less portable it is. To build an efficient program it has\nto be optimized for one specific system and because of that it is less portable. This leads also \nto less portability. First of all it can not be ensured that the program runs as efficient on other systems \nthan the one it was built for and secondly optimized programs are mostly only built for one system. \nFor example when building simulations that will run on a specific super computer the simulation is \nmost likely only optimized for that one system. \n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1429338,
      "meta": {},
      "text": "A common trade-off: Rapid development vs. functionality. Software design is hard. Every step of the creation process must be thought out, planned and implemented before it is ready. Therefore, if you want to get something up and running quickly, sacrifices in the feature set will have to be made.  For example, games which are pre-released while still in development. The designers can either push through versions really often with small iterative changes, or they can bring slower paced but feature-packed updates.\n\nSomething else to take into account is the balance between efficiency and portability. Indeed, efficient code must almost always be targeted to one specific ISA/Programming paradigm/Instruction set extension. However, this vastly reduces portability, as specific code must generally be rewritten before it can be run elsewhere. A perfect illustration of this is Python vs C. Python is interpreted and therefore orders of magnitude slower than most equivalent C code. However, anywhere where you have a Python Interpreter, your code just works. Whereas with C, you're going to be recompiling a lot.\n\nYet another frequent trade-off: security vs performance. Code that doesn't do any input filtering or sanitizing, integrity verifications... will run much faster and be easier to write. But leaving security holes is dangerous. This is often a problem in Webdev: user input with is then returned to the site can contain nefarious code. Every UI can be a vector of attack, and must be carefully handled to avoid XSS injections (for example.) ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1490162,
      "meta": {},
      "text": "Design goal tradeoffs are conflicts you have to consider when developing a system with multiple parties (Client, Developers, Users) involved. The parties might have different design goals in mind and often you cannot satisfy all of them. For example, when trying to develop a system with backwards compatibility (by the clients request) you might run into issues with maintainability on the developer side and performance issues on the user side.\nTrying to develop an app that runs on all windows systems reaching as far back as windowsxp, you might have to bundle large amounts of boilerplate code into the app to replace missing functionality on older systems, which increases complexity and lowers speed. Other examples might include functionality conflicting with Usability, as an overloaded menu could be difficult to navigate or understand. Another example of common design goal trade offs is cost and robustness. Without sufficient funds you cannot make a system that is stable until the end of time.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1637967,
      "meta": {},
      "text": "As a design goal any nonfunctional requirement will be included, however they can be in conflict with each other.\n\n1)Functionality of the system design is important but having numerous functions can decrease the usability, since the system gets complicated for the user.For instance, how easy it is to use a car, which is the usability of the vehicle, is related to the operations of the systems, which is the functionality. Having sets of operations that are more than needed or that are optional can create difficulties. \n\n2)Taking into account that the system design should cost an appropriate amount of money, it could be the case that the robustness will be ignored.The robust optimization should be proposed for the performance but the production cost should not be overlooked.\n\n3)The cost and the reusability are also related, since there are a lot advantages of reusing software systems. Some of them can be named as reducing costs, minimizing test and debugging efforts and also quality and performance improvement. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1647423,
      "meta": {},
      "text": "One of the most common trade offs in design goals is cost vs. robustness. The more robust an app for example should be the more money and time has to be put into the development. For example to prevent a programme from crashing when the user inserts a wrong input requires time in development, as these edge cases have to be identified and treated accordingly, which will ultimately lead to higher costs.\n\nFunctionality vs. usability is another common trade off in design goals, as very functional programs often aren't very user friendly and hence lack usability. A great example for this in my opinion can be seen when comparing windows to Mac (more specifically total commander to finder). While total commander might offer a lot more functionalities and features when working with it than finder, finder in my opinion is a lot more user friendly and easy to use. \n\nA third and final trade off can be seen when comparing rapid development vs. good documentation. The client of a software program will probably prefer a rather rapid development in order to quickly make use of the product. The end user and developer on the other hand will rather prefer a good documentation, as this will lead to a better usability as an end user and better maintainability as a developer.  ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1661105,
      "meta": {},
      "text": "One example of a design trade of would be the implementiation of a feature without optimizing its performance in order to make it behave a specific, more costly in terms of computing power, way. Another example is that sometimes design goes over functionality, while this is generellay a bad idea for functional software it is often seen even in big and popular software (e.g. Instagram) that software engineers decide to put form over function which degrades usability in order to maintain aesthetics. Lastly what is probably the most common trade off that you see in any kind of software, for example often in videogames, is that quality is lost over a shorter development time. When you can develop something faster it means more money more \tquick and sometimes that is favourable even if it is a bit short sighted.",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1291911,
      "meta": {},
      "text": "Funktionalität vs. Benutzerfreundlichkeit: \nUmso mehr Funktionen einer Software hinzugefügt werden, desto tendenziell weniger benutzerfreundlich wird diese. Natürlich wünscht man sich mit einer Anwendung so viele Bereiche wie möglich abdecken zu können, aber am Ende erschlagen den Nutzer so viele verschiedene Funktionalitäten. Ein gutes Beispiel dafür ist der Windows Taschenrechner auf dem PC, bei dem man für mehr Funktionen selbst in den Wissenschaftlichen Rechner umschalten muss, weil der Großteil der Zielgruppe/Nutzer diese Zusatzfunktionen wie Modulo oder x-te Wurzel von z nicht benötigt. \n\nKosten vs. Wiederverwendbarkeit: \nUm eine Software wiederverwendbar für andere Einsatzfelder zu machen, muss ein Developer Abstraktion anwenden. Damit die Elemente so flexibel wie möglich miteinander kommunizieren, erfordert es einiges an Planung im Voraus. Dieser zeitliche Mehraufwand schlägt sich natürlich in den Kosten eines Projekts nieder. Beispielsweise könnte ein Developer-Team ein IT-Ticketsystem nur für ein bestimmtes Unternehmen in der Pflege entwickeln oder den Anwendungsfall offen lassen und unabhängig diese Funktionalität implementieren. \n\nRapid development vs. Fehlertoleranz: \nDa bei rapid development auf Prototypen, schnelles Feedback und Minimum Viable Products gesetzt wird, rücken langwierige Test- und Entwicklungszyklen in den Hintergrund. Durch verringertes Testing kann es dazu kommen, dass Fehlerlücken im Code entstehen, die die Fehlertoleranz durch den Nutzer einer Software verringern. Zum Beispiel kann beim Bumpers Game durch schnelle Entwicklungszyklen der Collision Type vom Nutzer durch Texteingabe zwischen eins und zwei gewechselt werden, weil dieser sich das gewünscht hat. Dabei wurde aber vergessen, den Umgang mit fehlerhaften Eingaben wie bspw. die Eingabe einer null oder ein versehentlicher String zu behandeln. \n\n",
      "score": 58.3,
      "language": "GERMAN"
    },
    {
      "id": 1292600,
      "meta": {},
      "text": "The classical trade of is functionality vs usability. Vim is incredibly powerful lightweight text-editor, once it is learned. However with the sheer amount of arcane keyboard shortcuts it may not be suitable for everyone, and is only used by those wiling to overcome the very steep initial hurdles, making it somewhat unsuitable for widespread use.\n\nYou may also need to trade portability for efficiency. If you want your program to run on both an arduino and an esp32 microcontroller, you will need to use an external hall-sensor library (aswell as an actual sensor for the arduino) instead of using the included, esp32-specific hallRead() method.\n\nAnother trade of is reusability vs development cost/time. Writing a webscraper for one specific website will take significantly less time that writing that same webscraper for a lot of websites of the same time. However, if many websites of the same type need to be scraped it may be more efficient to write a generalized tool once instead of writing a specialized one every time.\n\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292829,
      "meta": {},
      "text": "There are often trade-offs with design goals where achieving one goal is only possible at the expense of another, thus resulting in these design goal trade-offs where the most important design goals have to be prioritised. In order to make a system highly usable it must be very simple and straightforward and thus requires sacrificing functionality. An example is a calculator software that can only perform basic operations being much more usable than a software that can perform interest calculations, automatically calculate taxes etc. which despite being less usable has a much better functionality. Another trade-off is that of cost vs robustness, if software is to be developed so that it can deal with various error types in an efficient way it would require more time and cost to develop it in such a way. For exmaple, a program that aims to deal with 99% of errors in a fast and effective manner would sacrifice cost: a program that is developed quickly and cheaply will be much less robust at dealing with errors. A third typical design goal trade-off is efficiency vs portability: efficiency being the amount of software developed and requirements met with respect to time, effort and cost required. For exmaple, in order to develop a software that is portable to windows, mac, ios, android etc. a lot of time and effort must be expended making all aspects of the software compatibile with these various operating systems, sacrificing efficiency in order to make it possible as increasingly more time and resources are used to develop this portability.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1301678,
      "meta": {},
      "text": "Typical design goal trade-offs:\n1. speed vs space: in the software engineering they trade off between speed and space;If the software cannot meet the response time, more memory can be consumed to speed up the software;If the software does not meet the memory space limit, the data can be compressed at the cost of speed.\n\n2. Delivery time vs quality:\nWhen develop a program and time limit, project manager can deliver the software on time with some small bugs, or deliver the software later with fever bugs\n\n3. Delivery time vs functionality:\nWhen develop a program and time limit, project manager can deliver a program with less functionality as expected on time or deliver the full functionality a later time",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1302586,
      "meta": {},
      "text": "Rapid development vs. functionality:\nAs rapid development focuses on just creating a prototype of the program without specific planning of tasks that improves the program, it is going to have to be a trade off with functionality. For example, when I try to write a 400 word essay homework that I have to hand in in 20 minutes, I have to focus on writing, rather than the content, as I want to accomplish the task to get my essay ready. Here, the content, which is the functionality in a project, would be ignored. If I would write an essay with good content, I won't be able to finish it quickly.\n\nEfficiency vs portability:\nA portable program needs to be flexible, with general content and moderate size. This opposes its needs to be efficient, as efficiency highly correlates with specification. For  example, buying football boots would let you play on the field more easily, as it is specially for it, with its spikes, where it does not fit to everyday lives. Having normal sport shoes would have the flexibility to both play football and to go to town with an above average performance.\n\nCost vs. robustness:\nMaking your program robust requires time, as you need to test, find and give an answer to many situations as well as edge cases. For example, in a RPG with a freely movable map, developers would have to check tons of interactions with non player characters and objects, so that glitches are avoided that might destroy the gaming experience. This secures robustness traded with cost.\n\n  ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344226,
      "meta": {},
      "text": "(1)Functionality vs. usability\nAlmost every app generally has more and more functions in order to satisfy users' needs, therefore it makes the software more competitive when it has more functions than other apps. However, too many functions will reduce usability. It makes it difficult for users to click on the correct button, especially when using a small device. It is also hard to remember where to find a button and what is its function. I think Google Chrome balance these two aspects perfectly, it keeps the interface tidy by displaying only basic functions but users can add extra functions in Chrome Extensions.\n(2)Cost vs. robustness\nIf we simply implement all the methods on the requirements sheet, the software might still run most of the time properly. But once it is in an unexpected situation and crashes, engineers have to stop the service to debug until it is fixed. But if we write test code and test it repeatedly. It will be much less likely to crash. For example, the system used in a car is can have more than 100 million lines of code (e.g. BMW 7 series), and most of them are test codes to secure robustness. But such a system takes years to develop, costing millions of dollars.\n(3)Efficiency vs. portability\nC language programmed apps usually have better performance than those using shell, but C language programmed apps are not portable for they rely on header files and machine architecture. But generally using portable techniques is more recommended, because when your app achieves great success in one system, it can be easily implemented on another one before other developers come up with similar apps.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344565,
      "meta": {},
      "text": "Meistens haben die verschiedenen Aktoren beim Design einer Software andere Ziele als die anderen.\nDabei muss man sich jedoch einigen und kann nicht auf jedes Design-Ziel hinaus.\nBeispielsweise braucht eine Bank ein Programm zum verwalten der Konten. Dabei ist es der Bank wichtig, dass sie dieses Programm möglichst schnell bekommen, da sie sonst starke finanzielle defizite haben. Da das Projekt jetzt von den Programmierern so schnell auf die Beine gestellt werden muss, haben diese keine Zeit mehr die Funktionalität gut auszuarbeiten. So musste der trade-off zwischen schneller Entwicklung und der functionality geschlossen werden.\nHat ein Startup mal nicht so viel Geld für eine App, wie ein großes Unternehmen, muss es sich auch entscheiden, ob es lieber mehr Geld investiert und das Risiko ein geht oder es lieber akzeptiert, dass die Robustness darunter leidet. Dadurch sind sie angreifbarer, wobei die Frage ist, ob das bei einer kleinen Appp wichtig ist. Auch muss man schauen, ob es schlimm ist, was passiert, wenn man zB eine nicht existierende Stadt eingibt. Je nachdem muss man zwischen Kosten und Robustness entscheiden.\nBei Musikboxen kann es auch Trade-offs geben. Dabei hat die Box ein Programm, welches das Stremen vom Handy zulässt. Wenn jetzt eine neue Version der Box rausgebracht wird, muss man entscheiden, ob die Backward compability wichtig ist, sodass man die alte Box mit der neuen nutzen kann, oder eher die readability, was vorkommen kann, wenn der alte Code sehr unübersichtlich ist und durch den neuen das ganze noch schlimmer wird, sodass sich auch kein neues Teammitglied einarbeiten könnte.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1391072,
      "meta": {},
      "text": "1. Functionality vs Usability\nWhile the end users want both functionality and usability, the developers' job is to make a system as usable as possible and functional as possible for the end users. However, these two design goals can't always work together because with increasing functionality the usability automatically decreases. As an example, when a developer is making an application for a university where communication and organization are the main purposes, there is no need for adding functionalities such as weather reports or additional information about the university in general. This will lead to complication and restricts the usability.\n\n2. Rapid development vs Functionality\nThis is a typical design goal trade off in software engineering. Developers and end users want the development process done as soon as possible and want the system to be as functional as possible. However, with rapid development a perfect functionality cannot exist because rapid development prioritizes the use of the software and developing with the help of the feedbacks of the end users. For example, with the example of the university app, when developers are rapidly developing, the application will be published as soon as possible to the students. These students use the app and are going to notice not working functionalities such as the app displaying the wrong calendar. This problem has to be then reported to the developer to be fixed.\n\n3. Specificity vs Generality \nThe software being developed should match the user's wishes, however the software also should be portable to other platforms. For example when the user is using an iphone, the app should be developed according to a iOS device. Then this software cannot be used from an android phone and this leads to the problem that the developer has to create another application only for android users(when having android user clients). \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1420794,
      "meta": {},
      "text": "\nCost vs. robustness:\n\n\"If you want to buy somethingcheap or to build a product what is cheap, usually its not so robust, if you pay a higher price, u get a premium product\" (c) Prof. Dr. Pramod Bhatotia. Egal ob für Klient oder Endbenutzer, das billigere Produkt wird nicht sehr robust sein. zB. alle Voodoo Handyspiele, die kostenlos ist, dafür aber nie geupdatet werden (dazu hoher Speicherverbrauch, langsam, mit vielen Bugs) und meistens nach dem Hype wieder vergessen werden. (BaseballBoy, Soccer Kick etc.)\n\nFunctionality vs. usability:\n\nHier gehts hauptsächlich darum, dass ein Programm sowohl einen großen Funktionalitätsraum hat, als auch benutzerfreundlich sein muss. Das bedeutet nicht direkt, dass das Programm, was viele Funktionen hat, sofort  benutzerunfreundlich ist. Schlecht überschaubare Programme oder die Programme, bei denen man mehr Fragen als Antworten hat, haben einen negativen Einfluss auf Endbenutzer. Ein Beispiel dazu wäre das Operationssystem Linux. Linux stellt zumindest genauso viel Funktionalität wie Windows, aber das ist sehr schwer zu benutzen für einen nicht vorbereiteten EndUser.\n\nRapid development vs. functionality:\n\nEine schnelle Entwicklung ist eine wichtige Aufforderung vom Klient. Der will möglichst schnell ein neues Produkt rausbringen. Dabei kann das Programm am Funktionalität viel verlieren, was schlecht auf den Endbenutzer wirkt. Wenn das Programm zu schnell entwickelt wird, kann es zu vielen Bugs kommen. Auch schnellgeschriebener Code mit Issues kann sowohl zur Verlangsamung der Entwicklung/des Programms in der Zukunft führen, als auch, dass das Programm  nicht mehr geupdatet werden kann. zB. Knight Capital Group, die nacheinem schnellen Update über DeadCode vergessen haben und dadurch 440M$ verloren haben.\n\n\n\n ",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1440943,
      "meta": {},
      "text": "Functionality vs usability : as we know, it is not so simple to develop a system, that has a lot of functions and is light usable at the same time. For example the InteliJ IDE, it has a hundreeds of functions, and students who want to use it, might have some problems at the begining, because it is dificcult to find out in seconds how it all works, that must be learned. Developers of InteliJ made it more functional, but they have of course lost some usability.\n\nRapid development vs functionality : it is logical that a system, that was developed for a short time can not have a lot of functions. For example: a man works on a project, they have only two days to finish the product, but the system must have hundreeds of functions, of course they must make a plan, who works on what. Then every function of the system must be tested and not only once and that all takes a lot of time. So they can not finish the work in two days or the system will be not as functional as it had to be.\n\nCost vs reusability : almost always reusabylity of a system depends on budget of the project. People who works on it must be payed and when a client wants a good product at the end, he has to pay a lot of money for it. For example : there is a project, they must develop an app, but the project has very limited budget. So first of all te app must be implemented. But if the client has not enough money, then he can not pay for the time, that must be spent to implement a reusable code, so also with tests, tha app must be tested. But the client can not pay for the good tests.     ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1476007,
      "meta": {},
      "text": "1-Cost vs reusability: Modeling a one to one association between two classes is cheap. However we can't use this specific association in another system design which requires another type of association. In the other hand we can do a multiplicity association which we can reuse in multiple system designs but this is expensive.\n2-Space vs speed: if the software runtime is not fast enough memory can be extracted and placed into Caches for example. But the software could also not match with data in Cache so memory has to be again compressed together and the system looses his speed.\n3-Delivery Time vs quality: The software manager can deliver his software in less Time but without solving all the failed Tests. In the other hand he can deliver it later than the expected time when his software passes all his tests.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1626270,
      "meta": {},
      "text": "1.  Functionality vs Usability\nExample: when designing university online app, one can opt either for one or another. As more functions are meant to be used by the user, the more the user has to keep in mind, or spend time discovering, pressing different similarly named options from a menu. Like \"Lehrveranstaltungen\", \"Modulhandbuch\", \"Studienplan\", all show your courses but with a slightly different context, making navigation difficult and the app less usabel.\n2. Rapid Development vs Fucntionality\nExample: when developing a small game like bumper cars, the core mechanics take little time, and most of the time is used to add optional functionality to the game, like car and collision times. However when time is short less fuctions can be implemented. Thus the faster the development, the less functionality and vice versa\n3. Efficiency vs portability\nExample: When programming in assembly language the code can be made more efficient by using the unique features of the architecture programmed on, which however will hinder portability as other architectures might have different features",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1293655,
      "meta": {},
      "text": "An obvious design goal trade-off is rapid development vs. functionality. The client may ask for a quick development of the software since he usually wants to apply the requested software as soon as possible. On the other hand the users of this software may demand extensive functionality, as they want to gain from it as much as possible. Implementing more functionality takes time, more planning has to be done and more code has to be written, which ultimately prolongs the development process.\n\nAnother design goal trade-off would be cost vs. robustness. The client usually wants the software as a cheap as possible. However, the user, who may inexperienced in dealing with sofotware, may need a particular robust solution that \"forgives\" the user's mistakes. This however makes the coding process more complicated, which leads to additional coding and testing costs.\n\nYet another design goal trade-off is backward compatibility vs. readability. Some clients may as for the software to be backward compatible so they allow for interoperability with the previous used system. However, the developer always wants to create software with high readabilty, so it's easier to work on the code and maintain it, saving time and effort. However, implementing backwards compatibility enlargens the code dramatically, since you have to deal with a complete whole different system, decrasing the readability by far.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1294116,
      "meta": {},
      "text": "1) Functionality vs. usability:\nEinfach gesagt umso mehr Funktionen und Features eine bestimmte Sache hat, umso schwerer ist dessen Bedienung. Eine Sache mit sehr vielen verschieden Funktionen kann einen User schnell überfordern und die Bedienung extrem kompliziert machen.\nEin Beispiel hierfür wäre ein Toaster, welcher 20 unterschiedliche Einstellungen besitzt, auf welche Weise man das Brot toasten kann. Aufgrund dessen hat der Toaster viele verschiedene Knöpfe und Rädchen, um all diese Einstellungen realisieren zu können. Ein gewöhnlicher User könnte davon überfordert sein, da er nur seinen Toast ganz normal getoastet haben will.\n\n2) Cost vs. robustness\nSehr robuste Systeme sind normalerweise auch mit höheren Kosten verbunden, denn um ein System sehr robust zu machen ist auch ein großer Aufwand notwendig. Und umso größer der Aufwand, umso höher sind normalerweise auch die Kosten. Ein Beispiel hierfür wäre die Datensicherheit von Nutzern bei verschiedenen Apps. Denn umso robuster die App ist, umso besser sind auch die Daten der User geschützt, dies ist jedoch auch mit höheren Kosten verbunden. Eine Online Banking App muss um einiges robuster bezüglich Datensicherheit sein als beispielsweise eine normale Spiele App wie Candy Crush und ist deshalb auch in der Entwicklung in Bezug auf Datensicherheit um einiges teurer.\n\n3) Rapid development vs. functionality\nNormalerweise wenn Softwareentwickler unter einem großen Zeitdruck stehen, da die Timeline nur sehr kurz ist, dann leiden häufig auch die Funktionalitäten dieser Software darunter. Der Grund dafür ist, dass sich die Entwickler sehr beeilen müssen um die Zeitfrist einzuhalten und deshalb limitiert sind. Ein Beispiel hierfür ist die Corona Warn App, welche aufgrund der Umstände unter sehr hohem Zeitdruck stand und aus diesem Grund zu Beginn nur eine Funktionalität hatte.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1297972,
      "meta": {},
      "text": "1. The typical trade-off would be money vs. quality: when company develops software, it wants to keep the cost of it as low as possible, to maximize profit. But on the other hand it wants the software to be reliable and have \"good quality\", in order to protects it's image. If it lowers the budget for a project, the developers will have less resources to work with, which might result in a product, that doesn't statisfy the customer. But if the company tries to keep the quality as high as possible, the companies profit will reduce or even go negative.\n\n2. Developing a program with a high performance and complexity usually restricts the portability of it. The performance often relies on not only the software optimization, but also the hardware of the device \\. An increase in performance would directly translate into higher requirements for the end-users device. E.g. a game might look great on a high end computer but it would be impossible to run it on an older computer or a smartphone, as the computing power of these devices simply can't keep up. Also high performance means high power-consumption, something a normal laptop can't support.\n\n3. The more functionality a software includes, the more it becomes unusable/ harder to learn. If e.g. some software offers high customizability and many advanced/ complex functions like Linux, the learning cuve for the end-user increases significantly. The software often looses it's appeal for most of the people, as they would rather trade some of the functionality for more simplicity and a steeper learning curve",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1301307,
      "meta": {},
      "text": "Functionality vs. usability\nWhen a system offers way too many possibilities or functionalities, it may become too difficult to use, therefore sacrificing usability. This also applies for website design for example. When a website offers too many functionalities and features (menus, categories, login, e-commerce, search, etc.), it becomes unusable, for some users more than for others.\n\nCost vs. reusability\nAlthough reusable design proves to be more productive over time, designing for reusability can be expensive. That's why sometimes certain systems are designed ad hoc to save time and money, while sacrificing reusability. For example, a code that's designed for just a specific purpose can be faster to accomplish and would not take much effort from the programmer, but it would be hard to read and understand in the future in case another programmer needs that same code for a similar purpose.\n\nCost vs. robustness\nJust like the previous example, designing a robust system takes time, effort and money. Therefore, some software engineering teams might opt to sacrifice robustness and go for lower costs instead. However, designing an aircraft system, for example, demands great focus on safety and reliability, making it very important to prioritize robustness over costs.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1334299,
      "meta": {},
      "text": "1) Backwards compatibility vs readability, for example, code will be less cluttered if it doesn't contain all the parts that make it compatible with older versions of itself, the code for Microsoft word would be much more readable if it didn't need to work with older versions of itself.\n\n2)Robustness vs cost, a robust system is able to handle errors in a better way but might also require more testing and longer development time which leads to higher costs. A cheaper production might be faster but will possibly break more easily. For example, you would like your banking application to be robust even if it comes at a price because the errors that might occur could be detrimental and cost way more than the initial investment.\n\n3)functionality vs usability: an app that provides many functions might be able to cater to a small group of people with very specific needs but could in return overwhelm the average user and scare them away if they have to spend a lot of time trying to figure out where the setting is hidden that they are looking for ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344157,
      "meta": {},
      "text": "Design goals are defined as the nonfunctional requirements which often conflict with each other(we name it design goal trade-offs). as an example we can name in the first place rapid development and functionality which means that for example when the customer wants the product in a short amount of time it still has to include all the functionalities required by the customer. As a second example we can name the functionality and usability. As explanation we can say that the product should function smoothly and be easily usable which means that the customer doesnt have to read a big manual or learn 100 commands by heart just to use the product. As a last typical design goal trade-off we can point to the cost and robustness. To understand the goal clearly we can mention as an example the fact that the product should be both cheap and durable. This conflict between both terms makes a huge challenge to big software development companies since creating a durable product can cost a lot of money and on the other side creating a cheap product doesnt mean that it can be durable too.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344506,
      "meta": {},
      "text": "1. A typical design goal trade-off is runtime efficiency and readability.\n\t-> The most efficient codes are often not very readable, for example when the code is optimized for \n\truntime it is often based on a very complex idea rather than a simple idea which is more readable.\n\n2. Another typical design goal trade-off is rapid development and good documentation.\n\t-> Having a rapid development often means there is little to no time for documentation, because all of the \n\ttime has to be used coding. For example when my team has to document everything they do perfectly \n\tthen instead of working for 40h on the code per week, they can only work on it for 35h because they spend \n\t5h on documentation. This leads to a slower development.\n\n3. Another typical design goal trade-off is low cost and functionality.\n\t-> When the budget for a project is lower, the less functionality can be implemented. For example when a \n\tteam is developing a voice recognition software. If the budget for the data used to train the AI is very low, \n\tthe software might only be able to detect a voice when it says a certain sentence. However with a higher \n\tbudget, more training data can be bought so that the voice is detected regardless of the sentence",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1359749,
      "meta": {},
      "text": "1. One trade-off is rapid development and shipment of a software product vs minimizing the number of bugs/errors in the product. Most developers, unfortunately, neglect testing even if they aren't on a strict time schedule. If the client requests rapid completion of a project then developers simply don't have the time to test the code extensively. The code will be tested but not all edge cases will be caught due to the time constraint. An example is PGdP.  I needed to develop a search engine rapidly and therefore could not catch all bugs.   \n\n2. Low cost vs. functionality is another trade-off. Of course, every client would like to spend the least amount of money on a given software project. In addition, they would also like to provide the end-user with as much functionality as possible. However, in almost all cases more functionality requires more code which generally drives the cost up. The Corona warn app is a good example. It was a software project that should provide unseen functionality. However, this entire project cost 130€ Million. -> high cost, high functionality. \n\n3. Backward compatibility vs. ease of learning is also a trade-off. An example of this is trying to learn C++ nowadays. Backward compatibility is desirable because many frequently used libraries are decades old and programmers don't want to and can't rewrite these libraries. Many count on them to work.  However, many functions/libraries are unsafe and dangerous to use. That's why \"updated\" safer functions have been implemented over the years. For users/developers, it's very hard to learn which functions they should / shouldn't use. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1374214,
      "meta": {},
      "text": "1. Efficiency vs. portability: High efficiency means that the software requires high performance of system resources, such as CPU, so it may not be easy to port. On the contrary, if the software is well portable, it means that the software is not so demanding on system resources and the efficiency is not very high accordingly.\n2. Rapid development vs. functionality: To have a system with more functions would mean that people would need more time to develop each function, so development would not be rapid. On the contrary if the system has fewer functions, people can focus on fewer aspects for rapid development.\n3. Cost vs. robustness: High software robustness means that the software should be able to respond appropriately to abnormal conditions such as \"hardware failure\", \"invalid input data\", and \"operation error\". Software developers must have a high level of requirements, design, coding, and testing. Then the corresponding coding and maintenance costs will be higher. Low software robustness means that the quality of software, programming cost and testing cost are all at low level.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1488154,
      "meta": {},
      "text": "typical trade-offs:\n    - performance vs readability:\n        For example in digital audio plugins code optimization techniques like shifting instead of dividing are often used to improve performance. Optimizations generally often lead to less readable code, so a trade-off between optimal performance and readable and thus better maintainable code has to be found. The right amount of optimization can be different for different parts of the system, e.g. high optimization in signal processing parts, low optimization in UI Code.\n        \n    - fault tolerance vs rapid development\n        Error detection and handling logic can sometimes quickly make up more than 50 % of the code if there are a lot of cases to consider. When developing prototypes that should only showcase, that a specific system can be realized, it might be feasible to skip error handling in order to improve development speed. On the other hand in some cases like train control systems this trade-off is already solved by constraints that require the system be absolutely secure.\n\n    - portability vs functionality\n        Often functions depend on interfaces not all platforms offer. So either more functions could be offered that make the systems support less platforms or less functions could be offered so the system supports more platforms. Sometimes it is also possible for the system to offer functions only if supported by the platform. For example google maps works on older devices too however does not offer 3D globe then.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1649126,
      "meta": {},
      "text": "1. Functionality vs. usability: Usability and functionality are often in conflict with each other. If your software product has many functions that may lead to a more complicated user interface, because you have to store all the information, which is way harder to use, especially for beginners. On the other hand if your software product is very easy to use it may lack of more functions which can then lead to unsatisfiability of users because they are just able to use a small amount of functionalities your software product offers.\n\n2. Cost vs. reusability: This problem often appears when it comes to financing the software product. A low cost software product may be very tempting to customers but it can result in a low quality software product that will not be reusable because the developers did not have the means to make a good software product that will be reusable. But a software product that's reusability is very good can also cost a lot more money because the software company has to put more effort into creating a good quality product that will last for a longer time.\n\n3. Portability vs. efficiency: This is a trade off that often appears in the game industry. If a game has to work on as many PCs as possible, for example on nearly every 32 bit and 64 bit PCs with Intel processors, the efficiency may be lowered by a lot because you have to make it work on many different setups and you can't focus on optimizing it for a specific processor. On the other hand if you want to have a high efficiency game you may only focus a small amount of devices and optimize it for these.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1318796,
      "meta": {},
      "text": "Cost vs. robustness\nWhen a young company with limited financial resources builds digital products in a very short time, it is usually not possible that the system can perfectly handle errors during execution and incorrect input. A fictional example would be a start up that built an online marketplace for bicycles within a few months. It turns out that if the customer makes strange inputs in the address line (e.g. special addresses), errors occur in the ordering process and an order cannot be completed. This costs the company revenue, and there are additional costs to fix the error. \n\nRapid development vs. functionality\nIn the wake of the Corona pandemic, the German government initiated the development of the Corona-Warn-App. The priority of this project was to complete this app as quickly as possible. In the first version, the functionality was limited to contact tracking only. In the meantime, you can also read in your vaccination certificates, view current Corona data and much more. This is therefore a classic example of the trade-off between rapid development and functionality. \n\nFunctionality vs. usability\nA fictitious example for this typical design goal trade-off would be a new spreadsheet tool that has 30 more new features than Excel and lists them right at the top of the menu box next to the other functionalities, which will result in the usability of this tool suffering greatly from this extended functionality.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1330366,
      "meta": {},
      "text": "Tradeoff 1: Efficiency vs. Portability\nThere are general algorithmic choices that can be made to make a program more efficient. If more efficiency is needed, one can try to make use of the hardware architecture of a system to make it more efficient. However, because we would be then optimizing for a specific system/machine, that would make the code less portable.\nExample: In GRA an optimization that can be made is to make use of the 64 bit busses available on the architecture. This however makes our program less portable on a 32 bit machine.\n\nTradeoff 2: Backward compatibility vs. useability\nIf you allow programs/methods from older software generations, this might lead to a \"patched\"-feeling software.\nExample: One of the reasons why the windows operating system is powerful is because it is backwards compatible. However, in Windows 10, one can see how the file explorer has a new finished look, while the control panel has an older design, that needs more technical knowledge in order to be used correctly.\n\nTradeoff 3: Rapid development vs. functionality\nIt is obvious that the more time is given to developers to work on an app, the better the functionality should get (since more testing can be performed and more bugs can be fixed before publishing)\nExample: After the rapid success of TikTok, many apps started trying to copy its model of short, horizontal videos. However, since these companies wanted to \"blitz\" the market, they were sometimes not well polished, like the Instagram reels feature, which still is not well integrated on the \"discover\" portion of the app.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1335087,
      "meta": {},
      "text": "Cost vs. Robustness:\nIf you want a very sturdy system that has been tested thoroughly and handles errors well, the developers and anyone doing manual testing are going to have to put in a lot of time and effort, which you will have to pay them for. This increases cost, making robust systems more expensive and non-robust systems, in comparison, cheaper.\n\nEfficiency vs. Portability:\nOne way to render software more efficient is to optimize it on a low level, working with the hardware in mind and changing things in accordance to the machine you are working on. While this makes the program faster, it also might make it unable to run well or at all on machines with other specifications and requirements. If you want to make a piece of software very portable, on the other hand, you will probably have to forgo certain optimizations, thus rendering the software less efficient.\n\nRapid development vs. functionality\nIf you want to have a functioning piece of software in a short amount of time, you will have to accept some limitations in its functionality. The developers won't be able to program a great numbers of functions or make them very complex, because there will simply not be enough time. Especially when you consider that the functions would have to be tested.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1346722,
      "meta": {},
      "text": "Cost vs Robustness : \nIt is much cheaper to develop a system that isn't very robust, where security isn't adhered to, or that can easily break from basic attacks. Eg : it can cost more time to implement security and robustness of a software system. This would probably also mean more team members, and thus, more resources.\n\nFunctionality vs Usability :\nThe system must sometimes sacrifice some functionality for usability. If there is too much functionality (too many functions), it's then very possible to have something that isn't easily usable anymore, because then the product will lost it's simplicity. Eg : a video game menu with all it's settings and options on the front page, sorted alphabetically will be functional, but not usable, because then the \"Start\" button will be somewhere at the end of the page.\n\nRapid development vs Functionality :\nA software system must be functional, but in a scenario where there are constant deadlines to be met by the development team, it is sometimes necessary to sacrifice certain functionality. Eg : a web project, where the deadline to provide the client with a proof-of-concept is nearing, neglects the tablet view of the website, because there wasn't enough time to design and build it. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1391470,
      "meta": {},
      "text": "Cost vs. Robustness\nMaking your application robust against wrong input requires going through many cases where a user could possibly do something wrong. For example, the email address might be invalid. This is time intensive, therefore making the application more robust comes with higher costs involved.\n\nBackwards compatibility vs. Readability\nMaking a web application backwards compatible and allowing for example older browsers such as Internet Explorer often requires having multiple CSS styles to achieve the same thing. This makes the code less readable.\n\nRapid Development vs. Functionality\nBuilding a MVP is faster than building a fully-functional app, but it comes with less features. This can come with disadvantages, for example with FL Studio where the initial product wasn't so advanced, giving the product a bad reputation for a long time. On the other hand, it could also lead to faster user feedback and thereby bringing positive change.\n\n\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1414419,
      "meta": {},
      "text": "Ein typischer Trade-Off ist der von Effizienz und Portabilität. Um den Speicher wirklich effizient zu nutzen, muss man dessen Eigenschaften ausnutzen. Daher lohnt sich Low-Level-Programmieren. Dadurch wird das Programm jedoch maschinenspezifisch, sodass die Portabilität zurückgeht. Daher muss abgewogen werden, welches Ziel besser zum Problem Statement passt. Geht es um High-Performance-Projekte, muss teils auf Portabilität verzichtet werden. Will man aber den Massenmarkt adressieren, müssen Abstriche in Laufzeit und Speichereffizienz gemacht werden.\nEin weiterer Konflikt besteht zwischen den Zielen Schnelligkeit und Funktionalität. Denn je mehr Zeit für Software engineering zur Verfügung steht, desto mehr kann für Modellierung, Implementierung und Testen aufgewendet werden. In kurzer Zeit können nicht nur weniger Funktionalitäten entwickelt werden, diese sind noch dazu oft nicht hinreichend getestet oder durchdacht. Ein Beispiel dafür zeigt die Corona-Warn-App, die in ihren ersten Versionen ihren Usern nicht erklären konnte, was sie tun sollten, wenn der Risikostatus in der App erhöht war.\nEin dritter Zielkonflikt besteht zwischen Funktionalität und Benutzerfreundlichkeit. Denn je mehr Funktionen ein System anbietet, desto komplizierter werden in etwa GUIs. Bald können nicht mehr alle Funktionen in einer Einstellung gezeigt werden, sodass das System weniger intuitiv wird und Nutzer eventuell eine Schulung zum korrekten Umgang benötigen. Deswegen muss abgewogen werden, ob ein System für ein Arbeitsumfeld designed werden soll oder für Freizeit (z.B. Spiele) und wie hoch der Nutzen des Zugewinns an Funktionalität wäre.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1420779,
      "meta": {},
      "text": "There are several design trade offs.\n1) cost vs. robustness: In the early stage amazon does not provide a summary site with all the necessary data before the order so that sometimes mistakes by the customers can happen with the order. For example the customer can not find the normal delivery instead the customer automatically uses express delivery. However this design is cost efficient as the system is not tested for mistakes.\n2) functionality vs. usability: In the Tesla car the touchpad controls almost all the functions in the car and it takes time to find some important functions as climate control as it is not on the top layer. Many functions are included (functionality) but the usability (finding the climate control) is descreased.\n3)rapid development vs. functionality: the new ID 3 Volkswagen was developed in a short time as the developers should finish the software on time but in the end the over the air update of the software of the car does not work.\nAs there is not much time for software development (rapid development) the functionality is not guaranteed.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1654722,
      "meta": {},
      "text": "1. FUNCTIONALITY VS USABILITY- It is important to have only specific and particular features and functionalities in the system and not just unnecessarily adding too many features.\nexample - In  bumpers game , if there was an option to choose other cars running on the game board as well , it is useless. we don't  require  that neither it is usable.\n2.COST VS ROBUSTNESS- It should be clear to the developer what kind of system the customer wants and how robust it should be. \nexample - in Bumpers game , after adding choose Car (use case in which a user could choose his car) we keep on testing whether it accepts all colors by test cases . This is only increasing the costs . contrary to this , user only wanted to have a simple basic system in which he could steer the car and play.\nEFFICIENCY VS PORTABILITY - The system should be both efficient as well as portable . \nexample - The system is really efficient on one platform  but is not portable . or the system is portable on different platforms but not at all efficient. \nIn case of bumpers , if it functions on java but not on python or it doesn't support any particular operating system .",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1290829,
      "meta": {},
      "text": "In der Softwareentwicklung kommt es häufig vor, dass \"Design goals\" verschiedener Parteien in Konflikt zueinander stehen. \n\nBeispielsweise möchte der Kunde, dass seine neue App so schnell wie möglich fertig wird, die Nutzer möchten aber umfangreiche Funktionen und Features in der App haben. Hier entsteht ein Konflikt Funktionalität gegen Zeit und es muss versucht werden, einen Kompromiss zu finden. Dadurch muss ein Ausgleich gefunden werden, dass die Nutzer möglichst viele (Extra-)Features bekommen, die Anwendung aber trotzdem in absehbarer Zeit vollendet wird.\n\nEin weiterer Konflikt könnte darin bestehen, dass der Kunde einen möglichst günstigen Entwicklungsprozess seiner neuen Website möchte, die Nutzer allerdings trotzdem eine robuste Anwendung der Website genießen wollen. Es entsteht also ein Konflikt Geld gegen Robustheit. Die Implementierung und die Garantie der Robustheit kostet Zeit und macht die Entwicklung somit teurer. Auch hier gilt es einen guten Ausgleich beider Ziele zu erreichen.\n\nLetztlich wäre auch denkbar, dass sich der Kunde eine möglichst umfangreiche App mit vielen Funktionen wünscht, die Nutzer allerdings auch eine leichte Bedienung und ein leichtes Erlernen der Prozesse und Abläufe wünschen. Es liegt ein Konflikt Funktionalität gegen Erlernbarkeit bzw. Nutzbarkeit vor. Umso mehr Funktionen eingebaut werden und umso umfangreicher das Produkt wird, umso schwieriger ist es natürlich auch all diese Funktionen zu erlernen und zu bedienen. Hier kann das Entwicklerteam versuchen durch geschickte Designentscheidungen den Konflikt zu minimieren, letztendlich gilt es aber auch hier einen guten Ausgleich zu schaffen. \n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1291148,
      "meta": {},
      "text": "-Efficiency vs Portability: to explain efficiency vs portability I will use video games as an example. Let's think about a PS5 game, these games are really efficient because for example, the loading space is really fast, and in just 2sec the game has already loaded but that does that these games can't be supported on a mobile phone since the mobile phone is not as powerful. \n-Functionality vs Usability: to explain this I will use a mobile application as an example. If you have to make a mobile application you can add many functionalities to the application but it can happen that so many features make the application less user-friendly.\n-Rapid Development vs Functionality: I can't come up with an example but I think if you have to design an application for a mobile phone in a short period of time it is obvious that you can't add all the functionalities that you could have added if you had more time.\n ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292813,
      "meta": {},
      "text": "Functionalities vs. Performance: I designed a small game and noticed that the performance decreased rapidly when I added new functionalities. As a solution I added an \"advanced features\" button with which additional functionalities could be enabled.\n\nFast development vs. Efficiency: Same Example as above. I also noticed that I finished the basic coding relatively fast but the efficiency was terrible. I needed additional time to optimise my code in order to enhance the efficiency/quality of the gaming experience.\n\nExtensibility vs. Maintainability: Currently we are planning the structure of our Team project. Since we opted for an individual problem statement we do not know all requirements and functionalities as of now. Hence we try to focus on Extensibility such that we can add new functionalities to the system. The disadvatage is that the structure is more complicated and locating bugs might be more difficult.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1294244,
      "meta": {},
      "text": "1. Der Client möchte ein First-Person-Shooter haben, der sehr effizient und sehr flüssig funktioniert. Somit kann das Spiel auch auf schwächeren Hardwaregeräten gespielt werden. Jedoch möchte der User ein Spiel haben bei dem die Graphik und Animationen sehr Realitätsnah aussehen. Um so eine Graphik zu bekommen, müssen aber viele Rechnungen, etc stattfinden, was sehr aufwendig ist und das somit das Spiel weniger effizient macht. Das Design goal des client steht im Konflikt mit dem des Users.\n\n2. Der Client möchte ein Online Shop auf dem er Fußballzubehör verkauft. Um in dem Shop einkaufen zu können muss man sich einen Account erstellen. Der Client möchte, das sein Online Shop gegen DDOS Angriffe geschützt ist und er möchte auch, das die Daten der Kunden sicher sind und nicht gehackt werden können. Weiterhin möchte er aber auch nicht so viel für seinen Online shop ausgeben. Da es aber teuer ist Leute einzustellen, die sich um die Sicherheit und regelmäßige Wartung des Onlineshops, steht das im Konflikt mit seinen Ansprüchen.\n\n3. Der Client hat seiner Meinung nach eine Marktlücke. Er möchte ein App entwickeln lassen, bei der man seine Rechnungen eintragen kann. Man kann sich seine Ausgaben dann für verschiedene Zeiträume sich aufgeteilt in verschiedene Kategorien anzeigen lassen. Er möchte seine App so schnell wie möglich auf den Markt bringen, weil er Angst hat, dass ihm sonst jemand anderes zuvor kommt. Jedoch braucht es Zeit die verschiedenen Funktionalitäten fehlerfrei zu entwickeln. Hier zu gehört das Programmieren des Webservers, programmieren der Funktionalitäten, testen auf Sicherheit, etc . Hier entsteht also ein Konflikt zwischen schneller Entwicklung und komplexer Funktionalität und guter Sicherheit.",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1360917,
      "meta": {},
      "text": "One of the typical design tradeoffs is to limit usability in order to increase safety. One example where this is done, is in car design. Car doors can only be opened from the outside so that kids don´t leave the car in a careless fashion. The car does not recognize when a grown-up is trying to open said door and he also cannot leave the vehicle.\n\nAnother design trade-off is when developing a system you don´t max out the capabilities of the system by building in limits. This ensure that performance is consistent and prevents usage restrictions. In mobile phones often the phone turns off even when it still has some power left, for one to ensure that the phone doesn´t deeply discharge so it can easily be charged and turned on again. Another function of limiting the power drainige is so that even though the phone is 'dead' an emergency call can still be fired off.\n\nA third design trade-off might be, that with added functionality certain goverment rules need to be followed.\nAs soon as any user data has to be stored to ensure faster login or to see a shopping history, the dsgvo or GDPR guidelines have to be followed to not violate any rights and ensure data security. This in turn requires more time and money.\n\n\n ",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1503257,
      "meta": {},
      "text": "Trade offs im Bereich Software Engeneering entstehen dadurch, dass unterschiedliche design goals sich meistens widersprechen oder nicht gleichzeitig umsetzbar sind. Hier widersprechen sich teilweise auch die Nutzungsgruppen, welche einen Wert auf die Goals legen (Client, End user und Developer). Ein gutes Beispiel sind hierbei die beiden Ziele \"möglichst viele Funktionalitäten\" zu implementieren und die \"Ease of leaning\" trotzdem hoch zu halten. Als Beispiel will der Entwickler eines Textverarbeitungsprogramms natürlich möglichst viele Möglichkeiten anbieten, den Text zu verändern und zu personalisieren. Auf der anderen Seite will der Hersteller aber auch seine Nutzer nicht überfordern und erstmal nur die hilfreichsten Funktionen zur Bearbeitung zeigen. Hier muss also ein Kompromiss gefunden werden, zwischen der Anzahl an möglichen Funktionen und der intuitiven Nutzung dieser. Schließlich soll ein Nutzer nicht durch fünf Untermenüs navigieren müssen, um einen Text auf kursiv umzustellen.\nEin weiterer trade off sind \"low cost\" und \"functionality\". Der Client will die Kosten für ein Programm nöglichst gering halten, aber trotzdem viele Funktionen anbieten, damit das Programm viele End user anspricht. Hierbei muss der client das Programm erstmal auf die wichtigsten Funktionen reduzieren und sich auf die Implementierung dieser fokussieren, damit die Kosten niedrig gehalten werden.\n\"Rapid development\" und \"Reliability\" sind auch meistens zwei widersprüchliche design goals. Denn bei einer schnellen Entwicklung des Programms ist klar, dass dieses mehr Fehler enthalten wird und dadurch die Reliabiltiy negativ beeinflusst wird. Allgemein wird durch die schnelle Entwicklung auch die Robustness und Maintainability beeinflusst, da bei hektischem Programmieren schlecht auf eine logische Struktur geachtet werden kann.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1291425,
      "meta": {},
      "text": "The first design goal trade off is functionality vs usability.\nLets take a simpe navigation app for cars as an example. As the software engineere you want your app to have as mutch functionality as possible..however the  app in order to be usable has to work properly. But lets say everything works perfectly and you implement more and more features. There is a point where implementing all those functions makes the app not usable anymore. \"is a app with 100 features still usable?\"\n\nThe second design trade off is Rapid development vs. functionality.\n Lets take our new innovative navigation app again. You want to normaly want the app to be released as early as possible however implementing new funtionalitys takes quite a lot of time since you have to test weather the newlly implemented functionality itself works, is bug free and weather it breaks f.ex other funtionalitys. The release of the navigation app then gets delayed. Functionality therefore contredicts rapid development at a certain point.\n\nThe third design trade off is Efficiency vs. portability.\n\nWe know want our navigation App to work not just on one particualar phone but on all the android devices and on ios. However in order for an app to assure maximum efficiency it has to be implemented on the architecture of the particular device since otherwise it cant assure it usess all the ressources as efficient as possible. So in order to work on multiple devices to have to generalize a lot in the app. A good example would be the camara of android devices on the actual photo app vs the snapchat camera.\n\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1296679,
      "meta": {},
      "text": "1. Cost vs Reusability\n\tCost and Reusablity play a major factor when designing larger scale projects. While simple projects are low cost they might not be reusable depending upon the methods used to write the code. Example: A simple calculator app (Addition, Multiplication etc) is easy to code and very cheap but won't be easily extendable to also in cooperate calculations for large scale Industries such as medicine or Automobile as the calculations used there are extremely complex and require more knowledge and hence cost to develop (as information isn't cheap)\n\n2.Cost vs. robustness\n\tCost and Robustness go hand in hand. Low Cost projects are often tested very well and hence are susceptible to errors which might be caught if the project had been tested more and by more people/technologies. Example: Games are often tested for months if not years before release as they need to be able to overcome various different inputs and inputs in various scenarios, so that it doesn't break/crash during live service.\n\n3. Efficiency vs Portability\n\tAn efficient solution to a problem is often more complicated and that translates to Software as well and more complicated software are often demanding on hardware and hence less portable as portable hardware is often lacking in computational power. Hence mostly computationally demanding tasks are done in the cloud or off site. Example: Server side calculations or Large Scale Storage are better suited for data center (not portable) and not for home pcs.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344195,
      "meta": {},
      "text": "1. Implementing more functionality in Bumpers like additional controls would decrease the usability\n2. Making Bumpers less subsceptable to bugs and failures would cost a lot of time, e.g. testing\n3. Bumpers could have all sorts of functionallity like many different items and special enemies or abilites but developement would take very long and be anything but rapid",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1349938,
      "meta": {},
      "text": "Functionality vs. usability\nA system with a lot of functionalities might not be better as it might be harder to use. With many functionalities, a system might become confusing. For example, a website where multiple hierarchies of menus and functionalities are instantly visible once opening the website downgrade its desired usability. The user might not be able to use it at all.\n\nCost vs. robustness\nBuilding a robust system is vital but will also make costs go up, which companies try to avoid. An example is a software used by a travel booking site where users are required to input their date of birth. There are multiple ways to input a date (e.g. American version vs. European). If the software would only allow the date to be written in one format, it could not cope with false user input at all. Allowing various date formats requires much more testing and is therefore more expensive, however the software is more robust.\n\nRapid development vs. functionality\nFinishing a software project as quickly as possible leads to fewer costs and customer satisfaction. However, the system might not be well tested and therefore lack the desired functionality. An example is an airplane manufacturer offering an IT company a huge amount of money if it  develops an avionics software for their new planes within 6 months. The IT company will make a lot of money but the manufacturer might be dissatisfied as the software is not well tested and ultimately not usable due to security concerns.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1465304,
      "meta": {},
      "text": "Functionality vs. Velocity of Development\nThe requirements can have a massive impact on the system, it could even change the core system. If the system is complex, it is only the matter of how efficient the developers can work. They will need more time in implementing the language, application frameworks etc., testing the processes and the build processes.\n\nFunctionality vs. Usability\nIf the system should be easy to use for example a ticket machine should not need more than 5 steps to use, but sometimes it needs to sacrifice some of its other functions in order to achieve this simplicity. By limiting the functions, a system will be easier to use but has a limited purpose.\n\nCost vs. Reliability\nIn order to make a system such as database, server etc. long lasting, a more robust material is needed to make the components. But it does not come in a low price. Using rare materials can be helpful in tolerating high heat, but the price will be higher from time to time.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1471159,
      "meta": {},
      "text": "1. Efficiency and portability can be really important but sometimes you have to make a trade off because if the system is supposed to be efficient it will be coded as short as possible and also as specific for the different hardware types as possible. But you will have a huge problem if develop for example a game which you want to publish for computers and mobile phones because the computer version is completly focused on efficiency and speed while the mobile phone version is also focused on energy efficency because of the small battery.\n2. Cost and robustness is another important tradeoff. You have to either decide on trying to make for example your mobile strategy game as secure as possible, so that it may neither be hacked nor that it reacts wrong on incorrect imputs but this will need very much work and resources. So it is really expansive or you can try to make your game as cheap as possible but there will be many people who either abuse bugs in the program to either hack it or cheat.\n3. Finally, Functionality vs. usability is another tradeoff. You want to for example give a computer game as many features as possible so that it is more interesting and interactive but if you implement to many different functionalities the user will very fast be overwhelmed by all the different possibilities and will not know what to do. Moreover, you want to present the different options as well arranged as possible so that the user can see with one glance where he can do what.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1481199,
      "meta": {},
      "text": "There are many typical desigh goal trade-offs. I am going to consider three of them which seem most interesting to me. \nFirstly, efficiency vs portability. The portability of software could be achieved by using standard languages and compilers. Portable software is easy to be moved between different computing environments, there's no need to re-develop or change. On the other hand, efficient software requires minimum time, cost and effort while being developed. Efficiency could be achieved by using suitable languages, efficient code is harder to test and efficient software usually requires an installer.. The Google Chrome Browser could be an example. It is one of the most portable softwares, therefore, its efficiency is lower than the Edge's, for instance.\nSecondly, cost vs reusability. Reusability is a great way to cut down on the development costs. Code, tests, even design or documentation could be reused. However, there's way more software parts to analyse and choose from, which affects time efficiency. Incompatible with system changes, reused elements can cause maintenance cost increase. There are many software libraries, where needed part of the code could be easily found by using key words, for example, Flashline or PAL.\nLastly, rapid development vs functionality. Rapid development focuses on prototyping with less specification on planning tasks. It is usually used when the projects needs to be designed quickly. Prototyping is easier to be done on small components of software, which means that rapid development is really hard to achieve when working with detailed, extensive projects. Therefore, the vast functionality of a software could potentially be the reason why a rapid development is impossible.  ",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1318078,
      "meta": {},
      "text": "Trade-offs in the context of software engineering are imperative. When designing we will often find ourselves in a sticky situation where we will be obliged to sacrifice a \"feature\" in order to give place to another to be fulfilled. Maybe one the most famous cases is Linux's \"sacrifice\" of usability in order to make it more functional because as we know it might be less user friendly than Ios or microsoft but it executes a lot more functions in a matter microsoft or Ios never could.And this Functionality for usability trade-offs if probably one of the more popular ones the software developers encounter.Another typical trade-off is the Efficiency vs Portability one.As more efficient products tend to have a bigger size and thus less portable and less easy to move around we find ourselves wondering whether we would opt to make it smaller or leave it that efficient and in this case we would tend(if the resources allow) to make two versions of the same product.This what happens with graphic cards for example.The last one we can mention is the rapid development vs functionality and this one is less tricky.Should we focus on giving the software all the features we want but then wouldn't have too much room to evolve rapidly or start with something more basic and give ourselves some room to grow in a more rapid way ?  ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1331993,
      "meta": {},
      "text": "Rapid development vs. good documentation: A freelance developer has been given a tight time frame to create a software that manages reservations in a restaurant. He manages to hand in the software on time, yet he took shortcuts in the documentation which is now insufficient. Years later, another freelance developer struggles to revise the existing software due to the lack of documentation.\n\nFunctionality vs. User Friendliness: A start-up is creating an app for ordering customisable coffees. The management wants the app to include at least 25 sorts of milks, 30 different toppings, and 20 different cups. The development team argues that the amount of choices could overwhelm the user and make a bad user experience. \n\nAdaptability vs. Ease of Learning: A company develops an app that shows property listings across Munich. The app has a modularised UI so that developers can quickly exchange parts, such as the map the properties are shown on, or the theme of the opening page of the app. However, that has lead to some confusion with the end users since elements keep getting placed at different places across the UI. The user has to relearn how to navigate over the app. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1345106,
      "meta": {},
      "text": "Cost vs. Robustness:\nUm die robustness zu verbessern muss man mehr Zeit in Testing und Fehlerbehebung stecken, was wiederum die Kosten erhöht. In der Spieleentwicklung beispielsweise werden spiele häufig um etliche Wochen nach hinten verschoben, damit das Endprodukt weniger Fehler enthält und runder läuft. Dies erhöht allerdings die kosten, da Mitarbeiter auch bezahlt werden wollen.\n\nRapid development vs. Functionality:\nDieser Konflikt ist Recht eindeutig. Wenn man mehr Funktionen einbauen will, muss länger entwickelt werden. Will man in Bumpers bspw. noch eine Speicherfunktion einbauen, muss noch mehr Zeit in die Entwicklung gesteckt werden, bis die Funktion implementiert ist.\n\nBackward compability vs. Readability:\nCode wird mit der Zeit immer unleserlicher, wenn stets darauf geachtet werden muss, alte Versionen und Funktionen weiter zu unterstützen. Wird beispielsweise eine neue Methodensignatur eingeführt, muss der alte Code drinbehalten werden, sonst funktionieren Programme welche auf die alte zugreifen nicht mehr. Entfernt man sämtlichen alten Code wird der dafür um einiges besser lesbar.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1359694,
      "meta": {},
      "text": "Cost vs. Reusability: Creating software requires specific Customer specifications to meet the customer's real wants and needs. Implementing a re-used software, reduces the costs to some extent, nevertheless re-using software, reduces the quality of the Software Product that is thereafter designed. Thus it is a decision to be taken analysing the opportunity cost of one decision to the other, and having a specific Team firstly defining the Client's real needs. Overall it seems to be a beneficial money-making aspect for the software developer, but tends to often be a big trade off for the Company requiring the software. Imagine using the code from the Bumpers game, and re-using the code to produce a Chess Game, whilst modifying it a bit. This solution would cause many problems on the client side and likely not fully follow the client's wishes. \n\nRapid development vs. Functionality: The Software development at its best, often requires longer periods of time to make sure to produce the best possible Software. A rapid development will likely involve not having the time for example to carry out Sprint's, from the Scrum Framework, it also leads low amounts of Testing, and little feedback on functionality. A rapid development of a Chess Game, would not be ideal as it doesn't allow Players to test it out properly, see functionality traits. \n\nFunctionality vs. Usability:\nA system can be functional, nevertheless if the system has too many functions it won't be easy for the customer to adapt. For example the implementation of Photoshop is close to impossible to master due to the amount of tools that the system consists of. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1512782,
      "meta": {},
      "text": "The three biggest trade-offs in software design are probably functionality, maintenance/bugfixing and cost.\nYou can't have all three in most cases. \nIf you want to keep the cost down as a client you probably want to cut down on working hours of the developers. This however increases the likelihood of issues with the code as well as decreasing the functionality.\nIf you want a huge amount of functionalities you most likely need more code, which tend to lead to more bugs that either need to be fixed, which adds cost, or overlooked. \nOr you could have a (almost) bugfree application that either is cheap and has few functions and vice versa.\nIn this example you can only have two things: functionality and low cost, which means more bugs, few bugs and high functionality, which increases price or a cheap application with few bugs that doesn't have as many functionalities. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1648458,
      "meta": {},
      "text": "1) First trade off would be the functionality vs the usability, meaning that a software cannot be used, when the functions available are simply too many to cope with. So sometimes having some simple and less functionalities are more helpful and usable to the user, than having to first learn all its functions first to be able to use a software properly. As well the time the system needs to work will add up with more functions. \nExample: \n\n2) Another trade off would be the efficiency and the portability, meaning that on account of the efficiency one device for example has the device might be easier to move and carry.\n\nExmple: A laptop is less portable than a phone, but the laptop has more functions such as writing on Word etc. faster and more comfertable.\n\n\n3) Performance and cost: the more one wants a new device to be more advanced in terms of performance, the more the costs will be. If something shall work better, faster and with more capacity one needs to increase the costs to develope such. \n\nExample: a gaming computers performance is much higher than a standart laptops. So can the diffrence seen in the price.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292740,
      "meta": {},
      "text": "Functionality vs. Usability: \nEnduser ist diejenige Gruppe, die am liebsten beide Design Ziele haben würde. Doch möglichst viele Funktionen und gleichzeitig eine sehr leichte Bedienung stehen im Widerspruch. Wenn versucht wird eine einfache Handhabung zu gewährleisten ist es nicht möglich das Produkt mit vielen Funktion auszustatten. Ein schönes Beispiel für ein Program mit vielen Funktionen, aber einer schweren Lernkurve zur Handhabung ist beispielsweise GIMP. Dort ist es für neue Nutzer schwer sich zurechtzufinden. Je nach Problem muss die goldene Mitte gefunden werden, was oft sehr schwer ist. Dadurch ist es natürlich möglich das weniger Bugs \n\nCost vs. Robustness:\nWie fast immer versucht der Client die Kosten gering zu halten. Das Problem ist dabei, dass dadurch ein kleineres Software Development Team, weniger Ressourcen und weniger Zeit zur Verfügung stehen. Dadurch kann die Software nicht optimal durchdacht, getestet und erweitert werden, um ein ausgewogenes und vollständiges Exception Handling zu ermöglichen. Wenn beispielsweise ein kleines Team mit einem älteren, dafür billigerem Server arbeiten muss, ist das Produkt tendenziell anfälliger für Fehler und Bugs.\n\nBackward Compatibility vs. Readability:\nClients möchten keine Kunden verlieren und wollen somit, dass ihr Produkt rückwärtskompatibel ist. So will man beispielsweise auch immer noch ältere Windows/Android Versionen unterstützen, wobei gleichzeitig natürlich das Produkt weiterentwickelt werden soll. Für die Developer wird dadurch die Lesbarkeit natürlich erschwert. So muss nämlich darauf geachtet werden welcher Code für welche Versionen zuständig ist. Es wird dadurch schwer mit diesem Code weiterzuarbeiten, denn dieser wird immer größer und unübersichtlicher. Beispielsweise konnten einige Playstation 1 oder 2 Spiele auf der 3er gespielt werden.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1312913,
      "meta": {},
      "text": "The first example for a typical design goal trade-off in software engineering is of course\nease of learning and user-friendliness vs. peek usage efficiency (how fast the user can do\nstuff once he learned all of the software's features). A fitting example for this phenomenon\nwould be vim which is known for being notoriously difficult to learn due to being keyboard only\nand having fairly unintuitive command keys at first. This steep learing curve increases potential\nefficiency though as there is shortcuts exist for pretty much every text modification possible.\nIn contrast notepad is easy to learn and thus user-friendly but only because there is nothing to\nactually learn. The next and probably most prevalent one would be cost vs. pretty much all\npositive features associated with good software. The problem here is that good sofware takes\nlots of time to develop, so the cost rises proportionally, as developers (hopefully) get paid.\nSo spending less means less time to allocate on testing and quality assurance in general\npotentially introducing bugs and decreasing reliability in the long run. Lastly efficiency vs.\nreadability is also an often encountered trade-off. Handwritten assembly is normally not considered\nto be an easy read and mathematical bithacking tricks like the fast inverse square root \ncan cause confusion if someone new to the project reads the code for the first time. This trade-off\nis mostly not that big of a deal because readability can always be increased by good naming and\ndocumentation but this in turn takes time and as has been previously established; time equals cost\nin a software project.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1313049,
      "meta": {},
      "text": "1. Functionality vs. usability\nDeciding to provide more functionalities often means the software needs users to spend more time and effort to get familiar with, which reduces the usability. For example, the developers of Adobe Photoshop decide to make it feature-rich to suit professional needs. However, users need to read documents or even take courses in order to operate it proficiently. On the other hand, the camera app on modern smartphones provides easy-to-learn photo editing with high usability, but the available functionalities are much more restricted compared with Photoshop.\n\n2. Efficiency vs. portability\nTypically, software written in low-level programming languages have relatively high performance, while software written in languages with a higher abstraction level has better portability. As for an example, writing assembly code by hand would result in an efficient program, but the code only runs on CPUs of the same ISA - poor in terms of portability. On the contrary, developing with JavaScript means your software runs everywhere from all web browsers to node.js with high portability, but at the cost of lower efficiency.\n\n3. Rapid development vs. functionality\nRapid development demands the developers to finish in a relatively short time period, which objectively restricts the variety of functionalities. For example, a team during a hackathon would consider to implement less functionalities so that the speed of development stays fast. On the other hand, as an operating system with many functionalities, the Linux kernel has been slowly developed for 30 years.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1333503,
      "meta": {},
      "text": "A design goal trade-off means, that you gain one aspect which affects another aspect negatively, e.g.:\n1. Functionality vs usability: The less functionalities a system has, the easier and more usable it gets, and vise versa. So the more and better the functionalities are, the less easier it is to handle those functions and get to learn them. e.g. If you add a laser shooting function in the bumpers game, it will make the game more fun, but it will be much harder, because you'll have to learn how to shoot the laser and how to dodge it and so on.\n2. Cost vs reusability: To make a product or a program more durable and give it the ability to be used many times needs much more money than a program that only needs to be used once. Its like using a plastic spoon vs a metal spoon, the plastic one will break, the metal will get used unlimited times. If you want a software to be reusable it will cost you much more to make it, but in the long run it will save money, so it really depends on the software itself and what it will be used for.\n3. Efficiency vs. portability: A perfect example to explain this is pcs vs laptop. pcs are usually much better in performance, because you have the space to store the rams, chips, ... but this comes to the expense of the portability. Laptops on the other hand are portable, but have less computing power. That's why an efficient program is usually not a portable one.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344237,
      "meta": {},
      "text": "1. Cost vs. Reusability\n\tIf a client wants low cost and and reusability, it may be hard to fulfill both. If the software developer thinks it is impossible, he/she may try to make the client to choose one of the two. For example, if the client wants a device to have the best processor, as well as low cost, it would most likely result in giving up one of the requirements, since the better a processor is, the more expensive they get. Although, nowadays it became possible to satisfy the client by fulfilling both of these requirements.\n2. Functionality vs. Usability\n\tToo many functions does not mean better usability. Apple, for example, keeps iPhone's user interface simpler and there are no advanced customizations that the user get lost through. IOS tries to keep functionality without complexing the usability. In contrary, Android smartphones have much more functionality, but sometimes considered as not user friendly because of its less usability.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344320,
      "meta": {},
      "text": "Backward compatibility vs. readability:\n\tOft muss ein Trade-off zwischen Backward compatibility und Readability eingegangen werden, da z.B alter\n \t(legacy) code viele, neuere Features der jeweiligen Programmiersprache nicht unterstützt, welche das \t\n\tjeweilige Programm lesbarer machen würde.\n\n\tEin Beispiel hierfür sind C-Style-Pointers in C++. Mit der Einführung von smart-pointer in C++ und \n\tzugehöriger move() Semantik  können C-Style pointer komplett durch um ein vielfaches leserlichere \n\tausdrücke ersetzt werden.\n\n\tDie rückwärtskompatibilität zu älteren C++ oder gar C-Versionen entfällt hierdurch jedoch und alter Code \n\tmuss entweder umgebaut oder komplett ersetzt werden.\n\nCost vs. robustness:\n\tJe robuster, bzw. unanfälliger eine Software gegen äußere und innere Fehler sein soll, desto mehr \n\tAufwand (und eben Kosten) muss in die Entwicklung (Testing etc.) dieser gesteckt werden. \n\n\tEin Beispiel hierfür sind hoch ausfallsichere Serversysteme, welche bei ähnlicher Leistung zum Konsumer-\n\tBereich ein vielfaches Kosten, um eine hohe Ausfallsicherheit zu garantieren, wie etwa Intel Xeon\n\tProzessoren, DDRX-ECC Arbeitsspeicher, redundante Server Netzteile uvm. \n\nEfficiency vs. portability:\n\tUm eine Software möglichst portabel zu gestalten müssen Heuristiken für alle möglichen Umfelder\n\teingeführt werden, in denen die Software ausgeführt wir. \n\n\tEin tolles Beispiel hierfür sind C++ und Java; Während die Java VM eine hohe portabilität bietet, hat\n\tfully\tprecompiled code bei Sprachen wie C/C++ etc. den Vorteil eine unglaublich hohen Effizienz zu \t\n\terreichen, jedoch für jede Zielplattform neu kompiliert werden zu müssen. ",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344711,
      "meta": {},
      "text": "When developing a software system, sometimes the established design goals may conflict. It may happen that we sacrifice one design goal to achieve another design goal. So, we must make trade-offs and determine which goal is more important. Typical design goal trade-offs are, for example, as followings:\n\n1. Functionality vs. rapid development\nWhen we want faster rapid development, the functionality will be less. So, in order to develop a software very quickly, we could give up some functions of the software. For example, I try to  develop a game software with twenty functions rapidly within one month. But I can only finish about three functions pro week in this software. So, I could only choose the more important twelve functions, and finish this development as rapidly as possible.\n\n2. Maintainance costs vs. reusablility\nWhen we want a software more reusable, it willl lead to higher maintainance costs. For example, if I want to develop a  high reuseable game software, that users can use even after six years.  Then I have to invest lots of time and financial cost to maintain this game during the using period in oder to make sure the reusablility. \n\n3. Functionality vs. usability\nIf a software system have too many functions, its usablity might be poor. For example, if I want to develop a game with action fighting, simulation development, role playing, social interaction and other functions all together, users would be confused what to do in this game. That leads to low usablility. So in order to improve the usability of this game, I just focus on role playing and social interaction functions, but give up those functions.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344740,
      "meta": {},
      "text": " A design trade-off happens because different goals often conflict with each other. That happens when client, developer and end-user have different end goals. In that case all options should be considered and the best ones chosen.\n\n One example is cost vs. quality - software takes money in order to have higher quality. Money has to be invested in more qualified personnel and better software and hardware, which leads to more quality software.\n\n Another trade-off example I can think of is rapid development vs. portability  - it is a common practice to develop software for different platforms, so that it can reach more clients and be used in different environments. However, in order for the software to be supported it it could be possible, that it has to be specifically modified in order to work on a specific platform and that means that development might take longer, which a client might not want, so less platform could be supported at the end.\n\n A their example is ease of learning vs. functionality - a software that is easy to learn most of the times also offer less functionality, which leads to professionals looking for more sophisticated software that isn't beginner-friendly. An example for that are iMovie and Final Cut Pro, both created by Apple. The first one is a fairly simple program that is easy to use and easy to learn with just a handful of functions. The other one is for professional video editing which takes quite sometime in order to learn how to properly use.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292567,
      "meta": {},
      "text": "Rapid Development vs. Low Cost:\nRapid development often requires more personal. This increases significally the production price. Also more \nspecialized software, that can be bought, can shortend development time, by not be needed to be implemented.\n\nRobustness vs. Adaptability:\nA robust system can handle with errors during execution without stopping. If the system gets more adaptable it gets harder to hold this robust standard, because the develloper can´t anticipate every possible adaptation and their possible errors. Also for special errors in an adaptation, where the system should stop, could be ignored by a too high robustness.\n\nMinimum of # errors vs. Rapid Development:\nTo achieve a minimum of errors the system needs to be tested extensively. This is increasing production time greatly. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1313273,
      "meta": {},
      "text": "Functionality vs Usability: \n\nOne example in the context of software engineering to strike an adequate balance between a system that allows for/ provides a large variety of functionalities, however inherently remains usable for users so that they can actually make use of the different abilities the system has is the car. That software without question highly complex and if all its intricacies would have to be understood by the driver, they would probably feel helpless and overwhelmed. Therefore some of the functions are combined/ simplified so that the above mentioned does not occur. \n\nRapid development vs Functionality: \n\nA new app conceived by a startup for example could suffer from being too rapidly developed i.e. in order to provide users with basic functionalities so that the app can be used and downloads can be scaled up. That may in turn lead to software that is a) not entirely thought through and b) that may suffer in the long run to implement additional functionalities on top of the existing basis. Naturally, in their quest to rapidly develop a usable/ presentable product, software engineers should always consider further developments on top of their existing structure. \n\n\nCost vs. robustness: \n\nTesting software is costly as one has to come up with profound tests in order to find mishaps/ loopholes that lead to frail software. Naturally that means more coding which could then mean lost revenue/ lost users etc.. However in for example the realm of safety these costs are of utmost importance, especially when lives are at stake like in the aviation business. The Boeing 737 MAX disasters are a dark example of how \"cheaper\" testing led to disastrous consequences. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1315327,
      "meta": {},
      "text": "One trade off you have to find is for example minimum amount of errors conflicting with functionality, so how more complex your program gets how more errors it will have.\nAnother one is the conflict between  the rapid development and robustness as with few time there isnt much time for testing.\nAnd you have to find a trade of between readability of the code and the speed of the code as code optimisation makes code less readable.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1316964,
      "meta": {},
      "text": "1) Good example of functionality and usability trade-off is TUM-Website. In order to find all the information you need visit many pages, so the website is functionally rich but hard to use. And people couldn't do another way. It is better to spend much time and find than not find something at all.\n2) Another good example is macOS system and efficiency and portability trade-off. Apple did a great job optimising their system on own processors. But if you would need download some soft that was not optimised specially for macOS or use your computer with not apple device, it will be horrible user experience.\n3) Apple again. They request too much money to sell just a cheapest and smallest macBook. This prices asked for robustness and reusability, it is a cost-reusability and cost-robustness trade-off. A good example of it is the first iMac and the newest apple mouse that can be used together even now.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1319293,
      "meta": {},
      "text": "-Functionality / usability:\nFunctionality, which represents a set of operations that an interface supports, is always in conflict with usability, which is the ease of use an interface. A lot of functions in 1user interface can make the understanding of the interface so complicated and therefore difficult to learn and use. Reducing the functions makes the interface less powerful.\n→ A university app with the features below: request friendships with other students,  generate a calendar, turn off/on the notifications, create favorite folders... will not be that easy to use. Making less features (application, search for rooms) is easier for the user to learn how to use it quickly.\n--------------------------------------------------------------------------------------------------------------------------\n-Rapid development / functionality:\nIt usually takes a lot of time to create something with high performance and to add all the functions requested by the client. The customer's desire to develop the project quickly means that the developer will not be able to develop all the required functions with a good quality.\n→Developing a mobile banking app in a very limited time makes a simple app containing a few features (transactions...), that's why many apps are optimized over time.\n---------------------------------------------------------------------------------------------------------------------------Efficiency / portability: \nDifficult choice the programmer faces is portability vs. efficiency, because choosing efficiency leads to non-portable code, while choosing portability often leads to software with unsatisfactory performance.\n→ Assembly is example of software, which is not portable, because the assembly code is specific to processor type, C compilers are readily available for the majority of operating systems. But The handwritten assembly language code, is always more optimal or equal to the compiler generated code.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1330499,
      "meta": {},
      "text": "Functionality vs usability: The more functionality you add to your app, the less usable it gets because it starts to get crowded with many new features that might overwhelm the user. For example, if we add a lot more sections, pages, and links to the university app, students who just want to find their exam dates easily might get lost in the process and end up scrolling through the wrong sections and lose time.\n\nRapid development vs functionality: If we prioritize rapid development, we might not have time to implement all of the functionality, test it, and debug it. That causes our project to have less functionality because adding features takes time. If the university app has to be built again from scratch and tum wants us to finish the whole app in a week, it's obvious that we will not be able to ship all of the requested features at launch.\n\nEfficiency vs portability: For software to be portable, it needs to have a translation or an adaptation layer that converts everything to a version that can be run on that particular OS. If it was a native program, it could directly run without processing anything which uses resources and takes time. If the university app can only run on IOS, it can be optimized to apple chips and software so that it becomes very efficient at doing that. Since it's native, no translation is needed and no resource is wasted with pre-processing.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1335592,
      "meta": {},
      "text": "1. Rapid development vs minimum number of errors\nOne of the things that clients usually want is rapid development. This forms a typical trade-off with the want of the developer of a system with as little as possible number of errors. By a rapid development this is often not possible, because any work done fast is more probable to be made with more mistakes as well, which also applies for software engineering.\n\n2. Cost vs reusability\nAnother thing that most clients want is a low cost. This crashes with the reusability of the product, because with less resources the product won't have a broad functionality and its quality will probably be lower, which makes the product not suitable for further use.\n\n3. Portability vs efficiency\nWhen developing a software in most cases it is a good thing when it is portable and can be used with all types of platforms. But if we want the software to be really efficient of course this will be accomplished easier if the developers focus on a certain platform and develop the product according to the requirements of the platform.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1337844,
      "meta": {},
      "text": "1. Funktionalität vs. Benutzerfreundlichkeit\nEine große Anzahl an Funktionen kann die Benutzerfreundlichkeit einschränken, da der User überfordert werden kann. Ist die Benutzerfreundlichkeit wichtiger so kann es dazu führen dass einigen Nutzergruppen Funktionen fehlen.\nBeispiel: Smartphone Kamera App Trade Off. Ist die Benutzerfreundlichkeit wichtiger und man kann mit einem Klick ein Foto machen, oder ist die Funktionalität wichtiger und der Benutzer kann verschiedene Funktionen vor dem Auslösen vornehmen wie z.B. die Belichtungszeit.\n\n2. Flexibilität vs. Einfachheit\nManche Systeme müssen sehr flexibel und erweiterbar sein, weil man weiß, dass man mit dem Kern einer Idee anfängt und dass sie größer werden wird. Andere erfordern einfach eine unkomplizierte Implementierung mit dem Hintergedanken das die Einfachheit und Schnelligkeit bei der Erarbeitung Vorrang genießt.\nBeispiel: Bumpers. Superclass \"Car\" und ihre Subclasses erhöht die Flexibilität da beliebig viele Cars einfach hinzugefügt werden können, Dies geschieht zu Gunsten der Einfachheit die man hätte würde man eine FastCar und SlowCar Class benutzen.\n\n3. Speicherplatz vs. Zeit\nSchnelligkeit erfordert häufig hohen Speicherverbrauch um in kurzer Zeit dem User Informationen bereitstellen zu können. Andererseits kann vielleicht Speicherplatz minimiert werden sollte die Zeit keine Priorität genießen, was bedeutet, dass man sich mit Komprimierung befassen kann, um redundante Speicherung zu minimieren.\nBeispiel: Suchmaschine. Beginne ich mit der Suche bereits während der User noch Tippt und benutze dafür mehr Speicherplatz um alle Möglichen anfragen bereits zu berechnen spare aber dafür Zeit, oder warte ich auf den User und benutze dafür weniger Speicherplatz aber dafür mehr Zeit.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344182,
      "meta": {},
      "text": "Cost vs. robustness\nIn order to increase robustness, more resources need to be invested in the project. In most cases that resource is money. More developers for a longer period of time result in higher salary payments by the company. A website for example that breaks down every time more than 100 people use it, needs to be optimized if the popularity of the website rises. In order to do that, server capacity needs to bee increased ore more developers need to be hired in addition to those who are already maintaining the website. Both is directly related to higher expenses.\n\nRapid development vs. functionality\nThe faster a project needs to be finished, the more details have to be left aside (in case that other resources are not unlimited). If the same developers with the same tech stack and the same budged have less time to develop a system, certain functionality's cant be finished and therefor need to be left aside ore done in another sprint/release. \n\nFunctionality vs. usability\nThe more functions a system supports, the more complex it gets. Photoshop for instance is known to have tools for every need. But some one who is unexperienced in editing fotos and has never used photoshop at all may struggle to do even to the simplest things. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1350663,
      "meta": {},
      "text": "Functionality vs. Usability\nWenn ein Programm bzw. dessen Benutzeroberfläche zu viel Funktionen oder Informationen enthält, ist der Benutzer schnell überfordert und kann nicht mehr so intuitiv das Programm nutzen. Wenn man eine Taschenrechner App hätte, die einem alle möglichen Funktionen liefert  wie Faktorisieren, Cosinus, Sinus, die Gauss'sche Summenformel und noch mehr, dann kann man womöglich alles schnell ausrechnen was man will. Jedoch wird es deutlich unübersichtlicher und ungeeignet für Leute die den Taschenrechner nur für simple Multplikationen benutzen will.\n\n\nCost vs. robusteness\nRobustheit ist mit mehr Aufwand verbunden, da zb. das Ziel ist möglichst viele Fehlerhafte eingaben abzufangen. Mit mehr Aufwand steigen die Kosten. Angenommen es wird ein Chatsystem implementiert, dann sollten auch alle möglichen Zeichen unterstützt werden, diese ganzen Fälle zu behandeln kann Zeit Kosten und damit auch Geld.\n\n\n\nefficiency vs. portability\nUmso spezifischer ein Programm mit der Architektur der Maschine arbeiten kann desto effizienter können die Programme werden. Jedoch funktionieren diese dann nur für bestimmte Maschinen. Sucht man zb.  sehr große Primzahlen, kann man ein Programm schreiben, welches mit 8 kernen arbeitet und dadurch deutlich schneller ist als mit zb. nur zwei Kernen. Dadurch ist es aber nur von Computern mit mindestens 8 Kernen ausführbar.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1360223,
      "meta": {},
      "text": "Design goals usually conflict to each other. We have to make trade-offs to deal with such impasses.\nThere are three (of many) typical design goal trade-offs: functionality vs. usability,  efficiency vs. portability, rapid development vs. functionality.\n\n1. Functionality vs. usability: functionality means the amount of operations supported by an interface. Usability defines the ease of using an interface. More functional apps takes usually more time to learn. Ex: Instagram has not so wide range of functions comparing to Excel tables, so it takes a few minutes to learn how to use Instagram. In Instagram case usability was chosen.\n\n2. Efficiency vs. portability: roughly speaking, efficiency is the amount of resources used per unit of output. The more efficiency we need, the stronger is the connection to the hardware/ operation system. In opposite portability requires  platform independency. Usually software developers choose portability over efficiency due to financial reasons. (Example: cross-platform Zoom client). But there is still high memory consumption apps (Ex: games for PS4 or Xbox). In this case portability wins. \n\n3. Rapid development vs. functionality: Development of interface with the high-level functionality is a process that takes a lot of time and resources. Rapid development requires huge amount of functionality sacrifices. In 20-min sprint during our lecture we could imply only a few functions to our Bumpers game. Development of Cyberpunk took years.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1493106,
      "meta": {},
      "text": "Different parties are involved in a project, and every group have a other goal and think this goal is most important. Usually there are three different groups. the client, the end user and the developer. For the developer is the technology the most important thing, he wants a good and reusable code. This is important but a lot of work. Especially in bigger projects where a lot of people work together it’s important for the developer that the functionality of a Function is well defined or there is a good organization of the classes. Thinks like this need time, and for easy-to-understand code sometimes you need mor resources, which is not always a goal of the client. He wants to have in the shortest time as possible and for the lowest price the best program. Is are goals which doesn’t work together. Also the product need to work out and have all required functions, so at the end the goals of this groups can be compinated to Maintainability. The last group the end user wants to have a safe system which doesn’t leak any datas and he wants to have understandable, transparent platform, which work out. A common goal with this group and the clients is the Runtime, because both want to hafe a fast usable program. In opperside to this ther is a shared goal with the developer, the documentation. because this means the code is good-to-understand and transparent for the user.\nAt least you can say ther is one goal for all and this is reliability or a other example its safe and always working because this means for the user a stabil system, for the client low coats for maintenance and for the developer a good program with less errors.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290834,
      "meta": {},
      "text": "1. Runtime efficiency vs Readability: A client and an end-user would demand an application which can run in a specific time frame. This, however, may provoke the software developer to optimize the code, chose algorithms and data structures which have a lower space and time complexity, and eventually make less readable and thus less maintainable code to a certain extent. For example, the developer may have avoided use of recursion and instead opt for iterative approaches throughout, although recursion in some cases provides a better presentation and readability or use optimizations which may be hard for another developer to follow.\n\n2. Low cost vs robustness:  The client always aims to minimize the costs, whereas the end-user always look forward to a product which is robust from both the software and hardware perspective. Both properties have an inverse relation and any possible constraints with one indirectly affects the other. For instance, if the robustness is the priority of a company e.g. Apple, then it will require them to invest a lot of money and resources, causing the Low-cost goal to be compromised. However, this gap can be bridged through increased efficiency.\n\n3. Rapid Development vs Minimum of errors: A client stimulates rapid development of a product through tight project deadlines. The developer whereas aims to code with minimum errors, ideally following clean coding conventions. However, haste and rush typically can cause tradeoff for minimum error. For example, in the long run if a company extremely prioritizes rapid development, then this may cause small errors adding up, eventually sabotaging the company to expand their code and innovate.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291350,
      "meta": {},
      "text": "1) Rapid development (Client) vs. User-friendliness (End user):\nThe client required a new reservation system for his restaurant to be developed in under a month. He doesn't really worry about the complication, with how his first customers would be using the user-unfriendly interface. The client prioritized the development speed because he is already renting a place for his restaurant and has to start making revenue as soon as possible. The reservation system can be improved in the future.\n\n2) Backward Compatibility (Client) vs. Minimum amount of errors (Developer):\nAll of the information of free hotel rooms is available on the hotel's website, all data is being synchronized within seconds with the Booking service. But after renewing of a website, free rooms are synchronized after several hours what leads to double-booked rooms. The owner asks to return to the previous website state what is impossible since no back-up was made. Developer suggests to fix the synchronization problem instead, as it would minimize the amount of errors.\n\n3) Low cost vs. Ease of learning:\nRegarding a new language learning app, the client is thinking whether she should spend more money into developing a tutorial level for the users to get to know the full functionality or save money for future investments. As an endeffect, she decides for the former one and requires a tutorial level to be developed in form of a mandatory introduction course. The players get a chance to test there all functions including those for premium accounts. And so, the owner makes money from more and more users changing to the premium account for a reason of liking the functions.",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292023,
      "meta": {},
      "text": "1. Good documentation vs rapid development:\nA good documentation requires time and effort. People shouldn't expect a product with a fast development to come with a satisfactory documentation as you have to set a goal: either you finish the product first or you focus on a good documentation while the product quality suffers. Prioritizing both would claim too many resources and time.\n\n2. Functionality vs ease of learning:\nA system with many useful functions might be nice to have but unless the end user doesn't know how every single function works or is an expert in the field in which the system might be used, the end user could be easily overwhelmed when using the system for the first time. Something that would enhance the ease of learning is a clean and intuitive set of less functions. See the saying \"sometimes, less is more\".\n\n3. Rapid development vs robustness:\nInsisting on a rapid development of your product could result in your desired product not being able to live up to your given standards/requirements. Because of shorter deadlines and the wish of a fast release of your product you could risk the quality. Either you get a robust, carefully planned piece of e.g. software or a sloppy implementation with a high risk of failure.  \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1302393,
      "meta": {},
      "text": "A typical design goal trade-off is functionality of a system vs. the usability of it. This directly clashes with the developers desire for a clean system and the user wanting all the possible functionalities. For example, in the team project, the user wants many different use cases to be supported such as seeing ratings, pictures, table layouts, etc. of restaurants. However, the interface must be transparent and easy to understand. The maintainability also must be there as well as the ability to implement new features. Therefore a careful choice of NFRs is crucial. \n\nAnother very common trade-off is Rapid development vs. functionality. In one of my projects as a working student, the client wanted the CRM system functionality to be implemented in 4 weeks. However, with the limitations this is not nearly enough time to implement all of the desired functionalities. Some were not implemented in the first phase, but added on after implementation and deployment. \n\nCost vs. robustness is another relevant trade-off. In one of my implementation products, the client only had a very limited budget, therefore could not afford to have many developers working for a long time. In that case we had to focus on the base case, and disregard some edge-cases that would have taken more time to handle. This means the system is vulnerable to certain actions, and not robust. The client had to invest more, therefore increase costs to create a more robust system.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344464,
      "meta": {},
      "text": "Security VS Cost\nIt is important for the applications to be secure from cyberattacks, especially in the era when information is considered to be the most expensive asset. For the data-driven companies, governmental bodies with secret information, it is important to meet the security needs. It is possible, however with help of ongoing security updates (in order to keep the processes and data stored as safe as possible in web-enabled computer systems), which requires a lot of costs. There are cloud-based options, which should include the use of the Advanced Encryption Standard (AES). But the integration requires a lot of costs.\n\n\nRapid development vs. functionality/efficiency\n Sometimes software developers either need to spend more time on more engineering oriented tasks to get more optimization to save up some computational resources(to go from O(n^2) to at least O(nlogn) for some algorithms), but due to limited time, it may not be possible to implement otherwise it would be detrimental for the functionality (some features of the requirements may not be met). \n\n\nCost VS Robustness\n\nSometimes avoiding the testing may be really costly. One of the most basic and foundational form of testing is Unit testing, which allows to find bugs in the earliest stages, which can save both time and money. This will maintain the robustness of the software in the later stages of implementation.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1351511,
      "meta": {},
      "text": "• Cost - robustness: \nIf you want to develop a robust, safe product of great quality this almost always means that you will have to put in more resources (labor, information, energy, tools etc.) As a result costs go up. Of course you could build an incredibly safe system/product but this would mean that it would be incredibly expensive as well. Therefore, a good balance has to be found between the two factors. If for example you are responsible for an aviation system (and therefore lifes depend on you) you would accept higher costs  for safety. For a bumper games application on the other hand you could accept more system crashes for low costs\n• Functionality - usability:\nOf course a product has to be functional and do what it is supposed to do, but sometimes giving too many options makes it less usable for the end user. Therefore you might accept fewer functionalities for the user if it improves usability. Some people for example prefer IOS to Android because it is more straightforward to use. They might miss out on some possibilities but for them this tradeoff works just fine\n• Backward compatibility - readability\nIf for example, you develop a video game, you might want the version to be compatible with older software, because therefore you will have a competitive advantage (people can use the same games and will prefer you to others.) But this also means that it is probably less readable and more complicating, which might result in time loss. Therefore, the balance has to be found",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1480093,
      "meta": {},
      "text": "1. One example of a design goal trade of is backward compatability vs adaptability. Keeping backward compatibility makes it harder to adapt to changes in Software engeneering, because for the backward compatibility certain things of the system have to stay the same, or similar and can't be changed too much without losing the backward compatibility. The other way around, adapting, and thereby changing too much might compromise the backward compatability.\n\n2. Another example is reusability vs functionality. In order to achieve reusability in the system design, it is important to keep the design as general and non-specific as possible, to be able to reuse the system design for other system. But keeping the system design too generalised might compromise functionality, because the system might lack specific functionality for that specific system. In order too keep it generalised and reusable the system design can't have too much specific functionality.\n\n3. A third example is modifiability vs backward compatibility. In order too keep the system backward compatible, certain parts of the system have to stay more or less the same, or at least similar. In contrast to that modifiability means it is easy to change and modify the system in many ways. But modifying too much of the system sacrifices the goal of backward compatability",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1644954,
      "meta": {},
      "text": "Functionality vs. usability und functionalitiy vs learnability:\n\nEin Formel 1 Auto z.B. hat eine sehr hohes Leistungspotential und sehr viele Funktionalitäten, um dies jedoch zu gewährleisten, müssen sehr viele Parameter / Daten verwaltet werden. Dies macht das System Formel 1 Auto für den Endnutzer, den Rennfahrer, nicht sehr usable. Denn es braucht ein ganzes Team und viele verschiedene Inputs, um dieses System zu operieren. Auch steigt hierdurch die Lernkurve für Team und Fahrer natürlich enorm.\n\nEfficiency vs. performance:\n\nAngenommen wir implementieren eine Software, dann könnten wir diese theoretisch nur in Assembler programmieren. Das wäre extrem effizient, da unser Code nicht sehr viel näher an der Maschine und ihren grundlegeden Anweisungen arbeiten könnte. Allerdings wäre das nicht sehr portabel, da unterschiedliche Systeme (z.B. mobile devices, PCs, Laptops, usw.), verschiedene Prozessoren und damit oftmals auch verschiedene Wege haben diese anzusprechen. In diesem Beispiel würden wir also sehr viel Performance auf Kosten einer geringen Portabilität erhalten.  Java ist zB. wesentlich weniger performant, dafür besitzt es eine hohe Portabilität.\n\nCost vs. Robustness:\n\nUm Kosten zu sparen wird bei der Entwicklung von Software X nicht optimal viel getestet, dies spart Kosten, da der Aufwand dadurch natürlich geringer ist. Nun kann es aber sein, das dadurch einige edge cases oder andere bugs nicht gefunden und demnach unter Umständen auch nicht richtig gehandlet werden. Manche Arten von user input oder Veränderungen im System können jetzt also dazu führen das, dass System eine unerwünschte oder gar keine Funktion mehr aufweist. Es geht also auf Kosten der \"Robustheit\" und führt zu einem nicht sehr zuverlässigen System.\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1292084,
      "meta": {},
      "text": "Functionality vs. usability:\nNehmen wir als Beispiel eine SAP Anwendung. Nutzer A möchte viele Aufgaben auf einmal in SAP erledigen können während Nutzer B SAP zum ersten mal benutzt. B ist daher eine intuitive, benutzerfreundliche Anwendung sehr wichtig, damit er sich schnell in das Programm einfindet. Nun muss ein Trade - off zwischen der Funktionalität und der Benutzerfreundlichkeit gefunden werden. Viele Anwendungen machen das Programm unübersichtlich und sind dadurch nicht besonders benutzerfreundlich. Benutzerfreundliche Programme sind dafür in den angebotenen Funktionen häufig beschränkt.\n\nCost vs. robustness:\nBetrachten wir als Beispiel ein System, das Anfragen vom User erwartet. Wenn zu viele Anfragen auf einmal gestartet werden, kann es passieren, dass der Arbeitsspeicher des Servers voll läuft. In solchen Fällen soll die Applikation nicht einfach abstürzen. Dazu muss das System in der Lage sein, gestartete und beendete Anfragen zu verfolgen und diese zu begrenzen. Solche Handlings müssen implementiert werden, kosten Zeit und gute (oft auch teure) Programmierer. Daher ist das Exception Handlings sehr kostenintensiv. Ist das Budget stark eingeschränkt, kann es also sein, dass ein System nicht sonderlich robust gegen äußere Einwirkungen ist. \n\nRapid developement vs. functionality:\nHäufig muss ein System innerhalb einer bestimmten Frist bereit zur Nutzung sein. Wenn ein Entwicklerteam beispielsweise innerhalb eines Jahres eine hochkomplexe Anwendung, wie ein unternehmenseigenes Rechnungssystem für den Client entwickeln muss, können oft nicht alle gewünschten Funktionalitäten eingebaut werden. Das Entwicklerteam bräuchte dafür schlichtweg mehr Zeit, um eine technische Umsetzung für bestimmte Funktionen zu programmieren, damit diese auch fehlerfrei funktionieren. \nAuch hier gilt es, den goldenen Mittelweg zwischen der zeitlichen Begrenzung und den gewünschten Funktionalitäten zu finden.\n",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1297696,
      "meta": {},
      "text": "- Usability vs. Functionality: The more functions are implemented the more complicated it can get. Its not always nice to have 500 Buttons on one screen. It adds more features but is just really hard to use.\n\n- User-friendliness vs. Runtime efficiency: If a game wants to have really good graphics for the user to enjoy. It might affect the performance of the game and make it barely playable.\n\n- Functionality vs. Reusability: The more functions one implements in one project the less reusable one gets. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1310608,
      "meta": {},
      "text": "Cost vs.  Robustness\nLow cost design won’t check the wrong data, such as page to get free WLAN, low cost and for email address, you can only tap random like aaaaa and you will get passed. \nEfficiency vs.  Portability\nLike using laptop to debug the code , is more efficient than using but telephone is more portable.\nFunctionality\nBumpers exercise deadline is tomorrow and I have 3 tasks to implement.\nYou have to give up 1 task so that you can make it before deadline.\nCost vs. Reusability\nBumpers Cars. If I just write the car part only in gameboard, then easy to code, but can’t be reused for collision. I write the car part as a class and it can be reused but requires more coding.\nBackward Compatibility vs. Readability\nUsing design patterns can maintain backwards compatibility while keeping the code readable.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1317043,
      "meta": {},
      "text": "There exist many designs goal trade-off in Software engineering. The three that I would like to talk about are robustness vs Cost, functionality vs. usability and efficiency vs portability.\nRobustness vs Cost: \nIt has always been a challenge to achieve Robustness at a low Cost. For the production to be robust it needs for example to tackle all the scenarios from the Point of view of users and have a response for every possibility which rises the costs. In Facebook s for example the data base must be redundant in case of data suppression and that can highly affect costs.\n\nFunctionality vs. usability\nSometimes many functionalities can be regarded as a disadvantage in an interface since it would be harder to learn using it from the point of view of the user but at the same time removing functionalities may be a less pleasant experience. For example, a gaming app for children should focus for instance on creating a friendly interface with less buttons and features since kids usually have no big understanding of how the game works.\n\nEfficiency vs portability\nWhen choosing efficiency over portability this can result to a non-portable code and the other way around lack of efficiency can lead to unworthy performance. For example an efficient software exploits the hardware features such as cache memories but when changing the software environment this can result in deficiencies in the software since it is not specific for the other environment \n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1337579,
      "meta": {},
      "text": "Functionality vs. Usability: Es muss oft abgewogen werden, ob es nötig ist, die Benutzerfreundlichkeit eines Programmes zu Kosten der Funktionalität zu steigern. Beispielsweise tritt dieses Problem bei für PCs optimierten Computerspielen auf, die in einer anderen Version auch als App für das Handy angeboten werden sollen. Hier muss auf einige Funktionen verzichtet werden, da ein Smartphone zum einen nur durch einen Fingerdruck bedient werden kann. Damit ist das Anklicken viel unpräziser und Eingaben über eine Tastatur sind während einem laufendem Spiel auch nicht gut umsetzbar. Die Steuerung muss also stark vereinfacht werden, wodurch das Spiel an Funktionalität verliert.\n\nEfficiency vs Portability: Ein Programm ist schwerer effizient umzusetzen, wenn es auf vielen Plattformen verfügbar sein soll. Wird eine App zum Beispiel nur für das iPhone entwickelt, müssen die Entwickler das Programm nur für wenige Modelle mit gleichem Betriebssystem und ähnlicher Hardware optimieren. Soll die App jedoch auf allen gängigen Smartphones laufen, müssen viele verschiedene Betriebssysteme und Hardwarekonfigurationen in Betracht gezogen werden. Eine hohe Optimierung ist nicht möglich, da diese auf unterschiedlichen Systemen zu Fehlern führen kann.\n\nCost vs robustness: Soll ein Programm robust sein, ist das mit höheren Kosten in der Entwicklung verbunden. Ein Beispiel, bei dem eine hohe Robustheit vonnöten ist, ist die Software einer Bank. Kommt es bei dem System zu einem Fehler, kann echtes Geld falsch überwiesen oder sensible Daten \"geleakt\" werden. Daher ist es wichtig, die Software auf alle Eventualitäten vorzubereiten, komplexe Sicherheitsmechanismen einzubauen und mit sehr vielen Testfällen über einen langen Zeitraum zu überprüfen. Das wiederum erzeugt hohe Kosten.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1344419,
      "meta": {},
      "text": "Functionality vs. usability: A programm should be easy and intuitive to use and at same point, should have a wide range of functionality. For example, if you want to offer a table with many features on a website, which displays a table with further user data at each column by clicking a button, you limit the second table to five columns without further buttons to not overwhelm the user with possible features.\n\nCost vs. reusability: It is the tradeoff between cost and the possibility, \n to reuse a program in a scaling way in the future. For example, it is an initial cost to create a shared component (can be an interface) for each feature on a large website, but for the basic features that are used frequently, it is worth creating them.\n\nCost vs. robustness: Is the tradeoff between the cost of a program and its robustness in use. For example, it is costly to test for all possible input from users. It is smarter to put the greater number of tests into tests that are most likely to occur, such as certain characters at login. It is important to focus on the tests that could prevent the whole non-function of a program, for example certain design views are less important.\n\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1346812,
      "meta": {},
      "text": "Efficiency vs protability \n\nIts a difficult choice, because writing efficient code results in a lack of portability (nonportable code) and focussing more on efficiency results in bad performance. It is attractive to focus more on efficiency because of the performance benefits. But for example in our group project we will focus more on the portability aspect because portability matters more to us. We want the code to be portable because we dont want out code to not only runs on one architecture.\n\nFunctionality vs. usability\n\nFor example if you want to develop an App you have to keep these two factors in mind. Because if the systems has to many functions it is hardly usable. So there is a thin line between those two that you have to find. \n\nRapid development vs. functionality\n\nIn todays time development is a very important factor f.e. new better technology is released every year. Wich is generaly a good thing but it has to remain functional. For example if we write code and always add new functionalities to it without checking its functionality it is most likely that the code will be unusable and have many problems. To avoid these problems you have to ensure that the code is reliable before developing it.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1424137,
      "meta": {},
      "text": "Typical Design Goal Trade-Offs\n\n1. Cost vs Robustness/Reusability:\n   The developer should prioritise robustness of their application to uphold the user experience standards, while ensuring that the production costs are minized as much as possible for his own sake. Putting in more finances into the development can increase the robustness and the overall quality of the application, however a lot of the times this can be determinant to company's financial goals. \n\n2. Funcionality vs Usability:\n   Generally speaking, user-experience should be the priority of any modern developer. Ensuring an easy-to-use, intuitive interface is crucial for the products success. Majority of the developed software is targeted at everyday user and as such it should not be overly complex. Increasing the functionality of the software can make it marketable for a more serious audience, however it will also decrease its usability to the actual consumer, as the learning curve of the program becomes far too steep.\n\n3. Rapid development vs Functionality\n The two most important factors to maximizing your profit as a development team are money and time. I've already covered the former in the first part. Time efficiency however, is just as important, if not more. Putting out your product as fast as possible is the key to winning over the customer and staying afloat in today's ever-chaning market. Rapid development can ofcourse have a negative impact on the funcionality of the product as certain features are neglected for the sake of functionality. An example of such case would be cyberpunk 2077, where the developers were trying to bring out the product as fast as possible despite falling behind the initial release data. As a result of this, the release was plagued with bugs and was a major disappointment for numerous fans. It is important to balance out there too in order to stay as efficient as possible while maintaining the quality of your product. \n   ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1425434,
      "meta": {},
      "text": "One typical design goal trade-offs is functionality vs. usability. Having a program with too many functions can result in making it harder for the user to use the platform, because it's hard to remember all the functions, therefore not a user friendly interface.  The Bumper exercise it's an easy game, because they are very few functionalities like start/stop the game which makes it easy to memorize and play.\nAnother typical design goal trade-offs is cost vs reusability.  In most scenarios, clients offer a very small budget for the project and expect a high performance app, but we have to consider if we have to change from one-to-one multiplicity to a many-to-many that is going to cost additional code and testing costs.\nAnother typical goal trade-offs is rapid development vs. functionality. If the client asks for an application to be done very quickly that could mean that functionality of the app, would not be fully implemented, or that new mistakes could appear when using it. Therefore there should be a balance between the speed and quality of the functions we want our product to have. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1463822,
      "meta": {},
      "text": "Cost vs. robustness: \nif the budget of a project is low, the quality of this project will also be low, let's take the example of a hotels booking application, if we hire an excellent senior engineer for 50€/hour, it's not the same as if we hire a freelancer on the internet for 10€. Requiring minimal amounts  translates directly into the quality of the engineers, thus defining the quality of the application.\n\nFunctionality vs. Usability:\nIt is not easy to design a website that can perform complex tasks and yet be simple enough for the intended users to handle. For example, it is difficult to develop a professional video editing application that is feature-rich and very easy and simple to use. \n\nRapid development vs. functionality:\nIf the time provided to develop a project was too short to deliver it quickly, it could compromise some of the project's functionality. For example, if the hotel reservation application was given only 1 week to complete, it could be incomplete; for example, the application could not include the ability to cancel a reservation, because the time given was not sufficient to implement this functionality.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1634231,
      "meta": {},
      "text": "In software engineering and any product development scenario, developers have to choose between goals to achieve a bespoke product for their clients. Of the six trade-offs exemplified in the lecture, three will be further examined here.\n\nFunctionality vs Usability:\nA classic dilemma is whether a product should be a swiss-army knife that may not be as useful for individual tasks, but does it all, or do a few things very well, such that even inexperienced audiences may use the tool without hesitation. A neat example is messaging apps, where Discord (probably just more than a messaging app) has a learning curve due to its bells and whistles whereas iMessage or WhatsApp get the job done and do it well enough that the entire world uses them to communicate.\n\nCost vs Robustness:\nThrowing more money at problems usually doesn't solve them. Still, in this case, developers have to decide whether they'd rather invest more money into making a system more stable or deploy it without checking. If costs can be cut, the benefits also trickle down to the customer, which makes this quite a delicate balance. \n\nEfficiency vs Portability:\nEfficient systems may require more code and more space, but in the end, they might end up being a lot cheaper in the long run. This however comes with the drawback of portability, as not all systems may support such extensive programs. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291304,
      "meta": {},
      "text": "When creating a program , in some cases set up plan objectives can lead to a blockage: a circumstance will emerge where one plan objective must be yielded in arrange to acheive another. When issues of this nature display themselves, the system's improvement group must make a trade-off, and choose which objective is more critical.\n For instance Usability vs Functionality: the software that microsoft has developped for IBM \"MS-DOS\" had a lot of functionalities but to excute any instruction one needed to write several lines of code but with \"Windows\" one was able to excute the instructions with couple of clicks  with the mouse.\n\nAnother example to a typical trade off would be Efficency vs Portability: having an efficient program that does'nt consume all of the cpu, ram and battery is far more important than having it available on all operating systems. Because the most important thing is having efficient software and statisfied customers.\n\nThe trade-off goal Cost vs Reusability is also a popular and typical one an example to it : equipping the phones with performant , expensive and long-lasting batteries is far more convenient than having short-life and cheap batteries that get worn-out in a couple of months. First of all the mining needed for batteries is harming for the environment which will lead to a bad image for the company and also the customers will be annoyed to change the batteries too often that they will end up choosing another brand.\n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291406,
      "meta": {},
      "text": "Cost vs. Reusability \nReusability is the use of existing code in some form within the software product development process. In order to write code that can be reused more time and effort has to be invested, thus more money has to be spent. Oftentimes as companies try to reduce cost to a minimum they pressure coders to finish writing a software fast. This results into bad code that is not reusable for the next software product development processes. \n\nFunctionality vs. Usability\nA software that has a lot of tools one can use creates a steep learning curve for a person that is not familiar with the software. Oftentimes this results in users 'giving up' learning the particular software as it's too complicated for them. That's why, while designing a software the creator should always consider the experience of a new user, focusing on the usability and the user friendliness. \n\nCost vs. Robustness \nFocusing on handling unexpected termination and unexpected actions is a very important part of software programming. Although this part is key it can take up a lot of time and effort for a team to find these 'weak spots' creating additional costs. Thus a sweet spot has to be found. \n\n\n\n\n",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344079,
      "meta": {},
      "text": "Usability vs Functionality:\nThis tradeoff describes the relation between the ease of use of an interface, and the set of functions this interface provides. The bigger the set of functions directly accessible from the interface, the higher is the difficulty of using and navigating through it. As an example, the menu of a game mostly contains three to four buttons, such as \"Start Game\", \"Exit\" and \"Options\". In this case the developers pack less used functions, like all functions needed to change the settings, in the menu button \"Options\", to higher the main-menu's ease of use. The tradeoff in this case is, that changing the settings now needs more user inputs.\n\nEfficiency vs Portability\nThis tradeoff describes the relation between the effort required to run software on different platforms, and the amount of work, time and other ressources needed, for developing the software. In most cases less effort needed to run the software on different platforms, leads to a higher amount of needed developing ressources for creating the same funcionalities, regarding the seperate platforms.  As example developing the same software for different hardware architectures with different computational power, could leed to redeveloping the same functions optimized for different hardware, or even changing some functions because of hardware limitations.\n\nCost vs Robustness\nRobustness of a software is the ability to treat errors during execution and erroneous input without crashing.  In order to provide robustness, recognizing possible error sources and treaten them correctly leads to additional coding and testing costs. As example in the software for coordination of airlines, the robustness of the software is a highly important design goal, for what reason this tradeoff is made without compromises. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344232,
      "meta": {},
      "text": "One typical design goal trade-off is the balance between the funktionality and the usability of the System. The more functionality we implemente, the less usability the enduser has. For example if we want to give the user, in a picture edetting tool, a extensive selection of colours with a little picture for each, we have to balance how many diffenent coulours we want to show(Funktionality) and a good usability, so that the user can find here searchen coulure easiely.\nAnother typical design goal trade-off is tthe choice between low cost wich are in interesst of the Client vs. robustness wich is in the interesst of the end user. For example by developing a server application wich a lot of endusers could use, you have to find the balance between low server and developer costs for the client and a good and fast user experience, even if a lot of users use the application at the same time and maybe one server is overwhelmed.\nOne essential design goal trade-off is Rapid development vs. functionality. It is ecvident that good funktionelity need there time, wich stands in contrest to rapid development. In a university application for example you have to choose if you want to implement a extra chat tool for students in a course, wich will cost time and give more functionelity, but issnt essential for this university application and is in contrast to rapid development.\n. \n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344326,
      "meta": {},
      "text": "A classic example is C++ versus Java. Most notably they are compared in their efficiency and portability respectively. C++ is closer to the machines hardware and allows for noticeably better optimization, while Java's bytecode has the clear advantage of being able to run on any machine that has a virtual machine available for it, without the need for recompilation.\n\nAnother pair of design goals that oppose each other are cost and robustness. For example finding all edge cases in a PGdP-exercise takes a lot of time and effort, even when you have a bunch of tests available to you. Now, in a real world scenario, not only do you not have a broad variety of - or even any - tests available to you from the customer, but also every resource and time spent on covering unexpected input will inevitably result in a higher production cost.\n\nLastly, functionality versus usability: When providing a lot of functionality, a software's interface naturally has to grow. With that, interaction with the system becomes more intricate, previous interactions might now take more steps or need more specification from the user. Searching a database just by a single String might be simple, but doesn't pose a lot of functionality. The more filter-, order- and/or aggregation-options you provide, the more accurate a search becomes, while the interface grows increasingly complex and harder to track.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1387399,
      "meta": {},
      "text": "1. Usability vs functionality\nUsability and functionality are often seen as a trade-off. For example, a large number of functions in one user interface can be a problem that makes this interface more difficult to learn and use. On the other hand, removing functions leads to the loss of functionality and makes our interface less powerful. The typical trade-off between these two aspects of software design is the popularity of functions: some functions that are rarely used can be hidden in the hierarchy of the menus.\n\n2. Rapid development vs functionality\nEvery software project has an expected set of application features. Project manager can deliver less features if the project is running behind schedule, or he can fulfil the task and deliver all desired features at a later time. So, if we are developing some app and want a rapid development, we can not guarantee that we will be able to implement all features that have been asked for and we will potentially have to sacrifice some of them.\n\n3. Cost vs robustness\nRobustness means the extent to which a system or component can function correctly in stressful environmental conditions or the presence of invalid inputs. Such products require longer development periods and a bigger workforce, which comes at a great cost. If the user wants a premium product of high quality, he will simply have to pay more. This is not a case just in software engineering. Example of robust design is umbrella fabric that will not fall apart when exposed to varying environments. So, if we want a durable umbrella, we have to pay more.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1518163,
      "meta": {},
      "text": "One tradeoff could between rapid development and functionality. E.g. a client like BMW would want to have rapid development, so they can launch their navigation app sooner and hence be profitable at an earlier stage. In addition, the developer may also want rapid development so they can finish the task quicker and have more time to work on other projects. However, due to limited time this may result in a navigation app that does not provide all the functionalities, e.g. does not provide voice control,  which is a negative for the end user. \n\n\nAnother tradeoff is between cost and robustness. E.g. a client like Deutsche Bank may want an stock trading tool, but at the lowest possible price. However, the AI tool might not be that robust e.g. it may vulnerable to buffer overflows, and memory leaks. This is not good for the end users which are the traders at Deutsche Bank. \n\nFinal tradeoff is functionality against usability. E.g. a travel company like Booking.com may want to create a travel app with many functionalities like showing reviews, costs, availabilities, etc. But Booking.com might have to sacrifice some of these functionalities, otherwise it may be overwhelming/confusing for the end user browsing the app, especially if it is the first time the user is using the app. \n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1630399,
      "meta": {},
      "text": "1. runtime efficiency vs. portability: Ein Softwareprogramm muss in einer akzeptablen Zeitspanne funktionieren. Für Endbenutzer und Kunden ist es wünschenswert, das Programm so schnell wie möglich auszuführen. Die gewünschte Laufzeiteffizienz zu erreichen und gleichzeitig das Programm portabel zu machen, was bedeutet, dass es ein Minimum an Speicherplatz einnehmen sollte, ist oft ein Kompromiss.\n\n2. rapid development vs. low cost vs. functionality: Ein Entwicklerteam braucht Zeit, um das Programm zu entwickeln. Ein Kunde wünscht sich eine schnelle Entwicklung. Wenn das System ausreichend funktionsfähig sein soll, aber gleichzeitig in kurzer Zeit entwickelt werden soll, dann sind eventuell ein paar Entwickler mehr für das Entwicklerteam notwendig, was die Kosten des Programms erhöhen würde. Wenn der Kunde nicht mehr bezahlen möchte, kann es zu einer Verringerung der Funktionalität des Programms kommen.\n\n3. backward compatibility vs. reuse-ability: Computertechnologien entwickeln sich so schnell in kurzer Zeit. Für ein Programm, das sowohl für die alten Technologien kompatibel als auch für die neuen Technologien wiederverwendbar ist, ist ein Kompromiss erforderlich.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1635705,
      "meta": {},
      "text": "1. Cost vs. robustness:\nWhen making any software, it is always clear that the more a software is funded, the better and more robust it would be. Software engineers always have to make a choice whether to make a software more robust which would cost more, or make the software less robust but will cost less. For example, making a less stable software that is cheaper in comparison to making a more stable software that would cost more.\n\n2. Functionality vs. usability:\nThere is always a tradeoff between functionality and usability. If a software has a lot of functions, it would be much harder to learn all those features or functions. In comparison, removing some features can make software less powerful, but it can increase the usability and user-friendliness. Example would be website building softwares. Some are easy to use with fewer features and others are harder but with more features\n\n3. Efficiency vs. portability \nThere is always a conflict between Efficiency and portability. Efficiency and portability have a reverse relationship. The more a software is efficient, the less portable it is. A more efficient software won't waste CPU cycles and work better, but it would be less portable and be compatible with only a few CPUs, which would decrease the potential selling market of the software. On the other hand, if a software is more portable, it could be compatible with much more devices, but it would be less efficient and would have the same effect on its potential to sell. So\no software developers have to find a right balance between  Efficiency and portability.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1651534,
      "meta": {},
      "text": "1) Functionality vs. Usability: On the one hand, we want our system to have a lot of good functions as possible. In order to achieve this goal we need to expand the features, have lots of different buttons to click. Our other goal is usability, where we want to achieve an interface as simple as possible. To achieve this, we need to cut off some features sometimes. Example: Soda machine in FiveGuys which has 127 different drinks vs the one in McDonald's where you can order just the basics.\n\n2) Cost vs. Reusability: On goal is to have a cost efficient system and the other one is to make it reusable. But if we want to increase its reusability, we need to increase the costs too. For example buying plastics straws for your party is the cheapest option but if you buy glass straws which cost more, you can use them again next time.\n\n3) Rapid development vs. functionality: If there are delays in the project, project manager can deliver less functionality than expected, or deliver the full functionality at a later date. Example: Corona Warn App had very small amount of functions at the beginning because there was the time pressure where it was needed as soon as possible. Most of the functions that it has now came with a delay.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1660374,
      "meta": {},
      "text": "1) Performance vs cost: \nPerformanz und Kosten sind meistens nicht zugleich umsetzbar. Möchte man ein extrem effizientes System, so muss sehr viel Zeit in Entwicklung und Optimierung gesteckt werden, womit die Kosten gleichzeitig automatisch steigen. Wartung etc. benötigt bei optimierten Code auch länger wodurch diese Teurer wird.\n\n2) Security vs usability:\nSichere Systeme könnten beispielsweise viele Passwörter zur Authentifikation benötigen, wodurch die Nutzung erschwert wird.\n\n3) Portability vs Functionality:\nUm eine Software auf mehrere Architekturen bzw. Plattformen anwendbar zu machen, muss man auf Architektur-bedingte Funktionalitäten verzichten und alles sehr allgemein implementieren. Dadurch können gewisse Funktionalitäten einer Rechnerarchitektur nicht angesprochen werden.\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1292059,
      "meta": {},
      "text": "A typical design trade-off is functionality vs usability, for example if you want to design a graphical user interface for a calculator you could either design it so that every mathematical operation and function is immediately accessible, which would make it less usable. But you could also design it so that you have to go to an extra menu for special operations so the initial Interface gets much more usable.\nAnother trade-off is efficiency vs portability, for example you could design a program so that it is optimised for one specific system but wont run on other hardware. Otherwise you could design a program platform independent, so that it runs on multiple systems but not as efficient on any of them.\nThe third design trade-off is rapid development vs functionality. If you only have limited time to design software there have to be shortcomings in the functionality of the system because you need to focus on the most important aspects first. If you have more time you can first implement the basic functions of the software and then think of other functionalities which may be useful for specific scenarios.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1292173,
      "meta": {},
      "text": "Robustness vs. costs:\nCosts represents a design goal (DG) of the client, where on the other hand robustness is a design goal of the end user. An example in Bumpers: There are several requirements by the client. On the one hand he wants to develop a game which has low costs vs. the end user wants that the game should be playable without time lags & crashes. The Trade-off: a robust design of the game is realized, additional costs occur when developers/employees enter the team which result in costs for the client.\n\nUsability vs. functionality:\nFunctionality represents a DG of the end user & usability depicts a DG of the end user. An example in Bumpers: the end user requires 20+ functionalities (select mode or level, stop, start) for the game, but on the other hand the end user wants the game to start within a least 3 seconds. The design-off: quick start on the on hand vs. many functionalities which the game should cover (complexity).\n\nFunctionality vs. Rapid development:\nOn the on hand functionality depicts a design goal of the end user, where on the other hand rapid development represents a DG of the client. In Bumpers the requirement of the client would be that he wants to build the game in less than 5 days by the developer, on the other hand the end user wants that the game covers 15+ functionalities (play online, stop game, start game etc.). The DG trade-off: 15+ functionalities could be not implemented within 5 days of dev. time. \n\n\n\nInfo: Reuse of my last years solution (SS2021)",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1331096,
      "meta": {},
      "text": "Design Goals schliessen sich oft gegenseitig aus. Beispielsweise kann das eine nur erfuellt werden wenn das andere nicht erfuellt wird. Man muss einen Kompromiss finden. Im Folgenden wird an drei Beispielen dargestellt wie solche \"Kompromiss-Design-Goals\" aussehen koennen.\n\nBeispiel 1: Die Software soll innerhalb von einer Woche fertig sein und gleichzeitig viele Funktionen fuer den Nutzer bereitstellen. Es ist kaum moeglich beide design goals zu erfuellen, da viel Funktionalitaet viel Entwicklungszeit fordert. Deshalb man sich darauf einigen muss was das wichtigere design goal ist.\n\nBeispiel 2: Die Software soll sehr viel Funktionalitaet bieten und gleichzeitig intuitiv und einfach zu benutzen sein. Da es meist nicht einfach ist viel Funktionalitaet in einem uebersichtlichen und einfach zu verstehenden Nutzer Interface zu verpacken muss sich am Ende wieder die Frage gestellt werden, ob es wichtiger ist, dass die Software die gewuenschte Funktionalitaet bietet, oder ob es wichtiger ist, dass die Nutzer ein leicht zu verstehendes Nutzer Interface haben.\n\nBeispiel 3: Die Software soll wenig kosten und moeglichst wenig Bugs haben. Da \"wenig kosten\" fuer Entwickler direkt einhergeht mit \"wenig Zeit\" sind diese beiden Design Goals meist nicht umsetzbar. Eine Software die wenig bis keine Bugs hat muss ausgiebig getestet werden, was zeitaufwaendig und somit kostenintensiv ist. Somit ist eine Software die wenig kostet und extrem zuverlaessig ist schlichtweg nicht moeglich. Deshalb muss sich wieder die Frage gestellt werden, was im Kontext des Projekts wichtiger ist.",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1380211,
      "meta": {},
      "text": "When designing a program there needs to be a lot of considerations to be made and that often requires making trade-offs between various dimensions. Depending on the end-user and other factors, one of the foremost questions asked is whether the program should focus more on Functionality or Usability. Functionality can be particularly helpful for a program where the end-user is expert and have enough training. Examples could be the SAP ERP system. Usability may be prioritized when creating an application for the phone, users need it to be intuitive and don’t want to press many random buttons to figure out what to do.\n\nCost and Robustness are another important facet. This budgetary consideration is important for the client to consider how advanced of a system they want including the scope of the project it covers. Perhaps the company requires only a few core features and the software that is developed can save the company 80% efficiency. In comparison, the rest of the 20% which are niche cases may require even more work to develop and of course more expensive.\n\nAnother consideration to make for companies when deciding to deploy and develop software is the trade-off between Rapid Development vs. Functionality. Similar to cost, how fast does the company have time to develop and test the product as well as implement it. Do they want to do a full release or an iterative launch? Do they only want to roll out a few important features first or develop a full-packaged software to the end-user? These are all important things to consider.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1479646,
      "meta": {},
      "text": "Ein typisches Design goal trade-off ist das Gegenüberstellen von Kosten und Wiederverwendbarkeit. Die Seite der Kosten wir hier von dem Client vertreten, der diese möglichst gering halten möchte, weil er z.b. durch ein Budget stark eingeschränkt ist. Auf der anderen Seite steht der Programmierer, der den Code nicht nur für dieses eine Projekt, sondern gerne so allgemein halten möchte, um ihn später auch bei anderen Aufträgen wieder verwenden könnte. Umso mehr ein Client so zum Beispiel für ein Projekt bezahlt, desto mehr Zeit kann der Programmierer in die Individualität investieren. Andersherum wird er versuchen, möglichst viel Code wieder zu verwerten und auf weitere Projekte schauend allgemeiner zu designen.  Natürlich soll ein Programm möglichst funktional sein, doch dadurch steigt auch die Komplexität der Nutzung. So kann die nutzerfreundliche Version vielleicht nur das Grundspiel Bumpers enthalten, was durch einen Knopf gestartet und gestoppt werden kann, die funktionellere Version enthält aber vielleicht noch Einstellungen, eine größere Auswahl an Autos etc. Hier muss abgewogen werden oder vielleicht durch eine Einführung in das Programm oder Tutorials ausgeglichen werden.  So gerät dieser unter Umständen in Zeitdruck, da er sich an kurzfristige Abgaben halten muss, kann dann aber vielleicht nicht die volle Funktionalität aus dem Projekt herausholen, die mit mehr Zeit noch möglich gewesen wäre. ",
      "score": 91.7,
      "language": "GERMAN"
    },
    {
      "id": 1641004,
      "meta": {},
      "text": "Functionality vs. usability: If we look at an app for a store that lets one customize their menus from start to finish, we see that the idea behind it is very interesting. But it can also be very overwhelming for people trying it for the first time or unfamiliar with it. So while the idea is very cool, you would still need to pay special attention to what degree the customisations are necessary or make sense and where it would be better to present default options.\n\nEfficiency vs. portability: The more efficient you want a system to be the more space it will occupy. \ne.g. you´re designing an app, that has many functionalities and you want to run as fast as \t\t\t\t\t\t\t \npossible and not crash even when many users are on it at the same time. Depending on \nwhat the app can do, it might need more storage, which many users would not be happy \n about.\n\n\n",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1645221,
      "meta": {},
      "text": "1. A new cyber security start-up is developing a new security product that works the way that they root all internet traffic over their own server to search for malicious content and immediately filter it. The company was just founded and they do not have much money so they only have one server and no backup. This is an example for Cost vs. robustness since the company depends on that one server and can no longer provide their services if there is any issue. However, a backup server to prevent this downtime would be more expensive.\n2. A mobile phone company has developed a new type of \"mobile\" phone. It is a box of 1 cubic meter and a small screen but it is a new quantum computing machine that is one of the fastest in the world and faster then any other mobile phone. This is an example of efficiency vs. portability since the new product is the most efficient on the mobile market in terms of performance. However, it is not very portable and practical for normal customers used to mobile phones.\n3. A new startup in the tech industry is developing new software for trains. They have to present a prototype of their new software in just one week in front of interested investors. In that one week, they can just build a basic prototype with the main functionalities and do not have time to implement all the other features. This is an example of, rapid development vs. functionality since they did not have enough time to develop everything and thus the prototype lacks some of the planned functionalities.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1656070,
      "meta": {},
      "text": "One of the easiest is Functionality vs. usability. The best example for this is always the UI (User interface, or UX). Sometimes, you design the UI the prettiest way possible and most ascetic and fitting to the game. But that is almost never a good Idea, since it then mostly isn't very functional, and you need to adjust it in a way that the User of the Interface knows what is happening and can easily understand it, even if it is not the prettiest. \n\nRapid development vs. functionality is another big one. Of course, the faster you develop a software, the better, but also the less time you have to really work on it and polish it. The Games Industry has a big issue with this, lately a lot of launches were rushed, and unfinished games came out. That obviously performed below expectations and standards, and all the developers suffer that. \n\nLastly, Cost vs. reusability. Of course, doing every single thing from your software on your own is the best you could do, because then everything would be perfectly catered to you, and you could change it all the way you want it when needed. But that is very costly, money and time wise. So sometimes it is very smart to reuse some of the things you did for previous work, or from libraries or other projects from other people. That way the project gets cheaper to make, but also less personalised from the devs. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291183,
      "meta": {},
      "text": "One of the typical design goal trade-offs in the context of software engineering is functionality versus usability. A software with more than thousand function doesn't main, that it has  a nicer usability and vice versa. For example if there is a software which is for make an appointment for restaurants, hospital , bank and so on for all over the world, but all interactions are completed in more than ten clicks. So maybe this software has a nice functionnality, but it is not easy and convenient to use.\nThe second one is cost versus robustness. Robustness is defined as \"the ability of a system to resist change without adapting its initial stable configuration\". If a software want to be more robustness, the cost will be more. For example if people want design a three A game without any bug. It is maybe possible, but it will cost much more money and time to achieve this. So this game may have a nice robustness, but the cost will be really high.\nThe third one is efficiency versus portability. If a software with high efficiency, the portability will be low and vice versa. For example a software for search engine can run on all desktop operation systems (Windows, macOS, Unix), but all interactions need more than 1 minute. So this SE has a good portability, but the efficency is quite low.\nTo sum up, we should balance all design goal trade-offs from two sides, to design a good software.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1291661,
      "meta": {},
      "text": "Functionality vs. Usability: The more funtions a software has the harder it gets for users to intuitively use the software. Therefore a High funtionality leads to an low usability but an high usability leads also to reduced functionality.\n\nRapid developement vs. functionality: The more functions a software has the longer it usually takes to develop it. Therefore a rapid developement is only possible with low functionalities.\n\nEfficiency vs. portability: Efficeny can be reached e.g. if there is not a lot of different code to be executed. Portability can be reached if e.g. Bootstrap is used for the Frontend which is responsive but also reduces the overall efficency.",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1293633,
      "meta": {},
      "text": "One of the core design trade-offs is related to speed. Focusing only on speed often leads to limited reusability of the code. Focusing on reusability leads to moving from \"project\" to \"product\", saving time in the future, as the reusable code can be re-applied. E.g., a university app, developed specifically for one university. Focusing on rapid development, the app is developed to ingest specific data sources and give a specific output. Focusing on reusability, development would be focused on general interfaces and APIs for data management, and would provide a more generalist system, applicable also for other universities.\n\nA second trade-off focuses more on the users preferences in terms of functionality versus usability. While a system can provide a long list of functions (example would be Photoshop), this might not appeal to users, not able to handle the large amount of functionality. Focusing on usability by reducing functionality can provide a simple / accessible system, e.g., Canva, but might also lose other customers.\n\nThe third trade-off is between backward compatibility and readability. While a system can be designed to also speak to previous versions of OS and hardware, this can be difficult to understand for new developers. An example would be game development for playstation, having significant differences in hardware and operating system over different models. When focusing on building code applicable for all previous versions, it becomes difficult to understand for new developers, which part of the code is motivated by which system requirement.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1294186,
      "meta": {},
      "text": "Cost-Robustness: To reduce the costs, the team might have to give up on the robustness of the project. For example, if you test your your software with only some specific inputs in order to finish your project in less time -which means less money-, you can reduce your costs. However, you can't be sure if the software doesn't crash with some edge cases, which affects the robustness of your project.\n\nCost-Reusability: Reusability can also be a trade-off against cost. For example, if you code your project just for a specific case that will be used in that project, you can implement it in less time because you don't have to generalize the problem and you won't have to think all different cases. However, this affects the reusability of the code. This way, you won't be able to use your written code in another project or method, because of the fact that you implemented it only for that specific problem without generalizing it. \n\nEfficiency vs. portability: Efficiency vs. portability is also a typical design goal trade-off. For example, Safari works really well on Apple products (battery efficient, fast...), however it doesn't works on microsoft, which affects its portability.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1323352,
      "meta": {},
      "text": "One trade-off is between cost and robustness. If you want to keep the cost of your product as low as possible the chance is high that less testing will be done to catch errors and bugs in the software. As a consequence the system will be less robust and could break down or react in unexpected ways to rare behaviour of the user that was not tested in the development process or be vulberable to security issues. For example an user choosing an unforseen sequence of options could crash the system.\n\nAnother trade-off is functionality versus usability. Giving the user a lot of options at once can overwhelm them and sigificantly lower the usability and user-friendliness. On the other hand a more minimalist approach could lead to the user not being able to find and use the function they need. As an example a text editor with a hundred different buttons might have very useful fuctionalities but will need a lot of time to learn and can lead to a lot of frustration for the user who might prefer to use an editor with less visible options and more hidden advanced functions.\n\nThe trade-off between efficiency and portability is that the more systems you want to run the more work has to be done to increase efficiency. Since efficiency can be quite dependent on the system you usually have to choose between a very efficient software running on one or a few systems or one that runs less efficient on a lot of systems.\n\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1332658,
      "meta": {},
      "text": "Design goals define how the software is structured and how it works. Design goals are influenced mainly by three parties: Clients, Developers, and End Users. All these parties have different expectations - or requirements - of the software, which often stand in contrast. Thus, trying to fulfill all requirements often requires making trade-offs. Here are three examples that showcase trade-offs in design goals:\n\n1)  Backward compatibility vs. modifiability: A client may expect the software to be backwards compatible in order to be able to run it on older environments (e.g. older windows systems). Backwards compatability might cause obstruse, messy and just an overload of code. As a result, modifications might require a lot of changes (if backward compatability should be maintained), resulting in a high workload.\n\n2) Low cost vs Fault tolerance: A client might wish for low costs in development while a end user would like the app to have a hight fault tolerance. A low budget might limit the developer in making the application fault prove, because the limited resources (money) force him to only implement basic functions that are required by the client.\n\n3) Rapid development vs Well-defined interfaces: If a client needs an ad-hoc/ fast solution he might request the rapid development of an app, but a rapid development might leave a lot of gaps that need to be closed later on. Therefore it conflicts with the idea of having well-defined interfaces, because they usually require time to be developed.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344162,
      "meta": {},
      "text": "One typical design goal trade-off would be security vs ease of use / usability.\nTo have high security, the app could require each user to have a long password, have 2FA enabled and automatically log the user out after 15 minutes of inactivity.\nThis however is annoying for the user, as he has to remember a long password, has to open an authenticator app on his phone and copy the displayed code whenever he wants to log in or is logged out automatically.\n\nAnother typical design goal tradeoff is low cost vs usability and aesthetics.\nFor the app to be usable and nice looking, one would hire UI/UX designers. Those however wont design your app for free, so that the app will cost more money.\n\nA third design goal trade-off would be backward compatibility / portability vs readability of the code.\nMost programming languages evolve to have more features which make developing easier and more readable, like switch expressions or Pattern matching in Java. These features will need the newer version of the language, in this case Java 14/16, while the old system, the app should be compatible with, might only have Java 8 available.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344315,
      "meta": {},
      "text": "In the process of designing a system a developer needs to make trade-offs between the design goals for the project, as many of them are in direct confilct with eachother.\n\nOne such example is the trade-off between functionality and user-friendliness. As a system grows in complexity and possible uses it becomes more and more difficult to convey its features to the user in an easy to understand way. A user might feel overwhelmed if presented with too many features at once. That could lead to an unwillingness to interact with the software.\n\nAnother conflict emerges between readability and backwards compatibility. As hardware evolves it gives the developer more tools to realize his/her projects. But in order to remain backwards compatible with older hardware these tools may have to be ignored and older, more complicated solutions may need to be employed. This leads to code that is more difficult to grasp, especially if a future maintainer of the code has no experience with the conventions of the older hardware.\n\nA trade-off also needs to occur between cost and robustness. A lot of time and money is needed in order to confirm proper safety and security standards. If the budget for a project is too low a developer may be forced to neglect complex encryption of data and extensive error handling in favor of simpler security measures and band-aid fixes. This can be catastrophic if the system deals with confidential user data.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1344756,
      "meta": {},
      "text": "There are many design goal trade-offs. One of them is the efficiency of a system and the portability. When a system has to run on many different platforms or for example processor architectures. It can't be specifically focused on one, it has to support all of them. That means that the hardware can't be used to it's full potential and efficiency is lost.\nAnother trade-off is the functionality and usability. The 3d software Blender is a good a example for this one. It is a very complex software which includes a lot of features and functionalities. That means many very overwhelming user interfaces with a lot of buttons and sliders. Removing those complex user interfaces to make it more useable would make it easier to use for beginners, but professionals would complain because of the loss of features and functionalities. That's where you have your trade-off!",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1365733,
      "meta": {},
      "text": "Functionality & Accessibility: Adding features makes the product more complex, thus makes user access more difficult. On the other hand, simplifying the application may result in a less streamlined experience for expert users.\n\nUptime - Maintainability: Maintaining a system that is required to have a high uptime is significantly harder than maintaining while the system is being taken down and tested to ensure security, expected behavior, etc.\n\nEfficiency & Platform-independence: Very efficient applications work with the hardware they run on directly (using registers and HW modules), which can't be done with platform independent programming (Java for example).",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1366316,
      "meta": {},
      "text": "1. Functionality vs. Usability\nUsually you want to make a system/program/application have as many functionalities as possible, let's say an ideal system could do just everything. But on the other side you also want it to be as easy to use as possible, you don't want your users to get confused by it. Too many functionalities can make your program look confusing, so you need to rethink which functionalities are really \"good\" and needed for your system and how everything still stays \"easy to use\".\n\n2. Cost vs. Robustness\nSurely you want your system to be as robust as possible, to work well even in the worst possible scenarios, or changes. It should maintain its functions even if there are wrong inputs or rapid changes in the environment.\nBut on the other side this can get deep in your pocket and will make you pay a big amount of money if you want your system to be \"inviolable\". You also have other segments where you need to put your money in so you should not give in more than needed into the robustness (just if it's explicitly made for extrem scenarios)\n\n3. Cost vs. Reusability\nIt's like in the real world, cheap things (normally) aren't made to be used for the \"eternity\". Look at plastic bags, they are cheaper than cloth bags, but will also tear easier. So you need to put in money to make your system be more reusable, but it's like in the point before, if Reusability isn't your only sector to focus on you should find a good point to make it as reusable as it needs to be but nor perfect.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1396368,
      "meta": {},
      "text": "1. Cost vs. reusability\nFor example the developer wants to save money on testing and we need to reuse the code for the different application which consists of more classes and functions someday. Unfortunately code was only for certain amount (e.g. for 1-1 relation) of modules, so it is complicated to reuse the code for the another application.\n\n2. Rapid development vs. functionality \nFor example the developer wants to bring one app fast on the market. The problem is, that in short amount of time it's impossible to make the code work without any big issues. As a result users will have troubles using the app.\n\n3. Cost vs. robustness \nFor example the developer wants to save money on testing and brings the app on the market. By registration the user has to register with the zip code but the app doesn't check if it is legit.\n\n",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1434872,
      "meta": {},
      "text": "Design goal trade-offs can be interpreted in various ways actually even though they are typical. To begin with, if we consider the \"rapid development vs. functionality\" trade-off first approach could be trying to create the first version of a system as fast as possible depending on some pressures that could lead the developers to hold each phase as short as possible, i.e. during system design acting fast could cause to leave out some important requirements and once they continue with the object design it would be the case that to not slow they could leave out this feature which actually improves functionality over-all. Another approach could be about the development tools if the developers chose to complete a project fast and with least afford possible they could go on with out-dated methods since they have previous experience and this would also cause less functionality at the end compared to competitors' applications maybe. \n\tTo go on with \"efficiency vs. portability\" we could interpret this trade-off as, if the developers or the client wants to have a wider user set, they need to give up on some advantages of OS specific features. For example, if the intention is to design a game fit to both mobile phone and computer hardware the implementation would have additional parts for sure. \n\tFinally considering the \"minimum number of errors- functionality\" trade-off it is obvious that users would like to have the applications they use as satisfactory as possible but once the application gets more complex it is not easy for developers to maintain the performance.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1437294,
      "meta": {},
      "text": "Die Kosten sind das Design Goal, dass vermutlich am meisten andere Design Goals einschränkt, da man mit geringeren Kosten beispielsweise weniger Möglichkeiten hat für Robustheit des Programms zu sorgen. Hier wäre es beispielsweise möglich anzuführen, dass man mit mehr verfügbarem Geld mehr Tester engagieren könnte, wodurch mehr Fehler frühzeitig erkannt werden können und damit auch wieder behoben werden können, bevor das fertige Produkt an den Kunden herausgegeben wird.\nAuch die functionality ist oftmals ein trade off mit der usability, da viele verschiedene Funktionen zwar der functionality helfen es aber beispielsweise für einen unerfahrenen Nutzer schwierig machen können die Nutzung des Programms schnell zu lernen.\nAußerdem ist rapid development oftmals ein trade off mit der functionality. So können beispielsweise mit mehr Zeit mehr Funktionalitäten implementiert werden oder bei bestehen auf einen engeren Zeitplan im Umkehrschluss weniger Funktionalitäten implementiert werden.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1646937,
      "meta": {},
      "text": "Cost vs. robustness:\nto program a robust software usually more time is required (for testing, to write code with great readability and maintainability). More time also means more costs, and therefore you have to find the right balance for the project.  \n\nEfficiency vs. portability:\nI think java is a great example: It uses a vm to be highly portable and to run on a wide variety of different hardware, but you also lose a bit efficiency through that vm (in comparison to other programming languages like C++)\n\nRapid development vs. functionality:\nA few months ago I participated in a hackathon where the time is the biggest constraint, and we therefore had to scrap a lot of nice ideas (functionalities) and had to focus really on the core functionality in order to deliver the software in-time",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291306,
      "meta": {},
      "text": "A desired design goal of the client could be a relative low cost of the maintenance and development of the product. But what if in order to compensate the user emergence and guarantee an flowing, stable service the developer decided that a high amount of servers will be need to handle the immense user data. In order to achieve the goal of an robust, stable service the clients goal needs to be canceled.\n\nAnother problem could be efficiency. Some relative low level developments need languages like C. If you try to meet the condition, the developments goal to utilize this language to build a highly efficient system you will meet the problem that this possible users goal cannot be met: portability / adaptation. C only runs on the system it has been compiled on. The product will be highly efficient in its cause but won't be able to be adapted on another system. The developers goal will be met but not the end users. Or you could even say the clients goal because less compatibility means more costs and more development time until a finished market ready product.\n\nThe last conflict be if the client wishes for more functionality, more features, more possibilities. The developer wants a more defined structure, a well defined project to work on. The problem here is that as soon as there are more functions, more features for the end user to use the more room will be for miss calculations, for errors and it will be way harder to find bugs and treat them. They need to find the right balance in order to maintain  a working system.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291732,
      "meta": {},
      "text": "1. Often there is a tradeoff between usability and functionality. In order to ensure a complete functionality, complications will have to be added to the user interface that impair learnability by hindering a quick and intuitive understanding. For example in developing the flight system for the group project, a usable flight search interface includes simply a departure and arrival location as well as the date. In order to refine the search, adding more options such as ticket type and class seating leads to a more cumbersome interface that occupies more screen space and requires more explanation.\n\n2. Backwards compatibility is typically at odds with maintainability. To offer continuous support for outdated versions means complying with the standards for these versions, which potentially creates redundancies and makes the system inflexible. A notable example is the many critical finance systems that still run on COBOL, in the modern age it is increasingly more difficult to find developers who are familiar and competent in the language to maintain the code.\n\n3. Performance also tends to conflict with portability. To achieve performance usually involves implementing optimisations, and optimisation is most effective when the specifications of the end user machine are well defined. This decision must be made when choosing a development language. Java for example runs reliably on anything due to higher abstraction, whereas C++ compiles into binary and therefore executes faster.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292604,
      "meta": {},
      "text": "Functionality vs. Usability:\nHere Functional and non-Functional requirements have to be weighed against each other and priorities have to be set. Increasing either one means setting back the other since by adding more features to the product while the Functionality increases Usability also falls since the UI will necessarily become more convoluted. An example of this Problem are sites like bitbucket or Jira which have a high learning curve to get started, meaning low Usability due to the amount of unknown features for new users,  but in turn having high Functioniality for Users who know how to use the various systems.\n\nRapid development vs. Functionality:\nHere the Team has to be careful not to overdevelop the product at the cost of spending too much time on not necessarily needed features as to not overextend their time window. If for Example the client requests the Product to be usable by 6 weeks time, the team may have to forsake some non functional requirements or quality of life features in order to quicken the development process and be able to delive the core functionalites on time. A practical Example of that would be video game studios having to ship games with bugs to get release on time, meaning the didn't Focus on Rapid development enough.\n\nEfficiency vs. Portability:\nLastly on this point a similar argument to the previous one can be made. when weighing Efficiency against portability you have to take into consideration both what the end user is most likely to be using as their operating system, and which operating system would be the best for the application function wise. an example of that would be Docker servers which while possible to set up on a windows system, run far better on Linux OS.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1295836,
      "meta": {},
      "text": "For example a common trade-off are the costs vs. the robustness because to build a robustness software means among other things that to include boundary cases.   These cases take a lot of time to determine them an to find a solution. \n\nAnother typical trade-off is the rapid development vs. the functionality, because if there's time pressure to develop a new software, there's not enough time to satisfy all functionalities. \n\nA third example is functionality vs. usability. A system like SAP uses lots of functionalities (ERP System with a lot of additional modules e.g. for HR) but it's not usable without getting teached because it's too confusing for the user.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1299573,
      "meta": {},
      "text": "Low cost vs. robustness\n-> Due to the limitation financial ressources you can not test every edge case or every possible input a user can make\n\te.g. with your budget you can hire only one person for testing although more people would be \n\tnecessary to finish the project in time\n\nRapid development vs. functionality\n->Since the time is limited maybe not all functionalities can be implemented:\n\te.g. you have three months to build a system like \"TUM-Online\", but it is not enough time to \t\n\timplement the functionality \"calendar\"\n\nEfficiency vs. portability\n->the system you build could be much more efficient, if you build it only for one specific device\n\te.g.  if you build a system for automated driving, it can be more efficient, if the system can not run \non every computer, only on a specific \"Auto- computer\" with a different processor\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1300902,
      "meta": {},
      "text": "Functionality vs usability:\nConsider conventional text editors like Notepad++, and on the other hand, Vim. Goals in development of conventional editors are usually high usability: Minimalistic UI and straightforward navigation with mouse. As such, conventional editors sacrifice functionality, in contrast to Vim, which follows the philosphy of providing maximally efficient workflow environment by being directly available in terminal, providing large amounts of shortcuts and macros. Vim, however, has generally much less usability than conventional editors: learning the shortcuts and macros to navigate efficiently takes much practice and requires you to use them frequently in order to retain them.\n\nEfficiency vs portability:\nSuppose you develop a client program for pdf document management and manipulation. Some of the functionalities like running OCR or upscaling on all pages in a large pdf may be computationally intensive, so efficiency is important. On the other hand, you want your software to be portable to easily reach large parts of the market. To make the software efficient you could use C++ with libraries  that allow you to target hardware more directly, which however leads to the software becoming less portable than say a Java implementation, because it may use features of hardware architecture that are not generally available on all systems.\n\nRapid development vs functionality:\nSuppose a Minecraft update introducing a new biome and mob is in development, and it becomes clear that the update cannot be released with full functionality in the given time frame. There are two options: Either the update has to be released with less functionality (e.g. include only biome, not mob) or the development time has to be extended for a full release.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1305122,
      "meta": {},
      "text": "Usability vs. Security\nThe product should be secure and easy to use. For security reasons, multiple identifications may be required when logging in. On the other hand, you want your customers to like and be comfortable using your product. \n\nRapid development vs. minimum of errors\nThe client wants to deploy the product to the user as quickly as possible to make money. There is a defined delivery date, requiring that all functionality be completed by that date. Therefore, there may be fewer checks and tests for the system during development, making the product more error-prone. \n\nSpecificity vs. Generality\nThe system should run efficiently and have all functionalities according to the user's wishes, but also be portable to multiple platforms.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1319154,
      "meta": {},
      "text": "1.) A big challenge is of course balancing the client's need to have everything be done cheap against the developer's need to make everything as robust as possible. Especially in security, a client might not see the need to spend money on something that isn't directly tangible.\n2.) Of course, depending on the system, it always has to be taken into account how efficient and portable a system is. The more directly a system can use the hardware, the faster it gets, but this leads to incompatibility with other hardware. Mostly, there needs to be a healthy compromise between the two.\n3.) How quick a software can be developed often makes or breaks a product. Too fast development time may lead to compromised functionality, so finding the golden middle is crucial.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1334490,
      "meta": {},
      "text": "Cost vs. Robustness:\nNo one can deny that coping with errors and handling them is an important optimization process that assures a robust and a high-quality system. Nevertheless this process can be really expensive and thus costs a lot of money, which will probably contradict one of the client's most important requirements; cheap cost. So arises an important  question is every cheap product unqualified? Can a product be cheap and handle errors at the same time? Well of course, everything comes at a cost and the more expensive a product is, the more robust it will probably be. For example, if you want your video game to be able to monitor errors and bugs, you'd have to pay highly qualified software developers who would probably need a long time to establish a robust system.\nFunctionality vs. Usability\nIn order to be successful, a system needs to be both functional and usable. And in order to be usable, its main functions need to be clear to the end user in terms of simplicity. A complex system will probably achieve nothing but a hard learnability for the user. Unnecessery features should always be avoided. A remote is a great example to that. If we really think about it, the more buttons a remote has, the less easy it would be for the user to understand its different functionalities. We should keep it functional and simple.\nRapid development vs. Functionality\nThe faster a system is developed, the more satisfied the client is. However, can we reach high quality when the speed is the project motto?  If a system is developed in a small time, it will be  for example no time for testing its functionality, which may harm the system instead of benifiting it. The fast food is great example of that; it is indeed made in a couple of minutes but will never taste the same as a cooked meal at Grandma's house.\n ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1336320,
      "meta": {},
      "text": "1: Time to delivery vs. quality of product\nOne thing a developer learns relatively fast is, that time correlates to good code. I myself have for example written an entire App within a week and the code was barely functioning. It did what it was supposed to yet I am to this day embarrassed. I have written precisely zero tests or documented anything.\nThis is relatively standard since reviewing your code takes time from you, that you can spend on writing new code. Therefore you have to decide between speed and quality\n\n2: Adaptability vs. Performance\nWhen writing code you can either focus on performance or on the ease of adapting your code. I for example have written a program that could parse mathematical equations. I implemented it so that it could be expanded to new types of mathematical calculations simply by adding one line to a config file. A friend of mine then told me he could write the same program that could run 2,3 times faster than mine in a shorter program. While his code was indeed faster, he could not just add new computations.\n\n3: Safety vs. low Price\nI have once done an internship at a startup. They build custom software for a low price. Since the budget only allowed for 5 developers on the specific project, they did not allocate one developer for safety checks. The client then later complained that when he performed edge-cases on the code, it would crash.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1340355,
      "meta": {},
      "text": "Of course we would always want our software to be as efficient as possible. This might mean using certain hardware-specific features. Oftentimes this makes the software less portable since hardware differs. If we are building software that should be accessible to people on different systems, like Doctolib, one would decide to program in a portable programming language like Java rather than Assembly. Furthermore with technological advancement, programming with portability in mind can facilitate adjusting to future platform changes, which is beneficial since often a slightly less efficient yet usable software is still better than a possibly not usable one in the near future.\n\nFunctionality and usability can also often clash during software development. Functionality encompasses the things one can do with the software/ the functions it provides. Usability on the other hand is about the ease at which a client uses the product. When developing a website for example, the goal is a product which provides the needed features, while still remaining concise and well laid out. It is important to balance both out since the user expects the required features but won't benefit from services that are too complicated for him to use.\n\nLastly, while effort goes to keeping costs as low as possible since a client can't or doesn't wish to spend for than needed, building robust software takes more time and effort and thus is more expensive. A car's software system for example should definitely be able to handle invalid inputs and stressful environmental conditions for user's safety. In consequence, it is important to not save on important aspects such as robustness, while still not going overboard costwise.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344642,
      "meta": {},
      "text": "1- Cost vs Reusability: Even though today this is not that much of a trade off, back in the days increasing reusable patterns would require costlier operations. Clients would want less cost, and developed would want more reusability. \n\n2- Functionality vs Usability: Functionality defines what the system does and the purpose of it. Most of the times increasing functionality decreases usability. It is because adding more functions to a system make the system unusable with a good chance. Think about a professional audio editing program. This program might have tremendous functionality however, it is likely that an average user would not be able to even trim an audio because of the complexity. \n\n3- Rapid development vs. functionality: This is a conflict between the client and end user. Rapid development can decrease the functionality because with the rapid development, the development team might not be able to accomplish all the items in the product backlog, or in the functional model. They might create a working base to be able to satisfy the client, but this might not satisfy the end user.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1346456,
      "meta": {},
      "text": "Usually there is a common tradeoff between effiency, cost and usability.\n\nTo make something efficient, it is required to forfeit time and usability to achieve an optimum of effiency. If you want to find an efficient algorithm for a new problem this is usally very costly in either time or spending on workers.\n\nThis can be observed by looking at projects of the same type developed in Python and C. Developing in python is fast, the resulting program isn't very efficient due to tradeoffs took in Pythons programming. Developing in C usally takes longer but due to close hardware usage of C the program can be very efficient.\n\nIf you want a cheap project, it is going to lack effiency and usability due to missing developing time caused by missing fundings.\n\nThis problem can be seen also outside the developing world in BER and Stuttgart 21, german building projets that were planned very cheap, but due to reevaluation cost the tax payer millions due to bad design decisions.\n\nLast, the usability can impact effiency and cost due to efficeny usally requiring to forfeiting usability and likewise the other way around. The increased cost is due to more or more skilled workers required to realise such a project.\n\nThis is a thing that can be observed by Apple products. Due to their usability features become they very inefficient for at least special use cases and very expensive due to their long product development.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1363116,
      "meta": {},
      "text": "High Performance vs. Rapid development:\n\nWhen developing on a tight schedule to ensure that the project will be deliverable as fast as possible, it can get difficult to ensure that the program has the best performance possible as well. When there are strict deadlines, the developers have to make sure that they are always on time with their coding. In this case, performance issues could be neglected. Now on the other hand, when focusing only on high performance, the developers could get stuck reviewing the same code over and over again just to improve the performance on a small scale. In that case, the delivery of the product could get delayed for a significant amount of time.\n\nSecurity vs. Usability:\n\nSecurity and usability are also two things that sometimes can collide. Take two-factor-authentication, for example. Obviously, it increases the security of the system, but when a user has to confirm their identity with a second device every time they want to log in to the system with another device, they can get annoyed by it. \n\nMinimum number of errors vs. readability:\n\nWhen aiming for a minimum number of errors in developing a system, the developer always has to pay attention to any edge cases that could be presenting themselves in the future. A system that interacts with a user, like DeepL for example, where the user presents a text to the system and the system has to translate the text, has to know what to do when the user adds a word that doesn’t even exist. The developer has to have edge cases like this in mind and make sure that they don’t crash the system. Intercepting more edge cases however, often makes the code more incomprehensible and less readable.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1475984,
      "meta": {},
      "text": "1. low cost vs. good documentation: often, there is only enough money to create the product itself, and in the end there are no resources left to create proper documentation. This leads to bad, or even no documentation.\n\n2. Backward compatibility vs. Maintainability: Keeping a product backwards-compatible is very important in many scenarios (e.g. to make sure not to break third-party integrations). But it also means, that a lot of old code has to stay in the codebase, supporting old endpoints and mechanisms. This may make the code less maintainable.\n\n3. Minimum # of errors vs. Rapid development: Minimizing the number of errors and covering all edge-cases in an app takes a lot of times for things like unit testing. This inevitably slows down the development.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1491481,
      "meta": {},
      "text": "In virtually any sort of product you produce, the production team will have to make some hard choices about what they want to prioritize. Those priorities come at the cost of other things. This min-maxing/balancing act is called a trade off.\n\nOne of these typical design trade offs in the context of software engineering is cost vs robustness. A product can be exceptionally robust, it can have handling for all bugs and exceptions, but that will take a long time to implement, and as the saying goes, time is money :D which is to say, it will cost a lot more to make the product as robust as possible.\n\nAnother example for a trade off for this would be rapid development vs functionality. This hits close to home, because just 2 months ago I had started a project with a friend, currently at around 50k lines of code, which only took us a month to finish. However, this also meant the project was riddled with bugs, since we were more focused on getting shit done instead of making sure it worked. In the end, we ended up spending another month just testing all the functionalities of the project, which did turn out to be quite useful and popular\n\nLastly, I would mention the trade off between efficiency and portability. This tradeoff happens due to the fact that, to make a product as efficient as possible, you have to know the limitations of the device you're working on. If you gear a product towards one software/hardware choice, it will have problems working in other platforms,  ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1558911,
      "meta": {},
      "text": "Functionality/ usabilit:\nmore functional a system is it can negatively influence its usability.\nFor example in the bumper car we now allow the car not only to steer but also jump shoot at other cars, role a dice to improve its odd of winning and switch collision type from left side to right side on demand depending on which direction the system's car is approaching. although now our player car has more functionality. it takes a lot more clicks and movement to control the car. in past when car could only steer only one key needed to be pressed now4 keys.\n\n\nCost/ reusability: running a system for a long time can be very costly. For example  if we have two battle royal video games both are based on one time purchase model. but one game tries to be reusable and let the server run for longer time. and running the servers can be really costly.\n\n\nBackward compatibility/ readability: backward compatibility is successfully use interfaces and data from earlier versions of the system or with other systems. this  can negatively influence readability and thus the matainbility of a software. For example The x86 family of microprocessors has backward compatibility with the 16-bit Intel 8086 processors released in 1978. however this makes the design of these microprocessors more complicated with more useless instructions that make programming for them less readable.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1661687,
      "meta": {},
      "text": "Design Goal Trade-offs\n1.\tOne of the hardest trade-offs in system design is Time vs. Accuracy.\nNo matter how short the system will take to deliver an answer as long as it is incorrect then the system is wrong. Efficiency should never overpower the correctness of a system.\n2.\tFunctionality vs. Usability can impact the order in which operations appear in a menu of an application. The simple and often used operation would be found at the top and the more complex ones would be at the bottom.\n3.\tPortability vs. Efficiency. Some of the most efficient systems are rarely portable.\nHowever, good portability often reduces the need for user training. \nIf for example, a client requests a program for a fixed platform, ensuring that the system is portable would be rendered insignificant compared to the program’ efficiency\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1296989,
      "meta": {},
      "text": "1.\nA typical trade-off in software engineering is Rapid development vs. funtionallity. The client typically wants to have his finished product as fast and with the most features as possible.\nBut these two conditions contradict themselves. If the development team does not have much time they cannot implement as many feature as they could with more time.\nSo the client have to state what the most time is he can wait and what the minimum functionallities are.\n\n2.\nAnother typical trade-off is efficiency vs. portability. If a development team knows that their software only has to run on a specific hardware type or device they can tailor the software perfect for this device and make it more efficient. But if they have to make sure their software runs on many different devices they propably have to adapt the software and lose a little bit of efficiency \n\n3.\nAlso typical is the trade-off between functionallity and usability. If the software should have a lot of different features and funtionallities it is very hard to keep the software easy to use because you have to get all these funtionallities in one interface.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344732,
      "meta": {},
      "text": "1. Functionality vs. Usability: As a developer, one must consider that sometimes, less is more. EX: Giving users a product that is convoluted, has 100s of different features that could be edge cases for the product, or an incredibly messy UI that is hard to understand or learn makes the end product suffer. It's very important to always consider usability, and that if many functions are important to deliver on, that even more time goes into a UI/UX layout to make sure that this software is also easy to use.\n\n2. Cost vs. Reusability: Classically, if one built resuability into a system, it was 'harder' or 'more costly' than not, ergo leading to this tradeoff (one-to-one multiplicity). EX: Allowing older generation games to be played on a new Playstation. However, if one moves to a many-to-many design, one can get resuability with low cost via design patterns, changing this tradeoff for the future.\n\n3. Backward Compatibility vs Readability: Software may change dramatically over time, and with that change, sometimes old methods or systems are deprecated internally in favor of new ones. EX: Excel 2016 working on Windows Vista until 2022. To maintain backwards compatibility can lead to bloated classes, confusing developers and hurting readability. It's important as a software designer to always balance clarity and legacy support to both not get stuck in a feedback loop where code becomes increasingly difficult to update due to compatibility issues, and not have angry legacy customers.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1355056,
      "meta": {},
      "text": "1. development speed vs. budget:\n\tThis is more for the client ordering something, but if a company wants to for example be able to catch up with a competetor quickly to not fall behind on the market, tehy will probably be willing to spend more in exchange of getting their product quicker. On the other hand, if the budget is very low, less developers will be allocated -> less speed\n\n2. flexibility/portability vs. maintainability:\n\tOne of the arguments Apple-users sometimes bring up is that since Apple only has one kind of system they can update older existing devices on a regular basis. Android in contrast runs on Samsungs, Huaweiis, etc... so it is harder for them to maintain their old products.\n\n3. scalability vs cost/availability:\n\tCompanies like Facebook/Meta, who are responsible for Instagram or WhatsApp need to ensure that huuuge amounts of clients can use these apps simultaneously. To be able to do that they have to spend quite the amount of money for giant server plants to also keep the systems available for 99,9% of the time.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1469555,
      "meta": {},
      "text": "As opposed to an open layered architecture, a closed layered architecture increases portability and reduces coupling, increasing maintainability, and reducing software complexity, making it easier to find and prevent bugs. However, it can potentially introduce bottlenecks that reduce performance. This affects runtime efficiency but could also eventually affect usability, flexibility, and cost depending on how severely the bottlenecks affect performance.\n\nOptimizing for performance often requires many optimizations to be implemented. This can affect maintainability and reliability of a software system. It can also increase costs and reduce development speed by introduction a large development overhead due to complicated software. On the other hand, not optimizing for performance can improve maintainability, and functionality as more development time and funding can be allocated to improve in those areas. It can, however, heavily affect runtime efficiency.\n\nKeeping costs low and speeding up development speed can allow a product to be shipped and incremented on much faster than normal. This enables rapid implementation and testing of new ideas to achieve a better product-market fit. Adding on to that, keeping costs low can enable multiple implementations and features to be implemented and tested simultaneously to improve functionality, user-friendliness, and ease of learning. It can also result in a lead over competitors which are moving at a slower speed. However, reckless high speed and low cost development can lead to severe technical debt with code that is riddled with errors, not portable, lacking documentation, and not being reusable, adaptable, or readable. This can not only ruin the experience for the end-user through low fault tolerance and robustness, but also heavily impede future development efforts.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1529519,
      "meta": {},
      "text": "Functionality and Easy of learning often collide, because with more functionalities of the product there are more options the user has while using it. This can lead to overstimulation and overload for the users brain. An example for this are IDEs (e.g. IntelliJ). They have many functions and using a new IDE for the first time is pretty hard, because there are many functions you do not need at the start and they just distract you from the basic functions you need (e.g. open a new file, run the program,...), so it is not very easy to learn.\n\nA second trade-off exists between low cost and robustness. A robust system needs much server power to stay stable even in critical situations (e.g. many users are using the product at the same time). Renting or buying servers with much power is very expensive, so you cant keep the costs very low and be robust with your system at the same time. An example for this is Youtube. They have over one billion users and handling high quality videos is leading to much traffic. Alphabet pays very much to keep the system robust, so they cannot achieve the design goal of low cost.\n\nOne more trade-off is rapid-developement and minimum # of errors. With adapting to new scenarios or implementing new things to have a rapid developement, errors in the program or edge cases which weren't recognized appear more often. An example is the new iOS 15 operating system which came out last year. After its release there came many updates like iOS 15.1 in short time, to fix the errors iOS 15 brought with it.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1645880,
      "meta": {},
      "text": "Cost vs. robustness:\nThe client wants the cost to be as low as possible, the end user demands robustness. Robustness means that the system is able to cope with errors during execution, with a changing environment and with wrong input. To make a software system very reliable a lot of testing is required, which is expensive. Especially finding the exceptional cases of environmental change and user inputs is cost-intensive. \n\nExample: For complex, high quality and extremely reliable software systems (for example in cars) the cost of the system is high – a lot of testing is involved to guarantee reliability and robustness. \n\nRapid development vs functionality:\nThe client wants the system to be developed as quickly as possible, the user demands certain functionalities. The smaller the design window and the shorter the system development period the less sprints a system development team can make and the less functions the developers are able to implement. \n\nExample Bumpers: \nIn the third sprint we added more items from the product backlog to the game – so the game supported more functionalities after the third sprint than it did after the second sprint.\n\n\nFunctionality vs. usability:\nBoth functionality and usability are demanded by the end user. Usability is about the ease of use of a system – is it easy to learn, fast to use and easy to remember? Functionality is the set of operations that a system offers. A system with a large number of functions is in most cases not usable since it will be much more difficult to learn, remember and use.\n\nExample Bumpers: \nThe developer could add many more functions to the game like shooting other cars, jumping or turning if you hit certain keys on the keyboard.\nConsequently, the game might be more exciting, but it will not be as intuitive to learn for the player and also harder to remember.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292205,
      "meta": {},
      "text": "you want a lot of features but you also want the system to be easy to handle with a few buttons no large nested menus (functionality vs usability)\n\nyou want to program to run efficiently but at the same time you want to support every platform (portability vs efficiency)\n\nstrict deadline but I also want a lot of features\n\nbackwards compatibility vs readability\n\n",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292349,
      "meta": {},
      "text": "Design goal trade-offs are about an imbalance between the preferences of two or more involved parts during the software development process. The three main participants in software here are the client, the users, and the developers, each having their own priorities for the project. \n\nFor instance, one of these trade-offs is rapid development vs. functionality. A client would prioritize that their product is ready to be launched to the market as soon as possible and would give up already discussed features in order to have a minimum viable product ready for deployment. On the contrary, the development team would prioritize having enough time to solve all problems that arise during development. \n\nAnother example among these lines is about cost vs. robustness. Again, clients are most likely to want to accelerate the process to pay less for the working time, whilst the development team's priority would be to thoroughly test and correct potential bugs in the system. An example of this would be a client dismissing a QA test before deployment because they think the app is ready, only to later find out about problems with the app from the users' hand instead, damaging the image of the business.\n\nThe third display of a trade-off is functionality vs. usability. Not all software that fulfills its purpose is necessarily user-friendly and accessible. Especially when targeting larger audiences, the need to make emphasis on usability gets higher. However, usability is usually sacrificed In order to deploy a system faster. \n\n\n\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1292642,
      "meta": {},
      "text": "When designing a software systems sometimes is necessary to sacrifice one goal over the other. \n\n- A typycal trade-off is \"Cost vs. reusability\", when normally the client is looking for a low cost but the developer is looking for reusability. A typical example of this is fast fashion, when probably the pair of jeans that you get are pretty cheap but that probably mean that you won't be able to use them that much after a few months. \n\n- Othe example is \"Functionality vs. usability\", sometimes is even the end user which ask for both, however that does not even that you can meet both goals. For instance, Evernote is a note taking and organizer, however, it has so many funcionalities that is overwhelming for some user and at the end you end up asking yourself if you actually are saving time or wasting more time putting all the information. \n\n- By the other hand in \"Functionality vs. usability\", JIRA, is a good example. JIRA is a software project management tool, I use it every day for work and I find it super useful, it let you to track some issues and you can get some basic statistics, however, if you want to do heavier statistics you can connect the data base of you JIRA project with Tableau and then create some dashboards, in my opinion this is very useful and even if JIRA does not offer ALL the funcionalities of Tableau I think it is smart to separate systems.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1332303,
      "meta": {},
      "text": "1. To increase the robustness of an online serive proivder the company decides to install a second redundant server with load balancing. This approach increases the cost for the company.\n\n2. By using a non hardware independant programming language the application performance is augmented but it requieres more effort to port the software to other hardware/operating system.\n\n3. By providing many options and features to the user the system offers a large range of funtions but also makes the system complex to understand and use.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1333595,
      "meta": {},
      "text": "The first typical one is \"product cost vs. amount of functionality (functionality in general)\". Of course the more funds support the build of the application, the more developed the system will be and thus have more functionality. But you dont want the product cost to be too high in the end, so you have to think about where you draw the line; how much functionality will be enough.\n\nA second one often times is a topic in the UI: \"usability vs. 'use-efficiency'\". If you want the UI to be usable nicely, you often times have requirements such as not having too many buttons visible on one screen to not overwhelm the user. Is the meantime if you don't have many buttons, you'll have less functions available at once, therefore limiting the use-efficiency.\n\nAnd as a third one you often times also encounter \"maintainability vs. efficiency\". Sometimes a weird, unclear algorithm with seemingly strange and random steps computes the same result as a standard readable algorithm but does so way faster. In those means the maintainability of such computations is very low but to have a maintainable system as a whole you need some coding standards (clean code) and rich documentation. So the trade off is having a slow algorithm which is easily maintainable or a tangled and confusing algorithm which is efficient.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1335875,
      "meta": {},
      "text": "Since developing software that has all the best qualities, such as: safety, security, low costs is unrealistic,- prioritizing design goals and trading them off against each other seems the best option for developers. Some typical design goal trade-offs are:\n\n1) Delivery time vs. functionality: In the case of the development running behind schedule, a project manager can choose between two options: whether less functionality than specified is going to be delivered on time, or the full functionality will be delivered at a later time.\n\n2) Delivery time vs. quality: Here, if testing runs behind schedule, a project manager can also have to choose: whether to deliver the software on time with known bugs-and later provide a patch to fix serious bugs, or can deliver the software after the schedule with fewer bugs.\n\n3) Space vs. speed: This trade-off has to do with meeting response time and throughput requirements-so if the software does not meet any of those two, more memory can be expended to speed up the software, like: cashing. But, if the software does not meet memory space constraints, data can be compressed at the cost of speed. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1337339,
      "meta": {},
      "text": "Functionality vs. usability\nA mobile app with 100 functions might be functional but not usable because it just introduces to much complexity.\n\nCost vs. robustness\nIn order to make a software system more robust you have to test it thoroughly creating more work and a higher cost.\n\nRapid development vs. functionality\nAdding functionality to a software system just takes more time leading to a decreased development speed.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344371,
      "meta": {},
      "text": "In austria the state wanted to create its own ecommerce platform to support local shop-owners. But because they wanted the project to have a low cost the quality suffered dramatically. Therefore, the usability and user-friendliness were ruined and the project was a failure.\n\nAnother example is website creation. The client obviously wants his product very fast. This causes the developers not only to reduce the functionality of the product, but also rush its development and cut corners in the documentation, as well as the readability of the code.\n\nThe employees (end users) of a business software to manage inventory want a program that is easy to learn, but this might require the client to make drastic changes to his old software. As a result backwards compatibility with the old system might be lost.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1347376,
      "meta": {},
      "text": "Functionality vs. usability: e.g. to many settings can overwhelm the user (even though these functions could be useful for the user)\n\nEfficiency vs. portability: e.g. game developing: you can optimize your game for high-end-gaming-PCs with Nvidia and Intel but your game will struggle on older generation, other configurated PCs and other devices(Xbox, Playstation, smartphones, ...)\n\nCost vs. robustness: e.g. Testing your systems cost money(/time)\n\n\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1348387,
      "meta": {},
      "text": "\"functionality vs. usability\".\n There is the interest, of having a program with high functionality. A wide range of functions can be very beneficial for problem solving and opportunities for the enduser. But usability is important as well, because if a program is too hard to use, it won't be profitable. \nExample: A machine at a car wash station. On one side, it would be great if every costumer could chose different types of programs and control every single step individually. On the other side, costumers could be confused by the wide range of options and rather have 3 main programs for washing their car. Also the time, people spend on the machine choosing their program would be reduced by high usability.\n\"cost vs. robustness\"\nEvery costumer wants to optimize their costs regarding software development but it's also important that a program is stable and robust, meaning that it can handle different types of inputs and deal with invalid inputs as well instead of crashing. \nExample: A company produces calculators. The less money it spends on software development, the less time developers have to go through all cases of possible inputs such as dividing with zero.\n\"Rapid development vs. functionality\".\nSometimes, programs need to be developed fast. So the time spent on software development is limited, what could result in a low functionality.\nExample: A new store is opening up in one month and it needs software to manage the earnings etc. So programers might only be able to initialize basic functions until the opening.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1460771,
      "meta": {},
      "text": "The first typical trade-off is - functionality vs. usability. For example, by designing MVV-Automate it would be very functional to place all the possible tickets offers on-screen at the same time, but the usability of the system would suffer from this, because it would be difficult for a human to read and understand this amount of information, so difficult to use.\nThe second trade-off - cost vs. reusability. For example, by developing the game, it will be faster and because of it cheaper, to write the code without considering the reusability. But in the future by developing the version of this game for another game console, for example, it will be more difficult to rewrite the code. \nThe third trade-off - is rapid development vs. functionality. By developing the software, when the developers do have not much time, they can hurry with writing the code, but the functionality of the code will suffer.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1472435,
      "meta": {},
      "text": "1. Maintainability vs Rapid Development:\nI made a Trading Bot recently and I really wanted to try it out.\nThe client (me) really wanted to have a rapid development, but the developer (also me) wanted to have better maintainability, so he can upgrade the bot more easily. 2 months in the future and he can't, because the client won with rapid development.\n2. Performance vs Robustness\nIf you made a program that doesn't test if every input is correct (for example a web page, that takes some input like your age and number etc. and produces a new contact) and it just continues with the given input, it may be faster, but in our example the program could crash if we try to call a number that isn't even a number but a text that says \"haha crashed your system, better sanitize your input\". \n3. Low Cost vs good documentation \nIf we want to keep the development low cost, we probably choose a software developer that does it 1. sloppier and 2. faster, both parameters that do not lead to good documented code. If we want to make an actual help page that takes time, for example the TUM Wiki, which probably cost thousands of dollars in personnel costs, but in the end, it's worth it as less people have to ask other employees how stuff works and they can just look it up.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1475629,
      "meta": {},
      "text": "1)Rapid development vs functionality :\nSometimes developers may not have time to make some functionality of the product by the appointed time. In these cases, you will have to decide whether to deliver a product with less functionality at the appointed time, or later, but with more functionality.\n2)Backward compatibility vs readability : \nFor backward compatibility of the product, we need to integrate the old interface into the new system. This automatically leads to the fact that there is more code and structure of the project, which makes it less readable. If the old interface developer didn't spend too much time on the readability of his code. Then the new system, where there will also be an old interface, will be even more terrible readable and difficult to perceive\n3)Cost vs robustness : \nIn order to achieve greater robustness of the product, more costs are required. For example, for hiring employees with suitable qualifications or for the testing phase. If we want to reduce the cost, then we will have to reduce the costs of the testing phase or workers with suitable qualifications, which will lead to a reduced robustness\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1532956,
      "meta": {},
      "text": "Robustness vs Cost : In a corona app while typing the corresponding address , the app should recognize if this address actually exists otherwise the user would type a false address and won't be notified for that.\n\nFunctionality vs Usability:  While implementing an app we have to prioritize if it is better when the app has more functionalities ( that means harder usability for the end user) or the app is easy to use ( then it has less functionalities for the beginners) \n\nReusability vs Rapid Development : implementing a reusable code takes more time than a non reusable code. Because to be reusable, the code has to be general, robust and after a good research to cover different cases.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1656847,
      "meta": {},
      "text": "Cost vs. robustness: A higher quality software with a high robustness is going to cost a lot of money, meaning, the higher the robustness, the higher the cost. For example: Twitter's servers are being used by millions worldwide. The server system needed for computing all of that is very expensive, but making it very unlikely for a tweet to not come through.\n\nBackward compatibility vs. readability: When developing a software that is going to be used on many different desktops, the developers need to make sure that it is still compatible with older versions of these OS'. But in making it backward compatible, often times the readability decreases, due to conventions and similar restrictions.\nFor example: when coding in a 64-bit system assembly, the backwards compatibility isn't going to be given when making it as readable as possible. On the other hand, making it compatible for systems you don't see using the software, it only damages the readability, making it harder for future developers to understand and further develop your code.\n\nFunctionality vs. usability: The usability of a system is one of the most important part, but so is the functionality. When developing more functionality in a software, it gets more versatile, adding a lot to the worth of the software. But added functionality can also be negative, when it comes at the cost of usability through confusing choices, filled up menus and other things. For example: A software for a ticket system should be really easy to use. When adding more functionality, like popups with different options to buy another ticket or preorder snacks, the system gets harder to use if that isn't what the user is looking for",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1294557,
      "meta": {},
      "text": "1) Functionality vs. usability\n\n\tFunctionality is about the diversity of operations and features that are included in a certain software whereas usability is about the simplicity and clarity with which the interface or program can be used.\nThe trade-off here is that usability requires more simplicity in design whereas functionality tends to make things more complicated and complex (the more you add features, the more complex your system becomes). A good example would be in web development where you'd want your website to clear enough for people to use but also you'd want to include many functionalities so that it is an actual interesting and rich website. Google for example chose usability when it made their https://www.google.com/ page so simple with just the search bar.\n\n2) Cost vs. robustness\n\n\tRobustness in a software means that it's able to deal with many different situations and not break down. If we go back to the web-developing example, it means that your website will be able to run on different browsers for example. This comes often with additional coding and testing and therefore results in additional costs. That's why we need to find a compromise between how robust we want our software to be considering how much funds (and time) we have.\n\n3) Portability vs. efficiency\n\n\tPortability refers to how much your software can be used in different environments. For example, if an app can run both on Android and iOS is a matter of portability. Efficiency, in a way, is the amount of software developed divided by the resources (like time and energy) required to do so. Achieving portability does require more and more work to be able to cover the different environments, so less efficiency. For example, some might argue that iOS is way more efficient than Android and that is because it is specifically made for the Apple hardware and therefore not portable..\n \n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344082,
      "meta": {},
      "text": "most of the time the goals are in conflict with each other.\nThe customer wants with less cost build a good product. this sometimes causes a lack of resources, which sometimes brings us to the point that the code is not usable anymore, and to make your code better, you should write a whole new program. so cost and reusability are in conflict with each other.\nfor some programs you need really good hardware, a game is an example of such a program. so the game should be efficient which needs good hardware and most of the time we can carry our PC with us. so Efficiency and portability are in conflict with each other.\ntime is an important factor in life. we want to develop our system fast so that our users can use our latest product which we offered them. but this could harm the Reliability of our system because most of the time when we work fast we will miss some edge cases and the whole system can crash.  so the Rapid development is in conflict with Reliability.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344183,
      "meta": {},
      "text": "A typical design goal trade-off is efficiency vs. portability, because when you want your software to be highly efficient, you have to optimize it for the specific platform and maybe even hardware, that it will be running on. However if you want it to be portable, because it will be used on many different platforms, you can not optimize it for every platform and therefore the efficiency gets worse. \nFor example: You could create an android app, which is very efficient but only usable on android or you create an website, which can be accedes from any type of smartphone but also from every desktop PC.\n\nAn other typical trade-off is cost vs robustness, because building a robust system requires more work and maybe also more expensive hardware. That is why you can not archive low costs and also a robust system. When you are running a system on a server for example, you either use an expensive server, that can handle a lot of requests at the same time or you use a cheaper one, which might lead to errors when many clients make requests at the same time.\n\nRapid development vs. functionality are also typical design goal trade-offs. because when you want to develop a system with the goal to be done very fast, you might only be able to implement the core functionality and skip some features. And on the other hand when you want to focus on functionality it takes long to implement every single functionality. For example when developing a video game with the goal of rapid development you might not implement as many characters as planed because you do not have the time.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1350631,
      "meta": {},
      "text": "Low Cost and Performance can conflict as design goals, as increasing performance is often impossible without increasing the amount of resources spent. As an example, if we want to make a web application perform faster, we may choose to add servers to the project, which will not be possible without experiencing increased costs, both for purchasing the machines as well as running costs. \nFunctionality and Ease of Learning can also stand in conflict. Software with a lot of functionality will often be geared more at professionals, who require the software to perform very specialised tasks. This, can be a problem as inexperienced users will struggle due to not being familiar with the workflow more experienced users employ, and other issues such as simply being unfamiliar with industry terminology that the software uses. A specific example that comes to mind is FLStudio for creating music, which is intuitive and powerful for experienced users, but will cause many beginners problems.\nRapid Development can lead to other, “less important” goals such as good Documentation losing attention, as they are not instrumental in the core function of the product. Additionally, most users will never experience any drawback because of poor Documentation and an unchanging development team will also not suffer due to poor documentation as they are familiar with the working environment. I see this sometimes in Games, as the accelerated release of new features sometimes comes with incomplete/inaccurate patch notes, which is only noticed by users who choose to investigate more closely.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1433377,
      "meta": {},
      "text": "Usability Vs. Functionality: Bloated systems trying to serve too many functions lose out on ease-of-use because of this.\nFunctionality Vs. Minimum # of errors: As we implement new functionalities, it's harder to keep errors to a minimum.\nRapid development Vs. Good documentation: When speed is of utmost importance, it's hard to find time for proper documentation.",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1620217,
      "meta": {},
      "text": "Backward compatibility vs. readability\n\nBackwards compatibility is generally wanted so a product doesn't become obsolete; however, making a software that works for previous systems can also seem outdated and it will have more constraints that maybe are not present on modern forward compatibility products. This way the design can become harder to understand not just for the end user but for the developers as well. Sony's Optical Archive Disc salvage tool was designed to archive old files for current use; however, going too far back would mean making a software that can read all sorts of old files that just isn't something that can possibly be achieved. This tool is developed to salvage old data and move it elsewhere so it can have an easier to read format in the future.\n\nEfficiency vs. portability\n\nNative apps are the best examples for this case. Apps that don't rely on a specific OS are highly portable because of all the environments they can work in. Native apps on the other hand are not portable but they can then use device specific hardware and software for more efficiency. WhatsApp is a native app while Instagram is a hybrid app that has a multi platform reach because it runs on a phones browser engine.\n\nFunctionality vs. usability\n\nRealPlayer is a company that originally didn't make this tradeoff. They were popular during the 90s but they added more methods to organize playlists, use CDs and DVDs etc. Later, they had too many functionalities to follow and as a result became less popular compared to other services like spotify.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291141,
      "meta": {},
      "text": "Cost vs Robustness\nThe design goal trade-offs are aspects which contradict each other well, in this matter design goal trade off which, personally I believe is quite important and not considered after in the industry is cost vs robustness. Typically, when we go purchases goods the price commonly corresponds to the quality. Hence if we buy clothes on AliBaba the quality would be pathetic however the price would be quite cheap to purchase the product. In the same context applications and software designs are in correspondence to the example above. The free or even cheap software subscriptions like copies of adobe illustrator tend to be quite bad in example their OCR algorithm in picking up handwritten text to computer generated text.\n\nCost vs reusability \nThe second design goal trade-off is in terms of cost vs reusability. In this case there have been varied cases in terms of cost vs reusability in example of the game temple run and clash of clans. In terms of those two games temple run didn’t have a vast funding however it became a hyped game and became more reusable to become similar games like subway surfer. In the case of temple run it was easy to code, low cost of test and became very reusable for companies to replicate the idea and improve the code but not the concept of the game. Clash of clans however was a hard to code, and high cost test game which is not really reusable.\n\nFunctionality vs Useability\nLastly functionality and useability compare to each other due to the case of having too many features which aren’t very useable or either functional. An example would be Microsoft word it has multiple features however it has features which are useable and function very effectively for the user. However using pages the equivalent to word, it has many features which aren’t that useable and is difficult for the user to use effectively to maximize their experience with the software.\n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292630,
      "meta": {},
      "text": "Gegeben ist ein System, welches eine Math Klasse verwendet, dieses System soll in Schulen verwendet werden. Das GUI zeigt bei einem Klick auf eine Info-Schaltfläche alle Funktionen an, die die Math Klasse zum berechnen von Werten zur verfügung stellt. Nun stehen sich zwei Design-Goals gegenüber, auf der einen Seite soll das System zahlreiche Rechenoperationen zur verfügung stellen, andererseits soll es nutzerfreundich sein, indem es dem User einfach gemacht wird, die Symbole für die jehweiligen Operationen zu finden. Hier besteht ein Tradeoff zwischen Functionality und Usability.\n\nEs wird an einem Gamejam teilgenommen, Hier soll ein Spiel entwickelt werden, welches laut Design goals 10 Level haben soll, zudem muss das Spiel jedoch auch in zwei Tagen fertiggestellt werden. Hier besteht ein Tradeoff zwischen Rapid development und functionality.\n\nEs soll ein Programm entwickelt werden, welches eine Menge von Daten verarbeitet, dieses soll zum einen kosteneffizient entwickelt werden, zum anderen auch eine angenehme Usererfahrung bieten. Hier könnte ein Subsystem eingeführt werden, welches automatisch beim starten der anwendung nach Updates sucht, dieses würde jedoch einiges an Recourcen in der Entwicklung kosten, gibt es dieses nicht, müsste sich der Nutzer selbstständig die neuste Version herunterladen, hier besteht ein Tradeoff zwischen Cost und Usability \n\n",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1295334,
      "meta": {},
      "text": "Ease of learning vs. rapid development:\nTo fulfill requirements like ease of learning the developer was asked to provide a tutorial guide for the users whose implementation could be time-intensive and would contradict the aims of the system design phase like rapid development. The focus on creation of an appealing GUI, where each function can be directly found by the user, is also important for marketing purposes but takes time and requires lots of testing/different opinions.\n\nCost vs. robustness:\nThe less budget is available for developing a software project the less resources can be used for long, thought-out   requirements analysis. Missing points might lead to incomplete system design and gaps in the problem safety & security. Spending few money on testing result in problems that wrong inputs can crash the problem(safety) or the software can easily be hacked and data get stolen. (security)\n\nRuntime Efficiency vs. portability:\nEspecially laptops show enormous differences in performance in counting and portability. While these flexible tablet/laptops that most students use in university are basically designed for using basic programs like Word or Java and would breakdown during playing games because of missing cores or not having best graphic cards bigger laptops have more space to be include high-end components. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1300837,
      "meta": {},
      "text": "Cost of the project <-> Robustness of the program:\nIn this case the cost of the project increases the more robust you want the program to be. Therefore you need to decide wether a certain robustness of the system is worth the cost occurring programming it. E.g. A game developing company Epic Games needs to make sure all Exceptions for the code are handled properly, so the user can play the Games smoothly without any disturbances or the game crashing.\n\nrapid development <-> functionality:\nA rapid development most often excludes the best functionalities for the system. E.g. If you want to program a game rapidly like Minecraft you firstly focus on the basic functionalities to make the game run in the first place. Complex functionalities like the nether world can be implemented later on and be released with an update. But if you decide to implement everything right away, the game will be developed more slowly.\n\nfunctionality <-> usability:\nThe more functionalities you have implemented in a system, the more difficult it gets for a user to understand and use the program without having a deep knowledge. E.g. Adobe's Software is very advanced in digital media editing and therefore there need to be tons of functionalities for professionals. Therefore newbies to the system are quite overwhelmed by the amount of functionalities and complexity of the system. In contrary there are also applications for digital media editing that are way more easy to use but therefore have way less functionalities.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344099,
      "meta": {},
      "text": "One of the most prevalent design goal trade-offs is functionality vs time/development speed. Obviously implementing more features takes more time. For example, if a client says he wants a desktop app finished in a short time it is probably not feasible to support a lot of older operating systems as well.\nAnother typical design trade off and an alternative to the previous one is time vs money. You can finish a well-planned project quicker if you for example hire more developers or buy faster equipment however this obviously cost more money as well. \nMinimum number of errors vs rapid development is a typical design trade of as well. It takes a lot more time to write well working code, create test to ensure that it actually works well and adjust the code in case it doesn’t. This can slow down the development process significantly.\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1344105,
      "meta": {},
      "text": "Cost vs. Robustness:\nThe higher the robustness the higher the cost of a system.\nIf a company wants to develop a new banking app as securely as possible they have to assume a higher cost compared to a less robust system. For a robust system, they should implement a lot of security features and test all of those. As well as few failures as possible. All of this requires knowledge/time thus increasing the development cost of the project.\n\n\nRapid development vs. functionality:\nThe faster the development the fewer functionalities can be implemented.\nIf a project has to be finished in two weeks' time a development team might not be able to implement all the requirements a client wanted to have or might simply forget/misunderstand the requirements of the client as the time is quite short and there is almost no time to communicate with the client.\n\n\nFunctionality vs. usability:\nThe more functionalities a program has the less usable it becomes.\nIf I am a filmmaker and photographer and I use a program for my editing, having one program for both will be worse than having one program for each task. As I have more functionalities in one program the program can get more confusing and less stable/performant thus damaging the usability of the program itself.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344107,
      "meta": {},
      "text": "Design Goal Trade-offs treten immer dann auf, wenn sich zwei requirements (zB. nonfunctional requirements) gegenseitig im weg stehen und sich blockieren. Ein typisches design goal trade-off tritt dann auf, wenn zwei Parteien, wie zB. der Developer und der Client oder der Developer und der Endbenutzer ihre Prioritäten anders setzen.\nFür den Client kann es wichtig sein, ein möglichst günstiges Produkt herzustellen während es für den Endbenutzer eine hohe usability haben sollte, um einen Mehrwert darzustellen. Eine hohe Benutzerfreundlichkeit ist im Normalfall jedoch teuerer in der Entwicklung und somit steigen die Entwicklungskosten für den Client.\n(Trade-off: Low-Cost <-> User-friendliness)\n\nEin weiteres Beispiel für ein design goal trade-off ist eine schnelle Entwicklung gegenüber well-defined interfaces. Dem Client ist eine schnelle Entwicklung wichtig, während der Developer oft lieber auf eine solide Programmstruktur setzten würde, die spätere Äderungen und Erweiterungen erleichtern würde. \n(Trade-off: Rapid Development <-> Well-defined interfaces)\n\nEin Design goal trade-off kann aber auch zwischen Client und Endbenutzer auftreten. Bei einer hohen backward compatibility kann die usability des Endbenutzers leiden. Nur weil man in vorherigen Versionen des Programms Dinge auf eine bestimmte art gelöst hat, heißt das nicht, dass es die beste Methode ist. So müssen im schlimmsten Fall Praktiken aus alten Versionen übernommen werden, bei denen die Benutzbarkeit des Endbenutzers leidet.\n(Trade-off: Backward compatibility <-> Usability)\n\n",
      "score": 58.3,
      "language": "GERMAN"
    },
    {
      "id": 1344677,
      "meta": {},
      "text": "usability vs. functionality - as a system is bloating over with functionality it can get very hard to use. With rising numbers of functions the learning process of the end user is hindered. He can also not remember all the functions and will maybe never be able to use them correctly. An example for this would be Facebook. If the functions of Instagram, Whatsapp and Facebook would be gathered in one app, the mere quantity of functions would confuse the end user. For themselves the apps are easy to use and understand. Instagram, for an Example, has the main focus on posting and liking pictures or videos. This is very straight forward and does not lead to any kind of confusion.\n\nRapid development vs functionality - on the other hand, when systems are to be finished in a certain time, the design window and the implementation may fall short. Then you might firstly not be able to elicitate every important requirement for the system, or you can not implement it into the final system, as there is no time left. This is very common for a software project so it is of high importance that you rearrange your requirements in line with the overall significance. An example would be No Mans Sky, a video game that failed on this trade-off miserably. They had promised much functionality which wasn't finished on full release, such as Multiplayer-Functions or space-battles. They had developed to rapidly and therefore went through a big storm of criticism.\n\nCost vs. Robustness - is a common problem in video game design as well. As Robustness is expensive both on hardware and software side, designers often cut it short to spare some coin. A perfect example is the MMORPG-Genre (Mass Multiplayer Online RPG). Almost every launch of such a game comes with BIG server issues. The system completely drowns in the high number of users trying out the new game. They just lack servers in quantity. This happend recently to Lost Ark and will always happen in future, because you never know if your game will be anticipated enough to get such high numbers. The designers often dont want to risk buying too much hardware and losing money for players that wont even be there. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349509,
      "meta": {},
      "text": "Scenario: the university plans to implement a platform where students can share useful files and information about the courses. \n\nRapid development vs. functionality: students want a platform that supports uploading many file formats, without size or number limitation, in order to share as much information as possible; additionally, they want to be able to comment on each uploaded file. The university plans to have the platform ready at the beginning of the next semester, but to develop all the functionalities is not feasible in such a short time frame.\n\nCost vs. robustness. The University needs a platform that can handle simultaneous activity and errors quickly. For example, when many students are uploading files simultaneously, the system must not crash or slow the processes. Moreover, the system should have a robust accessibility, to avoid that students access and modify other student's files and tasks. Developing the system that can handle all the functionalities in a proper way increase the costs significantly since more developers have to be paid to implement it in short time.\n\nEfficiency vs. portability: students want to use the platform in many devices (smartphone, laptop, tables) with different operating systems. However, if the university wants to ensure an efficient system and satisfactory performance, this can lead to develop non-portable code.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1359138,
      "meta": {},
      "text": "One of the most typical design trade-off might be the Time vs. Quality. For example, if the computer game company has a strict deadline when they should release a new game to the market due to the high competition (in rigorous competition there are certain trends in computer games development which get updated really fast and if the certain company will release the new game later than their competitor company, they might lose their customers). Because of the lack of time, the quality of graphic could be worse than expected or the game might have bugs, since developers have not had enough time for debugging.\n\nAnother case of the design trade-off is Space vs. Speed. For example, the mobile phone company develops a new mobile phone with larger memory, but eventually slower operation time. The opposite situation with faster operation time, but smaller memory is also possible.\n\nOne more typical design trade-off in software engineering is the Time vs. Functionality. For example, a bank wants to develop the mobile application, so that the bank's clients would have access to the bank operations online. However due to time constraints, the first released version of the app might have only basic functionalities, such as money transferring and viewing your actual balance. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1435862,
      "meta": {},
      "text": "One important tradeoff relation is development time vs functional robustness, which is essentially a conflict of interest between users and stakeholders or other profiteers. Recent examples are given by the video game industry, where games are often released in an unfinished manner, because financial interests require to cut time, that would be needed in order to test extensively against bugs and missing features.\n\nAnother one is backward compatibility vs efficiency and ease of use. For example: In the processor industry, Intel requires, that also newer processors are compatible with their early definition of x86 set architecture - the basis of software development -, which results in unfavorable artifacts concerning performance and usability.\n\nA famous topic is of course given by the goal of optimization, where readability and standards of \"clean code\", which should be readable in a way that it reveals its purpose easily, are measured against raw execution performance. While performance optimization trends to obfuscate meaning of code and general understandability as it often requires deeper knowledge of the underlying hardware or more precise distinction which can result in very long texts of code, a clean piece of code could be comfortable to read and maintain as a result.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1438525,
      "meta": {},
      "text": "If the development of the software includes future patches and updates, or the software is supposed to supercede older software, backwards compatablity may be desireable, however this will make the code less readable as additional code will need to be added to handle old api features. An example would be network package formats: if new data has to be transmitted or received the packae handlers need to be able to account for that.\n\nIn certain situations it may be beneficial to indruduce a more rigid system to increase efficiency although it may make the code less reusable. So for example if it is already known how many elements need to be saved, a developer may choose to use an array, or even seperate fields instead of a list, for quicker access, however the code would need to be adjusted for every usecase. As such this is only useful for code that will not be used in a lot of places.\n\nWhen there isn't a lot of time for development a developer may also choose to drop features that are not required on release in order to allow them to get the software done in time.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1596777,
      "meta": {},
      "text": "We can review three examples to understand design goal trade-offs in the context of development.\n\nFunctionality vs Usability: Team wants to build an application that is easy to understand and use. It will be achieved by foregoing unnecessary functions. (The feature set will be small.)\n\nFunctionality vs Low Cost: Because of the limited resources the developer team will try to refreain from an excessive functionality. (The app will be confined to basic features.)\n\nCost vs robustness: Main objective of the team is to create a great user experience. Although the developers in the team lean towards a low cost and easily usable design, robustness is important for a good UX. That is why team will spend some time (costs) for a robust experience.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291389,
      "meta": {},
      "text": "\t1_Cost <> robustness:\nFor a robust system you need to invest a certain amount of money. As many clients often have limited budgets they have to decide whether to invest more to ensure robustness or to publish a system that might not be robust in certain situations.\nThe company Jupiter wants softwarecompany Mars to develop a new online multiplayer game. The budget is 1million$. Soon after, Mars says that they need another 200000 to ensure no server crashes when more than 10000 players play simultaneously. After discussions they conclude that the budget won't change and take the risk of the servers crashing. (-> less robustness for lower costs)\n\t\n\t2_Rapid development <> functionality:\nThe client and developer have to decide whether to prioritize the duration of the development or the functionality of the project. To resolve this conflict of interests, they need a compromise and decide to either give the developer more time or decrease functionality.\nJupiter has contacted Mars to develop a new Fitnessapp. Jupiter wants it to be developed in less then 6 months, but Mars says that, in order to be able to integrate all sports it would need one year. Finally Jupiter and Mars agree to only include the most popular sports to be able to complete the app in 6 months (-> less functionality for rapid development).\n\n\t3_Efficiency <> portability:\nThe developers have to decide whether to make the program available for multiple OS and decrease the efficiency or to increase the efficiency (runtime it takes to perform a certain action) and therefore not being able to distribute the program to different platforms.\nMars has to develop a calculator and the users expect it to be as fast as possible. Mars decided to develop it especially for WindowsOS and make it only available there(-> more efficiency for less portability). ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292096,
      "meta": {},
      "text": "One trade-off in software engineering is functionality vs usability. Every new functionality added could decrease the usability. An example would be the windows calculator. Instead of adding new functionalities to the calculator, they split it into several different calculators (e.g. graphical, scientific). This has the effect that these additional functionalities still exist, yet they do not impede the average user's usability who often wants to use the standard calculator.\n\nAnother common trade-off is cost vs robustness. Increasing robustness will increase costs. One example could be having enough servers to avoid excessive users crashing the system. More servers reduce that risk (increasing robustness) but each additional server increases the cost.\n\nA third trade-off is backward compatibility vs readability. The bigger the project and code become the more difficult it becomes to achieve both. Ignoring any monetary incentives these companies might have but one example might be Sony, Microsoft, and Nintendo who increasingly have to juggle whether it is worth it to implement backward compatibility for their consoles. Often times the effort exceeds the benefits and it is not done.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1298639,
      "meta": {},
      "text": "1. Cost vs. robustness\nIn order to make a system more robust the cost increases accordingly and/or the time it takes to do it, which in return as the saying goes time is money, increases the cost again. For example if you are developing a project the more people you hire on your team the better and more robust your project will be but each new member of the team will increase the cost significantly so as with any trade-off a balance has to be found.\n\n2. Efficiency vs. portability\nUsually the more efficient and powerful something is the less portable it is. For example when it comes to computers if you want a very powerful and efficient computer it will most likely have to be a desktop or in an extreme case a quantum computer, which takes up a whole building, so the portability is terrible and you can not take it to the university to take notes for that you need something way less efficient but also much more portable.\n\n3. Cost vs. reusability\nThings that you can use over and over multiple times usually cost more in order to be durable enough to withstand the multiple uses but this trade off is usually worth it because the more times you use something the less is the cost per use for you in comparison to buying something new every time.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1333329,
      "meta": {},
      "text": "1- Usability vs Reliability\n\texample- what if a client says that within 2 clicks Transaktion should be done ,but is makes less \n                        authentication as needed to be done to be 100% sure of the user. In this case it's a security issue \n                        cause by usability requirement and security is a part of Reliability.\n\tSo usability and Reliability goes hand in hand. Error handling should be done properly ,because what if an \t \n        error caused a security breach in the system.\n\n2- Constraints vs Performance\n\texample- what if a client desire to build the system on a Computer Language that is slower that others, \n                        which can actually reduce the performance of the system. Response Time will be slower and may \n                        be system breakdown can be also possible.\n\tTherefore developer should has the right to decide and select the best possible environment for system. \n        Which is easy to implement and maintain whenever needed.\n\n3- Cost vs Supportability\n\texample- what if just because of less investing of money a system is delivered which can only work in \n                        30degree ,but due to some environment change system shut down. So cost has influenced the \n                        quality and support ability of the system.\n\tCost is always a big factor in System design and can affect not just supportability as well as Performance \n        and functionalities too. For best quality ,required amount should be invested to get the optimum result.  ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344193,
      "meta": {},
      "text": "1 Security v.s. Maintainability -> The security is often really importent especially in big companies, which makes also often the maintainability much more difficult because multiple identifications when logging in are required or\nchanges on the project are really difficult because you are restricted by the hard security structure and you have a smaller space to move in your work.\n\n2.  Efficiency vs. portability -> When portability is required for more accesability for diffrent users, it is more difficult to implement an effcient system because you cant specialise youre Product on a specific System or hardware, like for example a Game that is only for one Plattform would be much more efficient then a multible Platform Game. You have to make your Game more accesable and general for diffrent plattforms and hardwares which decreses your efficence because you cant consentrate and optimize your Game on one hardware. \n\n3.  Functionality vs. usability -> You have to hold the balance between funyunality and usability because when you have to many options and funcunalties, you have on the one hand many opurtunities and high fucunality as a user, but on the other hand you could overwhelm the user and decrease the usability. Because it would take a while until the user knwos what to do which would be less user-friendly and easy to learn. \n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344318,
      "meta": {},
      "text": "Functionality vs. usability:\n- While a user may profit from a large number of functions as it provides more variety\n- this exact variety can also be a downside as it results in a more difficult to use interface\n- providing many different car choices for the player of bumpers\n\nCost vs. Reusability\n- To keep costs low, one may implement classes / methods in a for one case perfect way\n- how ever this may cause high efforts to adapt the software to differing use cases, as in keeping the costs low, everything was implemented to only reflect one single use case\n- example from bumpers: implementing collision as an abstract class and implementing different subclasses, rather than always having to define all methods all over again for every collision type\n\nRapid Development vs. Functionality\n- developing something quickly may cause someone to not cover all different functions possible due to a lack of time",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1430928,
      "meta": {},
      "text": "One typical design goal trade-off is Functionality vs. Usability. For example in a software for building Presentations (like Powerpoint). The End-User and Client both want a software that has as many functions and features as possible, for example different text formats etc.  and on the other hand want the software to be user friendly, easy to learn and use. But these design goal clash, because the more functions you implement the harder the Use and Understanding of the Software becomes.\n\n\nAnother design goal trade-off is Cost vs. Rapid Development. Usually the client, who wants the developer to develop a game for him, wants the software to cost as little as possible and be ready as fast as possible. But there has to be a trade-off, because if the clients wants Rapid Development the developer has to employee more people or work more hours which builds up to a higher cost and therefore clashes with the Design Goal of low Cost.\n\n\nAnother design goal trade-off is Efficiency vs. Reusability.  For instance a university(client) wants a software like tum online. Of course the client wants his software to be as efficient as possible, therefore it has to be specifically designed for the universities needs, functions and for its specific hardware to make it as efficient as possible. This would make the code not very reusable for the developer, who would like to make the software reusable so he can sell it to other clients.\n\n\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1303898,
      "meta": {},
      "text": "Kosten vs. Robustheit:\nFür ein robustes System muss mehr Geld investiert werden. Aufwendigere & sicherere Algorithmen sind kostenintensiver, dafür läuft das System allerdings\nstabiler & ist sicherer vor Angriffen. Es handelt sich hierbei also um eine gegenseitige Interdependenz zwischen zwei design goals. Es sollte also immer\nbetrachtet werden was die Anforderungen an das System sind in Bezug auf die Robustheit & dann sollte evaluiert werden in wie weit das dafür zu\nVerfügung stehende Budget ausreicht. Es sollten regelmäßig Abstimmungsgespräche zwischen Auftraggeber & Projektteam stattfinden, damit es es zu\nkeinen unerwarteten & fehlinvestierten Kosten kommt - das gleiche natürlich auch in Bezug an den Anspruch bzgl. der Robustheit. Bei meinem vorherigen\nArbeitgeber gab es ein Softwareprojekt für eine Lieferantensoftware für die jedoch nur sehr wenig liquide Mittel bereitgestellt wurden. Darauf hin kam es\nzu vielen Beschwerden über Überlastungen, Abbrüchen & Störungen - die Fehlerbehandlung gestaltete sich in der Zeit wo ich eingesetzt worden bin als\näußert schwierig & das System war teilweise über mehrere Stunden nicht verfügbar.\n\nSchnelle Entwicklung vs. Funktionalität:\nUnter einer schnellen Entwicklung einer Software leidet meistens die Funktionalität. Als optimales Beispiel ist hier die Corona Warn App, welche aufgrund\nder aktuellen Pandemie möglichst schnell entwickelt werden sollte. Aufgrund der mangelnden Zeit ist die Funktionalität der App vor allem anfangs sehr\ngering ausgefallen (kam alles erst später bzw. noch in Planung: QR Codes für Terminvereinbarungen im Einzelhandel, direkte Übermittlung von\nTestergebnissen direkt über die Corona App, Vereinbaren von Testterminen, Auch über Ländergrenzen hinweg). Abschließend gab es durch die schnelle\nEntwicklung zunächst nur eine sehr begrenzte Funktionalität der Anwendung.\n\nFunktionalität vs. Benutzerfreundlichkeit\nKomplexe Funktionsweisen von Softwareprogrammen sind meistens mit einer geringeren Benutzerfreundlichkeit verbunden. Denn jede zusätzliche\nFunktionalität ist ein weitere Herausforderung für den User, damit umzugehen. Mit anderen Worten, je funktionaler eine Anwendung, so überforderter ist\nder User am Anfang. Funktionalität geht also meistens nicht mit der Benutzerfreundlichkeit einher. Ein Beispiel hierfür ist z.b Microsoft Word, was einen\nhohen Grad an verschieden Funktionen beinhaltet. Die Benutzerfreundlichkeit ist jedoch eher gering, viele wichtige Funktionen sind versteckt & schlecht\nzu finden (z.b Automatisches Literaturverzeichnis). Abschließend ein mächtiges Programm mit vielen Funktionen, die jedoch schlussendlich kaum vom\nUser - oft auf Grund schlechter Usability - genutzt werden.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1315207,
      "meta": {},
      "text": "1) To make a program system independent, a developper might sacrifice from the programs speed or memory usage. This might be good for the client.\n2) To make a program have more functions, a developper might sacrifice from simplicity of the user interface. This might be good for some users, who have experience with complex software.\n3) The developper might design a program simpler, so it is easier to maintain. This helps the developper.",
      "score": 25,
      "language": "ENGLISH"
    },
    {
      "id": 1319770,
      "meta": {},
      "text": "1. Functionality vs. usability \nA system could have a lot of functionalities that are all perfectly working. e.g. a software product for a middle-sized company: It would be possible to implement 1000 functions which are all implemented for one special case. But in the practical usage of this system it's not possible for the user to learn and use all functions the system provides. There you have to weigh up which functions are really necessary and which could maybe be combined to make the use of the system easier. \n\n2. Cost vs. reusability\nE.g. we develop a new system for a company. We could either focus on cost reduction by implementing simple code that is only applicable for this one specific case, or we could focus on reusability of the code and do a more complex programming that could easily be applied to other uses of the system or even systems for other companies in the future. \n\n3. Backwards compatibility vs. readability \ne.g. we take the system of a company and want to modify it to make it compatible with new processes. We could either write the code such that the new system is compatible with the old system, or we could use some newer functionalities of the programming language to make the code more readable. This could have the consequence, that the changes in the new system are not compatible with the old system in the initial form.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1320525,
      "meta": {},
      "text": "Due to different actors with different main interests in a software development project there are contradicting design goals. 3 examples will be elaborated in the following.\n\nA typical design goal trade-off is between functionality and rapid development. The developers need to deliver the solution to a given problem statement  until a fixed deadline. This is one of the design goals of the client, that wants to minimize costs and have their product finished as soon as possible. On the other side a design goal of the user is the functionality. The quality of the functionality may suffer due to that time pressure put on the developers by the client.\n\nAnother design trade off concerning the client is backward compatibility vs readability. The client could want to integrate the new product in his existing system and thus needs the developer to design his product for backward compatibility. The problem with that is that legacy systems are -often, not always- pretty old and bad written. The developer needs to adapt to this and the readability of the code may suffer.\n\nA third design trade-off is the rapid development demanded by the client vs the effort of developers to minimize their amount of errors in their code. With a constant time pressure, developers tend to make mistakes that lead to bugs etc. While a design goal of a developer is of course to have the least amount of errors in the code, the client needs to have his product ready to use quickly.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344265,
      "meta": {},
      "text": "Tradeoff 1: Cost vs. robustness\nYou rather can get a cost optimized or robust program. For robustness a lot of testing is required which is costly.\nFor example wrong user inputs can differ a lot. So if a program should be very robust, a lot of imput has to be taken into consideration, with takes a lot of time and thus money.\n\n\nTradeoff 2: Efficiency vs. portability\nThe new Apple Silicon chips, based on ARM are a lot more efficient than Intel's architecture, but applications have to be optimized for the ARM-architecture. When this is done, it ca no longer be ported to intel based Macs. If not done, it can be used on both systems, but efficiency on ARM suffers because another layer (virtual machine) has to run.\n\nTradeoff 3: Cost vs. reusability\nAs soon as you start to implemet additional features to your program, costs are rising really fast. \nWhile if u don't do it, usability is limited to a few special cases.\nAs soon as a program should be reusable, it's no longer designed to work in one defined scenario. It rather has to work in a lot of scenarios, so that one specific scenario will be supported.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344547,
      "meta": {},
      "text": "Cost vs. robustness:\nRobustness means the degree by which a programm can operate reliable under errors during execution and with erroneous inputs. To have those qualities more work needs to be done meaning more hurs spend on the project hence higher costs. E.g if i want to develop a game which has a very few bugs i need to test it a lot before selling it which means more costs because of the extra work.\n\nRapid development vs. functionality:\nFunctionality refers to the usefullness of a software and its funtions. This is in direct contrast to rapid development because to make a really funtional application there needs to be much thought invested in the design beforehand and work in the implementation.  E.g if i wanted to develop a search engine which has really high funtionality i would need much time to develop a good algorithm and choose the right databases to access which takes time and is therfore in competition with rapid development.\n\nBackward compatibility vs. readability:\nBackward compatibility is the attribute that software is interoperable with an older legacy system. This often requires to use older techniques or programming languages which are not in use that much any more and therefore are harder to read. Futhermore i have to include more edge cases and software in generel so that the program can run on older systems which makes it even harder. E.g the devlopment of operating system whoch should also run on older computers.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1346309,
      "meta": {},
      "text": "In modern work and personal infrastructure portability and runtime efficiency are very important. It is crucial used software runs *fast* on all used OSs integrated in the project. This portability can cause limitations in efficiency, because optimizing the system has to be done for all supported and mobile systems with less computing power. In the Gaming Industry “Crossplay” between platforms like Console (PS4, XBox), PC (Windows, Linux) or mobile devices can decide, if friend groups play a game (members on different platforms). But that leads to limited resource prerequisites of the game, commonly solved by more flexibility in graphic quality and a low minimum requirement: MinecraftBedrock goes from HD30Hz on iPhones to 4K>144Hz on “Gamingcomputers“. \n\nAlso security and speed goals can collide. Adding extra security layers to systems to prevent security breaches, data leaks, etc. leads to more complexity or less speed for the user. When choosing a password most systems require concrete prerequisites for the user’s password. GitHub or Google e.g. let the user decide between a fast way to log in with a password or requiring extra steps like 2-Factor-Authentication that cost time in the login process to solve this issue. \n\nAnother problem is uniting increased functionality with making an easy usable program. Adding more complex functions requires adjusting the UI with more incomprehensibility and reduced beginner friendliness. Usually developers combine both by extra buttons hidden in TopbarMenus, smart keyboard shortcuts, etc. keeping the basic layout simple. One TradeOff example are Microsofts Office Applications. When opening a document in Word, there are approximately 300 buttons on the opening page, but the user still can start writing text immediately through preset standard settings providing compromises between functionality and simpleness. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1352257,
      "meta": {},
      "text": "Efficency vs. portability:\nEfficent, optimized code is often platform specific, thereby hampering portability. For example in Game Development games that are only developed for one platform can be way more efficent, at the loss of portability.\n\nFunctionality vs. usability:\nLots of functionality will usually lead to clutter, to the downfall of usability. For example high end media production software (like Adobe Premiere Pro, Fruity Loops, ...) is very feature rich, but has a high learning curve as a result.\n\nRapid Development vs. functionality:\nShorter development times invetably lead to features getting scrapped due to time constraints.  ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291264,
      "meta": {},
      "text": "Cost vs. Usability:\nIncreasing usability and decreasing cost, whether time cost, resource cost, or financial cost, are directly competing design goals. Concretely, a game can be much quicker and cheaper to produce, if input is only collected via the keyboard. However, the nature of the game, for example, if it is a first-person shooter, might be more suited to also allowing for controller/mouse inputs. \n\nEfficiency vs. Readability:\nAlgorithms which work very efficiently, aren't the easiest to read for new team members / new developers. The learning curve between bubble-sort and quick-sort is an example of how even though bubble-sort may be easier to understand for a new coder, given the assumption of large unsorted lists, quick-sort will outperform bubble-sort.\n\nBackward compatibility vs. Usability:\nThe Nintendo Wii was a backwards-compatible system. Underneath the top flap of the Wii, there were 4 sockets to connect Nintendo GameCube controllers; the Wii was also able to play Nintendo GameCube games. Although this backwards compatibility may have been useful for a small segment of the user population, those that also had a Nintendo GameCube, the space could have been used more wisely. For example, a built-in AA battery charger for the Wii controllers would have appealed to a far larger proportion of the Wii user group, since finding charged batteries to use with the Wii controllers was a common problem. This becomes more obvious when considering that the people with GameCube controllers and games probably already had a system on which to play the games, namely, a GameCube.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291668,
      "meta": {},
      "text": "1. Functionality vs Usability. A software with many functionality- set of operations that a interface supports- may not be high in usability- ease of using an interface. An example is that of WayFair website (https://www.wayfair.com/). Although it gives the user many choices with many functionalities to serve the website, it is not easy to use as it is cluttered\n\n2. Efficiency vs Portability: Efficient software converse CPU cycles and take full advantage of the softwares and focuses on graphic accelerators, cache memories and specialised floating-point instructions. However, this might suggest that it runs on one architecture which is it very specialised and sophisticated resulting in low portability.\n\n3. Rapid development vs Functionality: For instance, during the development of a subsystem, should the change be rapid, the developers may not discuss the changes with each other leading to different terminology of the subsystem. This will lead to confusion reducing ease of usage lowering functionality.\n\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1291765,
      "meta": {},
      "text": "One trade-off is between the amount of functionality in a product and the deadline when a product must be deployed. For example the sprint 3 of bumpers could have had much more functionality if the deadline for it's deployment was a month and not just a week. \n\nAnother is the trade-off is the cost of a product and it's portability, because deploying a product to multiple platforms requires more development time and therefore money. For example to deploy bumpers to android would require quite a bit of work in redesigning the UI and player controls and if it were paid work, it would cost more. \n\nLastly there might be a trade-off between maintainability and runtime efficiency of a product. Writing readable and easy to understand code can sometimes limit its efficiency. For example creating ten functions to do one thing leads to many function calls, while doing all that functionality in one function will lead to really huge spaghetti code.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291954,
      "meta": {},
      "text": "- Functionality versus usability: While designing a software, we want to implement a software which is both easy to use and multifunctional. But mostly, we need to face contradictions within those two. Most of the time when we add a new feature to out implementation in order to increase functionality, we make the software more hard to use. That is because the user must adjust more settings or face more interfaces while using it. In the frame of bumpers example, if we add a feature which allows the user to select their car, it would make the user compulsory to adjust more settings before starting the game. \n \n- Efficiency versus portability: Efficiency and portability are also design goals that might contradict. Implementing a portable software might have lower efficiency compared to platform dependant software. An example from bumpers statement would be; We implemented the game using java, which made the game platform independant. We are able to run the game on different platforms. If we implemented the game using c++, it could be more efficient (faster and probably have less size). But it would not be platform independant, we might have some problems, trying to play it in different platforms or different operating systems. \n\n- Cost versus robustness: Another contradiction in design goals might occur in cost and robustness. We aim to make our code robust as possible and keep the costs at the minimum level. A contrast in software could emerge for example from while checking wrong inputs. Every check would increase the cost and its robustness.  \n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1351612,
      "meta": {},
      "text": "There is a tradeoff between multifunctionality and usability in the user interface. The more functions you want to be directly accessible with only a few clicks, the less clarity you usually have in the interface as the interface becomes really packed. This is for example visible in microsoft word. As there are so many functions in word, it is often difficult for inexperienced users to find quickly what they are looking for. \n\nThere is also a tradeoff between task specifity and multifuntionality. Normally, the more specialized a software is, the better it is to handle those few tasks it was specifically build for (qicker, more accurate). On the other hand, if the software is too specific, there is only a limited amount of potential customers. Hence software also has to be versatile to at least some extent. For example an inventory management software fpor a supermarket is probably easier to use, more reliable and icker in the supermarket environment compared to a generalised inventory management system, which might have additional variables and functions not required for supermarkets such as planning whole pallets and so on.\n\nThere is also usually a tradeoff between short time to market and maturity/maintance of the software. Customers want the software as quick as possible and software developers want to sell their software as quick as possible. However the more you push the release time, the less mature and tested is the software. Therefore you have more effort to maintain the software and to fix post production bugs. An example would be the new Battlefield 2042 where they pushed their product way to early and had consequently an immature game resulting in a lot of effort to maintain the software as well as the player base.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290847,
      "meta": {},
      "text": "One typical design goal trade-off is cost vs. robustness. For example the more you test your software for edgecases etc to get it more and more robust, the more expensive it gets. So you have to think how much worth the robustness for more costs is.\n\nAnother typical design goal trade-off is function vs usability. That means that you have to decide between the function and the usability of the software. For example the more functionalities a software has the less it is user-friendly. So you have to decide between Userfriendlyness and funcionality of you software.\n\nReusability is when you reuse existing code in the software development process. The more you want to write code reusable, the more time and money you have to incur, because the less you spend time and money, the more complicated the code becomes and therefore less reusable. Thats an example for the design goal trade-off of cost vs reusability.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291623,
      "meta": {},
      "text": "Understandability: Let's say I've just written a piece of code that I think is easy to understand, but others don't. Or someone else wrote the code, it's easy for someone else to understand, but I can't understand his mind all of a sudden, and then it's hard for you to understand. If that happens, it's all incomprehensible. So you need to modify complex content in your code to make it understandable.\n\nTestability: Code only performs the behavior you write, not the behavior you think it does. Testability is making sure that what you actually do is consistent with what you think you do.\n\nReusability: gradually improve the design results of system architecture design through continuous design reconfiguration process, and minimize the interrelationship between various modules, especially to avoid \"many-to-many\" dependence.\n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1295874,
      "meta": {},
      "text": "Rapid development vs. functionality\nIt is always important to develop a fast product to stay ahead of competition or meeting deadlines from the client. Of course if you do something fast the quality of the product suffers. In an open market when competitors come up with new technologies that turn out to be highly profitable, you as a company need to adapt quickly in order to stay ahead, but usually your not going to achieve the same result as the others. Uber and the taxi business is a good example, because taxi couldn’t develop a similar service as Uber in a short amount of time and were beaten in the market.\n\nCost vs. robustness\nRobustness means how a software handles, for example, wrong user input or different errors. This is done by doing a lot of tests on the software and looking how it responds. This is usually done by external firms or the company has a own section in itself that does it. No matter what, it comes with increasing costs for labour and energy depending how strong the firm wants its robustness. For example, Toyota’s software error that caused cars to accelerate without drivers touching the gas pedal and causing accidents.\n\nFunctionality vs. usability\nSoftware usually works different than the human brain. That’s why software oftentimes needs to be changed in order to be used by humans easier. Sometimes it’s the other way around and the function and the end-result is more important than the software being user friendly. The tum enrolment-system, for example, is highly functional and its only goal is the enrolment in the end, but for people who newly join the university it is an absolute nightmare to reach this goal and become familiar with the software.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1317984,
      "meta": {},
      "text": "Partially reused from own submission SS21\n\nFunctionality vs. usability \nFor a software to have the highest functionality means often to have as many functions as possible. This ends mostly in a very clenched user interface. What again leads to a low usability. The other way around, to achieve a high usability, functions get hidden by the developers, to make a clean and easy-to-use interface, which causes a loss in functionality. Here Microsoft Word could be mentioned as an example, because it has many functions, which are hidden and therefore rarely used by the regular user.\n\nEfficiency vs. portability\nIf you want to bring a desktop application to a smartphone, you often have to handle the Efficiency-Portability trade-off. Mostly the desktop application has more resources to use than the smartphone application has.   Therefore the efficiency on smartphones decreases. An example would be the Duolingo Application. To counter the Efficiency-Portability trade-off Duolingo provides more features on the desktop application than on the mobile one. (e.g. the whole vocabulary, more extravagant animations etc.)\n\nCost vs. Robustness\nTo build a very robust and stable software, the development team has to test it for every possible case. The testing process is therefore very long and intense, which causes a lot of working hours. Which again makes the process more expensive. A very cheap software therefore could be not very well tested, because it is an easy way to save some money. But when you buy expensive software, you expect a stable system almost every time. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344238,
      "meta": {},
      "text": "Rapid development vs. Functionality:\nThe developers would of course need more time to add more features & different functionalities to their software. e.g. if we consider an example of a music streaming platform development process, where the client requires rapid development: the developer may have only the time to add the basic features, but not additional functionalities like connecting to a friend, viewing what a friend is listening to at the moment etc.\n\nFunctionality vs. Usability:\nThis is the trade off between how easy it is to use a software vs. how many different operations it supports. Let`s think of a no code application creater platform: it offers the opportunity to create a mobile/web app with zero coding knowledge and it is super easy to use, but at the same time it is really limited what you can achive by just using the templates and customization options there. So here we can say that the usability is very high, whereas the functionality is limited. If we wanted to add even more customization options etc. to this platform, we could increase the functionality but then user control, thus usability would decrease.\n\nCost vs. Robustness: Robustness is the ability of a system to adapt to the changes in the environment and maintain it`s functions -> e.g. if you want your system to tolerate very low temperatures (-30 degrees), that is of course costly to build. You must make a compromise of the robustness level if you want to build it cheaper.\n\n\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344752,
      "meta": {},
      "text": "1. Rapid development vs. Functionality: the client will set a delivery date hoping that the software can be rapidly developed and on time delivered. From the point of view of customer there are many functionalities that need to be realized with the delivered product. However, such two goals sometimes cannot be fully considered. So, the trade-offs here is should the product be delivered on time or meet the complete functionality requirements.\n\n2. Functionality vs. Efficiency: to fulfill all the functionalities, the system should analyze the requests from end users completely, which may take some time and make the system not so efficient. For example, if we try to integrate a search tool for a shopping website, the system can show us all the relevant products that have relationship with the given keywords without sorting. But the system can also analyze the relevance of the products and sort them by relevance or customer’s own preferences. Obviously, the latter will take longer time but has more functionalities.\n\n3. Low cost vs. Adaptability: from the point of view of clients, there should always be a budget plan for product development. So, everything that happens during the development process costs time and money. As developer, it is wished to make the product adaptable. That means despite changes of environment, the product needs to be usable without any big Problem. To realize the adaptability, developers and testers need to take much longer time to optimize architecture and do a lot more tests, which surely means more costs for the client.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1350363,
      "meta": {},
      "text": "1- Low cost vs, Minimum number of errors\n\tTo minimize the number of errors in software, the developers need more time and maybe need to use more advanced technology, and all of these factors require more money. For example, using AI with a large database to make the software more precise can cost a lot of money. \n2-  Rapid development vs, Functionality\n\tLimiting the developers with a time span can affect the functionalities of the software. Some can be ignored or minimized due to a lack of development time or the time needed to test or finish the more important functionalities. For instance, two weeks to make software with many major functionalities is not enough.\n3- Backward compatibility vs Robustness\n\tUsing assets or parts of a previous version can prevent the software from being solid and complete. Old codes can contain bugs or unclear functionalities. It can make the software more complicated because they aren't compatible with the current updates. Like when using an old version of java to develop a software. The problem is that some useful libraries aren't available.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292199,
      "meta": {},
      "text": "1) Functionality vs. usability: A famous example for this trade-off is the conflict between the operating systems android and IOS. Objectively seen, iOS is for many people more user-friendly than android due to less functionality and fewer options for personalisation. Each iPhone works the same independently of the model. Many people consider this a very convenient and thus prefer apple. On the other hand, many people, especially those who have a general understanding of technology, complain about limited functions. \n\n2) Rapid development vs. functionality: A proper and broad functionality of a system requires certain amount of time. Functionality often means connectivity between different applications, thus complexity may increase. A complex system needs more testing and troubleshooting, which increases development time. The only way is to neglect testing or troubleshooting, which causes bugs and less usability. Consequently, the system functionality might be perceived as insufficient. E.g. we had this problem in a startup I had an internship. They introduced a chatbot, which was developed very rapid after clients were complaining about the support. After only two weeks the bot was taken offline again due to severe functionality issues.\n\n3) Cost vs. robustness: Coding can be seen as a service. Pricing is often based on development time. A small development budget affects the time a coder is engaged in the project. It might lead to less testing and troubleshooting. In conclusion, there might be huge vulnerabilities and bugs, whereby the robustness suffers. For instance, if there is less time left a coder might even make trade-offs which causes confusing and bad code, which is then unmaintainable anymore. Consequently, the robustness is poor.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1313557,
      "meta": {},
      "text": "1. Rapid development vs. functionality: You can either add many new features to a program or just focus on the central features and get it done time. For example in Bumpers, you can add special collisions and spend time on telporting cars or just focus on the central game features first.\n2. Functionality vs. usability: If you keep adding complex operations into the program this can end up reducing the usability. This is why there is a trade of between ease of use and functionality. In bumpers, the more possibilites you give the user to choose, shoot, collide, different car types etc. the more comlex the game gets and the less usable it becomes - but in the case of a game increased complexity is often what the users want.\n3. Cost vs. robustness: Testing is costly, the time and effort you spend testing and troubleshooting costs money. However it also makes your program/game more robust.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1313826,
      "meta": {},
      "text": "1. Flexibility vs. Simplicity.\nBecause you know you're starting with a seed of a concept, certain systems require a lot of flexibility and expandability. Others only require a simple deployment with frequent reminders.\n2. Space vs. Time.\nIf you're short on time, you'll want to start using tactics like pre-calculating possible values. On the other side, you may need to save space and have some spare time, which means compression and normalization will be used to reduce duplicate storage.\n3. Development time vs agility/clarity\nYou can do something quickly and unclean, potentially slowing down future progress, or spend time upfront designing proper interfaces while risking the frameworks' future use.\n",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1318267,
      "meta": {},
      "text": "Design Ziele werden üblicherweise von clients, developers und end users formuliert. Aber aufgrund der Differenz ihrer Hinsichten werden design Ziele oft so formuliert, dass die einander widersprechen. Zum Beispiel:\n1. Minimum # of errors und rapid development:\nZ.B. muss einen Betrieb in sehr kurzen Frist ein App mit viel unterschiedlichen Funktionalitäten entwickeln. Den ganzen App zu entwickeln ist gar kein Problem, aber alle Funktionalitäten ausführlich zu testen ist schon ziemlich kompliziert, weil es sehr viel Zeit im Anspruch nimmt: man muss Teste erstellen, Randfälle aussuchen, Fehler behandeln. \n2. Low cost und functionality:\nZ.B. nehmen wir wieder einen Betrieb, der einen App entwickeln muss, aber es wenig Kosten zur Verfügung steht. Das bedeutet, dass Mitteln, die für die Entwicklung eingesetzt werden und alla kostenpflichtig sind, nicht gekauft werden können (Lizenziösen). Aufgrund dessen werden einige Funktionen beeinträchtigt oder sogar nicht implementiert.\n3. Backward compatibility und readability \nZ.B. nehmen wird ein Programm oder Software, in die neue Funktionen integriert werden müssen, sodass Software mit anderen Programmen/Software weiter einwandfrei funktioniert. Das bedeutet, dass altes Funktionalität weiter beibehalten wird und neues hinzugefügt wird. Also wird code immer größer und somit wird readability beeinträchtigt.",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1330899,
      "meta": {},
      "text": "One typical design goal trade-off is cost vs. robustness. If you want to achieve a robust system you often times have to test a lot so that you cover every possible user input and change in the environment. So if you want a robust system there will be more testing and therefore coding cost. For example if you build a software product that will be also used by kids than you have to test all possible inputs and disruptions out there, because they don't know what they are allowed to press and what not. So therefore the software needs to be robust and hence the developers need more time to test and code the application.\n\nAnother typical design trade-off is functionally vs. usability. Because the program can have all the functions in the world but they still have to be usable. The user has to know where everything is and how they can execute all functions. For example if you have an calculator application, but the user only sees a input field and doesn't know at all how to write their calculations in the field, then the calculator could do all kind of things but the user does't know how to use all the functions.\n\nA third typical design trade-off is fast development vs. functionality. A developer needs time to develop all functionalities and debug them etc. So if you want your application to have many functions then it's often that  you have a longer development time. For example again with the calculator: If all the functions are necessary then the developer needs time to code them.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1336924,
      "meta": {},
      "text": "Typical design goal trade-offs are Functionality vs. usability, Cost vs. robustness and Cost vs. reusability a example of the Functionality vs usability would be that a a client wants to have a lot of functions and that makes the interface very unintuitve to work with so there is a trade-off with the usability. An example for the cost vs the robustness is the testing of a program one can test way less if the cost does not allow it so there could be reliability problems which could accrue that have not been for-seen on the other hand the cost will go up if the tests would be performed and made because these typically take up a lot of time. Cost vs reusability is very similar to the cost and robustness because the reusability has to be ensured by testing as well as adding more thing to the code so hit also costs time and therefore money and the client has to decide what he wants cost freienden or reusability .",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344668,
      "meta": {},
      "text": "\tOne of the typical design goal trade-offs is usability vs functionality. Including more functionalities or increasing their complexity will almost always make it more difficult for the user to learn how to use the system and then memorize it. For example if we add the functionality of ten additional types of collisions to the bumpers game that the player can choose from during the game, it will make it difficult for the user to remember what each collision does. \n\tAnother design goal trade-off is efficiency vs portability. If we want to make a system be portable - work on any platform, it cannot be optimized to work with a specific operation system/browser/hardware etc..  This makes the system slower and less efficient. For example if someone develops a game for a specific computer, they can adjust the game to perform better on the hardware by taking things like cache size into consideration or using instructions that possibly don't exist on other processors. This will make the game slower or possibly not executable on other systems.\n\tRapid development vs functionality is another design goal trade-off. When software is developed fast, some functionalities cannot be included or have to be simplified because they take way too much effort and time. I will take the bumpers game as an example again. If the goal is to have bumpers as a 3D game with the movement of the car being steered by the players hand movement in front of the camera, then it will definitely take more than a few days. If the priority is to be finished fast, these extra functionalities need to be omitted. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1345765,
      "meta": {},
      "text": "•\tFunctionality vs usability\nThe more options / functions you have the less usable the system becomes. This can be observed when comparing a state-of-the-art smartphone with a functionally reduced one for eg. elderly. The function reduced phone becomes easier to use and quicker to adapt to, thus appealing to generations new to the digital era.\n\n•\tCost vs robustness\nRobustness describes the systems ability to handle stress and tolerate invalid or unpredictable input. Overall robustness could also be called fault tolerance. A life critical device like a system monitoring heart rate of patients should be designed more fault-tolerant while accepting the higher development costs. These costs are needed to develop a system that for example includes process replication. There redundancies in processes are intended to ensure consistent runtime in the overall process.\n\n•\tRapid development vs functionality\nThe smaller the time frame for a development project is, the fewer functionalities can be implemented. This is a straightforward capacity calculation, where for example one developer gets 5 days to implement as many functionalities as possible. Assuming she spends 5 x 8 hours = 40h on the project and each functionality requires 5h. Therefore, she can implement 40h/5h = 8 functionalities. With a two weeks deadline she would have been able to implement 16 functionalities.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1390044,
      "meta": {},
      "text": "In software development trade-offs always have to be made in order to achieve a certain design goal.\n\n1. Minimum # of errors vs Rapid development:\n\tHaving minimal errors goes hand-in-hand with slowly testing and refactoring code in order to eliminate \t\t \n        the obvious and not so obvious errors that could occur, and rapid development directly opposes this. For \n\tinstance, asking software developers to make your fully functional app in three months, but make it run \t \n        seamlessly without errors is unreasonable, and a trade-off needs to be made.\n\n2. Well-defined Interfaces vs Modifiability:\n\tHaving well defined and structured software and interfaces doen't allow for much modifiability, because \n        then the interfaces wouldn't be very well defined, so this makes another trade-off. A software engineer \n        can't  make a website with a rigid interface that allows users to interact with it only in specific ways, and \n       make it easily changeable, because changing it would require redoing the entire website.\n\n3. Efficiency vs Portability (Cross-Platform): \n\tMaking an application or website crossplatform directly affects the efficiency of that programm, because it \t \n        requires making it efficient on multiple different platforms and architectures. The best example is Java with     \n        it's platform-independent VM, which makes it compatible with different machines, but makes it slower \n        since it adds another layer between the programm and the hardware.\n      ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1422394,
      "meta": {},
      "text": "Security vs Readability : One of the ways to have a more secure software system is Obfuscation which consists of making the code so hard to read and understand for example by giving variables long, cryptic and non informative names  and by adding useless operations in the code like adding a random variable at the beginning then subtracting it at the end ( example : Before : a = b + c; After :  r = rand(); a = b + r; a = a + c; a = a - r; . both Before and After do the same thing, the After however looks more complicated ). This might discourage potential hackers who don't want to spend much time understanding what the program actually does, but this will also make it hard and even impossible sometimes for fellow programmers who might work on the same software. \n\nEfficiency vs Portability : Developing efficient software might require using some lower level programming languages such as C and C++, however, once compiled, the program will only work on that specific operating system and if you want to be able to use it on another OS, you will have to recompile it or even rewrite it for that OS, if you use languages like java however, you might lose some of that efficiency that you get from the likes of C and C++, but you can actually run your software on any operating system without having to recompile the code \n\nFunctionality vs Usability : It might be compelling to include as much functionality as possible in a software system, for example a pvp fighter video game where you can use different input combos to perform different attacks. As the developer, you have to know that having 100 different attacks might be nice, it will be however so hard for average players to memorize all of these combos which puts them in a disadvantage when they play against other players who might know more attacks than them",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1486630,
      "meta": {},
      "text": "1. trade-off:\n Rapid development vs. Functionality:\nIf your customer wants you to develop a new streaming platform in 1 month but the requested functionality is to complex to implement in the desired time span you have to decide between just developing the basic functionality so people can actually watch the stream and chat and as much additional functionality as possible or you take longer then the desired month and finish all desired functionalities.\n\n2. trade-off:\nCost vs. Robustness:\nIf you want to develop a website for your costumer and they ask you to make it as cheap as possible you can rent less servers for the website which would reduce the cost but also lead to less people being able to access the website at the same time, which would lower the websites robustness. So you have to choose between a low Cost and a high robustness\n\n3.trade-off:\nFunctionality vs. usability:\nIf you want to develop a new controller that adds several new features like a touchpad and 3 more buttons you can increase the functionality of the controller but it will be far more difficult to use the controller.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1501674,
      "meta": {},
      "text": "1. In some cases compromises have to be made between cost and robustness. An example for this is that you might want to store data redundantly so data loss becomes less likely. This has the downside of requiring more storage capacity which in turn means higher cost for the client running the application.\n\n2. Another typical example is the tradeoff between performance and readability. If a change to a piece of code makes it 5% more performant but doubles the time for a new developer to start working on it and makes introducing a bug far more likely then choosing the less performant version might still be the better choice. \n\n3. Compromises also often have to  be made between backwards-compatibility and security. A real world example for this is an old feature that significantly increases the attack-surface of the application which can't be removed because a lot of users still heavily rely on it.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292061,
      "meta": {},
      "text": "1. Backward compatibility vs readability:\n\nSupporting both newer and older behaviors and functionalities is often hard because it often involves using and rewriting outdated systems into newer models. For example, when rewriting an API from a V1 into V2, you would need to properly understand the features of the V1 and then continue to support them, even after V2 is implemented. If said functionalities are not properly documented, future developers and users will have a hard time to understand what they do, why there is redundancy, or why they exist in the first place.\n\n2. Functionality vs usability:\n\nA common request of the end user is to have as many options and customizations as possible, which would require the developer to create a different configuration for each preference. For example: \"I would like to change my background image\", \"[...] change text size\", \"[...] change text font\", etc. The issue is that an excess of functionalities may lead to a convoluted client-interaction interface, and an often unorganized workflow for developers. \n\n3. Cost vs. robustness: \n\nIt is not uncommon for the client to ask the developer for a cheaper alternative, in exchange for lower robustness. A good example would be preferring a cheaper server with less memory and computational power, which, of course, may be easily overloaded by an unusual higher demand; this will, therefore, directly impact the end users.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292091,
      "meta": {},
      "text": "Design goals consist of non functional requirements and goals concerning the design metrics (eg measure costs) and the design methodology (eg agile). Design goals play a crucial part in the system design phase. However, in many cases they conflict with each other. That's where trade-offs come into play.\n\n1. Cost vs. robustness: A robust system should maintain a function even if e.g. the user provides wrong inputs. Checking for wrong input, and thinking about what could potentially go wrong requires time and work effort. This is of course linked to additional costs.\nEg. in a calculator you can input illegal formulas. If one design goal was robustness then these will return an error. However, making sure that a formula is correct took time/money in the development phase.\n\n2. Efficiency vs. portability: Efficiency is about fitting the software perfectly to the hardware (e.g. use the gpu for specific operations; store frequently used values in specific registers/caches). Portable software should run on all plattforms. That means that you don't know how the number of kernels, cache size, .... That means that you cannot optimally fit your program to your hardware and you loose efficiency.  \n\n3. Functionality vs usability: If e.g. a navigation system of a car not only has the function to show the shortest way from A to B, but can also be used to listen to music, browse the internet, ... the user will lose overview. Especially in the beginning this leads to a overwhelmess. It is very difficult to learn and remember all the different functionalites and how to use them in the best way. This impacts user experience and the usability of the system badly.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1355387,
      "meta": {},
      "text": "Cost vs. robustness: The cost and robustness are usually in conflict with each other. If you want to build a softawre product with a lower price, you can´t expext, that this product gonna be as much robust as another software product with a higher price. the best example is google, which is more robust  but expensive than PinguPingulos. \n\nCost vs. reusablity: If you build a reusable software product, you can use its components to build another software products instead of building it from scratch, so reusabilty has a lot of benefits in a long term. However in order to build a reusable software product you have to be aware of the higher cost, because it has to be build in a global and not specific way which makes it more difficult to build and test and eventually more expensive. For example if you have to build a reusable component, then you have to make a higher cost tests and also additional coding costs.\n\nRapid development vs. functionality: the built of a software product in a short time can cause a lack of functionality. As a human being you can't manage building an efficient functional product in a quick time whithout having some potential bugs. Even the most experienced Developpers can't manage that. For example, if you implement an app this month and test it. You gonna probably find a lot of issues after 2 or 3 months. So the more time you invest in developping a product the better is its functionality.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1413370,
      "meta": {},
      "text": "1. Backward compatibility vs. readability - in order to implement backward compatibility, many old, deprecated, possibly insecure and/or ineffective functionalities have to be kept in the system, which first of all makes the code less readable and the documentation becomes longer and more unclear.\nThe other possibility is to focus on readability, which may require removing every extra/deprecated code from the project (and its documentation).\n\n2. Rapid development vs. functionality - in order to have an application developed in the least amount of time, the developers can only focus on a limited amount of features - the core features. Of course, a solution might be to increase the number of developers, but then the costs are significantly increased.\nIf more functionality is to be desired, the development timeframe has to be increased.\n\n3. Functionality vs. usability - a higher functionality makes the system more complicated, i.e. decrease its usability. Take a scheduling/ daily activities app for example - if you'd like to expand its functionality by allowing the users to analyze their activities, the more powerful the analyzer is, the less intuitive it is to use, understand.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1417693,
      "meta": {},
      "text": "functionality vs usability:\nfor example in a video game on the pc. you can have different attacks on all keys of the keyboard which would be high functionality. But it wouldnt be user friendly anymore, because first the user would have to learn all those abilities, second remember all those and then also be able while playing to press all those at the right time, which all result in little usability. In conclusion if you add more functionality it can lead to worse usability because the user cant comprehend all features.\n\nperformance vs. space:\nMore memory can lead to faster programms (e.g more cache or beforehand calculations). For example hashing, if i do save the result of the hash function for every possible key, then i dont have to do the calculation every time which then leads to better performance and vice versa (only read operation vs. calculation). But typically the aim is not to need too much space, because of hardware constraints. so we want as high performance as possible with as little space needed as possible.\n\nfunctionality vs rapid development:\nin the dream case scenario the client wants to get all requested functionality fulfilled in as little time as possible. But simply more implementation means more time needed. \nSo in the most basic scenario where a developer can type 1000 lines of code in an hour and each functionality needs around 1000 lines, means the developer needs for one more functionality 1 more hour time. The aim is to get as much functionalities in as little time as possible.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1472511,
      "meta": {},
      "text": "Obviously, when functionality is added, it takes time to actually implement those features, increasing the cost of the project, since you have to pay the programmers, designers, etc working on the project and decreasing the development speed, since time is spend on more features, leaving other features to be done later.\n\nTesting programs and fixing errors that come up takes time and costs money, since developers have to spend more time working on the code, making it more expensive to pay them (because we still pay developers) in exchange for more robust and fail safe code.\n\nBackwards compatibility needs more code to account for the different systems, making the over all code longer and less readable, depending on the implementation... If you for example need to call different methods for different systems, you would need to somehow implement a check which of the systems you use, as well as one or more method call(s) for each of the possible results.\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1293646,
      "meta": {},
      "text": "1: cost vs. robustness - often when the available budget is limited, the developers can't put that much effort into testing and building edge cases because they have to focus on the main features of the software. For example, if you build an app for tracking tennis games/players and you have only a budget of 5000€, you cannot ensure that every edge case is covered since the implementation of the most basic features already use all of the available budgets.\n\n2: functionality vs. usability - the more functions a software gets, the more difficult it is for new users to use the software since it is very complex. For example, if you take a modern ERP system, it has a ton of powerful features and is capable of a lot of awesome things. But for a new user, it's nearly impossible without the help of a third party to get started in using the product.\n\n3: efficiency vs. portability: when you write a program that should run on all kinds of different platforms, you cannot provide a product that is tailored to and uses the resources of each platform very efficiently. For example, if you build an app with Ionic and distribute it to iOS and Android, you can never achieve the efficiency and performance you would get when you build the app natively for each platform.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1297832,
      "meta": {},
      "text": "When establishing the design goals for a software, the developer must not only think about his/her goal, but also about what the client and the user wants. As a result one must make a trade-off, and decide which design goal must be sacrificed in order to achieve another.\n\nOne of these trade off is for example functionality vs. Rapid development. For instance, a project has a defined due date, requiring that all functionality be completed by that date. However, sometimes the functionality  cannot be completed in time. The trade-off in this scenario is between required functionality and required schedule. Either the system is on time and not completed, or completed but late.\nAnother example is efficiency vs. portability. On the one hand the system should not be slowly to user input. It should run efficiently and according to the user’s wishes. But at the same time the client system should be usable on multiple platforms, and should be easily ported to a new architecture, should the need arise. Again, the developers must decide what to prioritize.\nFurthermore there is functionality vs. usability. When creating design goals, functionality and features usually sound like a good idea, but can often get in the way of the user’s goal. A large number of functions in one user interface can be an annoyance that makes interfaces more difficult to learn and use. The developer has to decide how to balance the function and control of the system, while making it neat for the user.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1299393,
      "meta": {},
      "text": "1) Functionality vs usability\nThe design goals of functionality and usability often conflict. On the one hand, the user of a system wants a high level of functionality so that he can achieve his goals in a straightforward way.  On the other hand, the user may be overwhelmed if you provide him with tons of different features.\n\nFor example, if you offer a player a huge number of settings in a game, all of which have very little impact on the game itself, you created a huge opportunity for individual customization, but you also frighten off any players who don't know what the specific settings actually do.\n\n2) Cost vs reusability\nThe cost of a project is often related to the length of the project.\nFor example, if you want to minimize the cost of a project, this usually means that you try to reduce the time and effort spent on the project and that fewer people are involved in the process. This means that less time can be spent on the actual planning of the project, resulting in poor coordination, code repetition, poor division of tasks (divide and conquer) and bad documentation.\nThis makes it very difficult to reuse already developed things in the current project, but also in following projects.\n\n3) Rapid development vs. functionality\nIf a project has only a very short runtime, but still should have many complex functionalities, it may be impossible to add them all because there is just not enough time.\nFor example, if a large project is designed in such a way that there is not enough time for a clear preparation and the development. It is obvious that a large part of the desired functionality is not available at the deadline.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1350444,
      "meta": {},
      "text": "Functionality vs. usability\n\nOften, if you try to implement as many functions as possible, there is the potential problem that the user can be overwhelmed by the many opportunities to choose from and as a result, he may choose not the best fitting functionality for his problem. For example:\nsoftware that enables dozens of different customization options, can be time-consuming and confusing. As a result, the user cannot easily make his decisions. Therefore usability is reduced. \n\n\nCost vs. reusability\n\nIf costs are relatively low, there is a great chance that the software engineers did not develop the best generic solutions (but used one-to-one multiplicity) because they would be too time-consuming and the testing effort would be pretty high (and therefore costly) to develop.\nFor example:\na software, which enables the communication between the TUM and their students. It would be more cost-effective to design the program only for that case, but it would be hard to reuse the program for another university system. \n\n\nRapid development vs. functionality\n\nIf the main goal of development is rapid development, then you have to make some compromises in the functionality area, because you don't have the time to make extensive testing and therefore some functions may not work out.\nFor example:\nA company wants to have software for calculating pay loan checks as soon as possible. Because of lack of time the chance that the functionality does not work as wanted is more likely.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1432868,
      "meta": {},
      "text": "When designing a product, our main goal is to create something new or improve something already existing. We have certain goals and focus on multiple different aspects, such as quality, functionality and maybe aesthetics. However, not always can we fulfill all areas and some compromises have to be made.\n\nA typical design trade-off that wasn't elaborated in the lecture for example is \"Efficiency vs. portability\".  If there is a deadline in making a website, the developer might have to choose between improving the website, that can be accessed on different operating systems and platforms instead of making an application. There is a reason why most games are only available on Windows. Most companies don't have the need to put effort into making games available for macOS since the system doesn't even support gaming and can focus on other things.\n\nAnother trade-off is \"Rapid development vs. functionality\", where rapid development is mainly focused on speed. Ideally, we want a well functioning program in a short period of time. If the developing process is rushed, problems and errors can be easily overlooked and not enough testing can result in a less functional program.\n\nLast one is \"Backward compatibility vs. readability\". In this case, when working on a code, essentially improving it, the developer has to make sure his new code works well with the already existing one. However, eventually, the old code might start to intervene with the new code and in order for the program to function well and be easy to read and understand, the old code would have to be removed or adjusted.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1448587,
      "meta": {},
      "text": "The first typical design trade-off is between functionality, low cost and well-defined interfaces. The end user wants a lot of functionality, whereas the client is only willing to pay a specific price, which is usually the lowest it can possibly be. That creates a problem and therefore priorities have to be discussed. Another trade-off happens when those two expectations meet the goal of the developer to have well-defined interfaces which takes a lot more time, which the client is not happy with.\nAnother typical design-tradeoff if the tradeoff between maintainability and functionality. The client and the developer both want code that is easy to read and cheap to maintain, whereas the end user doesn't really care about it, wants a high level of functionality and usability, which requires a lot of code which in return means that it is a lot more work to maintain it.\nThe last typical design-tradeoff I want to point out is between runtime efficiency and reusability. The client and the end user both want the product to run fast and return the expected results within an acceptable amount of time. The developer wants to create code that is reusable with which they can easily work in the future and build upon. To guarantee that the code needs to be well written and structured and not written down in a way that ensures to get the problem solved in the fastest way, but in the most elegant way.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1461944,
      "meta": {},
      "text": "Maintainability: We can define maintainability in software engineering as the degree of the improvement of developing application which refers to the repairement, improvement and the understanding of the software code. The quality of the software and the quality of coding can make create a very important difference for the software maintenance. As a result, the developers continuosuly adapt softwares to meet with the newest and latest customer requirements and address problems faced by customers. Example: Detection and the correction of the system bugs. Users mostly find bugs and as a result they report them. It is vital for the developers to make these corrections for the good of the software system. \n\nScalability: Scalability is essential for the longevity of the product and its system. In the evolving industry and the rapidly changing technology the customers' preferences can also quickly change and tehy can demand newer features. And as the maker/owner of the product, we need to keep up with the latest technology and the needs of the customers. This is where the software scalability shines. The software scalability is the attribute of a system or a product tool to increase its capacity and increase the variety of the functionalities based on the demand of the users. When the software is scalable, it has the ability to adapt the changes and upgrades while remaining stable. Example: You have developed a qualit antivirus program and it gained a lot of attention from the users thanks to its quality. You can then make changes and upgrade its security functions and integrate the system with other sources. It makes your system much more worthy and you can profit from it much more if you offer these features in a premium subscription pack. \n\nExtensibility: Extensibility in a software system is a must to have. We can define extensibility as the ability of a software system which allows an extension based on its own capabilities without having any big changes in the coding or the architecture ıf the softwafre system itself. More extensible systems consist of better tools so that the developers expand the capabilities and improve the product. Example: Some video games that can be played with multiple languages. It extends the options of the game, the system and can also offer a better time for some of the customers.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1466880,
      "meta": {},
      "text": "Cost vs Robustness\nIf there is a small seller and he wants to develop a website. Lots of people will be buying from this website. He needs it to be robust but also at the same time, he needs it to be cheap. As he is a small seller he cannot afford it to be expensive.\n\n\n",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1491143,
      "meta": {},
      "text": "One design goal trade-off is the trade of functionality or usablity.\nPrograms in software engineering can be full of functionality and uses, but for the end user, this just means that they will have a more complex program in their hands, that will not be that easy to use. People might need schooling just to get along with the program. A focus for functionality would be more apropiate for software used in a special apartment, like medicine or the military, where people can be more easily schooled about these programs do benefit more on their functionality. Unlike apps that are aimed at the public for entertainment purposes. Not so tech savy people will benefit from more usability.\n\nThen there is also the design goal trade-off of efficincy vs. portability.\nIn our modern times smartphones are probably the most widely spread computer around the population. These are not as powerful as a home desktop or a laptop. So programs like for example a video editor should have an efficincy downgrade if intended to be used with smartphones.\n\nThe final design goal trade-off would be cost vs. robustness.\nComputer programs can be exploited by people with enough knowledge, if constructed poorly. This can be avoided but takes a greater expense which will influence the costs. So if the intention is to build a robust code, like a program for a bank, you shouldn't be saving costs.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1648673,
      "meta": {},
      "text": "efficiency vs. portability:\nFor example the system should run efficiently and according to the clients wishes but should also be portable to multiple plattforms. For example if u design a selling system it would benefit if u can use it fo several different selling plattforms so you dont have to design every time a different personalised programm, which would cost u more money and more time.\n\nrapid development vs. functionality:\nOne example is the delivery date. A software project has a defined delivery date, but sometimes the required functionality is not ready till the due date so the projects needs more time to be completed in the right way.\n\ncost vs. robustness:\nfor example you need to decide if you want your system to be more robust for example by using an additional cloud service to safe all your data. This will be additional cost but it will be much safer and the risk of losing data will be lower. \n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1654488,
      "meta": {},
      "text": "A first tradeoff would be functionality vs usability. While creating the system we want to have as many functions as possible. At the same time we want a user to have a good understanding and overview of what it really does. If we look at the facebook 10 years ago and now we can see that although now you can do almost everything there(play games, sell things…), it is mega easy to lose overview, because there is now a lot of complexity in interface and functionality. \nA next tradeoff would be efficiency vs portability. When we create a system we want it to work on any of the devices(android, iOS,macos, windows, web version…). However each of those operating systems has its own specifications and a product that works really good on iPhone would not necessarily work good on Android, e.g. while creating a mobile app we discuss using cross-platform development or platform specific.\nA last tradeoff would be cost vs reusability. We can create two classes that will have relationships only with each other. It would be not that hard and really cost efficient as as the testing process would be really easy. However, these classes would not be really reusable. If we model two classes in a more generic way, which would allow us to link them with many other classes, it would of course increase reusability. However the costs for testing would be much higher.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291544,
      "meta": {},
      "text": "It is often very important for software to be backwards compatible, for example when a programming language gets updatet it should still support all the functions from before, if some of them would no longer work then many systems would just break, because somewhere in the code exactly this function is used and it is a massive effort to check your whole code after every update and maybe the software company does not even exist anymore but it´s software is still used.The problem that comes with backwards compatibility is the readability of the code, because all old functions still have to work the only thing really that can be done is add new functions or maybe just optimize previous code a bit and when functions with very similar functionality to a previous function are added, for example the function uses one parameter less, because it was optimized, then the old and outdated function still has to remain in the new code.\nAnother point is of course cost vs. robustness. Almost everyone does not want to pay huge amounts of money for software so at some points money has to be saved and money in software engineering is often equivalent to development time and this time can be used to test out potential security issues, but when not enough money is available this testing time can be cut down quite easily.\nThe next typical trade off is when the client wants a big bunch of functionality for his software but for example in a mobile app the space is limited and if the whole screen is fully packed with options to click on the usability is lost very fast.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1292145,
      "meta": {},
      "text": "1) fast development vs best functionalities:\nAs a development team, you can set the focus on very fast development and delivery but risking to suffer cutbacks regarding the details and quality of the functionality of the system which would take longer. This depends on the wishes of the client.\n\nExample: The \"Corona-Warn\" app was developed very fast as the need for a quick was very high in 2020. Unfortunately, this also resulted in cutbacks regarding the functionalities at first which were fixed over time.\n\n2) Implementing all functionalities vs reducing the functionalities for usability.\nDevelopers have to decide between implementing all functionalities in the system risking a cluttered appearance of the system or focusing on a lean and simple appearance of the system. \n\nExample: The old website of \"tum online\" laid a high focus on implementing all functionalities which in my opinion decreased the easiness of use, as you would have to get very familiar with the website to use it. The new website rather focuses on usability I would say.\n\n3) focus on efficiency of the system vs portability of the system:\nDevelopers can focus on high efficiency, laying a focus on the performance but risking possible cutbacks regarding the portability on multiple platforms. This depends on the wishes of the client. \n\nExample: MS Excel has a great efficiency on Windows but you will experience certain efficiency cutbacks regarding the portability on IOS systems. For example, you don't have certain keyboard shortcuts on IOS as well as some functions don't work properly like on Windows (e.g. the chart functions)\n\n\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292692,
      "meta": {},
      "text": "1. Functinality vs. Efficency  \nWhen developing a software product for example a system that purchase tickets, you can't put every possible feature into the system design for example the user is able to select dates, types of the ticket, compare the price between different tickets and chose the cheapest one and at the same time ensuring that the user could purchase a ticket in less than 2 clicks. \n\n2. Performance vs. Cost\nWe can't expect the software e.g. a chat system to support millions of users with zero downtime, when this software is developed with low cost. As low cost gives in return low performance for most of the time.\n\n3. Reliability, Perfoemance & User experience\nWhen implementing a safty feature in a car, you want the car to have more automated technology then the driver may feel a greater effect, such as losing the ability to control the car himself in certain situations and how safe he feels when the car is essentially guiding itself. When implementing new technologies that require less and less human navigation you must consider the consequences that people face. They lose the feeling of having control and freedom over what they own, which may make them feel uncomfortable, but at the same time they want a product that is smart and requires them to do little work. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1294992,
      "meta": {},
      "text": "A very frequent design goal trade-off is made between cost and functionality.\nThe client always wants to minimize the development cost, or even has a fixed budget they can't exceed in some cases, which usually means less time for the developers to work on the solution, as developer time is the biggest expense in any software project. Logically, this means that not all desired functionality can be implemented and the importance of some features has to be reconsidered.\n\nAnother common trade-off is rapid development vs. robustness.\nMany clients set very high expectations but very short deadlines. The consequence of this is often a decrease in robustness of the software, as developers have less time for testing and making sure everything works as it should. This can lead to unexpected errors happening in production, which is very undesirable.\n\nA final trade-off many projects make is between efficiency and portability.\nA mobile app might be developed using a technology like React Native so it can be released in both App Store and Play Store for iOS and Android devices, but that app will never be as efficient as a native iOS or Android app, so depending on which is more important, one or the other has to be overlooked to some extent.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1300556,
      "meta": {},
      "text": "Design goals can come from 3 different perspectives, the customer the client and the developer. These can conflict each other. The developer wants a minimum of errors, the client wants the product to ready as fast as possible. Obviously fixing errors takes time hence the conflict. Most video games today have many bugs on the release date due to very strict time limits and have to get fixed afterwards.\n In these cases the developers need to compromise.\nAnother common trade of is between backwards compatability and readability. If you have to make sure your Code works on older systems as well, you have to write more Code without changing the functionality and that makes. If a game should run on on older computers as well, this leads to more complicated code.\nA third example is functionality versus usability. The better something functions the lesser usable it is. To be usable you need certain comforts, so that a person who isn't an expert can use your product. Linux has many advantages compared to Windows, but most people use Windows, because it is much more comfortable to use\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1312512,
      "meta": {},
      "text": "Functionality vs. usability:\nEin großer Konflikt zwischen zwei Design Goals. Auf der einen Seite will der Entwickler dem Benutzer viele Funktionen zur Verfügung stellen, auf der anderen Seite jedoch würde die Benutzerfreundlichkeit unter zu vieler Funktionen leiden. Ein Beispiel wäre eine Wetter-App. Wenn eine Wetter-App 100 Funktionen hätte, die Daten über die Wetterlage gäben, wäre es zwar aussagereich und man könnte (als Kenner) viel damit anfangen, doch wäre es sehr schwierig so viele Funktionen in eine Wetter-App unterzubringen, sodass die Benutzerfreundlichkeit nicht darunter leidet. Wenn man die App öffnet und plötzlich 100 Möglichkeiten hat, mit der App zu agieren, kann das auf einmal sehr viel sein.\n\nRapid development vs. functionality:\nDer Entwickler will so schnell wie möglich sein Projekt fertigbringen, sodass er sich so früh wie möglich mit weiteren Projekten beschäftigen kann -> mehr Profit. Beispiel: Der Entwickler will eine Flughafen-App so schnell wie möglich entwickeln, sodass er schnell weitere Projekt angehen kann, um mehr Geld zu verdienen. Doch dieser Eifer, schnell fertig zu werden, kann dazu führen, dass das schlussendliche Produkt selbst darunter leiden muss. Mögliche Funktionalitäten, die gewollt waren oder sehr sinnvoll hätten sein können, wurden nicht implementiert, weil der Entwickler das Projekt früher abschließen wollte. So etwas kann natürlich immer problematisch sein, und deshalb muss zwischen diesen Aspekten gut abgewogen werden. \n\nEfficiency vs. portability\nAls Entwickler will man ein Produkt entwickeln, was effizient seinen Job erfüllt. Dabei ist es die Herausforderung, dass dieses Produkt auf allen Betriebssystemen, Plattformen etc. gleich gut effizient performt. Als Beispiel: ein Spiel, das auf allen Plattformen spielbar sein soll, soll auf all diesen ähnlich schnell effizient arbeiten. Eine Herausforderung für die Entwickler. ",
      "score": 91.7,
      "language": "GERMAN"
    },
    {
      "id": 1313596,
      "meta": {},
      "text": "Rapid-development vs readability:\nRapid development is a design goal that can interfere with readability because due to rapid development a project's code changes more often in a shorter time, which in most cases makes the code less understandable since the code was a lot different just a short time ago. \nThe Eist team project shows this trade-off quite well since the code changes relatively often there and all the new changes and functions make the code harder to understand.\n\nCost vs Portability: \nCosts and portability are opposed in the sense that it can often be the case that applications are only created for one operating system or platform and it, therefore, leads to increased effort/costs also to be able to use this application on other operating systems or platforms.\nAn Example of this trade-off is the Bumpers Game we created in the last weeks, which can now be run only on PC.\nSo it would be associated with higher costs to also be able to play the game on a mobile device.\n\nFunctionality vs Minimum # of errors:\nFunctionality and Minimum # of errors are a trade-off since more functionality means there are more opportunities for errors to occur. For example, when I tried to add a new collision to the Bumpers game, I encountered various errors that would not have occurred without this new collision/functionality.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1314639,
      "meta": {},
      "text": "1)  cost vs reusability.\nOne of the typical trade-offs in software engineering is cost vs reusability and there is a reason behind this. To make our system reusable we will need more time, more coding and even more tools to make our system maintainable and as a consequence; reusable. all of this factors will make the price go up for a project. For example: plastic cutlery costs about 25 euros for 150 pieces . On the other hand silver cutlery can cost around 350  for a 5 piece set. However plastic cutlery will only be used once and the silver one will be used again multiple times. In software engineering the same goes with systems, since to make it reusable we need it to make it maintainable  and stable enough to use it again \n\n2) cost vs robustness\nAnother typical trade-off is cost vs robustness. To make a system robust the price will also go up since we need to make adaptations to make it resist for example: wrong input. In the context of system design robustness can lead also to extra coding. For example, the user had given the wrong password. its very different when the user can try again to put their log in information as to when the page completely closes without even trying.  To make the user able to try again we have to code for example \"restore password\" etc. that's why its cost vs robustness \n\n3) Functionality vs usability \nThe last trade-off that i will explain is this one. more functions reduces the usability. Let me use an example. In an action game the clients may be really excited and want us to implement various things like \"run\", \"run faster' \"attack\" \"attack with sword\" \"super attack\", \"jump\" \"jump higher\", etc. But so many function won't be as memorable as if we only do \"jump\", \"run\" \"attack\" and as a consequence more functions are less usable  ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1347547,
      "meta": {},
      "text": "# H04E02 Design Goal Trade-offs\n\n## Functionality vs. usability:\n    In diesem Tradeoff geht es darum, dass mit mehr Funktion das System schwerer zu bedienen wird.\n    Ein typisches Beispiel ist openvpn vs wireguard. Openvpn hat extrem viele Features und viele Einstellungsmöglichkeiten (von Adapter, Verschlüsselung, Authentification, etc). Währendessen hat wireguard keinerlei Einstellungsmöglichkeiten, welche Verschlüsselung benutzt werden soll. Dies macht das WireGuard extrem einfach und sicherer, jedoch kann es Situation geben, in der die Software nicht verwendet werden kann, da bestimmte Einstellungsmöglichkeiten fehlen.\n## Rapid development vs. functionality\n    Ein typisches Tradeoff. In der Regel ist die Entwicklungszeit für ein Produkt beschränkt und i.d.R möglichst gering zu halten (um mehr Produkte zu entwickeln).\n    Ein typisches Beispiel wäre meine Abgabe für Bumpers Car. Um noch vor der Deadline fertig zu sein, musste ich auf zusätzliche Features wie mehr Collisionsmodelle für unterschiedliche Fahrzeuge verzichten.\n## Cost vs. robustness\n    Das entwicklen kostet immer was, ob Geld oder (Frei)Zeit des Entwicklers. Das ausführliche Testen eines Produktes sowie das abfangen von Edge-Cases kostet sehr viel Zeit. Falls die kosten (Zeit oder Geld) gering gehalten werden sollen, aber der selbe Funktionsumfang eingehalten werden soll, muss i.d.R. auf das auführliche Testen verzichtet werden.\n    Beispiel: EA bring ein neues Spiel heraus (Far Cry 5). Das Spiel wurde schon einmal verschoben, jedoch wurde entschieden, dass das Spiel trotzdem veröffentlicht werden muss. Als Folge bekam der Endverbraucher ein Spiel, das extrem viele Bugs enthiel und das Spielerlebnis wurde massiv eingeschränkt.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1457469,
      "meta": {},
      "text": "The design goals can be split between developer, client, and end-user goals.  The developer is interested in the comfortable workflow, instruments, and quality of his code. The client cares about costs, deadlines, and flexibility of the product, so the desirable changes can always be made. The end-user wants the product to be easy to learn and use, the product to be always available when needed, and of course the product that does the desirable. But these goals do not always intersect with each other. For example, the client wants the product to be finished before the developer can add everything he needs or fix all possible problems (fast development vs quality of the code), or the end-user would want the product to function any time, but it would mean more expense from the client (cost vs robustness), or the client would want the product to be easy to use for simple tasks, where the developer would gladly add more features (easy to use vs functionality).",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1651479,
      "meta": {},
      "text": "1) Cost vs. reusability: If the cost of re-using an already existing code is worth it. \nExample: Is the maitance cost of a code worth the amount of times you re-use the code for different purposes\n\n2) Functionality vs. usability: The trade-off between adding as many features as possible vs. still having an overview of all the features and making it easy for the user to use the software.\nExample: When releasing a new operating system can the user instantly understand and access all features or does he have to inconveniently google for all features.\n\n3) Rapid development vs. functionality: Does creating a software in a short amount of time hinder the features of the software.\nExample. Does releasing a video game early in a specific amount of time still deliver all features without bugs to the customer.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291813,
      "meta": {},
      "text": "Functionality vs. usability\nA typical tradeoff when building more complex systems where users of the system are not as proficient as the developers of the system. The challenge here is to build a system that provides a range of detailed functionality, while still being usable for the whole target group. An example here would be Trade Republic which fulfills a lot of highly technical stock trading functionality. The app has to be easily usable for non technical people while fulfilling all required functionality.\n\nCost vs. robustness\nThe challenge here lies in how much development time and other resources (=cost) one is willing and able to put into making a system robust. Therefore it is necessary to determine how important robustness for the system actually is, and how many resources are available. An example would be the embedded system of a modern car, with have to be very robust for safety reasons. This drives up cost. \n\nRapid development vs. functionality\nA tradeoff that is often observed in startups. The goal here is to ship something to your users as fast as possible, in order to receive feedback. On the other hand, you don't want your users to be disappointed by showing them a half-finished product. Finishing the product would however take a lot more time and you will receive feedback much later. An example here would be the launch of Amazon, which launched with a very simple design and only sold books. That way, however, they were able to verify that people were willing to order products online.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1293848,
      "meta": {},
      "text": "Three typical design goal trade-offs \n\n1. Trade off between rapid development from client's perspective and functionality from end user's perspective. Requirement of rapid development may lead to sacrifice of some functionality,  and vice verse.  \n\n2. Trade off between low cost from client's perspective and user-friendliness from end user's perspective.\nLow cost product usually is not well designed in details, which might cause inconvenience in some aspects  for user to use. \n\n3. Trade off between low cost from client's perspective and minimum number of errors from developer's perspective. Less experienced developers are cheaper but might have more errors in their code. \n\nexample:\n\nA restaurant owner wants to adopt a reservation system with low cost and within a short period, because of the low budget, he can only hire some unexperienced programmers, because of the rapid development requirements, developers have to deduct some fancy functions for end user, and the UI might not be user friendly, in the end, since the developers are not experienced and under time pressure, there might be many errors and the software can not achieve the functions at all. \n\n\n\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1312004,
      "meta": {},
      "text": "Software engineering often involves multiple parties, each seeking something different. Their needs often clash against each other, forcing them to compromise and causing design goal trade-offs:\n\n- Rapid Development vs. Functionality: This is an area where clients' and end users' needs are in direct conflict. For example, the client may want the product to be developed in 3 months, perhaps due to budget constraints. However, this makes it much harder for the developers to implement all functionalities needed by the end-user: The more functions the product offers for the end-user, the more time it'll take to develop. This is an area where these 2 parties will need to find a compromise: a development time window that doesn't exceed the client's budget, while still being able to guarantee major functionalities the client may need.\n\n- Efficiency vs. portability: A Client may sometimes need both, but a compromise is clearly needed. Efficiency in extreme cases may even need specialized hardware to run in, which severely inhibits portability. Embedded software such as Automotive or ATM Software for example is extremely efficient because it makes full use of the weak hardware it's given, yet it's limited to only that specific environment.\n\n-Functionality vs. usability: The more functions a program has, the more difficult it is to use. Documentation also becomes increasingly important with the addition of more features. Powerful software that offers a lot of functions becomes therefore harder to learn for the users. Example: Adobe Photoshop and Microsoft Paint serve the same purpose. Yet the former is clearly much harder to learn and use, simply due to its powerful functionality.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1312481,
      "meta": {},
      "text": "1.Functionality vs. usability\nif one program have too many function, it not so useful in normal case, guide from this program will be so complex. User need more time and focus to learn this program function.\nSo in program-design we need and only need the function for the ultimate-goal, too many unnecessary function will just delay necessary function to use.\n\n2.Efficiency vs. portability\nif one program can use at multiple platform, it need more code for multiple environment. and at end will  let this program less efficient.\n\n3.Cost vs. reusability\nif one program have in long time develop, it will be something same function have. So make some function at first time reusable, will reduce the cost in future developing, but will cost more time and resource in first developing.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1338736,
      "meta": {},
      "text": "Background: A client (a compony named Ali) orders a software company GO to develop an online shopping platform.\n\n1. cost vs. reusability\nrequirement of Ali: spend less money to have a high cost-performance platform.  \nideas of GO:  develop the platform using decomposition into subsystems and patterns so that the redundant work can be saved\nconfliction: decomposing code into subsystem will cost time and requires good engineers, it will spend more money. \n\n2. Efficiency vs. portability\nrequirement of Ali: the platform should be able to use across the device.\nProblems for GO: man can develop the platform using Java faster, but across-device portability will be hardly to achieve. The software engineers of GO have to invest more time in the project \n\n3. Functionality vs. usability\nrequirement of users: more accessible to be used\ngoals of GO: The more functionality the platform has, the more useful it can be. \nconfliction: GO released its test version platform to some test users, and most feedbacks say the platform is difficult to use.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344087,
      "meta": {},
      "text": "Functionality vs usability: \n\nSometimes, it is very easy to get caught up with the goal to provide as many features as possible. However, having many features will rapidly complicate the UI and directly affect the usability of the system, as it is important to consider the learning curve of the user.\n\nCost vs robustness:\n\nIf choosing a cheaper alternative in terms of completing the project faster and not perfecting the system's security against wrong or malicious handling will limit its robustness, which arguably, will lead to higher incurred costs later own.\n\nCost vs reusability:\n\nIt is cheaper to develop the system to just address the initial requirements. However, the infrastructure will not be easily reusable which again, arguably will lead to higher costs in the future. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344363,
      "meta": {},
      "text": "Es gibt 3 Akteure (Der Client, die Entwickler und die Endkunden) bei der Softwareentwicklung, bei der jede Partei eine eigene Vorstellung besitzt, was die Software bieten muss oder leisten kann.\nDabei gibt es Überschneidungen jeglicher Art.\nManche davon führen zu Konflikten z.B. Kosten vs. Robustheit der Software, wobei abgewogen werden muss, was bei der jeweiligen Software wichtiger/möglich ist.\nHier 3 Beispiele: \n1. Cost vs. robustness\nUnsere Bank-Applikation braucht mehr Geld und Zeit um die Sicherheit der Banktransfers zu gewährleisten. (mehr Tests)\n->Das Geld und die Zeit müssen gegeben werden, da sonst die möglichen Auswirkungen fatal wären.\n2. Functionality vs. usability\nUnser Bumpers game hat 10 Fähigkeiten, die von allen 30 Autos verwendet werden können. \nDas Team entscheidet sich aber dafür die Zahl der Fähigkeiten und Autos auf 3 zu reduzieren, wobei jedes Auto eine eigene Fähigkeit besitzt, damit es dem Spieler einfacher fällt ins Spiel hereinzukommen und nicht überwältigt zu werden.\n4. Rapid development vs. functionality\nAm 31.05.2022 ist das Release Date unsere Spiels \"Bumpers\", wobei uns die Zeit zu knapp wird, um die 3 Fähigkeiten zu testen, sodass wir uns entschieden haben die Fähigkeiten zu streichen. So haben wir mehr Zeit die anderen Funktionalitäten zu testen und wir können am 31.05 ohne Probleme das Spiel releasen.",
      "score": 83.3,
      "language": "GERMAN"
    },
    {
      "id": 1347912,
      "meta": {},
      "text": "Rapid development vs. functionality\n\nRapid development is hardly possible if we want a functional system with many options and functionality. If we want the University App to be developed in 2 weeks we can't have too much functionality and set priorites. We can make the system adaptable and add less important functionality later.\n\n\nMinimum number of errors vs. rapid development\n\nWhen developing the system we often have to intensively test the system in multiple aspects and all different ways each time something new is added. This takes a lot of time and makes it rather difficult to develop the system quickly. If we add multiple car types to Bumpers we have to test them if the interaction is exactly how it is planned out with other car types and collision types.\n\n\nUsability vs. functionality\n\nHaving a lot of functionality is great for the user, but it can hinder the system by not being userfriendly or being less usable. If we offer 20 car types in Bumpers then the player has to learn all the car types when wanting to play the game. It makes the game overly complicated for the player.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349204,
      "meta": {},
      "text": "One typical goal trade-off is usability vs functionality. High usability means usually, that the system is clearly structured, easy to overview and use. The trade-off is, that systems like that might lack functionality, since not all functions can be portrayed. The interface of IntelliJ, for example, is relatively easy to overview. But, in order to change specific settings, you need to dive deep in to the software, which lowers the functionality of IntelliJ.\n\nAnother typical trade-off is efficiency vs portability. An application, that needs a lot of computing power, can either be efficient and fast, or portable. A chess engine that runs and computes locally on the users device for example, needs a lot of computing power in order to run fast. This computing power, in form of processors and graphics cards needs space, which is not very portable. A trade-off for portability would be, to have the engine run on a phone, which is portable. The calculations would need more time tho, which is not efficient.\n\nA third typical trade-off in the context of softwareengineering is rapid development vs functionality. If your system has a lot of functionality, it is necessary to decompose the system into small functionalities and solve them, one at a time. A fast working version will have a low amount of functionalities. If you want to maximize the functionalities, you need more time for development. A complex calculator, for example, will be able to solve basic mathmatic functionalities like plus and minus in its early versions (low functionality, but rapid development). Later versions, after some time, might be able to calculate with sinus and cosinus (high functionality, but slow development).",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1350678,
      "meta": {},
      "text": "First, it's hard to achieve both cost efficiency and robustness. To build the robust system, we need to define and do many of tests in diverse aspects. Also we should make the system to pass the tests. This process may cost a lot. For example, we can do stress tests to ensure that the server can reliably handle 10K requests per second. Simulating that amount of requests will require a lot of computing resources. At the same time, designing the tests and making server to pass the tests will take much time.\n\nThere also is trade-off between high performance and flexibility. If we want to design flexible system, we should lower the coupling so we can easily replace one component of the system to another. However, it may limit the performance of the system because lower coupling means less connections between components. In this case, we can think of closed layered architecture for example. On the other hand, opened layered architecture might have better performance because the components of high layers can easily use any other components of layers below. Of course, this causes high coupling and makes system inflexible.\n\nIt's hard to take backward compatibility while keep the readability of the system. For example, let's say we have 3 versions of the same API which are not compatible with each others and we didn't remove all of them to keep backward compatibility with client applications. There would be three different versions of code for the same API while two of them are legacy. It might not be very clean and confusing for the developers. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1502505,
      "meta": {},
      "text": "Functionality vs. usability: if a program has many functions, it is hard to accomodate all functions in a usable, well ordered and clear UI.\n\nCost vs Robustness: if the provided budget for the software project is too low, the developers cant put much time and effort into optimizing the robustness of the system, for example to make the system not break down in the case of a wrong user input or when there are changes in the environment.  \n\nEfficiency vs. portabbility: a software that is developed for a special operating system, works in most cases more efficient than a software, which was developed for multiple operating systems, beacuse the developer can consider efficeincy issues more precisely when developing for only one operating system than for more than one.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1637357,
      "meta": {},
      "text": "A typical design goal trade-off is backward compatibility versus readability. If you are working as a developer on a new Application, the client often wants it to be backwards compatible, which means it also works on older machines. But in terms of maintenance you want your code to be readable and easy to modify. These two design goals collide because often the readability of the code suffers from backward compatibility. Another typical design goal trade-off is functionality vs usability. If you download yourself a new tool for graphical design it often has so many functions and possibilities to edit for example a picture, you are completely overwhelmed by this mass of functionality that you can't find the function you really search for. But on the other hand a tool with much less functionality could be insufficient for the task you're working on. There the two design goals limit each other because if you want your tool to have great functionality, you have to cut corners in terms of usability and the other way round. Also there is the aspect of Cost vs. reusability. If you go to a store to buy a new fridge often there is a selection of fridges you can buy. One is cheaper but less reliable and the other one is expensive and very reliable. The cheaper one could brake down after a year and could result in work and costs, but if not the expensive one wold be unnecessary expensive because the cheaper one would be sufficient.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1656115,
      "meta": {},
      "text": "Rapid development vs functionality is the tradeoff between the time needed to develop the system and the functionality that can be implemented. Of course, with a shorter development schedule developers do not have the necessary time to implement additional functionality.\n\nBackward compatibility vs readability is the tradeoff between the system's ability to work in older contexts but oftentimes this old functionality may grow incongruent with the current user interface. For Example windows 10 still has functonality from older windows versions which results in different menus looking and working quite differently (compare the windows 10 settings menu to the Control Panel)\n\nFunctionality vs usability is the tradeoff between the amount of functionality in a system and the ease of use of the system. More functionality requires more menus/clicks/interaction/knowledge to use it while usability usually focuese on decluttering the interface which means reducing funcitonality. For a messenger app like signal which only implements direct messages and groups is much more usable than a chat app like discord which implements direct messages, groups, servers, roles, permissions etc. This makes settings menues much more cluttered and as such less usable.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291103,
      "meta": {},
      "text": "One design goal trade-off is functionality vs usability. If a system has many functions it is often that it is not very usable. The other way around as well. For example IOS always was known as an very usable mobile software, but earlier (and still) it hasn't as many functions as android but which is known as more complex.\n\nAnother goal trade-off is cost vs. reusability. If you invest more many in a system/product it is often more reusable than if you invest less money. For example razor blades which cost more can be used more than cheap ones.\n\nAlso rapid development vs functionality is a goal trade-off. If you develop a software rapid it has often less functionalities than a software where you did invest more time. For example if you develop the bumpers game in 5 minutes it will not have as many function as developing it in 5 hours",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292140,
      "meta": {},
      "text": "Cost vs. robustness: If you create a system that works for 5000 users it will be cheaper but less stable than a system that works with 500000 users\nCost vs. reusability: Similar explanation to cost vs. robustness: If you create a more expensive system for 500000 users you can later on still use it even if the company no only needs one for 5000. So the system is already an investment for later.\nBackward compatibility vs. readability: If you create a system that should work with many versions of an operating system, it needs to be able to communicate with all of them. That leads to many lines of code.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1337415,
      "meta": {},
      "text": "Runtime Efficiency vs Portability:\nPortability, by using java, will limit the optimisations and speed compared to less portable programming language for example c.\n\nRapid Development vs Robustness:\nRapid Development means that we lack the time to test the software. Hence, bugs are less likely to be found.\n\nRobustness vs Readability:\nAs different edgecases might have to be checked, readability will reduce.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1434160,
      "meta": {},
      "text": "When developing software the programmer faces different design goal trade-offs. Some of the most typical ones are:\n1. Backward compatibility vs. readability\nWhen developing software, the developer has to think about whether he wants to write a more readable code or a more compatible one for older models. Let's consider an example, suppose you released a game on the market. Of course, eventually, you will be releasing newer improved versions of the game. Let's say that one of the new features requires changing an existing API. So the programmer faces 2 options: First, you can choose to replace the old API with a new one thus making the code cleaner, up-to-date, and taking advantage of the newest technology, but users with older versions won't be able to use the app. Or you can keep the old API and sacrifice the newer technology, but all users with older versions will still be able to play the game.\n\n2. Cost vs. reusability\nReusability is the ability to reuse existing code for different purposes. The code isn't designed to do one thing only but it is flexible enough to be used in various aspects. Say you work in a giant corporation and you have to program 2 web applications. You start with the first one and you notice that both web applications have a similar blogging feature. You could either ignore this similarity and start working on the first project, which needs to be finished first. You finish the project after 1 month and deliver a code specific for the 1st project characteristics. Afterwards, you do the 2nd one. The code of each of the projects is a one-time thing, it cannot be used for anything else, it's dead. If you were to spend a bit more time and money you could the blogging feature more general and create a foundation, which could be used for both projects and continue to be reused for future ones as well. \n\n3. Cost vs. robustness\nIn software development time is money, and developing an excellent software requires both time and money. A code is robust when it is strongly formed and can cope with errors. Robustness can come in different levels. Suppose you were to program a calculator. You program all basic functionalities and in a short time your software is ready to go, but it may not be robust. What if the user divides by 0 or the root of a negative number? For the programmer to find and fix the edge cases and make the code resistible to everything, they need to spend more time, money, and thought on the code. When all the edge cases are covered and the code copes with running errors then it is robust.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1452242,
      "meta": {},
      "text": "Design goals formulated when designing software are by multiple parties (client, developer and end user), each  with different expectations for the software. This leads to conflicting design goals. In this case, some design goals have to be sacrificed in order to fulfill others.\n\nExamples:\n- rapid development and few errors: finding and correcting errors in a program takes a lot of time\n- functionality and ease of learning: a broad spectrum of functionalities can make the program feel cluttered and hard to learn\n- low cost and robustness: the development and upkeeping of a robustly working program is cost intensive",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1469363,
      "meta": {},
      "text": "1) Cost vs. Reusability\n\nWriting the code for a specific condition is always easier and faster and therefore costs less. But it's not reusable when we face a different condition. So, should higher the costs and write reusable code or use non-reusable code with lower costs. So, one should decide on this trade-off.\n\n2) Usability vs Functionality\n\nWhen we define too many functions, in general, would our program not be so usable in terms of understandability and clearness. So, one should decide on this trade-off and limit the functionality or sacrifice some usability.\n\n3) Efficiency vs. Portability\n\nGenerally, to be efficient, one should sacrifice portability - and vice versa. Portable code isn't efficient because it has been written to be used in many places (for example GPU + CPU). But one can decide to code non-portable in order to boost efficiency. This is a trade-off that one should decide on.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1635955,
      "meta": {},
      "text": "1. Functionality vs. usability: the higher the amount and complexity of a system's functions, the lower the usability of that system. If a bank app offers hundreds of different services, the quality of the user experience might be affected, because the user interface might no be understandable for the client and he/she might not understand how to find or do certain transactions. \n\n2. Cost vs. robustness: developing a robust system that keeps on functioning under all possible disturbances can get very costly. That is why, the software developer and the client need to define under which most common disturbances a system should keep on functioning, while leaving certain possible issues open, in order to remain under the development costs budget. \n\n3. Rapid development vs. functionality: the higher the amount of functional requirements, the slower the development of a system. That is why, it is important to define the importance of each functionality and prioritize them, in order to achieve realistic goals during the time defined for the development of the system ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1655048,
      "meta": {},
      "text": "1) Ein typisches dsign goal trade-off ist die Entscheidung zwischen Funktionalität und Nutzbarkeit. Eine Software, die von der breiten Masse genutzt werden soll, sollte einfach zu bedienen, klar strukturiert sein und eine aufgeräumte Benutzeroberfläche bienten, damit der User auf keine Komplikationen trifft. Eine Nischensoftware, die für den Gebrauch von wenigen ausgebildeten Fachkräften geschrieben wird, sollte eher den Fokus auf eine einwandtfreie Funktionalität und fehlerlose Ergebnisse legen. \n2) Eine weitere Entscheidung sollte zwischen den Kosten und der Wiedernutzbarkeit der Software getroffen werden. Für eine breit anzuwendende Software ist es von Vorteil, wenn sie nach der Entwicklung kaum gewartet und weiterentwickelt werden muss, was hohe Kosten mit sich ziehen würde. Stattdessen sollte sie ohne Bedenken wiederverwendet werden können. Andererseits kann Software, die nicht regelmäßig geupdated wird, bald geoutdated werden. \n3) Außerdem sollte eine Ausgleich zwischen Effizienz und Tragbarkeit der Software getroffen werden. Eine Software, die zu viele Ressourcen verbraucht, kann nicht von jedem System genutzt werden. ",
      "score": 33.3,
      "language": "GERMAN"
    },
    {
      "id": 1290896,
      "meta": {},
      "text": "Functionality vs usability, applications with massive functionality can be sometimes slower a much more complicated, this means that the end users usability is decreased because it is harder for him to understand all the concepts  and practises used in the applications functional design. Example: Customer wants a accounting software with complex functionality and machine learning for increased performance and safety. However this final application will be really complex and complicated to use for normal office worker in this company, which will decrease the application usage by the employees. \n\nCost vs robustness, customers, who want to spend less money on a development of an application need to count with a problem with robustness of the project on many levels because developers don't have some much time to work on everything in really great detail and also less skilled developers with smaller wages will be working on the project. Example: Customer wants to have an accounting application designed, but he has a strict budget and wants complex functionality, so the developers don't have time or resources to fully develop a robust application because the clients resources.\n\nRapid development vs functionality, applications which are developed rapidly(quickly) won't have the same functionality as other applications, so for shorter development time we need to decrease the functionality of the final application. Example: Customer wants to start selling their new product and they request a new web-eshop for this occasion. However developers have only two weeks to complete the web-eshop, so the final product won't have the same functionality as other ehops because of the rapid development speed. It will be missing user registration, discount codes or product categorisation. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291553,
      "meta": {},
      "text": "Functionality vs. usability: This trade-off is on the one hand concerned with the system functionality, so which functions the system offers to the user, and on the other hand with the usability, so how easy it is for the user to use the system. A good example of an application with high functionality and low usability would be a program like AdobePhotoshop, which offers a huge functionality, but is really hard to use for somebody without experience. They made this trade-off and therefore attract professional users. An App like VscoCam took a different decision, they opted for usability and only offer a limited amount of filters and no extra functionalities. \n\nRapid development vs. functionality: This trade-off is as well concerned with the level of system functionality. However, here not the usability but the development time is of relevance. A good example of where this trade-off happens are MVP's (Minimum viable product). The developer has to develop a working product in a really short amount of time and therefore has to cut back on functionality and really limit the system to the basic functionality.\n\nBackward compatibility vs. readability: This trade-off usually occurs whenever a new system of a software is released. Not everybody will get the update, however, people still expect the software to work. Developers face the trade-off between allowing this backward compatibility and increasing the code complexity a lot vs. limiting the backwards compatibility and having nice, readable code.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292533,
      "meta": {},
      "text": "The process of software engineering has three main actors: the client, the end user and the developer. All of them have different views and goals regarding the application and in most cases it is not possible to perfectly meet most demands of all of them because they are standing in conflict to each other.\nOne big trade off is funtionality vs usability. The client might think that it is the best for the end user to do all imaginable actions with the application. Therefore the application would be huge and confusing to use.\nThe end user on the other hand only wants to have the features that he/she actually needs or likes. Otherwise the use won't have a great user experience because most time is spent on navigating the application.\nThe aspects of cost and robustness also stand in conflict to each other. The client always wants to be the cost to be as low as possible but the developer need time to build a stable system with a minimum number of errors. The more time it takes the more money has to be spent so there also have to be made some trade-offs reagrding robustness of the system.\nEffiency and portability may cause conflict in a software project. The application should of course be as fast as possible but it should also be available to as many users with many different devices and operating systems. Integrating this into the application so generally speaking the application becomes slower if it is useable on more different systems.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292664,
      "meta": {},
      "text": "1. Functionality vs. usability\nSometimes the client wants to satisfy a lot of situations by requiring different functionalities. How ever this could then affect the usability of the system as there are many options and it will be hard to decide. For example McDonals implements different types of bonus and discounts in its app. But it can make the customer decision harder. \n2. Rapid development vs. functionality\nOne common issue that a product owner face is to align the timing between the developers and the functionality requirement of the customer. In this case, the prioritisation of functionalities plays a key role.  \n3. Cost vs. robustness\nIt could be the case that the customer wants to invest low money comparing with the  founds needed to full fill the current robustness. Therefore the final solution could be something that is not reliable. ",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1310525,
      "meta": {},
      "text": "A typical example of a design goal conflict is the security aspect vs costs. The end user typically has an interest in a product/service to be resistent against malicious activity. For example, customers of an online store would like their credit card information to be stored securely and strongly encrypted. On the other hand, the client normally wants to keep the development costs to be as low as possible. Taking our example again, the conflict is obvious as hiring security experts during development phase is expensive.\n\nA second common design goal trade-off is functionality vs usability. Of course the end user wants an application to be as easily usable as possible. Also, the owner of the application would like his application to provide a high level of functionality. Nevertheless, a higher amount of functions can result with a more complex user interface, hence in decreased usability. A good example might be a person who uses adobe photoshop for the first time and has to constantly look up how to use/find certain functionalities as one simply can't overlook the sheer amount of functionality this application offers.\n\nLastly, costs and reusability often represent competing factors: Developers would like their code to be reusable. Needless to say, to achieve this, a higher amount of initial work might be needed. This again results in increased development costs, a thing clients are normally unhappy about. One example could be the development of an app, where the team has to invest additional days of planning to make the code they write more reusable.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1316942,
      "meta": {},
      "text": "1) Functionality and usability:\nusability is the ease with which the user can use the system , while the functionality is the set of the functions that system provides. The large amount of functions, which are provided by functionality can sometimes overload the system interface which can lead to difficulties with interactions with the system. By removing this functionality the system won't  provide required functionality.\n\n2)Efficiency and portability:\nthe system is portable if  there is very low effort required to make it run on different platforms. That is very useful because the system is not tied to a specific platform. Portability saves time and mental overhead for anyone involved in moving new versions of the software across environments. But in some cases, portable versions of applications have a restricted set of features, as compared to their installable counterparts. So they don't have the same efficiency as the systems that have to be tied with platforms. \n\n3)Cost and robustness:\noften high-quality and robust systems are more expensive than simple ones. Since quality and robust systems require more development time, testing and effort which of course cannot be for free.\n\n\n\t",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344296,
      "meta": {},
      "text": "Rapid Development vs. functionality:\nA System, which has to be developed fast needs to save this time by developing fewer features. The choice of features must be carefully done in the planning phase. It is also possible that during development a feature must be omitted in favour of the development time. An example is the Corna-Warn-App. We needed this app as fast as possible to prevent the fast spreading of the virus. To be able to deliver the app fast, features had to be limited to the necessary.\n\nEfficiency vs. portability:\nTo achieve the maximum possible efficiency the software can use platform-specific optimizations. If you now want to use the same software on another platform the program might not work anymore. In this case, it would be more sensible to focus on portability in exchange for a bit of performance loss. For example, a company which wants an app for their customers to buy their products should focus on portability, to make it possible for every user could use the app. A scientific institution with software on a supercomputer, which computes one specific problem should focus on efficiency instead of portability.\n\nFunctionality vs. usability:\nSoftware which is full of functionalities is often so complex, that there are very complicated to use. Many times it isn't possible to design the software differently. It is either simple to use or has a lot of functionalities. An example could be software like Premiere Pro. At first, it isn't really usable because it has too many functions, but experts need all those functions and Premiere can't be developed in any other way.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344394,
      "meta": {},
      "text": "functionality vs. usability \nThe trade-off between these two goals is quite simple. Because if you want to make something with high usability it needs to be clean, simple, and with little but clear options. However, if you also want a high functionality this contradicts the usability. It is hard to make a lot of options easy to navigate through. An example of this trade-off would be a game that should have high usability but also a lot of options to choose from before starting the game.\n\ncost vs. robustness\nRobustness involves more development time to make the software safer and find solutions for more edge cases. However, this can only be implemented when developers have more time. More time means more cost. For that reason, this is a trade-off.\n\nrapid development vs. functionality \nThis is a trade-off because functionality needs time in software development. Therefore if you want something to be developed in a short period of time it usually misses lots of functionality.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344441,
      "meta": {},
      "text": "1: Scalability : For example, a server needs to be able to be able to have as many clients as possible. Even if it was built for 1000 servers, it needs to be able to accomodate 10.000. For example, the mebis server of the bavarian education ministry crashed on the first day of the Covid lockdown as it was not engineered for so many people to use it at the same time.\n\n 2: platform independence. A product needs to be independent of what it runs on. For example, MineSweeper was able to run on Windows x86, but it should also be able to run in following Windows versions like 7,10,11 etc, Linux, and Mac versions without having to change much of the code.\n\n3: portability/localization : The product needs to be able to keep up with changes in technology and new developments ( Ascii-Multi-Page ASCII-Unicode and Modem-AppleTalk-IPX-Internet)\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344676,
      "meta": {},
      "text": "Functionality are operations an interface provides. Usability is how easy an interface is to use. Functionality vs usability example: a website. While designing a website one needs to find an equilibrium between functionality and usability for it to be aesthetically pleasing as well as easy to use but also provide complex functions to the user. As such webpage design as evolved from multiple cluttered text and links and pictures collaged into one page into a more minimalistic design. \n\nCost are costs for developing software. Robustness is how well software can handle errors. Cost vs robustness example: development on a budget. The budget limits the time for development as everyone wants to be paid. Therefore, sometimes the software is rushed which requires sacrificing robustness of said software, potentially being riddled with bugs and glitches. On the other if you want to make it more robust you need to sacrifice cost allocating a larger budget so development does not need to be rushed and bugs and glitches can be patched out.\n\nRapid development is how quick a product can be completed. Functionality are operations an interface can provide. Rapid development vs functionality example: game development. Companies always promise many features for their games which are not always reciprocated in the final product. As they are on a schedule game development often sacrifices features to pump out the final product as it takes time to add more feature, vice versa. This also similarly to the previous example often leads to sacrifices in robustness.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1437471,
      "meta": {},
      "text": "A trade of would be quality of a product vs the time to deliver it. The perfect example would be the game CyberPunk2077 which had the chance by all mean to be a great game, but because the development was rushed, parts of the game were cut and the result was a buggy and not finished game.\n\nPrice vs Staffing -> The Owner would most likely have low costs, but if he want's low costs, then in return he must use lower staffing, which would lead to either higher Production Time or more bugs and a rough finished product. -> see point above\n\nTime vs Memory -> Last in using a algorithm usually there is a trade of between, time it takes and storage. For example the algorithm might run faster with a lookuptable. But also it takes more space to store. Another Example is so called \"Loop unrolling\" In which time is traded for more code, because when a programm utilizes less jumps it runs faster.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1453884,
      "meta": {},
      "text": "The most common trade-offs in software engineering appear in a context with the costs. For example the back compatibility with older version can be a lot of effort during implementation. If there is not enough money for the working hours a trade-off needs to be made. On one hand you can try to rise the costs if the client accepts it, on the other hand you need to implement without backward compatibility or only support a few older versions.\n\nAnother trade-off could exist between efficiency and readability of the code. Very efficient code could contain parts which are complicated, for example special breakpoints in loops or returns in recursive methods. In those cases there might be a way of implementation that is better understandable but would be less efficient.\n\nAt least there is another very common trade-off. When the functionality of your application grows it gets much harder to keep an easy usability. So for example if you expand you chat app by a map feature where people can see each other, there maybe needs to be a navigation/menu entry that guides you to the map feature. This could result in a more complex UI design what describes the trade-off between usability and functionality. Another example are the settings from windows. There is an option for nearly everything, but its sometimes very hard to find the functionality.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1634636,
      "meta": {},
      "text": "-functionality vs usability: die software sollte zwar gut funktionieren jedoch bringt es einem nichts wenn sie perfekt funktioniert sie jedoch so kompliziert aufgebaut ist dass sie kein normaler user benutzen kann, z.b.: wenn man in modernen haushaltsgeräten zu viele optionen einbaut werden die benutzer nur verwirrt und es ist umständlich das gerät zu benutzen stattdessen sollte es einfach zu nutzen sein \n- rapid developement vs functionality: die developer wollen natürlich so schnell wie möglich mit der software fertig werden jedoch hat das auch einige nachteile da so oft schlampig gearbeitet wird und kompromisse auf kosten der funktionalität eingegangen werden, z.b.: ist es heutzutage häufig mit videiospielen so dass sie zur deadline released werden sollen und die devs so durch zeitdruck ein kaum fertiges \"spiel\" releasen\n-cost vs reusability: wenn man wenig geld in ein projekt steckt ist es meist nicht wiederverwendbar da es auch meist im engeneering veraltet ist, z.b.: wenn man t shirts zu niedrigen preisen kauft kann man sie nicht so oft wieder anziehen da sie schneller kaputt gehen ",
      "score": 75,
      "language": "GERMAN"
    },
    {
      "id": 1645229,
      "meta": {},
      "text": "Functionality vs. usability: Adding a large number of functions to the system may decrease usability, because a user has way to many options, which are both increasingly hard to find and use. Increasing Usability (Simplifying) may decrease the Functionality of the system.\nFor example:\nIf we think of a simple shopify webpage, usability means as few button clicks and options as possible, to buy an item(decreases functionality). Functionality means the user has a lot of options to choose from, and can for example customize every item(decreases usability).\nThese two contradict each other.\n\nRapid development vs. functionality:\nFinishing the product fast may include seperating out many functionalitys with low importance, while increasing functionality requires more development time, because more features have to be coded.\nFor Example:\nIf we build a webstore, we can increase development time by using some prebuilt libraries for checkouts, e.g stripe. This will save a lot of time, as we dont have to implement it. But stripe doesnt support our voucher system, so we decrease functionality. If we implement our own checkout logic, we can also add the vouchers, but this will take time to implement.\n\nEfficiency vs. portability:\nTo increase efficiency we can use any machine bound functionality to speed up our code, with the tradeoff that not all client pcs will have this functionality, and therefore the code will not run on their machine.\nFor example:\nIf we use raytracing to draw graphics in a video game, many of the clients graphics cards will not support it.\nIf we dont, the clients who could do raytracing will have a worse experience.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1648309,
      "meta": {},
      "text": "1. Ein design goal trade-off ist zum Beispiel eine schnelle Entwicklung der Software oder eine Software mit möglichst wenig Fehlern.\nBeide Anforderungen stehen miteinander in Konflikt, weil bei einer schnellen Entwicklung weniger Zeit zum Testen der Anwendung beansprucht werden kann. Somit können weniger Fehler identifiziert und behoben werden. Bei einer langen Testzeit hingegen werden mehr Fehler erkannt und behoben, aber die Entwicklung der Software dauert deutlich länger.\nEin Beispiel dafür wäre eine Software mit noch 34 unbekannten Fehlern. Für eine möglichst schnelle Entwicklung von 2 Wochen muss die Software aber schon in 2 Tagen fertiggestellt werden. In diesen 2 Tagen werden nicht 34 Fehler gefunden werden können. Wenn jedoch die Entwicklungszeit 2 Monate umfasst, bleibt noch genügend Zeit möglichst viele Fehler finden zu können, sodass am Ende von den 34 Fehler nur noch 2 übrig sind.\n\n2. Ein weiteres design goal trade-off ist ein kleines Budget oder eine ordentliche Dokumentation\nBei einem kleinen Budget reicht das Geld nicht aus, um eine ordentliche Dokumentation der Systeme und Methoden anfertigen zu lassen, weil dies nochmal deutlich Zeit in Anspruch nimmt. Eine ordentliche Dokumentation kostet hingegen nicht wenig Geld, was mit einem kleinen Budget nicht einzubringen ist.\nEin Beispiel wäre, dass ein Unternehmen 3.000€ zur Verfügung gestellt bekommen hat, um eine Software zu erstellen. Mit diesen 3.000€ können sie gerade so den Stundenlohn für die Entwickler bezahlen, damit der Code fertig wird. Um eine Dokumentation zu schreiben benötigen die Entwickler aber noch weitere 15 Stunden, die aber nicht mehr bezahlt werden können, weil kein Geld mehr übrig ist.\n\n3. Ein drittes design goal trade-off ist backward compatibility oder user-friendliness.\nWenn der Client eine  backward compatibility haben möchte kann das System schnell unübersichtlich werden und Funktionen die man gar nicht mehr benutzen soll können benutzt werden. Führ den Benutzer ist dies Verwirrend und eine Fehlerquelle. Damit der Benutzer keine überholten Funktionen des System nutzt, muss er sich erst erkundigen und sich mit dem System länger auseinandersetzen.\nEin Beispiel wäre ein Protokoll in einer Chatanwendung das nicht mehr benutzt werden soll, aber trotzdem noch als Option verfügbar ist, damit auch ältere Versionen der Anwendung noch benutzbar sind.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1291415,
      "meta": {},
      "text": "One typical design goal trade-off is cost vs. robustness. In this context, usually when developing the software one cannot optimize both aspects at the same time. Certain aspects  of the software product are going to be neglected for cost benefits. However, this can negatively affect the robustness of the system, as increasing the robustness of the system also increases the costs. E.g. when developing a software product for an end user, increasing the robustness by adding several components to prevent the system from failing when the user enters a wrong input.\n\nFunctionality vs. usability is another common trade-off. Increasing the functionality of the product by adding more functions decreases the usability at the same time, because the user has to spend more time learning all the functions of the system. E.g. a user can create his dream car on a website by choosing certain components of the car. If many new functions are being added, meaning you can choose more components of the car, functionality is increased but usability decreased.\n\nWhen developing software, one has to make a trade-off between rapid development and functionality. By choosing one over the other, you either focus on decreasing the amount of time it takes to develop the software or you focus on maximizing the functionality of the software. E.g. When developing a chat systems that lets users communicate with each other, you can focus on the time and just implement a function to exchange text or you spend more time developing the software and also implement functions to exchange pictures, voice mails and documents.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1293629,
      "meta": {},
      "text": "1. Möchte man ein platformunabhängiges System entwickeln, \nminder dies die Effizienz, da das Programm nicht auf eine bestimte Umgebung optimiert werden kann und somit langsamer läuft.\n\n2. Möchte man Software kostengünstig entwickeln kann sich das negativ auf die Robustheit des Systems auswirken, da zum Beispiel weniger Zeit und Geld in das Testen des Systems fließt.\n\n3. Entwickelt man sehr funktionale und komplexe Software, verringert das die Nutzbarkeit des Systems und es wird schwerer für neue Nutzer die Software zu verstehen und anzuwenden. Eine Software kann sehr gut sein, ist sie allerdings zu komplex, kann es zu Verständnisproblemen beim Nutzer kommen.",
      "score": 25,
      "language": "GERMAN"
    },
    {
      "id": 1299310,
      "meta": {},
      "text": "1) Robustness vs. cost: It is important for software systems to have fault tolerance and be robust, as wrong inputs of the users or rapid changes in the environment may damage the existing software program. For example a player might accidentally close computer while the game is running, a robust programm saves its state automatically and doesn't crash, after being closed unexpectedly. However in order to achieve robustness, more time and effort must be invested in the project, which increases the production cost.\n\n2) Functionality vs. usability: Software projects are constantly improved, as new features are added to the system, in order to meet new requirements of the client and satisfy the users. However new functionalities often result in the software system to be more complex, which may affect the usability negatively. For instance developers of the university app may add new features such as streaming lectures, online exams feature, document sharing platform etc. Such new functionalities increase the appeal of the app to the users, however they may also make the interface of the app chaotic, making it harder to learn and use different features.\n\n3) Efficiency vs. portability: For software programs that need to run very fast, such as a program needed in a spacecraft that constantly needs to compute new outputs due to changes in the environment, it is important to be efficient and have low runtime. Efficiency is often achieved through taking advantage of special hardware capabilities or programming languages, which reduces the portability of the software system to another software/hardware environment. However for a simple game like Bumpers portability may be more desirable, hence it is developed in Java.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344502,
      "meta": {},
      "text": "One prime example for a design goal trade- off is functionality vs usability. For instance when comparing the operating systems for mobile phones one could argue that iOS is way simpler to use since it is way more intuitive, everything always works seamlessly and you do not need a lot of knowledge in order to use it. Android on the other hand offers way more usability, you are able to customise way more things, are free to download any applications you want etc. Still, this comes with a less simple usability, as you need much more technological knowledge to use it.\nAlso very common is the trade off between functionality and portability. When you look at computers for instance a laptop with a very advanced internal components and software tends to be way heavier and bulkier than a simple laptop like a Chromebook which can merely access Chrome but is very light and portable.\nAnother example is the trade off between cost and reusability. If you design a system for very low cost which only fulfils the bare minimum of requirements, you will likely have to design a whole new system if the requirements change slightly. On the other hand, if you are willing to spend more money in the development you will be able to build upon the existing system or reuse its components.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1346376,
      "meta": {},
      "text": "Rapid Development vs. functionality: \nThe client's goal is to implement a system as fast as possible, in order to reduce the cost and effort for the product. However, the end user still wants a perfectly functioning system without waiting forever for a product. One good example for this is \"No man's sky\", which is a game, that was released too early and therefore was not functioning well. \n\nFunctionality vs. Usability:\nWhen Software Engineers come up with a new product, they usually have to stand out from the rest of the market in order to sell enough units. They do this by implementing a lot of functions in a system, which are not really necessary, but the end user wants the most things (here functionality) for his money. This results in a very confusing, bloated product, which is not really user friendly, because the user has to many options. One example for this, is Apple. They usually don't include as many functions as other companies, but they are the most user friendly.\n\nCost vs Robustness:\nCompanies try to keep the cost low in order to maximise profit. This results in less testing of a system, and therefore the system is more vulnerable for errors. In contrast to this, the end user wants a very robust system, which is also affordable. Now the company has to balance these two demands. For example, the ISS needs very robust software, because they are floating around in space and if the system fails, the astronauts are pretty fucked.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1656602,
      "meta": {},
      "text": "Performance vs. maintainability:\nTo increase a softwares performance it makes sense to call methods with minimal intermediate steps as direct as possible. Maintainability is achieved by decomposing the system into logical subsystems, which should be coupled low. Thus performance can suffer with high maintainability, due to more intermediate steps and vice versa.\nExample: Implementing the facade pattern leads to a higher degree of maintainability, but due to the higher number of intermediate steps needed to call a function performance can be decreased.\n\nCost vs. performance:\nAchieving high performance takes a lot of testing and many iterations, meaning it takes more time than developing a low performance software. Furthermore it might require better hardware. Thus costs rise by developing a high performance software and the software ist likely to have a low performance if it's developed on a small budget.\nExample: To develop a high performance online application, high performance servers are needed. These servers are more expensive.\n\nPrivacy vs. functionality:\nPrivacy requires anonymization and encryption of sensible data. Thus this data is harder to process, which can lead to lower functionality just because some functions aren't actionable considering privacy.\nExample: K-anonymity: Some statistics can't be shown if the number of data points is to small to obtain privacy.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1294302,
      "meta": {},
      "text": "1.  Flexibility vs. robustness :\n\nWhen creating a software for e.g. a chat system, you wish for it to be flexible and deliver the information quickly and low cost, which also leads to more room for potential errors to occur.\nThe end user wishes for it too be as robust as possible, so it will not crash because of minor inconveniences like wrong inputs for example,  so it is not as flexible, since a lot of tests have to be done increasing the cost and delivery time.\nIn this trade-off it is important to prefer the aspect of robustness, but by trying to generalize some tests as much as possible still try to maintain some kind of flexibility.\n\n2. Backward compatibility  vs. functionality :\n\nWhen implementing new functionalities for your software because of constant development, there are certain parts that can not be maintained in older systems, because they are not as advanced as the newer models, making it impossible to play a newer game on an older system for example, because it has certain functionalities that would crash the system.\nIn this situation it is important to assess how important the backward compatibility is, since systems that are completely outdated may not be used anymore, while recently old systems are probably worth maintaining.\n \n3. Efficiency vs. reuseability  :\n\nIt is often more efficient to reuse some code pieces, since it is easier to maintain, but there are times, where there is a better and more efficient solution to certain problems, instead of reusing an already existing code that is less efficient for a certain task.\nIn this case it is more important to focus on efficiency, rather than reuseability.\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1315939,
      "meta": {},
      "text": "The first design goal trade-off is cost-efficiency vs. operating evironment. If the client wants to use the system in diffrent operating environemnts (e.g.: iOS and Android for smartphones), it is often linked to higher costs in the development.\nThe second design goal trade-off is functionality vs. usability. You often want to have many functionalities in the system but it also has to be easy to operate (e.g.: the user should only need two clicks to start the analysis function of the tool).\nThe third design goal trade-off is rapid development vs. robustness. If the software is developed in a very short period of time (and maybe in a relatively small team), it is often not very robust.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1325106,
      "meta": {},
      "text": "1: Cost Issue: The client sometimes wants to keep the budget low while the development need more.\n2: Time Issue: The client sometimes wants rapid development while the developer need more time to make a good one.\n3: Issue of documentation: The developer and end user want the project to be well documented while the client may not be interested in it.",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1342914,
      "meta": {},
      "text": "Cost vs. Robustness:\nBy lowering the expenditure on a certain product, resulting in a lack of resources to implement certain functions that would further secure a system.\n\nRapid development vs functionality:\nAnother meagre resource is time. As is the case with the lack of financial backing, having to release a product to the market quickly forces rapid development.\n\nBackward compatibility vs readability:\nOld programming languages are a dying art. Many people nowadays are unable to read old code, let alone use it. However, newer software may build up on this old, \"unreadable\" code, and may in regards to this, have to be backward compatible.",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344461,
      "meta": {},
      "text": "There are many different design goals a programmer can focus on. Often, however, there are certain goals, that are in conflict with each other. In those cases, trade-offs need to be made to find the best possible weight on each goal.\n\n1. Cost <-> Robustness: Building a robust application that can handles various types of errors and exceptions is more difficult than coding software that crashes with every wrong input that occurs. You need more time or more people, you may also need to write more different testcases. All this additional effort, in the end, results in a higher price for the software. You can not expect a very robust system without willing to pay the extra money.\n\n2. Efficiency <-> Portability: If you have an application / a software that always runs on a certain Computer under a certain operating system, you can, without to much effort, optimise your code exactly for this szenario. \nBut if you want to create a portable software, which runs on almost any device and any operating system, you cannot provide the same optimised efficiency like in the first example.\n\n3. Rapid development <-> Functionality (/Quality): I think this point is pretty obvious. If you have enough time, you can add a lot of functionalities to your system, even if it may takes very long. But if you, conversely, have a hard deadline till which your product has to be finished, you may won't be able to implement as many funcionalities than in the first example. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1352006,
      "meta": {},
      "text": "A typical design trade off is the amount of functionality you want to deliver to the client vs the efficency of the programm. The more you offer to the client the slower your programm might get, so you have to find a good balance between performance and functionality. \n\nAnother aspect might be cost vs reliability. For example having information stored on just one server is very cheap, but very prone to errors/failures. Having multiple backups is more expensive but also more reliable. The trade off is between the amount of money you are willing to spend and the amount of errors/downtime you are fine with having.\n\nMoreover another trade off might be time to deliver vs functionality. A client might want a product within a certain timeframe, with certain funcitonalities. Both of these goals might not be achievable, so you will either limit the amount of funtionalities, or extend the timeframe for the development.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1412195,
      "meta": {},
      "text": "Functionality vs. Usability ( a system that has too many functions and is complicated to the user to understand and use\nfor example the arngren website, its a website that contains too many informations and pictures and is hard for the user to understand\n\n\nCost vs. robustness ( cheap design that enters wrong data and give false informations )\nfor example Apple in 2012 decided to write her own map application which led to giving the wrong directions to the user.  \n\n\n\nSpace vs. Speed ( if a software has not enough memory or space for the data, that can effect the speed because data will be compressed at the cost of the speed )\nfor example in 2018 was Yoox website tested as the slowest site \n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1415734,
      "meta": {},
      "text": "First typical trade-off: Functionality vs. Usability, as a developer who is familiar with his product you typically want more functionality since it makes your product more interesting to certain customers. But for a new customer this can be very challenging, since he encounters all those functionalities and can't really comprehend what he can do. I myself have experienced this with video editing programs. You just want to cut a few seconds of the video and get overwhelmed by all those options and the multiple video tracks you can insert. For a new customer this makes it very hard to use, but it can be useful for more advanced editors.\n\nSecond typical trade-off: Efficiency vs. Portability, especially in software engineering your efficiency is limited by the underlying hardware. If your device is built portable it's not that fast and loses efficiency. The prime example is the smartphone. Being that small it really can't run cost-efficient programs like a very advanced editing program. But a pretty big Computer can run this. So you have to find a balance.\n\nTheird typical trade-off: Cost vs. Robustness, if you are not willing to pay the money it requires your program might be vulnerable to attacks or won't be really stable to start with. I have experienced this when building web applications. Since i was not willing to pay money for good DDOS protection my websites were very vulnerable to such attacks. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1415949,
      "meta": {},
      "text": "1) Rapid development vs. Functionality:\n\tThe client wants you (the developer) to develop a system that will be used in an upcoming TED Talk. The \t \n        problem is that this event is next week and there is not enough time to develop and polish the application.\n        Therefore, a Design Goal Trade-off occurs - rapid development must be prioritized above functionality.\n\n2) Cost vs. Minimum # of errors\n\tThe client is a small shop that wants you (the developer) to create a website application for their users. Their\n\tmain concern right now is saving money from whenever they can in order to keep the business going. \n        Because of this they a Design Goal Trade-off has to be made - the development of the application will cover\n\tonly the most important aspects and some errors and edge-cases won't be taken care of.\n\n3) Functionality vs. Usability\n\tFunctionality is a really important aspect of the application. However, it is very easy to get lost into the loop \n        of constantly adding new functionality. This has a negative impact on the usability of the application from     \t \n        the end user's perspective. Because of this there is typically a Design Goal Trade-off between these two \n        requirements.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1474159,
      "meta": {},
      "text": "Design goals regulate the system design activities but often they stand in conflict with each other.\n\nFor instance low-cost vs.  Performance: it is very hard to maintain a system with high performance such as supporting one million users concurrently while being on a budget. Because this high performance needs to get financed and it is costly. If a developer is creating a game he would have to choose between a game that could support a lot of users at the same time but therefore he would have to pay a lot to support the high performance or he could develope the game on a low cost but only a limited number of concurrent users are supported\n\nFunctionality vs. usability:\nA system with a lot of functions can be very practical and in-demand but it is also of significance for the system to be easily used. The usability describes how easy it is to use a system. If the system has many functions the usability decreases, because for instance instead of clicking on one button to start a game, the user would have to choose all different kinds of features and then start a game.\n\nrapid development vs. functionality\nA system that has been developed at a rapid pace would most likely have a small number of functions. However, a system that has been developed at a slow pace would most likely have more functions. To have a high functionality developers need time to come up and work on these functions. For instance, the bumpers game had only one collision type at the end of the first week but in two weeks another collision type and another car type have been implemented thus increasing the functionality.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1293676,
      "meta": {},
      "text": "Design goals guide the decisions to be made by the developers, when trade-offs are needed.\n\n1.Functionality vs usability: Usability is the ease of use of an interface. And functionality is the set of operations that an interface supports.A large number of functions in one user interface can be annoyance that makes interfaces more difficult to learn and use, e.g the complex operations of aircraft make normal person can not navigate.\n2.Cost vs Robustness:Robustness is to describe how efficient a computer is to run operations and make sense of an error or to handle incorrect input or output. Low cost always comes with low robustness.For example, when we buy a good performing computer, it is always expensive.\n3.Backward compatibility vs readability:Backward compatibility is a property of an operating system, product, or technology that allows for interoperability with an older legacy system, or with input designed for such a system.For gamers, upgrading to the latest consoles can mean games or components that are no longer compatible. Therefore, in order to boost customer satisfaction, there are numerous cases of backward compatibility in video game design and consoles.But on the other hand, it will be less readable for new players.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1332692,
      "meta": {},
      "text": "The most important thing in big companies is delivering working software in the shortest possible time. The company has to pay developers. Therefore shorter development durations mean less costs. Good examples for this trade-off are probably all AAA games (e.g. Battlefield 2042). Every game has its problems at the beginning although you can already buy and play it.\n\nAnother conflict is portability against efficiency. The most efficient way is developing everything with C optimized for every system. But if a new system has to be supported the whole project has to be ported. Therefore companies use programming languages like java or even python although they lose performance. An example of this trade-off shows the trend that more and more applications today are realized with webservers because webapps can be used with every webbrowser and a working internet connection.\n\nA really frustrating trade-off is backward compatibility vs development comfort. It is important that old systems can use newer versions of the software although with every new version the software is extended with  features. The problem is that maintaining backward compatibility restricts your extensions and improvements to some boundaries. That leads to software which frustrates you using it. Also the extension process keeps getting worse and slower because every update more and more things have to be respected. For example Android. Developing native Android apps with java became that uncomfortable that more and more apps are made with alternatives that are easier to use like dart and flutter.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344088,
      "meta": {},
      "text": "1. Functionality vs. Usability: To increase the number of its functionalities, an app must contain more buttons and more options/settings. Therefore, a new user could be overwhelmed by all of the \"expert users\"-oriented functionalities. The developing team then has to decide whether they will make the app user friendly, or high-functional. Think for example of LaTeX, which is highly functional, but less user-friendly than a simple notepad.\n\n2. Cost vs. Robustness: When developing a product, there are always more tests we can do, and more barriers we can build to prevent undesirable behaviours in our program. But this comes at a cost in real life. The developers have to be paid, and the final product is delayed. \n\n3. Efficiency vs. portability: To be efficient, a program might want to use the newest available frameworks or computationally intensive libraries. This can be a good choice for up-to-date hardware and desktop computers but will affect the portability of the software to mobile devices or older computers. For example, if a program uses multiple threads and was designed to run on multi-core computers, it will lose efficiency if used on a single-core computer.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344168,
      "meta": {},
      "text": "Rapid development vs. fault-tolerance: If you want to bring a system to market quickly, it must also be implemented quickly.  However, not enough tests can be performed in that time to see how the program reacts to edge cases, to incorrect user input, to a high number of concurrent users, and so on. Accordingly, the system may have limitations in functionality such as bugs. When implementing a search engine very quickly, you may not realize that blanks or large and lower case letters may influence the search, or how to rank the search results when the search key is on every website. \n\nFunctionality vs. usability: The more functionality a system has the less intuitive it may look to the user. Imagine the Bumbers Game with 50 different cars and collisions types. You may have to crash one car twice and one car 10 times before it stops driving, other cars can only be crashed when it is the last one on the field. So the user may have a hard time understanding how the game works, which makes it quite unintuitive. \n\n\nCost vs. robustness: The less you invest in a system, the less money you have for the right hardware or to hire the right people to implement the system so that it can withhold extraordinary external influences. So when e.g. a lot of users use the system at once, the performance may be restricted or the systems doesn´t work at all anymore. E.g when you choose a cheap webservice provider in India for your Website instead of Google, the performance may be much worse. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344390,
      "meta": {},
      "text": "Cost vs. Robustness:\n\tReducing the cost will also limit your resources to make a reliable product. \nRapid development vs. Robustness:\n\tA hastily developed software might not be as thoroughly tested and is therefore more prone to errors.\nBackward Compatibility vs. Readability\n\tMaking your code backwards compatible requires you to implement a greater functionality, making it more complex and as a result less readable.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344641,
      "meta": {},
      "text": "The first trade-off is functionality vs. usability. A system can have many functions, but that may make it much harder to understand and use for the end-user. An example might be JIRA, it has (in my opinion) a lot of features, but it's really hard to get used to it, while most other TODO apps (e.g. Trello, Todoist) are very easy to use, but lack the functionality JIRA has.\n\nAnother trade-off is rapid development vs. functionality. This is pretty obvious, if you try to develop your application fast, there is no much time to implement more functionality. You see this in the real world quite often with beta and full releases. Beta releases are sooner, but they don't have as many features yet, while full releases take more time, but then offer more functionality. The same applies for later full releases. For example Artemis, I took some time (too long), but now we have a new functionality: dark mode.\n\nThe last trade-off is cost vs. robustness. If you pay your developers more, or let them work longer (results in more costs), they can work harder on covering edge cases and making the application more robust, and vice versa. You can also, for example, make a separate team that solely focuses on testing the application and making sure it's robust. These can be internal or external (e.g. pen-testers).",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1347791,
      "meta": {},
      "text": "One typical tradeoff is between functionality and usability. For example, showing all options and menus directly in the would make the user interface rather unusable since everything is full of different options. Hiding some options behind sub menus is a common tradeoff to enhance usability while hiding some less used options. For example, if programs like Photoshop would not sort options into sub (and sometimes sub-sub menus) the user interface would instantly be cluttered and full of mostly unused options.\n\nAnother often discussed tradeoff is between backward compatibility and efficiency. Designing a new system with a new set of features while maintaining compatibility to some old yet still used system warrants extra effort and cost in developing the new system. Also, maintaining the old system within the new one can limit or worsen performance of both the old system which may have to be emulated and the new system since it could rely on the old system. One such tradeoff would be in the Windows operating system. It maintains function for very old programs (even to 16bit programs) this of course limits performance and makes new features slower since the OS has to be able to work for the old system as well as the new system alike.\n\nOften a tradeoff has to be made when considering Cost and robustness. Making a program more robust, for example by testing more thoroughly, adds cost to the overall development of the project. Since you have to come up with new tests and also more complicated tests that simulate user behavior and so on. For example, in bumpers have more checks with weird/unusual user inputs might be necessary to make the program more robust.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1393339,
      "meta": {},
      "text": "Trade-Offs need to be make in order to fulfill the best allocation between the different design ideas of different stakeholder in a Software development project.\n\n- Time vs. solid Implementation: This is a Trade-Off which often can be very important because it can have big consequences on the further product. If a clients request to have a very quick developed MVP to have a first mover advantage, the Trade-Off might be that at the one hand the client has a first product for its costumer but on the other hand due to the strict time limit the implementation is not good which ultimately can lead to bucks, data leaks etc. which at the end would mean that clients are not interested in the product anymore.\n\n- Flexibility vs. Complexity: A System should be flexible in chase of system errors and other unpredictable events through handling exceptions but with further flexibility to problem the system gets complex which lets to higher maintenance cost and also higher data storage which is ultimately bad for mobile application. \n\n- Functional vs. non-functional Requirements: On the one hand the usability and that's why non-functional Requirements of the product for the client is very important because at the end the GUI is the interaction interface between the system and the client but with further add usability add-ons the underlying important function that the system should perform can suffer through an overkill application GUI. Also because the system should have a certain size not every non-functional Requirements should be implemented to fulfill the the overall requirement of the system. ",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1641292,
      "meta": {},
      "text": "1. Privacy vs Users' Experience: Many apps require access to certain types of data on your phone, which some users are often not too happy with that, as they are often unsure how their data will be handled, and in case of a data breach. An example of that is the advertisement suggestion system of apps like Facebook, which can be as direct as based on your search history, or indirect as how they use location tracking to discover a possible mutual interest between 2 parties, then base on the online interaction of one side to suggest for the other. This has been the root for a story discussed among the public for years on how they believe major apps are \"eavesdropping\".\n\n2. Performance vs Availability of Hardware: an app can ask for permission to run in the background so that they do not have to take much time to boot up when user starts the apps, but sometimes user complains about this making their battery drain faster. An example of this would be there are a lot of articles on the Internet about how you could stop apps running in the background on search engines, bit in exchange for that people complain apps take more time to start. In another case, certain softwares require specific high-end devices so that they can operate more efficiently. \n\n3. Ease of learning vs Functionality: users certainly do not want to take too much time to learn to start using a software, which in some’s opinion is they take less steps, or the app display seems as direct as it can be. In exchange of that is naturally the lacking of some features. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291627,
      "meta": {},
      "text": "-> Rapid development vs. quality: Shortening the development duration of a system in order to reduce costs often leads to the unwanted loss of system quality. E.g. Game developers usually push for extremely fast game development and it often leads to a final product that is very upsetting to the players, due to bugs and lack of features of the game.\n\n-> Scalability vs Complexity: Adapting a system for larger data volumes and larger workloads, often leads to an increase in complexity. E.g. using distributed systems instead of a centralized system: it allows for more scalability through the processing on different hardware nodes, however, it also significantly increases the complexity of the setup and maintainability.\n\n-> Functionality vs Usability: Designing a system that offers the highest amount of functionalities and features can often hurt the overall usability of the system. E.g. Designing an advanced arithmetic calculator with several complex mathematical functions would make it hard for the general public to understand and operate, because the majority of them only want to use it for basic use cases.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1335550,
      "meta": {},
      "text": "One of the important activities in the system design is defining your design goals, but that includes some important constraints . Therefore you need to make trade-offs :\n1- Functionality vs usability : the end user is mostly intreseted in a user friendly system ( easy and intuitiv to learn and use) at the same time they want the system to provide many needed functionalities. This can be controversial since a sytsem offering many functions will get bigger and more complex.  example : an application with many options and functions may be not intuitiv to use\n\n2- Efficiency vs portability : the client and the user want to have an efficient system with portability to use it on different devices. But most of the times , in order to increase the efficiency and performance of the software, the developers need to work on the details of the architecture and hardware on which the system will run. example :  to increase the performance of one specific function developers may go to a lower level and implement it on assembler ( specific to an architecture ), this will affect the portability as the machine language is specific to the architecture and depend on many factors related to hardware\n\n3- Cost vs Robustness : The client is intrested on a low cost product and at the same time a robust one.  But working on a project with constraints of time or a limited budget will make it harder to assure good testing and good system reliability. example : if a client wants his product to be robust ( ability to maintain a function)  he needs to invest money and time on a team testing the software and assuring its reliability.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1349126,
      "meta": {},
      "text": "Functionality vs usability\n\nA typical tradeoff is functionality versus usability. For example if Microsoft Word would give you 12 instead of 3 alignment options (Left-bound, centered, right-bound), it would provide you with way more functionality but it would lose a lot on the usability side, as they could not fit all the buttons in the space and you would lose track on what is what.\n\nCost vs. reusability\n\nIf you want to cut cost on a project, it is cheaper to build a software for a specific purpose than a software platform which would be reusable for comparable programs. For example if you build a software for hotel booking management, it is cheaper to build the program specific for the customer hotel, than to build a platform and specialise the platform to the customer needs. But you could use the platform for further development for other customers, to build a tailored system to their needs.\n\nEfficiency vs portability\n\nIf you are developing computer resource demanding programs, for example like adobe programs you are faced with the tradeoff between efficiency and portability. You could benefit of efficiency by developing the program only for a single operating system and hardware type. For example like Final Cut Pro is only available for MacOS. But if you are a big Software developer like Adobe you want to make your programs available for as many people as possible and thus you need portability, even if portability mean you can not maximise the efficiency for every operating system.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1364376,
      "meta": {},
      "text": "Functionality vs. Usability:\nFunctionality and usability often collide with each other, as high functionality often requires complex workflows or cluttered UI's, which can drastically decrease usability (especially for new/inexperienced users).\nA perfect example would be a tool like Photoshop, which provides a very high grade of functionality, but can be hard to pick up or even intimidating for inexperienced users because it's not always easy to find or even use the function you are looking for. In comparison, the IOS native photo editor is very limited in scope, but enables everyone to just make simple adjustments to their photos.\n\nCost vs. reusability:\nFor a system/codebase to be reusable it often requires a lot of design and development overhead because you have to think in advance how a future user/use case might want to use your system, which in turn increases development costs, as more time/man power is needed. A good example for that are frameworks. It takes whole teams at Google or Facebook to maintain their web frameworks Angular or React respectively which makes them very expensive, but they are highly reusable pieces of software that are used in thousands of web projects.\n\nEfficiency vs. portability:\nIn order to write portable software, that runs on (almost) every system, a high level of abstraction over the hardware is needed. But abstraction always comes with a cost: if a python interpreter is written in C, the language it self cant be faster and is almost always magnitudes slower than something written in C or even platform specific ASM.  \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1373130,
      "meta": {},
      "text": "There are multiple typical design goad trade-offs. One of them is the difference between functionaly and usabilty. Functionality describes the functions of a program and that by if it works, if it does what it is supposed to do and similar things. The usabilty describes the actual ability of the user to use to functional product. This can create problems like an intranet for a company which is perfect to share personal information, official news and everything else a perfect intranet needs. But if not a single emplyee knows how to work with the software no one will use it. \n\n\nAnother is cost vs reusability which describes the cost products can create. This means that a good product can still have high cost in the development, the testing and everything else. But the question is if these costs are resueable. This means that the company who may have spend the money may be forced to spend similar money a few years afterwards due to new data or in general new information which make the old expense information obscelene. If a company for example spend thousend of dollars on a developer team that created a software that works but one year later nobody in the company understands the system or can maintain it. Then this money was not spend reusable. \n\n\nAnother is Rapid Development vs functionality. This describes the difference between simply developing a product without really testing it just to see if it is possible vs actually making sure that the products works just in the way it is supposed to. For example a company that brings out a new exciting phone but it might not work because they wanted to present their phone before e.g. apple presented their newest products",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1469792,
      "meta": {},
      "text": "1) Cost vs Reusability\nIt is a major aspect of design goal trade off and the favourite and the most conflicting topic of all times in the software engineering . A highly good invested software is always better in functionality as compared to a lowly invested software. That's why a developer always prefer high invest ,in order to make it flawless .But users will always prefer a low costing item(like software) but the best is to make a something more expensive but a bit high cost which increases conflict in the industry .For example- plastic bags are cheap but not reusable where as jute bags are more efficient ,better and reusable but are a little expensive.\n\n2)Functionality vs Usability\nUsability is the ease of use of an interface. Functionality is the set of operations that a interface supports. Usability and functionality are often seen as a design tradeoff. A large number of functions in one user interface can be an annoyance that makes interfaces more difficult to learn and use.Removing function or burying them in obscure places generally makes interface less  powerful.Usability purpose is to make the thing easy to use whereas functionality are a set of operation set to make things bit complicated.Example -It's relatively easier to pilot an aeroplane in comparison to use it's operational and safety features.\n\n3)Efficiency vs Portability\nA choice the programmer faces is portability versus efficiency. It is an agonizing one, too, because favoring efficiency results in nonportable code, while selecting portability often results in software whose performance is unsatisfactory.Efficient software doesn't waste CPU cycles. It takes full advantage of the underlying hardware, often completely disregarding portability issues.Although efficient software is attractive from a purist's standpoint, the value of running the software on many different machine architectures tips the balance in the other direction. The reason is more financial than technical: in today's computing environments, software that runs on only one architecture sharply limits its potential marketability.\n\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1481760,
      "meta": {},
      "text": "A typical design goal trade-off is Performance vs Maintainability. In order to increase the performance, it is often necessary to write code with low-level optimizations that is hard to understand and maintain. Clean and understandable code often uses abstractions that might have an influence on the performance.\n\nAnother trade-off is Functionality vs Usability. If a software has lots of functions, it is often complex and hard to use because the user interface might have many different options that have to be selected by the user. \n\nAnother trade-off is Rapid development vs Functionality. If a software has to be developed quickly, it is often necessary to focus on the most important aspects and leave out the most complex use cases. ",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1643343,
      "meta": {},
      "text": "One common trade-off in regard to design goals is that of cost and robustness. Usually, creating a very robust system is harder than creating a less robust system, therefor requiring more work. This, in turn, leads to higher development cost. Another obvious one is between development time (especially fast development times) and functionality. As each functionality has to be implemented and tested, it takes time to add functions or improve the current ones. Accordingly, it is usually not possible to develop a software very quickly, while also implementing a wide variety of functionalities. Lastly, there is also often a trade-off between functionality and usability. Adding more functionality also always adds more complexity to the software. When increasing the level of complexity, the ease of use tends to decrease, as well as the usability.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1646900,
      "meta": {},
      "text": "The first design goal trade-off is functionality and usability. The functionality is what a system is supposed to do and it combines the functions a system provides. Usability is the ease with which actors can use system functions. These two requirements usually stand in contrast to each other. If a system provides too many function, it is usually not easy to use. For example an overly complicated calculator app with a lot of (unnecessary) functions might be too complicated for users and therefore they would use a calculator that is simpler and therefore more appealing. Another design goal trade-off is rapid development and functionality. It is easier and way faster to design a system that provides only the most basic functions (rapid development). But on the other hand if this is the case the functionality suffers and the system doesn't provide a lot of useful other functions. For example: the task is to program a calculator. The developer only has a week to program it. He would therefore only add basic functions such as +,-,*,/ in order to finish the system in time (rapid development). But if this is the case the functionality is not given, because the system does not provide a lot of functions, which might be useful in some cases, such as the square root etc. One other design goal is cost vs. robustness: if more money is invested the developer has more time to think about the robustness of a system. The robustness is: can a system recover from errors, e.g. calculator: it is cheaper to only hire a developer to program a calculator with basic functions, but more expensive to tell him to think about the robustness, because it takes more time for him and therefore is more expensive.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291784,
      "meta": {},
      "text": "(1) Functionality vs. usability: Out of my own experience I can tell that this trade-off typically occurs for me when using mobility apps. E-scooter apps are mostly extremely easy to use, because they only support one brand and one type of vehicle. For me personally this makes it really easy to use. Sometimes, it would also be nice to have more vehicle options like a bike or a car, however, having too many options might get overwhelming very quickly and therefore would hinder me using the app at all.\n\n(2) Cost vs. robustness: Developing an app that is robust means for example a user can’t really break the system. To develop such a system is very cost intensives or takes a long time, which ultimately is cost intensive as well, because the software engineers have to put a lot of thought and work in it. Therefore it is clearly a trade-off.\n\n(3) Efficiency vs. portability: Apple is a classic example of a company that is developing software which is perfectly adapted to Apple hardware. This means all the software runs extremely efficient, because even if the hardware is technically not as good as in other devices, the software still outperforms. However, this comes at the trade-off for being only accessible for Apple devices and therefore not portable to other devices (like Linux or Windows )at all.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292528,
      "meta": {},
      "text": "Functionality vs. usability:\nBei der Implementierung von zb. Schach kann man zwar verschiedene Optionen für das Spiel anbieten, wie zb. wie schwer das Spiel sein soll, ob die Zeit zwischen jedem Zug mit berücksichtig wird oder ganz banal Hintergrund vom Spielbrett ändern. Diese Funktionen sind zwar gut aber man muss aufpassen, dass man das Spiel nicht durch zu viele Möglichkeiten unübersichtlich macht und somit ein Nicht-Userfriendly Spiel hat.\n\nBackward compatibility vs. readability\nDer Client erwartet von Developer, dass er die Rückwärtskompatibilität berücksichtig. Die neue App zb. muss trotz allem mit den vorherigen Produkten kompatibel sein. Dem Developer ist es wichtiger, einen cleanen Code zu haben der gut zu verstehen ist und nicht veraltet. Daher muss er ein Kompromiss zwischen seiner Priorität der Lesbarkeit und die Priorität des Clients finden. \n\nCost vs. reusability\nDer Client möchte ganz klar so wenig wie möglich für seine zb. App ausgeben. Der Developer könnte natürlich schnell eine App (zb ein Spiel) implementieren, aber das wäre nicht sehr sinnvoll für ihn. Dem Developer ist auch wichtig seinen code so clean und \"allgemein\" wie möglich zu schreiben, dass er ihn auch in der Zukunft für andere Projekte wieder verwenden kann. Um aber eine wiederverwendbaren code schreiben zu können, muss er sich mehr Zeit lassen bzw. mehr Energie rein investieren.",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1301119,
      "meta": {},
      "text": "Design goals usually come into conflict with each :\n  Typical design trade-offs may include : Functionality vs Usability since functionality represents the operations that the system must support whereas usability means the ease of use of the system. So when a system offers a large number of functions, it can make it more difficult for the user to learn and use all the functions presented to them. As an example a website that offers a myriad of features and displays many tabs that are cluttering it  makes it harder for people to find the features they need.\n   Another important design trade-off would be Cost vs Robustness : A software system that is developed on a low budget will have a hard time maintaining some functions when faced with unusual situations (changes in the environment..) To develop a more robust system higher costs are needed. A concrete example from the real world would be the early free version of the eBay mobile app that has a lot of problems( disappearing cart items..) and crashes randomly offering a not so robust system. \n    Last but not least comes Functionality vs Rapid development : all required functionalities should be completed before a certain system delivery deadline. However, not all functionalities can be completed before that date so the final system is either delivered on time but not really complete or complete but late. For example the bumpers' car game doesn't have the functionality of added new car types because the game had to be developed in a short time.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1322735,
      "meta": {},
      "text": "Einer der offensichtlihsten Design Trade-offs ist Functionality vs. usability. Hierbei geht es darum, dass viele Funktionen innerhalb eines Systems schnell zu Unübersichtlichkeit führen können, da all diese Funktionen inovativ erreicht werden müssen, dies bei einer großen Anzahl jedoch oft sehr schwierig ist. Andersherum kann man bei weniger Funktionen diese besser in seinem System hervorheben. Ein gutes Beispiel für so ein Problem ist das Design der Adobe Apps, welche unglaublich viele Funktionen bieten, jedoch auch recht kompliziert zu bedienen sind und man lange brauch, um sich zu merken, wo nun einzelne Funktionen zu finden sind.\n\nEin weiterer Trad-Off, welcher besonders in der Videospielindustrie oft zu merken ist, ist cost vs. robustness. Möchte man ein System billig entwickeln, so muss man an Zeit und/oder an Arbeitskraft sparen - da die gewünschten Hauptfunktionen jedoch höhere Priorität haben, wird meistens die Optimierung und Fehlerbehandlung bzw. Fehlerrobustheit hinten angestellt und das System wird weniger gepollished veröffentlicht.\nAls Beispiel hierfür könnte man Cyberpunkt 2077 nehmen, welches mit einer Menge von Bugs und Spielabstürzen veröffentlicht wurde, da an Zeit und somit auch an Geld gespart wurde. Diese Fehler wurden zwar später durch DLCs behoben, diese haben aber wieder Geld in der Entwicklung gekostet.\n\nAls letztes wäre da noch Efficiency vs. portability. Da durch Portability viele Systeme unterstützt werden müssen, kann nicht auf Einzelne optimiert werden oder auf plattformabhänge bzw. hardwareunterstützte Funktionen zurückgegriffen werden. So geht natürlich Performance verloren. Als Beispiel könnte man hier die Programmiersprache JAVA nehmen, welche nicht direkt in Assembly Code auf dem Prozessor ausgeführt werden kann, sondern erst als Bytecode in der JVM ausgeführt werden muss. Somit wird hier Efficiency eingebüsst",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1331551,
      "meta": {},
      "text": "(1) Robustness vs. costs\nIf a system has to be robust this will require lots of testing and extensive error-checking. This will increase development time and thereby costs. You might also have increased server costs at a robust system as you might have redundancy in order to be safe in case one server crashes. (The board-computer of an airplane has to be more robust than a gameboy, therefore it needs to be tested to the absolute extreme, whereas you can do fairly limited testing on a gameboy).\n\n(2) Functionality vs. ease of learning \nIf a software is highly functional it is also often quite complex and therefore hard to learn. At work we recently introduced. the bookkeeping software Datev which is very functional but far away from easy to learn. However, software with little functionality is very simple to learn, e.g. the Notes app on apple where you just open the new note, type your thoughts in and then leave with the app automatically storing what you just typed. This is little functionality but very easy to learn. \n\n(3) Functionality vs. rapid development\nThe more functionality a software should have the longer it usually takes to create it. Additional functionality is usually quite complex and therefore requires longer development time by the developers. At work we currently try to help a company evaluate student answers. Simple multiple-choice evaluation can be done really quickly, however evaluating text-exercises that includes NLP is way more complex and therefore takes more time to implement. Therefore, usually, the more functionality you want the longer it takes. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1336674,
      "meta": {},
      "text": "The first design trade off is the cost and performance issue. If you want high performance, programmers need more time and therefore need to be paid more money. but you also want to keep costs low, therefore there is a trade off.\nthe second is rapid development and minimum number of errors. It takes time to find and fix all errors and therefore there is a is trade off between rapid development and number of issues.\nthe third trade off is costs functionality. If you want a lot of functions, it takes more time for them to be programmed, and therefore it costs more money, since you have to pay the developers. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1414314,
      "meta": {},
      "text": "When it comes to design goals, design goals typically conflict with each other in many cases. Therefore, developers and client will decide on the trade-offs they want to make. One of the typical design goal trade-offs that faces developers is cost versus robustness when a developer wants to build a robust app it will be for him time consuming, and this cost will be passed to the end user or client. For example, the client university want to build a university app, where students can register for courses, exams and communicate with their fellow students, the university want this app to be robust in order to do its job, but this will add more costs in order to be achieved.\nIn many cases, developers have to decide on whether to build with more functionality or better usability. For example, adding to many functions to the app the university wants to offer to its student, will make overwhelming for the end user in this case the student.\nMoreover, efficiency versus portability is one of the common trade-offs, there is no way to run away from this trade-off. When the university prefer to have an app with high portability, where the app works on as many systems as possible like Windows in its different versions, Linux, Android and IOS, the app will not be able take full advantage of the system and will waste CPU cycles. Therefore, a decision has to be made here again about on how many systems will the app be functioning.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292595,
      "meta": {},
      "text": "Backwards Compatibility vs Clean Code : Some projects are dependant on legacy code, which is often depreciated or undermaintained. This could be for example due to an old server which runs on outdated network protocols. In order to maintain backwards compatibility, new code would have to include outdated or deprecated code/languages/style in order to still work. This however means that you can no longer have clean, readable code, which negatively affects maintainability and supportability at later stages.\n\nCost vs Robustness - Another example is whether a system should be very robust or whether it should  be cheap. A prime focus for a banking system would be robust, secure, stable systems, which are safe from external sources or internal errors. On the other hand a cashier system isn't really required to be as stable or secure. For them it would make more sense to spend less money on the system, in exchange for a system which they maybe have to restart every now and then.\n\nFunctionality vs Usability - Dependant on the software being developed, we can also make a decision on whether the system should have lots of different, versatile functions, or be simpler and instead easier to use. For example, in designing a Integrated Development Environment, functionality is a high priority. Typical users will be high skill, or trained and as such, extra functionalities which might not be easily accessible at first would be considered worthwhile adding to the system. On the otherhand, a simple order system at a restaurant will be used primarily by untrained or \"low skill\" workers, and as such, should be intuitive and easily interacted with, at the cost of not containing as many extra functions.\n\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292636,
      "meta": {},
      "text": "1. Sometimes you have to decide between functionality and usability, which means that in order to make the system more understandbale for the user (e.g. by only displaying a certain amount of information/buttons at a time) sometimes there have to be cutbacks concerning the functionality, for example because there are more clicks necessary to reach a program point. \n\tFor exmaple when shopping for clothes everything is divided in multiple encapsulated categories, so instead of being able to directly access the category 'winter jacket' you would have to select 'jacket' beforehand and then you can see the different types of jackets, where you can select 'winter jacket'.\n\n2.  The trade-off backward compatibility vs. readability means that when you have to design a software for a great variety of devices, it has to be able to work on old devices ,too. Possibly you would have to (slightly) change the software for those devices because the version for newer ones isn't working equally on them. Therefore it gets less clear which functionallity for which device or which version is placed where and it gets less clearly structured and harder to install updates.\n\n3. When deciding between cost and robustness, the problem may be, that it is cheaper to not invest in workers to enhance the security of a software meaning that it would take them more working hours to make the software more robust concerning attacks. But therefore some undeteckted security gaps can become a problem for the software and the enduser. ",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1293610,
      "meta": {},
      "text": "cost vs. reusability. On one hand the client doesn't want to spend a lot of money on the new software, on the other hand the developer would like to use his or her work for other future systems and therefore is willing to put in more effort and time which would cost more for the client. E.g. the TUM wants to spend only 5000 euros on the new Student App, but the development team would like to build the App not only for TUM but also for other universities which would mean more time investment and therefore more costs for TUM.\n\nfunctionality vs. usability, both located at the design goals of the user. Every user of a software wants to have as much functionalities as possible but also a system that is easy to use. For example, in terms of a new Student App, students not only want to book courses and exams and chat with other students, but also want to see their schedule and plan meetings ect. This would mean that the menu site of the App will be very loaded and full of possible links and buttons which leads to a worse usability. \n\nrapid development vs. functionality. The client wants the developer to finish the software as soon as possible in order to save some money, but the user wants a high functionality on the system, meaning many functions and easy handling. The TUM wants the developer to finish the project in 5 months, but the students want more and more functionalities meaning more time needed for the developer. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1295754,
      "meta": {},
      "text": "Functionality vs. usability: Man will natürlich ein Programm haben welches multifunktional ist. Jedoch ist dies nicht besonders praktisch zu benutzen und man verliert schnell den Überblick. \nCost vs. reusablitiy:  Als Entwickler probiert man die Kosten möglichst gering zu halten. Am besten wäre auf java bezogen eine Klasse. Wenn man den Code jedoch wieder verwenden will ist dies ineffizient. Ein Konstrukt mit Vererbung ist oftmals besser um Code wieder zu verwenden.\nCost vs. robustness: Wenig Code mit vielen Funktionen ist optimal aber schwierig und teuer zu coden. Manchmal ist es praktischer und billiger mehr Code zu haben welcher nicht komplett optimiert wurde.",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1315246,
      "meta": {},
      "text": "1- low cost vs high  performance : when  a system  is developped at a low cost without investing in a lot of resources in order to be able   to work on every detail and make the system as performant as possible it may lead to a lot of crashes , because the system is not build well to support high loads of requests for example .\n\n2- rapid development vs Adaptability : when the client requires that the software is finished within a short time , this will exerce a pressure on the developer obliging him as a result to not pay a lot of attention or put a lot of work in making the system able to deal with all the changes  that may occure and adapting to them smoothly  in a way that keeps the functionality of the system and do not disturb the user's experience .\n\n3- functionality vs user friendliness : when a system is composed of  a big number of functions which are complex and hard to understand , this can lead to the confusion of the user and a lack of understandibilty of the system , thus it will result in the non-user friendliness of the system.\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1317828,
      "meta": {},
      "text": "The first, very common design goal trade-off is rapid development vs. functionality. In the world of software engeneering, the speed, in which a project can be completed (and still be functional) is of core importance. Time is money, and no one wants to lose money. However, developing a procuct in a small timewindow, inherently comes with the problem, that the developed app is less functional than it would be after a longer period of development. Hence software engeneers need to find the sweet spot between invested time and functionality, so that the finished product fulfills all the needed requirements and satisfies the customer/end user. An example for this is the development of web services. They need to fullfill all the required functions, and be developed in a short timespan. The reason for this being that the business behind the website need it to be up and running asap to advertise and sell their products.\n\nThe second most important trade off is development costs vs. robustness and security. For instance the software behind an ATM machine needs to be robust and secure, for obvious reasons (password protection, no leakage of bank information and personal data, hacking problems, etc.), but the development costs need to be held low in either case. More often than not, this tends to be very difficult, expecially when developing complex systems, that have to be as secure and robust as fort nox.\n\nThe last trade-off, that I'd like to touch upon is functionality vs. usability. For instance a system for image manipulation software(Adobe Photoshop) needs to provide a vast array of functionalities (sharpen an image, add Gaussian Blur, cut out image sections, etc, etc) and stil e easy to use. This means that the user interface needs to be intuitive and simple and at the same time the end user needs to have all the needed functionalites at his/her fingertips (getting there with few clicks). Gimp is a prime example for an image manipulation software that prioritizes functionality over usability (I speak of experience), which is not alway the best way to go.\n\nI apologize for the length of my answer. I understand that tutors have a very tight schedule.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344137,
      "meta": {},
      "text": "Functionality vs. usability is a typical design trade-off. You want the system to be able to do many things, however you still want a qualitatively easy to use interface. A very good example for this is website design, you want the website to have as many functionalities as possible, but it should also be usable and have a simple experience: it should be easy for people to find informations, and learn how to use the features.\n\nCost vs. robustness is another typical design trade-off. Of course, you want to save money and therefore the development should not be too costly. The cost is proportional to the size of the software and its user base. Yet, the system should still work when the user enters a wrong input or when there are changes in the environment. An example for that could be, with testing and the release of a software. Testing can go on forever, it is necessary for the robustness of the system but it also comes at a cost!\n\nFinally, rapid development vs. functionality is also a typical design trade-off. Rapid development means putting more emphasis on the product development. For example, a project has a delivery date, where all the functionalities should be complete. Nevertheless sometimes all the required functionalities cannot be completed on time. The system will then be either on time but not complete or late but complete.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1468916,
      "meta": {},
      "text": "Security vs. Time: The aspect of securrity of a system often depends on the budget and the invested time by the developers. While users often care about their security of personal data, the client cares about the duration until the software is ready for release. Both goals should be reached by the developers but a save system couldn't be created within hours. More safety, more time needed. It's important to find a mediocre.\n\nLoading vs. Coding: Every user of an application hates when the loading circle on the screen appears. Users want all the data on time without any delay. But that's hard for the Developer to realize. It's hard to write efficient code without nearly none delay. When the User needs to load a huge amount of data, it needs to be loaded and processed by the system. Coders can try their best but a waiting time of 0 won't be realistic even in future.\n\nEfficiency vs. portability: When customers want the developers to create applications for multiple plattforms, is the efficiency of the program and the development decreasing. Multiple plattforms combined in one code could be realized but it's not that efficient than writing the code in pure plattform oriented languages. For example could Flutter be used for Android and iOs development. Instead of using the cross plattform language, using Java and Swift, offers way more functionality and efficiency for each plattform. The code could be optimized for each OS itself. So the efficiency could be increased. But with increasing the efficiency, the portability decreases as mentionend, because only one plattform is supported by the software. The user gets restricted by the usage of the app.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291792,
      "meta": {},
      "text": "• Functionality vs. usability\nIf a software has 100 functions, then the user needs to remember how to use so many complex functions. That would not be very useful. Because there are only a few functions that are commonly used, too many functions increase the user's burden of use.\n\n• Efficiency vs. portability\nSoftware with high portability means that not much needs to be done when porting to different system platforms, without much time cost. This requires more time and cost initially in development and is necessarily not as efficient\n\n• Rapid development vs. functionality\nFor example, meeting many customer requirements for functionality means more time is needed for development, in which case there is no way to develop quickly and there is a trade-off\n\n• Cost vs. reusability\nIf you want to reuse it, it means a lot of time and cost to develop a better software\n\n• Cost vs. robustness\n\n• Backward compatibility vs. readability",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1292511,
      "meta": {},
      "text": "1.Functionality vs. usability: \nDuring my bumper exercise, multiple buttons were planned to add to the top bar of the gameboard, so the user could adjust the music playing, choosing his or her car or choosing difficulty on the go. Help document was also planned. This however adds too much stuff and can make the bar too crowded, especially when a future boss health bar was also planned to add there. So in favour of usability, these functionalities were either canceled or implemented elsewhere. \n2.Cost vs. reusability: \nI added bullets as cars in the game. Even though there were only enemy bullet's moving logic and player bullet's moving logic to be implemented, I still wrote a new shoot() method for them instead of simply intergrating them in drive() method, so that further developments on new bullet types and functionalities would be simpler. Cost here is the trade-off for future code reusability. \n3.Cost vs. reliability: \nDuring testing, the game did crash a few times despite functioning normally in most cases. I fixed most of the problems, however there're still chances where the game would not respond to player inputs. This is quite rare, and the situation is hard to simulate during testing. Since this is just a simple small game, and rare crashes won't cause much harm, the initial version is thus compiled and launched without fixing the last issue, saving cost on the project. Of course this will be looked into afterwards, but this small reliability issue won't matter much for the initial release. ",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1294271,
      "meta": {},
      "text": "Oftentimes design goals conflict each other, which is why one always has to prioritise and also make compromises in order to achieve the best possible medium between them.\nOne prominent example is quality versus costs. Both monetary as well as different kinds of costs (time,...) are possible. We want for example a software that fulfills highest quality standards, and is able to handle any possible error that could occur. To ensure this, however, it is necessary to take a lot of time and multiple people in order to check and improve the system over and over again, which is very expensive. \nAnother example is the conflict between maintainability and short development time. In order to have a system that is easily maintainable, you will need a clean code and especially a proper documentation. This however again takes a lot of time and makes it impossible to deliver the product as soon as possible.\nLastly also the idea of simplicity and functionality can be very conflicting. On one hand it is very desirable to keep the system as simple as possible, so it easier to understand and handle for the user. On the other hand you want to offer as much functionality as possible, which can sometimes be overwhelming and confusing.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1295244,
      "meta": {},
      "text": "Functionality vs usability:\nIF you want to have a website that is easy to handle, you can't have many functionalities. It just would result into \nan confusing and unclear webpage for users.\n\nPortability vs Efficiency: \nportability is contrary to efficiency. A good example is an office laptop that is easy to carry due to its light design but not doesnt have the same efficiency as a PC. With a PC you are free to do intensive programs in a short amount of time due to the better components a PC brings with itself.\n\nCost vs Robustness:\nYou cant aim for very low expenses if you want your product to be robust. F.e. a computers workload increases making its temperature rise to 50 C°. If your Components dont have an temperature tolerance and if you dont have measures for those enviromental changes just as  a cooler restriction or time outs at certain temperatures your computer might be cheap but it wont be of any use since it will be burn out once it is overwhelmed with the workload. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1340024,
      "meta": {},
      "text": "1.Functionality vs. usability \nif a system has a lot of functions that it makes it overwhelming to use so it is not very user friendly , a simple system with less functions could be more usable from the end users\n\n2.Cost vs. reusability\nyou can make a system cheaper by not making the code reusable in other projects or spend more now and save later when you re-use parts of the project.\n\n3.Efficiency vs. portability\nyou can make a system very efficient for a particular environment but you can't use it in other environment.\nOr you can lose some of the efficiency and make it protable to be used in many environments.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1361054,
      "meta": {},
      "text": "1) Functionality vs. Usability\nFunctionality means that many functions are in the same interface but that isn't a good thing in terms of usability, because it is difficult for people to use these functions and the app as well. For example if a university website gives you the chance to chat with your friends, sign up/off for lessons, share comments and etc., you might have difficulties while signing up for an exam because the app has so many functionalities and it's harder to find the right pages on the website. \n2) Cost vs. Robustness\nIn order to increase the robustness of a system,  more work and money will be needed. But the client always desires to make the best app with low costs, which is really difficult.\n3) Security vs. Usability\nTo make an app more secure, some features are added to apps, which makes the apps harder to use. For example social media apps require high protected passwords, they want us to use special characters, more than 10 characters etc. but it is hard for users to remember these difficult passwords. This happens to me all the time, I always forget some of my passwords and have to request a new password frequently. But if we had chosen weaker passwords, then our accounts could've been hacked easily.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1375102,
      "meta": {},
      "text": "Funktionalität vs. Usability: \nDabei geht es darum, dass je mächtiger eine Software ist, also je mehr Funktionen, Aufgaben sie erledigen kann , desto schwerer wird es diese Software so zu gestalten, dass sie für den Benutzer sehr effizient anwendbar ist, um bestimmte Aufgaben schnell und intuitiv zu erledigen. Bspw. bietet Photoshop abertausende Möglichkeiten an, Bilder den eigenen Vorstellungen nach zu verändern. Jedoch sorgt der Umfang der Funktionen und die damit verbundene Komplexität dafür, dass sich ein Anfänger nicht sehr schnell darin zurecht finden kann. \n\nCosts vs. Robustness:\nEs muss mehr Zeit, Abstraktion, und Wissen über meine Anwendungsbereich, also mehr Geld investiert werden, damit sichergestellt ist, dass Software korrekt auf möglichst allen möglichen Eingaben laufen kann, ohne abzustürzen. Bei der Testphase eines Programmes müsste mehr Zeit investiert werden um etwaige Eventualitäten abzudecken ,damit das erwünschte Verhalten garantiert ist. Bei Ebay kam es mal dazu, dass die Verwendung eines Dezimalpunkts statt Dezimalkommas, zu einem höher als gewünschten Gebot führen konnte.\n\nEffizienz vs. Portabilität:\nEffizienz ist die Frage danach wie gut eine Software auf einer bestimmten Umgebung läuft. Wenn das Ziel ist, dass die Software möglichst portabel ist, also auf verschiedenen Hardware und Umgebungen laufen soll, wird es schwer individuelle hardwareabhängige Verbesserungen zu implementieren für bestimmte Umgebungen zu entwerfen. was zu Effizienzeinbußen bei der Software führen kann.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1515054,
      "meta": {},
      "text": "1. Functionality vs. usability\n\nTalented software engineers naturally have the ability to pack applications full of interesting features and functionalities to appease clients and users. However, there needs to be a balance between how usable these functionalities really are, because then they just go to waste and suck up valuable development time. The most successful video games today, Minecraft, GTA V, Call of Duty, are naturally chock-full of interesting functionalities (more with mods). However, the basic underlying principle of these games is clear, and players aren't overwhelmed with functionalities that casual players cannot be expected to use. These games have core usability features that everyone can easily understand, without risking functionality.\n\n2. Rapid development vs. functionality\n\nAmbitious entrepreneurs are often faced with the notion of getting an MVP (minimum viable product) out there as soon as possible, to attract investors and demonstrate that their idea is worth further development. To get this prototype or MVP done, the entrepreneur (client) and developer(s) will be faced with many dilemmas about which functionalities can be developed rapidly, and which are even worth being developed in a rapid manner. It is a difficult balance to create, likely part of the reason why so many startups fail.\n\n3. Cost vs. robustness\n\nCost and robustness obviously contradict each other, because making a development process/application more robust naturally requires that more time and therefore money is invested. For example, a banking application will need to consider this heavily, given the reliance of its users on it and sensitive data stored (need for robustness) but also the never-ending seeking of profitability and cost-effectiveness.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1521437,
      "meta": {},
      "text": "1- Rapid development vs.  functionality :\nIf a team runs behind schedule the software can be delivered with less functionality or the software will be delivered later. For example: League of legends updates\n(Riot Games) are always scheduled before an Esport event and it has happened sometimes that the update is delivered with less functionality and be added  later.\n2-Cost vs. reusability: \nThe maintenance costs of a reusable software increases if the source code of a component or a subsystem is not available or incompatible with the new system changes.\nTrivial example : the cost of maintenance of non reusable software developed in the 90s.\n3- Functionality vs. usability\nThe more functionality a software has  ,the complexer the user experience will be.\n A web application which is easy to use and has a simple experience is usable . An example for that is an online simple calculator. It ‘s usable for the majority of the users but does not have the functionality needed for a mathematician. An online scientific calculator with matrix and functions calculation can be hard to use for a casual customer.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1608109,
      "meta": {},
      "text": "1. A software developer has to decide if he wants it software available on all Platforms like on PS4, XBOX, PC but then this would mean he cannot have the best performance and price because if he only focus on one platform it becomes much easier and cheaper.  This is why often games run on much lowered Hardware on consoles but on PC you need much better hardware to run the same game at the same quality.\n\n2. Photoshop put a lot of functions into their system which make them very hard for new user because they are overwhelm with functionality.\n\n3. When CD Project Red developed The Witcher 3 they have mad their own engine what cost a lot but they plan to use the engine in their future games their for have a good reusability.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1635520,
      "meta": {},
      "text": "Functionality vs. usability\nduring the delivery of a software engineering product/project, each party has their own expectations. for example, client wants each and every function which be deliverable, and software engineering team wants to keep things simple. on the other hands, delivered product should have enough functions to make product user-friendly and reusable enough.\n\nCost vs. reusability\nsometimes client wants to keep it cheaper and also software engineering team wants to meet minimum needs to make product cost-efficient. it is crucial to have the most cost-efficient products on the other hand reusable sources-codes-analysis-structures help easier production processes in the future. once you start an analysis and system design, considering all aspect of current production and deliverable futures features, demands and functions of the product makes things easier.\n\nBackward compatibility vs. readability\nbackward compatibility is most of the products' biggest issue because during the development circle, engineering team focuses on one sprint and forgets rest of the sprints. in addition to that, they wants to have clear coding to make it more readable for other developer. readibility is crucial because none of the developer is going to stay in same project forever, but backward compatibility should be considered during the production. adding comments during committing and coding and also adding backward compatibity items in analysis would be helpful to make codes easy to read.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1650665,
      "meta": {},
      "text": "There is firstly the functionality vs usability trade off, where it has to be decided if a lot of functions really give more usability or does it lower the system's usability because of how overwhelming the amount  of functions is.\nNext there is the efficiency vs portability. This basically means if you want your code to be fast, you have to write it specifically for one platform. For example writing the code for ARM based CPU's or for Linux. Or you can write for example in Java and run the code in JVM which is a lot more portable but also slower than if you would write it in C for a specific platform.\nLastly there is the backwards compatibility vs readability trade off which is about legacy code and features. Since the technology is moving forwards at a rapid pace, the technology and the methods that were used 10 years ago are a lot different than the technology used today. If you want your code to run on 10-20 year old machines, you have to support the technologies that were used by those machines. But since that is old, it may make the unreadable.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1654119,
      "meta": {},
      "text": "1. Cost and Robustness \nAs the client or Developer, you want to make a cost-efficient product. It applies to the choice of the hardware for example as well. The more robust and long-living materials are more expensive too. So it is a trade-off between the cost you want to spend on the product and how robust you need it to be. For example, the choice of components for the ATM Machines should be made toward high protection even if the client has to spend more on the equipment. And if the case of the laptop, to make a lower-price laptop, the manufacturer might go with cheaper plastic housing.\n\n2. Functionality and usability\nUsability means for an end-user how user-friendly and how easy to use is the product. Usually, it includes minimalistic design approaches, to make the program as easy and simple for the user as possible. However, in complex programs, it is often not possible to reduce the functionalities. For example, Exel provides great functionalities and features for all different kinds of tasks. The user-friendliness is however very arguable, so there are many new tools on the market, that have a better focus on the UX and UI aspects but, reduced functionalities compared to Excell.\n\n3. Rapid development vs. functionality\nTo reduce the time-to-market client and/or developers are seeking fast solutions often neglecting the functionalities of a program. This also includes the trade-off with the \"fault tolerance\" design goal.\nFor example, it is a good approach for building an MVP app, where you have to show the basic idea as soon as possible without detailed features. But for the final product, it is always a trade-off, which often requires good planning in advance.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1655294,
      "meta": {},
      "text": "1. Functionality vs. usability\nFlexible designs cater to a broader range of user needs, naturally becoming more complex. But it also means they require more compromises, which will reduce usability. For example, software that integrates ticket ordering, shopping, navigation, chat, and music player must be flexible, but at the expense of usability.\n\n2. Cost vs. robustness\nTo improve robustness, better infrastructure, hardware configuration, etc., are required to improve robustness, so more cost is needed. For example, software wants to support 1 million people logging in at the same time without crashing. Then it has to buy more servers to support, which is bound to add more costs.\n\n3. Rapid development vs. functionality\nA software project has a defined delivery date by which all functionality is required to be completed. However, sometimes all required functions cannot be completed by the specified delivery date. The trade-off is between rapid development and functionality: is the system on time but with fewer functionalities, or complete but release later?",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291973,
      "meta": {},
      "text": "1. Ein Trade-off könnte zum Beispiel der Konflikt zwischen Kosten und Robustheit sein. Der Kunde wünscht sich in den meisten Fällen eine robuste und fehlerresistente Software. Um dieses Ziel zu verwirklichen muss die entwickelte Software natürlich ausgiebig getestet werden um Bugs oder unerwartetes Verhalten so gut wie möglich auszuschließen. Dies verlängert den Entwicklungsprozess und erhöht so die Kosten für den Kunden, daraus folgt dass es hier einen Kompromiss geben muss, der je nach Einsatzzweck der Software mehr zu Gunsten der einen oder anderen Seite ausfällt. Soll zum Beispiel eine Fahrassistenzsoftware entwickelt werden, fällt die Robustheit für gewöhnlich besonders ins Gewicht, während bei einem Handy Spiel eventuell mehr auf die Kosten geachtet wird.\n\n2. Ein weiterer möglicher Konflikt der auftreten kann ist der zwischen schneller Entwicklung und Funktionalität.\nJe weniger Zeit dem Entwickler bei der Entwicklung eines Programms zur Verfügung gestellt wird, desto weniger Funktionalität lässt sich ordentlich implementieren, daher müssen hier Abstriche beim Umfang der Software gemacht werden wenn ein sehr straffer Zeitplan Priorität hat. Will zum Beispiel ein Kunde ein neues Software Produkt auf den Markt bringen um eine Marktlücke zu erschließen, so ist es eventuell wichtiger die Software so schnell wie möglich zu entwickeln um als erster den Markt zu erreichen auch wenn dafür die Funktionalität der ersten Version noch nicht voll ausgereift ist.\n\n3. Des weiteren muss man oft Trade-offs eingehen wenn es um die Eigenschaften Funktionalität und Benutzbarkeit geht. Eine einfache Benutzeroberfläche zum Beispiel darf nicht zu viele Knöpfe und Funktionen haben da sie sonst leicht unübersichtlich wird. Daher muss man sich hier oft auf die wichtigsten Funktionen beschränken um eine Reibungslose Benutzererfahrung zu gewährleisten. ",
      "score": 91.7,
      "language": "GERMAN"
    },
    {
      "id": 1292638,
      "meta": {},
      "text": "Cost vs. Robustness:\nThe more robust (handle more edge cases) a software has to be, the more time it takes to develop this software and the more time it takes, the more expensive it gets. (eg.: a game has to handle also wrong inputs and should not crash from that, which takes more time to implement)\n\nBackward compatibilty vs. Readability: \nIf the client wants a backward combatible software (eg.: should be able to handle data from older versions) the more complex the code gets and most oft the time also the interface. And the more complex the code/interface gets, the more unreadable it gets also. (eg.: if a new database is backward combatible, it should be able to handle data from the old database, for that it needs to interpret more types and work with then, which needs more lines of code)\n\nRapid development vs. Functionality:\nSometimes a client wants a software project finished really quick and the developer has to hurry up. This can (and with bigger projects WILL lead) to bugs and forgotten features. (eg.: during game development there are publishing dates and sometimes the developers have to rush and this often leads to the game being more buggy)",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1299233,
      "meta": {},
      "text": "cost vs. robustness: \nIf you do not want to spend much money on a software product you can not expect it to have a high quality and to be robust. The more money you spend, the better the resources that can be used for the product are. Furthermore you can hire people with better abilities. In addition, if the software development team has more time to develop and test a product, the result will be better. But the costs will also be higher, because you have to pay more money if more time is spend on working on a project.\n\nrapid development vs functionality:\nA good software product with an impressive functionality needs time to be developed. You need to spend enough time on planning as well as developing. The more time you invest the better the ideas can be. If you hurry to much the consequence can be that the result is not finished as expected and has unwanted issues. Furthermore if you spend more time on developing and testing the product, you will be able to improve the current functionality, find mistakes and ameliorate them, and also add some new functions. In conclusion more time means better functionality.\n\n\nfunctionality vs usability:\nA product with an impressive functionality usually has complex and many functions. Good usability means that the system is easy to use. But if the functionality is complex, it can not be easy to use by the actor, because something complex can not be transformed into something easy. In addition, if a product has many functions, it is also hard for the actor to remember each function and differ the functions. Imagine for example a product with 100 functions. It will take a lot of time until the user gets comfortable with this product and can distinguish each functions.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1321223,
      "meta": {},
      "text": "A typical trade-off is efficiency vs. portability and a good example for that is Java. It is portable and was basically invented for the concept of \"Write once, run anywhere\". But this comes at the expense of efficiency, as Java is not translated into the Assembler of the machine it runs on, but into Java bytecode, that runs on the JVM that runs on the machine. This Java bytecode is an abstraction of typical Assembler and as long as a machine supports the JVM, the compiled Code can run on it. But of course it is less efficient to run a JVM on the machine and let the code run on the JVM, than to just run Code on the machine itself.\nAnother trade-off is Backward-Compatibility vs. readability. Backward-Compatibility wants to support old syntax/ structures, in order to be able to still compile/ run old code. If older versions are supported over a long time and new syntax is added, there is a lot of valid syntax, which one often doesn't know.  It might also be unintuitive why certain syntax is accepted or software has a certain structure, which might be due to e.g., hardware constraints of older versions. For example, handling of In-/Output in Java used to be complex and low level, while there are now Readers/ Streams that can transfer more information at once.\nThe last trade-off I want to touch on is Functionality vs. Usability. Vim is the perfect example for this. Vim offers a wide array of functionality and is very powerful, but it takes years to learn it. Although it might increase your productivity a bit once you mastered it, up until there it will take you hours to do simple things.\n\n ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1351144,
      "meta": {},
      "text": "The first typical design trade-off is cost vs. robustness. This means that making a software more robust, increases the costs at the same time. One such example is the robust network design of Facebook/Meta. They have 3 billion monthly active users in the first quarter of 2022 and their servers are handling this many requests without any major issues. That's because they spent 20 million Dollars on housing data centers in 2009 for only 200 million active users. The amount spent likely exceeds 300 millioni Dollars in 2022. The sum spent on designing the networking so flawlessly probably took an equal amount of money.\nThe second trade-off is efficiency vs. portability. The software runs faster but it can't run everywhere. One such example can be found in compiled code of the programming language C. The compiled program might have a different structure depending on the processor, which means it's portable to every device, but the program is more efficient in return.\nThe third trade-off is functionality vs. performance. If a software has more features, it probably takes longer to run. This is especially noticable when designing a website. When I try to open YouTube it takes way longer than opening Wikipedia. On the other hand is YouTube a video-sharing platform with way more features than Wikipedia does have.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1398620,
      "meta": {},
      "text": "1. Rapid development vs. functionality:\nA common tradeoff in software engineering is between rapid development and functionality. This is pretty intuitive: One of the easiest way to be able to release a product quicker is to shed functionality because shedding functionality means this functionality doesn't have to be designed or implemented which saves time. Conversly, if one desires to add more functionality, time has to be spent on designing and implementing the said functionality.\n\n2. Cost vs. robustness:\nWhen engineering a piece of software, robustness can, for example, be improved by writing tests. This takes development time and thus money, increasing overall development cost. On the other hand, if one decides to sacrifice on robustness by saving on e.g. tests, one could save development time and thus costs. This is why there is a tradeoff between cost and robustness.\n\n3. Backward compatibility vs. readability:\nAnother common tradeoff in software development is between backward compatibility and readability. If we take the case of a developer who is creating a widely used library and that developer decides to make some change to the API - let's say the developer decides to replace two functions `floor(double)` and `ceil(double)` to `round(double, RoundingMode)`, the developer has to support all three functions in the end in the sake of backward compatibility and to not break existing code. Conversly, readability can be improved by giving less importance to backward compatibility (e.g. by just removing those two aforementioned functions).",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1425759,
      "meta": {},
      "text": "Rapid development vs. functionality:\nThis trade-off describes how it usually takes more time the more functionality you want to add to a program. The trade-off is usually made for example during prototyping, when it is required to just implement some key fetures of a program in a very short amount of time.\n\nCost vs. robustness:\nWithin this trade-off robustness could be for example the uptime of a certain program and the cost that is needed to build up redundancy in order to ensure the uptime of said program. An example could be Google, who heavily rely on their uptime being near perfect, so in order to ensure that, they put a lot of money into the redundancy and robustness of their system and split their services across multiple datacenters.\n\nFunctionality vs. usability:\nThe more functionality a system offers, the harder it is for the end-user to understand/learn. An example of this can be seen by comparing different video editing softwares. Software like Adobe Premiere Pro offers a lot of functionality and features to the end-user and therefor is harder to learn. On the other hand Windows' built in video editing tool offers just a small amount of functionality, but can be even used by beginners with ease.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1472155,
      "meta": {},
      "text": "We need obviously design system when we talk about the design but it is not always possible to avoid by some conflicts and ı want to talk about some typical design goal trade-offs. One of the most common trade-offs,  we face in Software engineering is Functionality vs. usability. As Software engineers, we are thinking sometimes very complex and it brings us to not showing really off what we in our heads had. At the end of the project, we have an app with a  lot of different functionalities maybe they don't even different, they seem just a little bit but it is really confusing for the user, especially in the sense of efficiency. The second trade-off, I want to mention is Cost vs. robustness. What we are firstly planning, of course, is our budget but one of the biggest mistakes is trying to keep very low the costs although it affects mostly bigger problems which stand up after we finished the project. Our system must stay stable as soon as it can. It can just destroy our all effort. Our last example is Rapid development vs. functionality. As impatient, young software engineers, we have always, what to do. We can not just wait and check, what we did in every step. We have to finish a project as soon as possible but it is sometimes very dangerous because we can pass accidentally very important steps. Let's say, we finished the project in 30 days but we were like a drunken sailor and we faced problems with the functionality. It can take maybe 90 days to rebuild the project and make it reusable therefore we must check every step if are we going very rapid and is functionally correct what we build.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1474876,
      "meta": {},
      "text": "One very typical design goal tradeoff is between the design goals functionality and usability. An extensive functionality means that there are a lot of functions. For example, Java IDE's like Eclipse or IntelliJ have a lot of different clickable GUI elements and even more accessible functions when navigating through the different submenus. However, this great amount of functions comes with a price of a decreased usability, as it is hard for the user to keep an overview on all of the different possibilities and also to memorize how to access a desired function.\n\nA very obvious design goal tradeoff is between functionality and rapid development. This means, that having a better and more sizeable functionality slows down development speed. This is plausible, as , for example, adding a new collaborative-coding feature to eclipse not only requires the time to implement and test the new feature itself, but also requires additional time to test existing functions of the system, as more complexity can always cause problems through interdependency.\n\nThe design goals efficiency and portability are competing with each other, as well. This can be seen in the case of the JVM, for example. The Java virtual machine allows the same Java code to run on different operating systems, which means java has great portability. However, this advantage brings lower time efficiency at runtime, as the JVM itself also has to be run by the machine and it means an additional layer (and therefore additional complexity) between hardware level and java programming language level.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292734,
      "meta": {},
      "text": "1.\nGründliches Testen von Software nimmt meist viel Zeit in Anspruch und verursacht daher auch einiges an Kosten. Somit steht die Fehleranfälligkeit von Programmen in Verhältnis mit, wie gut getestet und weiters wieviel Geld dafür ausgegeben wird. Beispielsweise wurde in einem Projekt von mir nur die grundlegenden Funktionalität des Programmes getestet, nicht aber das GUI und deren Schnittstelle zu den unterliegenden Funktionen, da dort eher auf Test verzichtet werden kann. um Zeit und Geld zu sparen.\n2.\nDas Dokumentieren von Programmfunktionen und Usecases macht die Wartbarkeit des Programms einfacher, stellt aber auch einen nicht unerheblichen Zeit- und Geldaufwand dar. Bsp. um Code im Umfang von ca. 10h Arbeit zu Kommentieren und zu Dokumentieren bedarf es an ca. 30min Arbeit. Allerdings fällt die Einarbeitung in Neue Projekte somit wesentlich leichter. Langfristig ist eine gute Dokumentation also sehr zu empfehlen.\n3.\nDie Runtime Efficency steht auch of im Konflikt mit der Lesbarkeit und somit der Wartung von Programmen, da schneller code zur Optimierung oft unleserlicher wird. Beispielsweise wird leserlicher Code in möglichst kleine Funktionen unterteilt um den Programmfluss sprechbarer zu gestalten. Jedoch benötigen Funktionsaufrufe in Zeitkritischen Algorithmen oft nicht unwesentlich länger als ohne.",
      "score": 75,
      "language": "GERMAN"
    },
    {
      "id": 1430000,
      "meta": {},
      "text": "i will start with the \"Rapid development vs. functionality\" topic and i'll take  video Games for example,  many of Game Companies develop their Games at short term to release it as soon as possible, but the Games maybe will have bugs because they didn't enough test period, at the other hand there  are many companies postponing their game if the game is not working with minimal bugs in it.\n\"Functionality vs. usability\" for example phones, many of them have a lot of functions but we do use just small amount of the function.\n\"Cost vs. reusability\" for example u-Bahn thicket, one way ticket is cheap but you can use it just once, otherwise buying a monthly ticket that is more expensive, but you can use it at any time during the month.\n\n ",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1658604,
      "meta": {},
      "text": "1) Functionality vs Usability:\nCompanies can forget about usability when trying to implement new functionalities. For example, the latest iOS version 15.5 offers a lot of new functionalities, for example notifications summary, but it also has to introduce a tutorial to the users, since without a tutorial it is not easy for the users to know these new functionalities\n\n2) Efficiency vs Portability:\nThe increased speed by adhering to one design goal may end up reducing the ability to reuse the program again. For example, using assembly code can speed up the run time of a program but assembly code is specific to each processor type, so it is not portable.\n\n3) Cost vs Robustness:\nThe costs cut in software engineering may lead to serious security issues in the end product program. For example, Boeing engineering managers allegedly try to cut costs by imposing arbitrary deadlines or outsourcing the development to cheaper contractors, and the result is the flight stabilizing program developed, the Maneuvering Characteristics Augmentation System (MCAS), believed to be the reason behind two 737 airplanes crashes.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292157,
      "meta": {},
      "text": "We have to continuously perform tradeoffs throughout software development, and the type of tradeoff that has to be considered changes depending on roles and the progress of the project through its lifecycle. \nTypical examples may be:\n\n1)Functionality vs. Cost and Maintainability\nWhen developing some systems at the early stage, developers tend to focus a lot on functionality and trying to cover all existing and potential user needs into the system design. The idea behind us maybe to cater to user experience. However, the complexity and huge loading often come along with high costs in the maintenance of the system. Therefore, when you are just starting with the kernel of an idea, it's better to keep the design simple and usable first and to improve it step by step later on.\n\n2)Functionality vs. Rapid Development\nThe Rapid Development approach in software development generally means putting lesser emphasis on planning tasks and more emphasis on development and coming up with a prototype. Prototypes are often used instead of design specifications,  functionality design goal are the tradeoff for the project's rapid development.\n\n3)Time vs. Scalability\nFor example, you are engineering server scalability to handle customer visits(early stage). In normal cases, there are only 2000 users on a server, and in very rare cases, 15,000 users are on the server. Eventually, you would engineer it for 10,000(random number) as it requires much more time to build it on a larger scale, you would simply build a minimum viable product(MVP) first.\n\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344526,
      "meta": {},
      "text": "1. C/C++ vs. Python:\nSince Python's interpreter is a C++ application, literally every project to be written in Python can be developed in C++ instead. This would likely improve the system's performance substantially. On the other hand the time and cost invested into the development process increases by a lot. Additionaly python code tends to be much simpler and thus easier to maintain in the future.\n\n2. Unity vs. Unreal Engine\nBoth Unity and Unreal Engine offer an enormous toolset for game developers. They support countless modern features and partially come with an endless choice of assets to include in a game. However both come with specific costs or fees. If your company earns more than 100k per year you need a payed plan to use Unity according to their TOS. These plans quickly exceed several thousand USD per developer a year. Unreal Engine on the other hand in totally free until your game makes more than 1 million USD. If that line is reached UE takes a 5% fee of your earnings. If your game is expected to make hundreds of millions you might not want to pay the several million fee to UE but opt with the many - but still less - thousands for Unity instead. For obvious reasons UE might still be a better choice though, if your game is not expected to reach the 1 million USD mark.\n\n3. Library vs. DIY\nMost libraries come with lots of features of which you don't need most. Writing a lightweight replacement fitting your needs might consume extra time but will likely be the better performing and less ressource hungry option.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1350445,
      "meta": {},
      "text": "Ein großer Konflikt von verschiedenen design-goals ist zum Beispiel der zwischen Funktionalität (\"functionality\") und Benutzbarkeit (\"usability\"). Hierbei ist das Problem, beide möglichst gut zu implementieren, sodass keines zu kurz kommt. Will man möglichst viele Funktionen zum Beispiel auf seiner Website implementieren, sodass diese möglichst viele Anwendungszwecke erfüllt, besteht meist das Problem, dass diese Funktionen zu \"verschachtelt\" ineinander sind und der Nutzer sie somit sehr lange suchen muss, bis er die gewünschte Funktionalität verwenden kann. Das macht die Website für den Nutzer schlechter benutzbar und dieser entscheidet sich schlussendlich möglicherweise sogar dazu, die Anwendungen von anderen Anbietern zu verwenden.\n\nEin weiteres Problem ist der Konflikt zwischen Effizienz (\"efficiency\") und Portabilität (\"portability\"). Die beste Effizienz kann man theoretisch auf der niedrigsten Programmierebene erreichen (nötiges Wissen und Erfahrung vorausgesetzt). Je tiefer man allerdings bei der Programmierebene geht, desto systemspezifischer wird die Programmiersprache, wodurch die Portabilität immer schlechter wird. Ein Beispiel hierfür ist beispielsweise x86_64 assembly, womit man sehr schnelle und effiziente Programme schreiben kann, allerdings können diese beispielsweise auf ARM-CPUs nicht ausgeführt werden. Programmiert man allerdings in Java, so ist es nahezu auf jedem Betriebssystem ausführbar, läuft allerdings dadurch deutlich langsamer und ineffizienter als in Assembly.\n\nEin drittes Problem ist das Ziel der Abwärtskompatibilität (\"backward compatibility\") im Konflikt zur Lesbarkeit (\"readability\") des Codes. Abwärtskompatibilität kommt oft mit vielen Abfragen, in welcher Version man sich gerade befindet, was den Code deutlich unübersichtlicher und schlechter lesbar macht. Ein Beispiel hierfür ist die Abfrage, in welcher Windows Version man sich beispielsweise befindet, da man als Entwickler hier verschiedene Funktionen nutzen kann bzw. nicht zur Verfügbarkeit stehen.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1353791,
      "meta": {},
      "text": "1.Functionality vs. usability:\nChrome really did a nice job here.We all know that chrome is one of the most complex software in the world.No one could ever learns all the functions in chrome!But for all,includes those who has no idea about computer technology,it is also easy to use.Against that ,QQ, a chat tool in chat is a bad example.At first,chatting is the only function in qq.But generation after generation,now qq can be used to lecturing, to gaming...But when you want to find the function you really want to use,I have to search on goolgle even!\n\n2.Efficiency vs. portability:\nwhen designing a programm,it is always the case that you try to implemente it and make you programm faster,but then you gonna find that the size of your programm becomes bigger.For instance,via is a small chrome,only 2 MB,but when you search something,you gonna find it slower than chrome.\n\n3.Backward compatibility vs. readability\nThere is a word called shit mountain to describe the conflicts between backward compatibility and readability.Like for GTA 5, there are billions of loop just because of this.Also,for the company,if the products like a computer language,when considering backward compatibility,then you have to obey a lot of old rules,which may confuse users.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1404473,
      "meta": {},
      "text": "- Kosten vs Funktionalität:\nFalls die Kosten auf Kundenwunsch niedrig gehalten werden sollen und somit das Budget für Programmierer und Softwarearchitekten knapp ist, kann das die Funktionalität der Software einschränken: Wenn nicht genügend \"Zeit\" (Arbeitszeit in Geld) verfügbar ist, können einige Features eventuell nicht implementiert werden.\n\n- Flexibility vs. Runtime Efficiency\nBei der Wahl der Programmiersprache wird der Trade-off zwischen Flexibilität und Laufzeiteffizienz sichtbar: Schreibt man sein Programm in Java, so ist man plattformunabhängig und kann schnell neue Features implementieren; Dafür ist die Laufzeit nicht so effizient als würde man ebendieses system in Assembly umsetzen. Bei letzterem bliebe aber dann die Flexibilität aus: Weder lassen sich leicht neue Funktionalitäten einbauen, noch das Programm leicht auf neue systeme migrieren.\n\n- Rapid development vs. Minimum # of errors\nWenn die Entwicklung unter Zeitdruck passiert und schnelle Implementierung von vielen Funktionalitäten gefordert ist, bleibt womöglich Zeit für ordentliches Testen aus. Dadurch bleiben mögliche Fehler eventuell unerkannt und beeinflussen sich sogar gegenseitig, sodass viele Funktionen des Systems gestört sind.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1550551,
      "meta": {},
      "text": "A typical design goal trade-off would be functionality vs. usability. If a clothing brand for example displays all their products on the first page of their website, it is functional because all of the information is in one place but it can overwhelm the user getting the information all at once. \n\nAnother design goal trade-off is cost vs. robustness. For buying a cheap product the user is probably aware that this product would lack robustness. A cheap laptop for example doesn´t have the same performance as an more expensive one. It would get strained a lot faster and easier by a task like opening a lot of tabs on a browser.\n\nThis design goal trade-off is efficiency vs. portability where the user has to choose whether the efficiency of a product is more important or the portability. For example a tablet doesn´t show the same performance as a computer but it’s easier to carry. Therefore the user can decide which aspect is more important for him und choose accordingly.\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1639565,
      "meta": {},
      "text": "1) functionality vs usability\nFunctionality can come in conflict with usability. The usability of a system can be limited by to many functions. If there is  only one system for a whole manufacturing company which is for example necassary, for HR, accounting, material ordering, warehousing, production, etc. the system will not be very user friendly. The user won't be able to find the right function withing 10 seconds for instance.\n\n2) cost vs robustness\nCost can come in confict with robustness. If the costs for the developement and testing are limited to a small amount it will be impossible to have a very robust system in the end. For example will there be problems (system crash e.g.) if users enter wrong inputs. This will happen, because the time for development was cut down to a minimum and not all scenarios could be tested before.\n\n3) usability vs security\nUsability can come in conflict with security. The usability can easily be limited by the (very necessary) measures of security. For example, if an order is to be completed in 3 clicks, a necessary 2 factor authentication can make this goal impossible.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290771,
      "meta": {},
      "text": "1)The meaning of Cost vs. robustness is pretty clear. The less money one use on a software design, the less complete the software will be. Robustness means the ability which can prevent software system failures caused by imperfection in concept, design and structure. For example lots of the VPN app in China are easy to crash while using because of its low cost. \n2)Functionality vs. usability means that when people are designing a software of course they want the project to be omnipotence if they can. But conversely the usability of a software with too much function will also recede. For example, the app Lieferando as one of the most popular app has only one function which is food ordering. Although it has only one function but it dose not affect user's experience. Because it provide the user what they need. There's no need for it to create more function.\n3)Cost vs. reusability. Reusability means the ability which can define a related module that are relatively functionally independent as a part. It can be assembled anywhere in the system in order to reduce the workload. For example there is a COVID-19 tracing app in China. Just like every other COVID-19 tracing app the user can show their COVID pass, besides users can also check the temperature of the day in this app. Check temperature as a functionally independent function are easy to assembled in this app.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291397,
      "meta": {},
      "text": "Rapid development vs functionality: \nWhen a system is rapidly developed, it is very likely some functionality will either be poorly developed or not implemented at all since there is limited time. For example, if the Bumpers game due date was extended for a week, students would have had more time to come up with new functionalities (high score boards, multiple levels, new collision types etc. ) since they had more time to work on the Bumpers game.\n\nBackward compatibility vs readability:\nA system that needs to keep up with legacy code to provide backward compatibility will have its readability reduced. This can be due to a number of problems. One example is that the system used to have a different structure (e.g. all the code being in one independent module when the code base was small ) and now has a different structure (e.g. developers have introduced new modules and features since the system grew). The difference in structure can become complicated to work with and thus resulting in ugly code that has low readability.\n\nCost vs Robustness:\nIf the client is willing to spend more money to hire developers who are more experienced, the resulting application will likely be more robust since more experienced developers are able identify bugs better through writing tests with more coverage or just general software development experience. Example: an eCommerce application written by students hired at a low cost will likely be less robust than an eCommerce application written by experienced developers who already know how to structure and design the application, as well as being more efficient at fixing bugs. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292438,
      "meta": {},
      "text": "Functionality vs. usability\n If you design e.g. a software for video editing, you could theoretically implement endless functions that help customers to edit their video. The problem is that human beings are overwhelmed with too much information and only have limited capacity to learn and remember new functions. Especially beginners prefer products that are intuitive to use which are typically products that won't overload the user with possibilities but show them the most important ones.\n\nCost vs. robustness\n A software can be developed and it can never be protected from failing due to all external influences. So in the beginning the trade-off is already relevant when the client and the dev team agree on the situations and the external influences under which the software has to continue working normally. This is a question of budget because the more money the client spends on robustness, the safer is the software and the higher the costs. \n\n•Efficiency vs. portability\nThis trade-off occurs e.g. in the mobile app development. Sometimes applications run more efficiently if you specialize on a certain system e.g. Apple. Maybe even within the apple product universe, you could specialize only on I Phones newer than I Phone X because they have strong enough hardware to run a potential complex functions to a degree that is satisfying for the end user. As a developer you have to weigh the importance of these features against the importance of the inclusion of customers with other systems. If every customer should have the same user experience it may be necassary to cancel some functions. \n\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1298564,
      "meta": {},
      "text": "Three design goal trade-offs could be:\n\nFUNCTIONALITY VS USABILITY: This is the case where one developer can either present a product that is large and complex in order to cover all possible scenarios (risking making it hard to understand and use) or present a product that is more intuitive and straigh-foward (risking over-simplification and limitng its range of use for alternative scenarios).\n\nRAPID DEVELOPMENT VS FUNCTIONALITY: In the fast paced technlogy scene it is important to keep up with trends and competition which may lead releasing a product in a reduce time frame (risking the product being underdeveloped and/or not working properly, hence, limitng it use). On the other hand, one can release a high quality product that is robust and covers all needs taking the time necessary to cover needs that may arise (however this risks the developers losing on the trend as their other competitors may take over the demand through a simpler/fast-release product, hence setting the standard)\n\nCOST VS ROBUSTNESS: This is the case when a developer decides between releasing a more cost-efficient product which may require less capital/time investment, allowing the distribution of resources into other areas (releasing a simpler product who's system might not be able to mantain all needed functions); or making a product that is able to mantain all needed functions (and more) which due to its complexity required heavy capital investment in its development, making it more costly for the developer. ",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1301090,
      "meta": {},
      "text": "Design goal trade-offs sometimes incur in software engineering and already established design goals can lead to an impass: a situation will arise where one design goal must be sacrificed in order to achieve another. When problems of this nature present themselves, the system's (or subsystem's) development team must make a trade-off, and decide which goal is more important.\n1) An example for such a trade off is, an online banking software, where customers can send or receive large amounts of money. For safety reasons, the customer needs to verify him/herself various times, sometimes undergoing lengthy procedures. In this instance the customers comfortability of quickly sending money is restricted, but there will very few, to no successful fraud attempts (efficiency vs. portability).\n2) Another example is rapid development vs. functionality: A software project which has a defined delivery date, requiring that all functionality be completed by that date. However, not all the required functionalities can be completed by the specified delivery date. Now to team has to decide, wheather the system is on-time but incomplete or complete but late.\n3) Another typical example is cost vs. robustness: A team builds a website, which synchronizes calenders of different platforms. The customer has to decide, if he wants the website to be able to handle many different users at the same time(~10.000 users). If he decides he wants that, it's going to cost a lot of money, as many new features have to be added by the team. Or he can save that money and have the website only be able to handle ~1000 users at the same time.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1321617,
      "meta": {},
      "text": "Design Trade-off 1\nRobustness vs Cost: Um zu garantieren das unsere Applikation robust ist: keine Bugs, Glitches hat . Muss unsere Applikation getestet werden. Dies ist jedoch Zeit aufwendig und Kostet auch viel. Wir müssen uns also mit Edge Cases zufrieden geben um Kosten zu reduzieren.\n\n\nDesign Trade-off 2\nRapid development vs. functionality\nWir haben einen Zeitplan einzuhalten in dem wir unsere Applikation fertig sein soll. Jedoch haben wir mehrere Funktionalitäten die wir gerne implementieren würden aber nicht können aufgrund des vorgegeben Zeitplans.\n\nDesign Trade-off 3\nFunctionality vs. usability\nEvery game wants to add new functionalities to make it fresh and entertaining. Introducing pvp or other popular mechancis on top of the existing mechanics. The user needs to memorize/learn more things in order to play the game which conflicts with Learnability.",
      "score": 50,
      "language": "GERMAN"
    },
    {
      "id": 1332512,
      "meta": {},
      "text": "Functionality vs. Usability:\nCompromising functionality for usability's sake or vice versa is a common situation when trying to deliver a usable interface on the one hand but a wide array of features and possibilities to work with on the other. An example of this would be the following: a photo editing program should have many features to edit photos and professional users should be able to do whatever they intend to. It should however be able to use every tool without the obligation of knowing keyboard shortcuts or having to click through settings an excessive amount of times.\n\nbackward compatibility vs. reusability, adaptability\nIf a system has to be backward compatible this might limit the reusability or adaptability since every aspect of the project is designed in context of the desired backward compatibility but a different system which wants to reuse parts of the initial system might not need or might not be able to handle the backward compatibility. Let's say that a software project has to be compatible to a certain type of existing software of the ordering party. If the developers want to reuse parts of this software project under different circumstances they have to adapt the system since the different project might not need the backward compatibility. \n\nLow cost vs. rapid development\nthis is an obvious one. If a software project should be developed rapidly the developing party has to concentrate resources onto this project. They will only do that if the reward (i.e. the payment they receive) for shifting their focus toward this project is high enough. A software company would for example not use their resources predominantly on a project with poor compensation.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344288,
      "meta": {},
      "text": "One typical trade-off is functionality vs usability if you have an application that functions as a dictionary it might be highly functional if you just show every entry there is but dont connect them, but it would be far easier to use if you had a search-function, and if the individual articles were linking to other articles discussing similar topics.\nAnother trade-off would be cost vs robustness, while it may be very cost efficient to get the cheapest servers/the cheapest hardware or simply the less energy consuming software it may not be very robust, it might stop working if it has to work with too many users at the same time, the software might not be good in catching exceptions, leading to crashes or it might have easily exploited loop-holes.\nAnother typical trade-off would be rapid-development vs functionality. While a fast development is certainly very appreciated it should come at the cost of the applications functionality, for what use is a very fast developed System, that isnt working as intended or very limited in its usabiliy, but you also shouldn't develope longer then neccessariy because it might be enough to focus on the important aspects of the System",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1344376,
      "meta": {},
      "text": "1. Functionality vs. usability\nPrograms with more functionality tend to be much harder to operate by the end user, who has not developed the program themselves. An example would be the programs used for industry robots and machines like the software for a CNC milling machine or programs for editing video or audio. They offer a very large amount of possible functions, but usually have a very steep learning curve, which makes using them difficult for beginners. The developer can try to make a program more usable, but usually functionality suffers from this.\n\n2. Cost vs. reusability\nDesigning a reusable program takes more time, because everything needs to be programmed at a much more abstract level. Since developers' time increasing also means cost increasing for a company, this modularisation of different parts of the program can, while probably being more profitable in the long run, cost more money in the short term. When making an application that utilizes a database for example, it is easier and less expensive to make this database only work for the one application, but it is also possible to modularize it, so it works with others services aswell.\n\n3. Efficiency vs. portability\nA video game for example, just cannot work as performant on a mobile device, like a phone, as on a computer. Developers have to weigh the benefit of the portability of the phone against the performance and efficiency of it. A game like GTA V cannot run on a phone (at the time).",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1372663,
      "meta": {},
      "text": "Wenn man an einer Software arbeitet, sind Trade-offs unumgänglich. Es ist wichtig, die Prioritäten richtig zu setzen, um eine gute Balance zwischen den Bedürfnissen des Kunden, der Nutzer und der verwendeten Tools zu finden. Für jedes Projekt ist diese Balance eine andere, weshalb es zu den wichtigsten Fähigkeiten eines Software-Ingenieurs gehört, diese zu bestimmen. Drei Beispiele solcher Trade-offs sind:\n\n•\tSicherheit vs. Kosten: Man kann nicht alles daransetzen, das System so sicher wie möglich zu machen. Sicherheit muss immer im richtigen Verhältnis zu den anderen Anforderungen stehen. Hohe Sicherheit erhöht beispielsweise die Kosten der Entwicklung und der Aufrechterhaltung der Dienste. Deshalb sollte man sich z.B. überlegen, wie sensibel die Daten sind, die man verarbeitet und das System dementsprechend sicher genug für diese Anwendungen machen. Ein Passwort-Manager sollte mehr Ressourcen in Form von Geld und Rechenleistung für Sicherheit aufbringen als ein Taschenrechner.\n\n•\tNutzbarkeit vs. Sicherheit: Die Nutzbarkeit ist sehr wichtig. Doch auch sie muss entsprechend der Anwendung gegebenenfalls zugunsten der Sicherheit eingeschränkt werden. Im Falle einer Online-Banking Anwendung muss man die Nutzbarkeit durch z.B. Zweifaktor-Authentifizierung und mehrfache Bestätigung einschränken, um eine entsprechende Sicherheit zu gewährleisten.\n\n•\t Effizienz vs. Langlebigkeit: Effizienz erfordert das Anpassen eines Systems an die Hardware. In der Regel möchte man aber, dass die Anwendung auch in vielen Jahren noch nutzbar ist und nicht obsolet wird, selbst wenn es große Veränderungen im Bereich Hardware gegeben hat. Hier muss man also die richtige Balance zwischen Optimierung und Universalität finden.\n",
      "score": 91.7,
      "language": "GERMAN"
    },
    {
      "id": 1652709,
      "meta": {},
      "text": "1. Development time vs. good Documentation.\n\tWhen the release of software is rushed one of the first things to fall short in development is the documentation, since it doesn't affect the functionality of the software itself. However it will be more difficult to handle the software in the future.\n\tFor example: If a company need a one-time-use software (maybe its just a small project) it might be a good idea to cut documentation times, if you don't plan on maintaining the software long-term.\n\n2. Backward compatibility vs. readability\n\tHighly backwards compatible programs tend to have a lot of artifact code handling older versions of requirements. That makes the project \"messy\" and in general, the code less readable.\n\tFor example: Windows is highly backwards compatible, however a usual Windows installation comes in at around (min.) 16-20 GB. Since I don't know the source code for windows, I can't really comment on that, but I would bet that there are some quite confusing passages to be found in it.\n\t\n3. Cost vs. Robustness\n\tMaking a robust program can get very costly because it requires a lot of testing which is usually very time consuming. That means it is expensive since development time = $.\n\tFor example: We all know these cheaply made mobile games which only purpose it is to get you to spend money on in-game stuff. If you ever played one of these you will know they tend to crash a lot, because there were no resources committed to making the app more robust.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291301,
      "meta": {},
      "text": "1. Maintailability vs Speed\nThe better an application is structured and planned the easier it is to maintain: f.e. to add new features and debug. But this comes at the cost of speed since planning and structuring is work intensive.\nF.e.: The manager of a startup made to many promises to the stakeholders. To account for that, the team chooses speed over maintalability.\n\n2. Scalability vs Functionality\nDo we want to implement our project knowing that we are going to upscale it? Or do we want to first provide functionality?\nF.e.: Knowing that a function type is going to be used more often, do we choose to first make a template (-> scalability) that we can easily adjust later, or do we choose to implement it directly? \n\n3.  Portability vs Robustness\nDo we want every OS to be able to run the application or do we want the application to run very smoothly on one certain OS?\nF.e.: A program used in aviation has to be developed. Because of the consequences of failure, we choose robustness over scalability.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1312006,
      "meta": {},
      "text": "When working on a software engineering project, there might be a number of goals, some of them contradicting each other. Some typical design goal trade-offs are:\nFunctionality vs. usability: A perfect example for this would be Vim in my opinion. While Vim is very powerful and one can achieve a lot of things very quickly with it it can also be extremly frustrating to use at times. It is hard to use and very complex. Furthermore, it does not possess a GUI which further brings down usability.\nEfficiency vs. portability: My example for this one would be iOS vs Android. I would argue that in general iOS is faster and more efficient than Android, mainly because iOS is developed for one platform only and Android hast to run on a multitude of different devices. This allows iOS to be more optimized towards one kind of device and as a result be more efficient while Android needs to stay more general in order to run on all devices.\nBackward compatibility vs. readability: Writing code which is backward compatible can get messy really quick, as you have to support old features/hardware/standards. This makes the code harder to read and maintain. A good example for this would be Perl which can also understand Awk, its predecessor. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1330396,
      "meta": {},
      "text": "3 typical design goal trade-offs:\n\n1. functionality vs. user-friendliness\nFunctionality always means there are multiple functions which can fulfil the user's expectations by using the product. There are also many professional users. For those users, They always have a demand of professional functions, which are normally not so friendly to the beginner. So is is hard to make the product also user-friendly in this situation.\n\n2. cost vs. robustness\nTo make the product robust, the developer and the personal of testing must be very professional and experienced, which costs much.\n\n3. cost vs. reusability\nIt is always important to create a product with a limited budget because the clients always want a low price. \nIt is really difficult to make the product in a low price and also reusable. Products with reusability always are normally made by some good materials which are normally expensive.\n\n\n\n\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1344324,
      "meta": {},
      "text": "Functionality vs usability:\nOften times massively increasing the number of functions a piece of software has can make it a lot tougher to use because of the amount of options present and how complicated they get-navigating it to get what you want can be hard.  A good example to illustrate this point is a system like Mathlabs-because of the amount of things you can do it can get difficult to figure out exactly what set of instructions you need to follow to achieve your desired result.\n\nCost vs robustness:\nJust like in normal architecture, where you could choose to use more costly materials such as steel to build something that can withstand a maximum amount of stress, or choose to use something cheaper like wood, which is more vulnerable to natural forces but also cheaper, in software engineering, the time, effort and resources required to make a system robust also  result in an increased cost.\n\nRapid development vs functionality:\nIf one wants to develop a piece of software extremely quickly, the best way to do that is to keep the functionality to a minimum and quickly construct the surrounding front-end. The less functionality has to be implemented, the quicker you can have a finished system. An easy example would be a calculator-if you simply implement basic mathematical functions such as addition, subtraction and multiplication, it will obviously be done much quicker than if you choose to include things like integrals, logarithms etc.\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344331,
      "meta": {},
      "text": "Aesthetic vs. Usability\nMost of the time the rule that is followed is to make a product beautiful. Sometimes that can mask some usability issues.\nThere was one study of NNG (Nielsen Norman Group) where a user had many minor annoyances when interacting with the product but managed to finish the task. However, in the end, talking about the experience, person rated the site “very highly in ease of use” because of aesthetic appeal (photos, colors).\n\nSecurity vs. Ease of use\nHere everything depends on the situation. For big companies, for example, banks etc. security is is more important than ease of use. That means, they use multiple identifications when logging in and so on. \nHowever, smaller companies who are building products for the public, might want to prioritize ease of use first. First, they get people to like and use their product, then thinks about security.\n\nMinimize cognitive load vs. Minimize motor load\nHumans have 3 types of loads (according to \"100 Things Every Designer Needs to Know about People\" by Susan M. Weinschenk):\n- Cognitive load. For example, when you need to do the mental calculation, remember passwords, etc.\n- Visual load. Everything you look at on a screen.\n- Motor load. Such as moving the mouse, pressing buttons, etc.\nAnd we can conclude that always just reducing the number of clicks is nor a golden rule, especially if it causes a big amount of information on one page.\nInformation overload causes more thinking. And the cognitive load is more painful than motor load, i.e. a few more clicks.\nWhen the information is easy to get and follow, you will not remember how many times you clicked.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1450099,
      "meta": {},
      "text": "1) Cost vs Reusability: a good software-system has to developed on a proper \"basement\". This means, that you can moderate your system, build and re-build using that basement, preserving the project structure and applying less efforts than you could if you built it from the very beginning. Of course it takes more time to create such a basement and therefore costs more money. At the same time you can create a simplier model which won't be use to reuse in the future, but save some money. Example: object model in Java. You can create more abstract class-model with general functions, on which you will create all other functionality. The concrete functions can be changed, but the new would still be built on the general ones. At the same time you can implement all the functionality directly, it will work, you will save time and money, but if you want to moderate it, you would have to rebuilt the whole system.\n\n2) Cost vs Robustness: the more money is being invested in the project, the more chance it is to anticipate the probable violations while using the software. With more money you can just simply cover more cases, when possible mistakes/exceptions/safety violations appear. For example: while developing a website you can buy an https-protocol. That costs money and therefore makes the project more expensive, but at the same time it makes the data transfer between server and client safer and less likely to be read by scamers. \n\n3) Rapid development vs functionality: in case of short time give for a development, a client has to decide, which functional requirements are more important and which are less. To finish the development on time, we have to implement the most important ones. Therefore we sacrifice some functional requirements. Example: we create a graphic editor, that has to draw lines and edit those according to mouse movement. Functional reqs: draw a line by clicking, edit line by clicking on some point of it, fill the shape with color. Our main goal is to make the editor work as soon as possible, we don't have time for everything. So we just implement  lines and editing, sacrificing the color filling. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1459931,
      "meta": {},
      "text": "Three of the typical design goal trade-offs are as follows:\n1. Cost vs. reusability \nWhen a system only being input with limited money, a lot of situations will not be considered and the portability and security of the system will often be a problem. Thus after the current assignment being solved, the system may never be used again. It will be an one-time usage since there are better choices. For example many onboard systems for new energy vehicles are just one-time and are not able to use on new models or after updated.\n\n2.Backward compatibility vs. readability\nThe closer it relates to hardware, the harder it is for developers or users to understand. For example software written in assembly is way more difficult to read than that in java.\n\n3.Time vs. space \nIt’s often faster to use pre-computed values, but it takes a lot of space. You can use less space by doing things on the fly, but that generally takes more time.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1633512,
      "meta": {},
      "text": "Low cost vs. Minimum # of errors: Then the customer wishes to have a system which makes only a small amount of mistakes they should understand, it requires more development and  testing time, that necessarily leads to increased project’s costs.\nRapid development vs. Maintainability: Since Rapid development works better in the small teams it can lead in the end to bad maintainability, because the other developers could not have the whole documentation if the team that worked on the project before decided to skip it.\nRuntime efficiency vs. Robustness: The robustness of the system can make the system  more complex and it will increase the runtime efficiency. \n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291995,
      "meta": {},
      "text": "1. Functionality vs. usability: Functionality describes a function of a product or service that can fullfill an instruction through an interface. However, usability means the level to which if the product or service is usable or suitable. Sometimes a system could be very functional, but not usable and looks very clumsy. \ne.g. is a reseveration system with 200 functions usable? \n\n2. Cost vs. reusability: this design goal trade-off shows the relationship between two classes with one-to-one or many-to-many multiplicity. And changing from one to many will result in different costs and coding difficulties. \n\ne.g. A website can consider being compatible with very old browsers such as Internet Explorer, or a desktop app, or consider being compatible with very old operating systems, such as windows 7, but this will result in high expenses, and it is very expensive. It may not be possible to recover the cost, because Windows 7 is a system that few people are using now. \n\n3. Rapid development vs. functionality: this trade-off describes the development measure adopted in projects with short schedules, it also means to develop quickly, however, might only with few functionalities due to the tight timeline. \n\ne.g. the software may have a scheduled delivery date. But some functionalities might be difficult to finish the implementation before the scheduled date. So there is a trade off between as many as functionalities developed versus the rapid development ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1296836,
      "meta": {},
      "text": "A typical problem is the trade-off between cost and robustness. For example, the budget for a an app is very low. Thus the team of developers is very small which leads in most cases to more misstakes in the code and let the system be more error prone.\n\nAnother issue is the trade-off between rapid development and functionality. If the final date of submission is picked to early this can lead to a lack of time. Due to this problem some planed functionality musst be strike out of the orginal plan. For instance, functionalities to change to dark mode.\n\nThe third trade-off is backward compatibility vs. readability. For instance, if the an application should run on older software systems or older hardware this can lead to problems in readability. The code gets more complicated if it has a strong backward compatibility since there is often old sytax involved. ",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1297465,
      "meta": {},
      "text": "1. Firstly, a typical trade-off is cost versus robustness. For example when designing a system it is very costly to use many servers as a backup to be robust against any viruses or bugs. Therefore if you want to reduce cost, there will be a reduction in robustness to some extend. \n\n2. Another trade-off in the context of software engineering is efficiency versus the portability. For example apps that are solely developed for iOS devices will work very efficient with that hardware, screens and user interfaces provided by the system. But these apps are only compatible with devices from the Apple ecosystem. Therefore you limit yourself on portability.\n\n3. Lastly, rapid development versus functionality is also a trade-off, which is often seen in the field of software engineering. The efforts of a long and detailed development of a software result in a very functional and thought out application. But if there is a lack of time, some functionalities like APIs or IoT functions will not be able to get implemented. ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1311243,
      "meta": {},
      "text": "From my own experience, the non-functional requirement that in case of a server brake-down, all data must be preserved (robustness) is a trade-off regarding costs. Whilst developing a new Cost Controlling software at BMW, this was a key requirement. Cost data must not be lost in any case, even if a server breaks down. Therefore, backup servers had to be implemented. This heavily influenced the project costs and therefore led to trade-offs.  \n\nMoreover, the project followed the goal to make code reusable through good documentation, standards and conventions in order to re-use parts of the code for similar Controlling software in other departments (e.g. IT Controlling, etc.). However, due to time constraints, this was often not possible, since documentation takes time and standards must be communicated and followed by each and every developer. A trade-off between code re-usability and time has been visible. \n\nLastly, the most challenging trade-off of the Cost Controlling software at BMW has been which functionalities to include such that the software remains understandable and usable by Business Users. For example, \nfilter options should be available but only to a reasonable extent in order to obtain usability. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1318443,
      "meta": {},
      "text": "1) One trade-off is between cost and robustness. Whenever you want your code or system to be more robust, you have to test it for all edge and special cases. But testing takes time and time costs money. An example: If you want to implement a new feature for your eShop you have to test it before the go-live. To test the basic functionality the developper needs 3 days time, to test the special cases 2 days on top. One day of a developper costs around 1.300 EUR. Now the business has to decide between costs and robustness of their new feature.\n\n2) The second trade-off is between rapid developments and functionality. If the design goal is to develop the system very fast, the developpers have less time to think about the functionality requirements of the system and the best way of implementing them. One example in business is the implementation of a new feature because of new legal regulations. The regulations come to effect to a special point in time and until then you have to be ready. If this point comes very fast the functionality may suffer, but the main goal is reached, that is to have the new legal regulations implemented.\n\n3) The third trade-off is between efficiency and portability. High portability implies to have a system that is easy to use on different operating systems and has well-designed interfaces to other systems. But the more interfaces you implement, the less efficient the system works because the more data has to be updated every time a request is started.  For example the implementation of a closed layered system gives you high portability but low efficiency because all of the data is transferred throughout the sytem every time you start it.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1349828,
      "meta": {},
      "text": "1. Cost vs. robustness, e.g. in order to overcome sudden power failure, the databank of the university must backup every minute to ensure that no data would get lost. It increases not only the system robustness but also operating costs. Since backups need more space to store, and temperary logs should be deleted after one minute.\n2. Efficiency vs. portability, e.g. a program specific for format conversion(i.e. xx.jpg -> xx.pdf). The user could easily click the buttons on the website without installing the programm. But the transfer speed would be slowly due to the Internet or some other issues. If the user want to speed up, for example he needs to transfer 1TB xx.rvmb to xx.mp4 to play these videos on his iPad, he must download the pragram and install it on his computer. Otherwise it may take a whole day to finish.\n3. Functionality vs. usability, e.g. SAP system. SAP system is perfectly designed with hundreds, thousands of functionalities to make it much easier for the staff to manage the supply chain. But it's too complicated for a new hand to use without any specific training.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1435044,
      "meta": {},
      "text": "1. One typical trade-off is between cost and the robustness of the product. For example one could spend a lot of money funding a huge qa-department which extensively tests the product or don't do any testing at all which saves cost but might reduce stability. This point is especially noticable withing game development.\n\n2. Another trade-off is efficiency vs. portability. On one hand it is possible to write all software in assembly by hand which can be blazing fast but is dependent on the exact processor used just as it is possible to write all applications in a browser environment in javascript which is extremely portable but can not achieve the same performance.\n\n3. Finally one last tradeoff is rapid development vs. functionality. For instance the client may request a lot of features but might not have the capacity to pay for the development of all of them. Then client and developer must decide which features are crucual and how much the client is willing to pay for specific features.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1478981,
      "meta": {},
      "text": "-Costs vs Robustness:  \nWenn ein Programm am ende wenig kosten sollte , kann es häufig dazu kommen dass dieses ohne großen Entwicklungsaufwand entwickelt wurde. Sie kann daher sehr fehlerbehaftet sein und es wird bei Angabe der Anmeldedaten nicht richtig auf Fehleingaben eingegangen. \nAls Beispiel wären da kostenlose Apps wie Ebay oder Amazon, welche Transaktionen durchführen können müssen aber dennoch alle fehlerhaften Eingaben von Daten erkennen und diese behandeln.\n\n-Functionality vs Usability: \nWenn man ein möglichst nutzerfreundliches Programm entwickeln möchte dann wird versucht dass auf dem Bildschirm so wenig Eingabetasten bzw Felder vorliegen und der Nutzer leicht den Überblick behält. allerdings ist es nicht einfach wenn das Programm viele verschiedene Features enthält , da man für jede Funktionalität\neinen entsprechenden button bzw Feld braucht. \nIn Videospielen wie League of Legends ist es üblich dass die Nutzeroberfläche möglichst übersichtlich gestaltet ist , da es sonst den Spielfluss oder im Generellen die Nutzerfreundlichkeit stark beinträchtigen würde. Die verschiedenen Features wie Änderung der Lautstärke oder der Auflösung kann man mittels eines simplen Mausklicks in den Einstellungen nutzen.\n\n-Rapid development vs Cost:\nEine kurze Entwicklungszeit welches aber trotzdem mit einer gewissen Qualität einhergeht, erfordert zwingend gute Programmierer mit hervorragendem know how, diese sind aber meist sehr teuer.\nBeispiel dafür ist das Entwicklerstudio Gamefreak , das wegen Kostenersparnis nur aus wenigen qualifizierten Entwicklern besteht, musste innerhalb eines Jahres das neue Pokemon Legenden Arceus Spiel zu programmieren. \nMan hat versucht Kosten zu sparen und gleichzeitig möglichst rasch das Spiel zu entwickeln, sodass am Ende ein unfertiges Produkt mit schlechter Grafik rauskam.\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1486646,
      "meta": {},
      "text": "Functionality vs usability: The more functionalities a system has, the more difficult it is to utilize it and therewith the usability decreases often. Photoshop is a good example since it can produce almost anything, I prefer other tools for simple foto editing like Canva since Photoshop would take too long to develop sth. It's just too complicated, and the usability isn't good enough to produce quick and easy outcomes.\n\nRapid deployment vs. functionality: This issue also describes the balance of the Minimum Viable Product (MVP) which has the goal to have as much functionality as necessary but to deploy it as soon as possible. One example for this is Whatsapp. Whatsapp continously adds new functionalities and improvements to the App which have not been part of the first version. This was only possible due to rapid deployment to get user feedback.\n\nCosts vs. Reusability: Reusability necessitates extensive preparation and consideration of how items could be reused in the future, and it is frequently more expensive. Plastic or paper coffee cups are one illustration of this compromise. Most people choose plastic cups over reusable cups (like RECUP) for odering coffe because it is cheaper to buy it in plastic cups than in areusable cup. In addition, the reusable cup would have to be stored, washed, and maintained in some way, which would require extra labor.\n\n",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1529174,
      "meta": {},
      "text": "Functionality vs. portability:\nThe more features a system provides, the harder and more time consuming it is to port the system to a different platform while still ensuring that every piece of functionality still works as intended.\nConsider a game engine that runs using DirectX12 on Windows that we now need to port to Vulkan to be able to ship the software to Linux users: the more shaders, lighting effects and complex rendering code we have, the harder it is to get every functionality running on Vulkan which e.g. needs shader code in a different language than DirectX.\nCost vs. usability:\nThe more polished the user experience hat to be, the more it will cost to develop the system because more experienced/expensive developers have to spend more time to carefully evaluate and refine the user facing components of the system. E.g consider a calendar app developed with a very limited budget: the developers might not have the time (or experience) to make calendar events drag&drop-able so you have set the start/end-times of events manually by typing them into a textbox which is a much worse user experience.\nRobustness vs. Rapid Development:\nTo develop a more robust application careful system planning, documentation, verification and testing has to take place before the software is released which takes time away from the developers who could otherwise spend their time coding (implementing new features). E.g in a social media app the videos sometimes don't load properly which could have been avoided by spending more time on testing the VideoPlayer and corresponding backend services instead of implementing a comment functionality under the videos.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1640680,
      "meta": {},
      "text": "1. Functionability vs Usability\nIf there are lots of functions in the service and developers want to show all of these functions with same emphasis, users feel confused. For example, when people use bank application, their biggest interest is how much money they have, when their money was out, or send money to others. The other functions like when they opened the accounts are less important. It is important to consider usability with the priority of functions.\n\n2. Cost vs Robustness\nCost is important in software development. But if developers reduce the numbers of concurrent users to reduce costs, the system would be down when there are more users than usual. For example, when famous singers do the concert, their fans wants to go concert and reservations site would have more traffic than usual. So, it is crucial to consider robustness of system. And developers can reduce cost when they design the system well in advance.\n\n3. Efficiency vs Portability\nThere are Mac OS, Windows, Linux operation systems. If the developers develops the program which runs only in Mac OS. The other users who use only Windows have difficulities to use it. It might be not efficent to developers to consider all of operating systems. So, they have to choose one or uses replacements. For instance, instead of swifts or android programming, they can use Kotlin for mobile app programming.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1655871,
      "meta": {},
      "text": "Efficiency vs. Portability: Often different platforms offer specialized methods to do something very efficiently, but those methods are often very specific to that platform, so it isn't transferable to others. An example would be Nvideas CUDA, which runs generally more efficient than OpenGL, but only on Nvidea Graphics Cards.\n\nCost vs. Robustnes: To take every edge case into account and handle every error that can occur takes time, and time is money, so those two often conflict.\n\nBackward compatability vs readability: High backwards compatability requires a lot of different ways to do the same thing, which makes the code clutterd and often unclear",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1660180,
      "meta": {},
      "text": "1. cost Vs. robustness: basically in every system design goals, weˈll find the client looking for a lowest cost\nwhile the end user is looking for the highest robustness. The latter requires the most money and the lowest cost enables only the lowest robustness. So the best combination between both edges of the requirement would be preferred and worked on. Letˈs take the example of Facebook from 2009, the registration on the website used to require that the user enters their E-mail adresse without sending a verification link in return to assure the security and the true identity of the user, now Facebook has dedicated an extra budget (higher cost) to enable verifying the new subscribers and thus assureing their privacy (higher robustness). \n\n2. cost Vs. reusability : the client looking for a lowest cost while the end user is looking for the reusability.\nreusable systems cost obviously more than the other less reusable systems. For example last year, non-reusable face masks cost around €1, whereas the reusable face masks (that should be saved in a higher temperature than 17°C ) cost +€2,5. \n\n3. functionality vs. usability : the end user aims for the functionality and the usability goals at the same time.\nBut in the long run these two features can cancel each other out. In fact, the user would prefer a less fuctional system as long as it's more usable. For example a pocket calculator with basic addition and multiplication functions is more usable than a developed expensive calculator with over 50 functions because the pocket calculator includes the most used operations and will always be consumed. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291028,
      "meta": {},
      "text": "1. performance versus simplicity:\nwhile the end user wants the system to be performant, it often comes with the cost of being hard to\nunderstand for joining developers or even the same devs but after some time has passed.\nSystem simplicity is also important to developers because of its maintainability and easy extension.\nBut performant systems are often not the obvious approach and thus by definition not easily understandable.\n\n2. performance versus security & safety:\nSecurity requires additional parts in the whole system. Additional data to be stored and proccessed\naswell as additional tasks make the system slower and adds dependencies, which adds more coupling between subsystems which in turn makes concurrency less feasible, less concurrency will likely lead\nto less performance.\n\n3. Reusibility versus Functionality / flexibility:\nif clients or end users want more and specific functionality the chance that the developers get to reuse old subsystems is low. With high and very custom demands of the end user, it becomes easier to\njust create a whole new system which will then be perfectly tailored to the end user. But of course this\nis then suboptimal for reusable systems, especially when speculatively extra time was spent in the past to make a system reusable when in the end it was for nothing.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291817,
      "meta": {},
      "text": "Ein möglicher typischer Trade-off entsteht häufig zwischen Efficiency und Portability. Man kann ein System effizient machen, indem man bestimmte Funktionen so implementiert, dass diese auf einer bestimmten Hardware besonders schnell ausgeführt werden können. Beispielsweise könnte man in ein Programm komplett in Maschinencode speziell an die Architektur einer bestimmte Desktop CPU angepasst schreiben, was dann aber dazu führt, dass dieses Programm nicht auf einem Smartphone mit völlig anderer CPU ausgeführt werden kann. Sorgt man aber dafür, dass ein System auf möglichst vielen Platformen läuft und nicht speziell an eine anpasst, verliert man mögliche Effizienzsteigerungen.\nZwischen Rapid development und Functionality kommt es auch häufig zu Trade-offs. Generell könnte man mit unbeschränkter Zeit so gut wie alle möglichen Funktionen in ein System einbauen. Da in der Realität aber häufig sehr strikte Zeitvorgaben herrschen, in denen ein System fertigzustellen ist, müssen immer wieder Abstriche gemacht werden, um den Zeitplan einhalten zu können oder der Zeitplan verlängert werden, um alle notwendigen Funktionalitäten fertigzustellen, wie man es zum Beispiel oft bei Games hat, wo sich entweder mehrmals der Release Termin verschiebt, oder dem Game beim Release einige versprochen Features fehlen.\nCost vs Robustness ist ei weiterer typischer Punkt bei den Design-Goal-Trade-offs. Will man ein System, das besonders zuverlässig arbeitet, muss man Geld darin investieren jede mögliche Schwachstelle zu erkennen und zu beheben. Mit mehr zu Verfügung stehenden Geld kann man zum Beispiel viele Tester anheuern, mit deren Feedback gefundene Schwachstellen behoben werden können. Hat man dagegen nur wenig Geld zu Verfügung und spart beim Testing, ist es sehr warscheinlich einige EdgeCases übersehen zu haben, die das System dann beispielsweise unter bestimmten Umständen zum Absturz bringen.",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1292048,
      "meta": {},
      "text": "A very common design goal trade-off is functionality vs usability. Accommodating multiple functionalities in an easy to use interface can be challenging be its very nature. Let's consider mobile operating systems as an example. iOS chose to specifically value usability resulting in an intuitive UX Design with a very steep learning curve. While it doesn't give exceptionally many options (e.g. high restriction on how the home screen can be organized), the option that are available are organized in a clear way. Android for example uses a different approach, where a lot of settings can be customized but therefore the settings menu tend to be very overwhelming for new users.\n\nAnother common design goal trade-off is efficiency vs portability. This is because often when software is very efficient it must be optimized for a very specific platform by leveraging its strengths and avoiding slow instructions.\nThis, however, is only possible when the exact target platform is known. If software should be portable and therefore run on several platforms optimization is much more complex to achieve. If we consider Java for example, which runs on almost all platforms, only very little optimization is done since Java Byte Code is interpreted during runtime. Assembly code on the other hand is written for a very specific architecture allowing to take all its strengths and pitfalls into consideration.\n\nAlso functionality is very often opposed to rapid development. The more time you have, the more features you can usually implement. Usually at hackathons there is not enough for features not important for showcasing (e.g. 'forgot password'). This can however be compensated by other factors as well like a bigger team or using pre-written libraries.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1294054,
      "meta": {},
      "text": "Functionality vs. Usability: \nOften functionality is achieved with additional features that can make the interface cluttered and overwhelming. For example, in excel it often seems very overwhelming when right clicking on a cell, or looking at the menu bar because of the many options excel provides you. The learning curve for a beginner like me is steep and for 90% of the tasks you want to do with excel you do don't need most of the features provided, however if these would be cut the application would be much less functional. \n\nCost vs. robustness: \nRobustness of a sever or an app is often achieved through redundancy or quality of code by handling many different exceptions and solving all edge cases. Redundancy can be achieved by implementing many different servers that counteract one another should one server fail, which would however cost a lot. In the case of the quality of code, it takes a lot of time and therefore money to make sure all edge cases and errors are covered and handled intelligently. \n\nRapid development vs. functionality: \nI believe that the concept of an MVP can be used to describe this fairly well. An MVP is a rapidly developed product that does not have a lot of features (functionality) and a great design. The faster you develop the less features you can include. When you want to bring a product to market before your competitors you have to develop rapidly. In beginning stages it is ok that functionality is lacking as long as the main idea is implemented and you iterate over your product to constantly improve functionality. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1296184,
      "meta": {},
      "text": "Functionality vs. User friendliness:\nTypically the more functionality you offer your customers the harder it gets to implement them in a clean design without overwhelming your customer. Also it gets harder to achieve maximum ease of learning. \nLow cost vs. functionality:\nTypically the more functions an application needs the longer it takes to develop them. Therefore the cost are skyrocketing. You try to minimize this trade off by first creating a minimal viable product and then with the money you can get from that to develop it further.\nRapid development vs. minimum # of errors:\nThe faster you want to develop a software, the easier errors sneak themself in. And testing to find out and to get rid of errors takes additional time. Therefore you loose development speed.\n ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1303238,
      "meta": {},
      "text": "1. Rapid Development vs. Functionality\nWhile I'm designing the Bumpers Game, in order to make it creative I come up with many ideas like adding many collision types that have different standards not only according to the right-most rule but also depending on the car type, speed, used years, and even the specific position like in the air or on the ground to evaluate the winner. And to achieve these goals I have to develop a lot more functions to let users choose different car types, decide to drive on the ground or in the air, consider if he wants a new car or an old car, etc. Apparently to realize these functions I have to think about how to implement them and test whether they fulfill my ideas or not which will cause a long time for sure which is against the so-called \"Rapid Development\" since I've got other homework to do and I have to finish this homework in a certain time.\n\n2. Functionality vs. Usability\nAlso, too many functionalities will absolutely lead to a more complex way to evaluate the winner and it might take a long time for users to understand the rules, to learn the specific way to operate each function, and increase the difficulty of playing this game which is obviously against the Usability NFRs.\n\n3. Cost vs. Robustness\nFor the implementation of a certain function, it costs little if we don't do any assertion whether the user gives the right input or not, and the program gets directly crushed if there are any Runtime Exceptions. However, in order to keep the program stable, it is a must for us to handle such problems to ensure the Robustness of the program. Obviously, we must put more effort because it's harder to code and we have to do many tests for it than before",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1320814,
      "meta": {},
      "text": "Functionality vs. usability: \nA system offering a lot of functions is longer easy to use in a correct way, what is meant by that, is that for example if a system offers more functions than what is really needed, then the end user will probably need more time to understand the system, thus making it counterintuitive. Those functions could also step on the way of other more important ones making their utilization complex. For example the login process to a certain system could be made so strict that the user may get fed up with it pretty quickly.\n\nCost vs. robustness: \nA low-cost software system is in most of the cases a weak system. The code won't last long before experiencing bugs because of the fact that many of the edge cases has not been tested properly nore dealt with. Usually low-cost software systems are poorly tested making it harder to add new features and update the code. An example would be paying developers less which will for sure lead them to not invest themselves to 100% in the making of the system.\n\nRapid development vs. functionality:\nA software system that is quickly developed is probably a system lacking some features as nothing good comes for doing things quick. In fact by cutting off time, there is less margin to add functionalities or implement them. For example asking a team of developers to provide you with a system as you (the client) intended it to be within a week of time will probably end up in you getting a system but with less functionalities as asked for. \n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1331476,
      "meta": {},
      "text": "The most prominent design goal trade-off is probably the trade-off between a low cost wanted by the client and the minimization of errors in the code desired by the developer. The client needs a search engine for a low budget , but at the same time a small number of wrong search results or search errors. The developer then has only a limited time of resources and time for testing leading to a significantly larger amount of errors than desired. An equilibrium between those goals needs to be find that is acceptable for both client and developer.\n\nThe second trade-off could be readability and runtime efficiency. In the search engine example if the developer would program everything in low-level-code like assembly or C he could achieve runtime efficiency benefiting the client and the end user, whereas the developer himself will have a hard time to read and modify the code in the end compared to using Java, Python or C++. Nevertheless, this could also create a longer development time for the project and thus higher costs not wanted by the client.\n\nFurthermore, developing a video game where the player runs and collects coins should have an appealing User interface, easy to use even for small children and hence be user-friendly. This contradicts a rapid development wanted by the client who needs the product to be on the market as soon as possible to beat the competitors and also lower opportunity costs for the project.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1653645,
      "meta": {},
      "text": "1. Functionality vs. usability: The client wants the system to have a lot of functionality, but also be intuitive to use. Now if you would implement let's say 1000 different functionalities, this can easily become overwhelming, and make the system less useable, as the user would first have to find the wanted function with all the other options. There should be a good balance between functionality and usability, so the functionality doesn't become overwhelming.\n2. Cost vs. Robustness: If the clients wants a cheap system, this can often affect the robustness of the system. Testing a system takes a lot of time and therefor money. So testing the system a lot to make it more robust also makes it more expensive. \n3. Cost vs. Functionality:  If the clients wants a cheap system, this can often affect the functionality of the system. \nSome functions might be complicated to implement, and therefor take a lot of time and money to implement. The client might decide to leave those functions out in order to save money.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291309,
      "meta": {},
      "text": " Design goals is the controller of the system design activities. But in the most of time, our system, that we finally delivered, cannot fulfill all the system designs perfectly. That is because, some of system designs conflict with each other. When we are choosing one of them, means also giving up the other one. There are many different typical design goal trade-offs.\n First one that come up in my mind, is the conflict between functionality and usability. \nWhen we want to combine all the cool features we want to achieve in one system, the usability of this system will gradually decrease.  For example, if I buy a printer, it will come with a manual to tell me how to use its different functions properly.  If it is a very complex system with many functions, the manual for it will become very thick.  Even if someone has read all the instructions, they may not be able to remember it. But when we only pick the most core and easy-to-use functions, the usability of the system will be greatly improved, and users don't even need to read the instructions.\n Second, the rapid development and functionality are also incompatible. Rapid Application Development is a development model that prioritizes rapid prototyping and quick feedback over long drawn out development and testing cycles. But it only suits for projects which have a small development time. When we want to build a bigger project, the time will be so limited so we must give up some function, that the system should have. For example, the game Cyberpunk 2077. It was once the most expected game in last few years. But the development time for it seems too short. When the game finally come to us, it is full of bugs and many function, that we have seen in the trailer have not been implemented. For example, the subway system in the real game is just a closed area but in the trailer we are able to take subway to travel in the city.\n Third, the development cost and robustness. When we are requiring more safety and security to the system, we must pay more in order to guarantee. For example, when a sudden power failure occurs, the system is infected with a virus or the network is attacked, etc., the system must be able to take some measures to ensure data security. A system like this has more robustness. But maintaining the security of a system at all times also means an increase in costs.\n ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292037,
      "meta": {},
      "text": "1. Functionality vs. usability: A system that has high usability, i.e. is easy to use, will most likely not provide many functionalities. The more functionalities the developer wants to provide, the lower the usability of the system is going to be as the user will easily be overwhelmed and confused by the system.\n\n2. Cost vs. robustness: Code that is very robust to errors requires more time and is costlier. On the other side, if the code is cheap, the code may be prone to errors.\n\n3. Cost vs. reusability: Code that is specific to a single context and not easily reusable for other projects will be cheaper to code and test. If the code is generalized it becomes reusable in other contexts. This, however, may require additional coding and testing which results in higher costs.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1295901,
      "meta": {},
      "text": "One typical design goal trade-off between availability and usability, for example the outsourcing of payment processes. With such an outsourcing process you add a dependency on third party providers and thus can't influence the systems downtime. If you provide an online shop and added a third party payment service it is possible that the customers can't buy a product from your shop if the payment service is down at the moment. So you basically trade-off the possibility of a downtime of your services with the availability of a good payment service that will make the payment process in general smoother, faster and will increase usability.\n\nAnother goal trade-off is the trade off between availability and security when implementing new applications for the user. On the one hand it is important for the user that the system has a minimum downtime and on the other time security of the system is also very important. In this situation the developers have to decide whether they implement changes as secure as possible and do a longer testing phase or if they try to implement it as fast as possible given the highest security possible in this short time.\n\nAn additional trade-off is between costs and security. While the customer wants to have the system implemented as cheap as possible but still providing the wanted features the users security will lack. So if for example the customer has a fixed budget which is too low to run reasonable security checks and adaptions, the user will have a less secure system to use. However if there have already been attacks on the system the costs increase a lot to achieve the required und sufficient security for the service.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1330500,
      "meta": {},
      "text": "Goal Trade-Offs in software engineering\n\nOne of the most important trade-offs is the trade-off of time vs functionality.\nThis means that it is often possible to engineer a software system very rapidly, but at the cost of features and functionality. One example for this would be developing an entire web-server from scratch within a few days. It might work alright, but it will most certainly not contain all the features it could and some features might be buggy or broken entirely.\nAnother typical trade-off is between functionality and usability. Adding more functionality to a software system often clutters the interface and makes it harder to use simpler functionality of the software, decreasing its usability. Examples for this can be found in many large applications, such as Visual Studio 2019, Gimp or Blender, which complex and extensive interfaces can be confusing and almost overwhelming for a new user.\nA third typical design trade-off in software engineering is the trade-off between backward compatibility and readability. For example supporting older versions of file formats in an application often either requires a lot of extra checks in the code or even keeping the entire old code in addition to the new one.\nIf a format therefor undergoes many revisions and changes over time, the code can become very complex and quite hard to read and understand",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1332749,
      "meta": {},
      "text": "The first design goal trade of I want to talk about is the \"Rapid development vs. functionality\" of the system. Those two goals are two very diverse goals that partly exclude each other. This can be represented using the following example: On the one hand the customer wants the IT to develop their new bookkeeping software as fast as possible in order to safe costs. But on the other hand it's a very high rated design goal to provide the best possible functionality of the bookkeeping system because even small inaccuracies could lead to legal consequences. So the development-team has to find a (middle) way to serve both goals: Provide the new system as soon as possible but also guarantee an adequate functionality. \n\nThe next trade-off is cost vs. robustness. This can also be clarified by using the example of the bookkeeping system. On the one side it is a high recommended goal to reach a high level of robustness regarding the bookkeeping system because it would be terrifying for a company if the system broke down or gets leaked/hacked by people with criminal background and the sensitive data gets published. But on the other side the customer also wants the system to be as cheap as possible to safe costs. Those two goals partly exclude each other so that the question arises whether to pay more money or accept the higher risk --> trade-off. \n\nThe last trade-off I want to explain is functionality vs. usability. Looking at the bookkeeping system much different functions in the system seem very beneficial but changing sides and looking at the users side, that much functions could lead to confusion and questions that limit the goal usability. --> Trade-off",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344427,
      "meta": {},
      "text": "Trade off 1: Portability vs efficiency\nIf you want to make software very efficient you might optimise for the specific cpu used or offload certain tasks to a gpu if it is more efficient in those. This will make it quite efficient to run on one specific setup but now it will be way less portable because it can only run on this combination of cpu and gpu. The same analogy can be used for different OS's. The result is a trade off.\n\nTrade off 2: Cost vs robustness\nThe more robust you want to make a system the more different scenarios you have to first come up with might happen and then test them all this costs time and because developers are paid for their time also money. Which means more robustness costs more money therefore a trade off is to be made.\n\nTrade off 3:Functionality vs usability\nIf you want to develop a painting software you could just have a brush and an erase this would make it very usable as everyone instantly understands the function of everything. Now if you want to have more functions like different brushes, brush sizes, colours and so on you will have to introduce new buttons and menus which means the usability will suffer because the user needs some time to become familiar with it all. This means we have a trade off.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1358588,
      "meta": {},
      "text": "Functionality vs. usability: The more functions a system offers to an user, the more complicated it is for the user to learn in order to be able to operate the system. For example, when the bumpers game has more than 10 collision types, each requiring multiple conditions, the user might be confused when playing the game at first, because he has no idea how his car get collided.\n\nCost vs. robustness: When the system is designed on a low budget, then the robustness, in particular the capability of error handling is often not guaranteed. For example, the bumpers game is designed with very low cost and very little time, which means that it might crack down when the player enters wrong inputs or hits multiple cars in a very short period of time. These legal actions could be ignored or misunderstood by the system and therefore have an impact on the user's experience.\n\nEfficienty vs. portability: A system that works with high efficiency is usually based on a certain programming language or environment. This efficiency often leads to low portability, which means the adaptability of the system under another environment is harder. For example, programs that are written in c++ works efficiently in linux system, but they are less portable to other systems.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1368167,
      "meta": {},
      "text": "Funcionality vs. usability is one of the most incurred design goal trade-offs. A developer wants to desing a system that is very functional and responses to nearly every request that the client has. It is possible but the main problem is the usability. In most systems more functionalities means more complicated and more complicated systems lead to decrease in the usability. The balance between these two aspects is a very thin line.\n\nCost vs. robustness is another common design goal trade-off. A system that is completely robust costs a lot. From salaries to needed equipment, from manpower to time it can cost a fortune but unfortunately every company has a budget for a system and therefore the developers can not cover all the requests from the client/clients. They need to limit some system abilities and with that some of the clients can not get what they actually wanted.\n\nRapid development vs. functionality is another frequently incurred design goal trade-off. Functionality is a feature that needs quite some time in order to be good or perfect. Rapid development considers time more important than any other feature and therefore many developers do not have enough time to implement a system that has near perfect functionality",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1481872,
      "meta": {},
      "text": "Functionality vs Usability\nIf you try to offer the maximum when it comes to different functionalities, it can happen really fast that the design becomes confusing to the user and as a consequence it damages the usability in terms of learnability and efficiency.\nExample: You have a game where you have over 10 different settings, which you are forced to choose for, before playing the game. You need at least 13 clicks to start. If you have a game with a good usability like Bumpers, you have to pay with less functionality and individualization for the player.\nCost vs reusability\nLet’s imagine that you create a game engine. For every game the budget plays a big role. If you’re low on budget, a company might develop a game engine which is just suited for this particular game, without considering that it may be smart to take the time (which costs money) to develop an engine which could be reused for future games, which is standard in the scene. Therefore, you have high cost at the beginning, but low cost in the future, because future games don’t need an engine which is built from scratch.\n\nCost vs Robustness\nLet’s imagine an application which can solve different math terms for the user. If the developers got enough capital, they might be able to search for a lot of bugs, which occur through wrong user input, which wasn’t recognized as a mathematical edge case by the application. But because all resources are limited in an economy, they might invest less in capital and therefore endanger the robustness of their application against wrong choices.\n\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1566893,
      "meta": {},
      "text": "Rapid development vs. functionality\n- a new law comes into place and a start up wants to build a software for that law (e.g. GDPR). They need to develop the software fast because of the publication of the law and on the other hand they can not implement all the functions that they want in the first place\n\nFunctionality vs. usability\n- a company wants to implement SAP as their new ERP software. SAP has a lot of different functions but the usability is difficult in the first place especially when the end user is using SAP for the first time\n\nCost vs. robustness\n- a self-employed worker needs a new payment software and therefore he hires a external software development company. The client now has the choice between a more costly (more development hours for the software developvers) solution that would be robust if the needs to send out a lot of invioce or he could go for a cheaper software solution where he may have difficulties with sending invoices",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1291292,
      "meta": {},
      "text": "Rapid development vs. Functionality\nStartups developing a software system usually face this conflict. On the one hand they want to launch their product as quickly as possible in order to get feedback and check if the product is even wanted in the market. But on the other hand they try to include as many functionalities as possible in order to offer future users a complete product with no/minimal errors.\n\nFunctionality vs. usability\nThis can occur when a website is to be developed for a government. People contact a government due to very broad and also very specific regards(taxes, license, payments, business opportunities, etc.). This means that the website will have to offer multiple functionalities, but it also has to be useable. Users should be able to easily find information for their concerns. Adding too many functionalities can slow users down(more clicks) and make the website overall less intuitive.\n\nCost vs. Robustness\nThere is the possibility of developing a product with minimal cost, but the tight budget results in poor software development. There will for example be very less budget for testing cause most of it will probably have to be spent for the development itself. As a result the product isn't sufficiently tested for errors and not robust. Consequences can range form poor performance to system not being able to cope with erroneous input. Here again a reasonable trade-off has to be made, such as not dealing with certain errors( errors that are not noticeable for the user).\n\nDesigning involves choices and these then again represent trade-offs.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291794,
      "meta": {},
      "text": "1. Often rapid development and functionality are in conflict to each other simply because implementing a feature takes some time. In the bumpers game for example I could have implement a forth car type which attacks the player's car with cookies, but I haven't done this because it would have taken to long.\n\n2. For the same reason, cost and robustness can be in conflict with each other: The more robust the software should be, the more time (and therefor cost) is needed to implement the software. In a search engine for example it isn't useful type in an empty query string. But in order to make the search engine robust against this pointless user input, an input validation must be performed (and this takes some minutes and leads to higher costs).\n\n3. Functionality and usability are often in conflict with each other as well. The more functionality a software offers, the more control elements it must have which possibly leads to a less usable software: If you add the functionality to choose the player's car to the Bumpers application, an additional dropdown menu (with a list of colors to choose from) is needed. But that way, the player gets more confused because of the increased quantity of input elements.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291847,
      "meta": {},
      "text": "* Functionality vs. usability\nProducts have to be usable and easy to understand, but at the same time it needs to have plenty of many functions, but not too many. When an application has too many functionalities, it becomes hard to use.\nFor example: Google have not only search engine but also office writer, cloud disk, map, etc. but although it has a lot of functionalities is also usable and easy to understand.\n* Efficiency vs. portability\nPortability is a form of reusability. Some kinds of software are known to be less portable than others. It's less time and resources consuming the product not to be portable. Assembly programs compile differently depending on the 0S. Also, a lot of apps are in .EXE file format not comparable with MAC and Linux. For example:  Facebook can run on all platforms, because it's a web app which uses a browser emulator, but that makes it slower and other applications.\n* Backward compatibility vs. readability\nIt's more a matter between backward and forward compatibility. Readability make the software easy to use, read and understand. However, making software more readable helps in reviewing and maintaining it over the course of its life. For example: Microsoft Office 365 is comparable with .docx files and the older .doc files from MS Word 2002.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292623,
      "meta": {},
      "text": "For University App development, the university has following design goals:\n1. The App can be developed within 1 million Euros \n2. The App can be finished within 2 months. \nThe develop team's design goals: \n1. The app should be developed with 0.5% error occurrence. \n2.  The App should be adaptable. More services can be added easily later.\nThe students'(users') design goals:\n1. The app is user-friendly,\n2. The app's downtime is 0 minutes.\nThe design goals from third parties are different. The university focus more on budget and developing time.  The develop emphasises more on quality of the app. And the students wants best user experience.\nFirst, the develop team should evaluate the development cost and time to see if the design goals of University is realistic or not. For example, if the development team says they need 4 month. Then the Uni might change the time period to 3 months.  At the same time, the development team should consider the design goals from two other sides. Based on the university's budget and time requirement, the error rate of the app might be changed to 1%.  They might also add that \"the app should have a good user Interface\" as an additional design goal based on the students' hope. Besides, the student's goal like 0 minutes downtime is very difficult to achieve, it should be adjusted to like 30 minutes downtime per week.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1298313,
      "meta": {},
      "text": "1. Cost vs. reusability\nTo make a systeme reusable, the code should not only be suitable for the specific application scenario of the customer, but consider different application scenarios in an abstract way. Therefore, some more development (dev.) effort is needed - which means higher costs. E.g. a shopping marketplace has to connect with external shops. One option is the individual integration of one specific shop. If in the future another shop wants to connect, the same dev. effort is needed. Better: code a reusable API, that allows a high number of shops to connect.\n\n2. Functionality vs. usability\nIf a system has many functions -> high functionality, where the user can profit from. If there are too many functions, it could be that the user is confused. Moreover, the function menu would be crowed and unclear - the usablity decreases. E.g. Microsoft Excel: It has more than 750 formulars, but a usuall user ony knows up to 50. \n\n3. Rapid dev. vs. functionality\nBasic functions are implemented quickly. With increasing functionality the dev. effort increases. Moreover, functions are added over time, because of change. If there is enough time, the dev. team can response to change. In a rapid dev. process could be no time to add the last functions - but this functions are important for good functionality. E.g. bumers game sprint 3: We only had 1 week for the dev. The functions of the system are rather basic, with more time, me game could (propably) has more functions. ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1316112,
      "meta": {},
      "text": "1. Rapid development vs. functionality\nThe time pressure and the wish to develope as fast as possible leads to a neglection of the functionality.\nF.ex.: The Scrum Team has only about 3 weeks in order to fullfill all their assignments and requirements. Since there are a lot of functionality requirements and the customer needs a finished/useable application, the team decides to focus on the rapid development. In 3 weeks, they implemented every requirement. The functionality got neglected because the time limit didn´t offer enough time to refine everything and to identify and  fix every bug available.\n\n2. Efficiency vs portability\nThe efficiency and portability dont complement each other as well. While for example the system works really fast and efficient on one operating system or platform, since the developers focused and specialized specific on these, the application may not work as good as on another operating system since the structure of the other one is just different. So the efficiency suffers if you do use it on another platform or the portability suffers since it´s not optimal to port it to another system because it wouldnt be as efficient.\n\n3. Cost vs robustness\nThe cost factor plays a huge role and every customer wants to keep the cost as low as possible. Because of that, the robustness suffers. For example a software developerteam only gets a budget of 10000 euro in order to develope a new application. They had to use 9000 euro in order to just develope the main functions etc. and they only have a small budget of 1000 in order to make the system more robust against failures. If they would have more budget, they could have make it even robuster than with a mere of 1000, but if they make it robuster, the cost will go up",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1316908,
      "meta": {},
      "text": "Design Goal Trade-Offs are well known in software and should be handled the right ways. \n\nAn example of a design goal tradeoff would be cost vs. robustness: the client doesn't want to spend a lot of money so you're limited by a certain budget, but they also ask for a robust and high quality program that doesn't lack anything. So the choice in this case is between making it affordable, easy to sell, and making it work efficiently with no issues. \nAnother design goal tradeoff would be functionality and schedule. In this case you're limited by a deadline and the developer gets torn between rapid development but incomplete work and a functional project that gets ready after the required deadline. \nThe last design goal tradeoff mentioned here is user-friendliness and portability. The project has to be simple and easy to use to attract the user and keep him interested, however it should also have some sophistication and specificity  in it in order to be portable on multiple platforms and optimized on a software level. \n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1333012,
      "meta": {},
      "text": "The financially aware client might favor low cost, which conflicts with the developer's goal of good documentation. Good documentation doesn't earn the client more money in the direct sense. For devs who have to work on a system they might not even really know, good documentation is a godsend.\n\nThe client might want backward compatibility, which of course comes with loads of \"unnecessary and old\" code. This in turn severely decreases the readability of the code, which is a necessity for developers.\n\nLastly, as time is key, rapid development is something that many clients love. This however comes at the cost of many errors, that haven't been fixed or even found during time constraints.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344341,
      "meta": {},
      "text": "A typical design goal trade-off is rapid development vs. functionality. \nA company often has to communicate with the client on compromising between how fast the client gets an application vs. how many functionalities they want (for that version). An example in video games is the amount of side quests implemented. The main story line is essential to the game so it needs to be implemented on release, but it is common for more side quests to be added with later updates as a way to handle this trade-off.\n\nAnother common trade-off is cost and robustness. \nWhen developing an app, you should try to test a lot, to identify as many special cases as possible and then handle them accordingly in the implementation, so that the app works despite unexpected input. The problem is that this takes a lot of time and will therefore cost you more. For video games, you need to think of a compromise, where the initial game is robust enough to be enjoyable to play (e.g. the user does not constantly get stuck in walls), but also does not cost too much. Later, with user feedback, testing can become cheaper. \n\nLastly, there is a trade-off between efficiency and portability. \nYou often want your game to be available on several platforms (e.g. Windows and Switch) to reach as many users as possible. However, this also requires more effort in development, for essentially the same functions, meaning you may not be able to implement as many features, e.g. in character customization, because you are also working on portability.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344618,
      "meta": {},
      "text": "1. Functionality vs. usability : for example, wile developing a lecture system many functionalities can be added : the user could have a possibility not only to view resources of the courses, he/she has signed up for or enrol in other ones, but also view the courses of his/hers friends, chat with them, write comments on courses he/she has visited etc. A system like that would have a great functionality, however the large amount of buttons, that would support functionality, would make a system less intuitive to use.\n2. Cost vs. avalability: for some social networking services like Facebook a high availability percentage is needed. The high uptime percentage can be reached with redundancies : instead of one application servers multiple application servers are required so if one of them fails Facebook still would not be down.  Additional servers however result higher cost. On the other hand system with only one server has lower availability but is cheaper to develop/maintain.\n3. Cost vs. reusability: while creating a university system for students simpler patterns and models can be used during the system development. Such system would be easy to code and test, which implies lower costs. However, if we were to expend the system for the usage of tutors/lecturers we could not reuse the code of already existing program. Compared to that, if we would create a system, that is suitable for being extended to many-to-many multiplicity, it would be harder to code and test so the costs also would be higher, however we could reuse the code in the future.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1351959,
      "meta": {},
      "text": "There is a perfect example that can explain plenty of design goal trade-offs in context of software engineering. \n\nCyberpunk 2077 is a first-person shooter role-playing video game developed and maintained by Poland-based studio CD Projekt Red. \n\nIt is famous for its abundant functionality – especially before it releases.  Player has a rich interactive experience with an open-world nature. Players can not only engage in main or side quests but simply grab a car and explore the vast scenery. It is because of the variety of functionalities in 2077 and the attractive publicity, the player has extremely high expectations on it. However, it turns out that it is incompatibility with current-gen consoles. As we all know, the most important design goal of a game is its robustness and its adaptability.  As for the ps4 version it could barely pass the first cutscene of the game let alone running the game with more than 15 frames was rare, the game continuously crashes each 30 min. In both pc and ps5 2077 did work, but endless bugs can definitely not meet the design goal of robustness. We see that to fulfill the functionalities, 2077 compromises on its robustness ① and adaptability ②. \n\nWhat’s worse is, when the player opens the game, they find that the functions promised by CDPR and the advertised features are not fully implemented. For example, most buildings are not freely accessible. Cyberpunk 2077 was released prematurely. Due to its rapid development, it sacrifices the promised functionality ③. \n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1664811,
      "meta": {},
      "text": "Cost vs robustness: \nIt is a common trade off. The more money and time you spend on a project the more robust it will be. A rapid development can cause a system with multiple breaking bugs. \n\nEfficiency vs portability:\nAn efficient code is almost system specific and written for a specific system. This is completely different from portability. Like writing a code in assembly for an arm cpu vs a general code in java\n\nBackward compatibility vs. readability:\nBackward comp needs multiple assessments for the same function. This greatly hinders readability. That is why it is a tradeoff, Like a game of playstation 4 vs 5",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1291278,
      "meta": {},
      "text": "Here are 3 examples of design goal trade-offs :\n\n- Functionality vs. Usability \nThe first example is functionality vs. usability. I think this is the most obvious one, as it presents itself too often. An example for this is a system that has too many functionalities and so it can no longer be usable. If a user uses an app that has too many functionalities, they might get confused and so their user expeirence is affected. Too many functionalities contradict the usability.\n\n- Functionality vs. Rapid Development\nSometimes the client requires a certain amout of functionalities in a given design window. But the problem that might pose itself is, is that the developers might not have the ability to implement all functionalites, as they may need a lot of time to go through everything. For example, we need to create a system for a plane. To do this rapidly would be extremly difficult, as we need to divide it into sub-systems and create each subsystem individually depending on the number of functionalities. The more functionalities you add to the system, the more time it takes to design.\n\n-  Cost vs. Reusability\nThe last example is involving cost and usability. This is also important because you want a system to be reusable, while keeping low costs. But sometimes it might create a contradiction. For example, a system that is cheaply designed might not be durable on the long run and so can't be reusable. ",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1292686,
      "meta": {},
      "text": "For video game development:\n\nLow cost as a design goal is in conflict with almost any other design goal. For example, having a stable, polished game with a low number of errors takes a lot of manpower, testing, and time to achieve, which massively increases costs. (Low cost vs Minimum number of errors)\nRapid development is another design goal that is in conflict with many others. For example, game studios usually want to publish a game as quickly as possible, which usually leads to aspects of the game's functionality missing, or again, a number of bugs that are introduced/not found or fixed before the publishing date. (Rapid development vs minimum number of errors & functionality)\nBackward compatibility, while popular, clashes with some design goals such as Usability. As seen with recent big titles, making a game backward compatible with less powerful hardware, often causes the games to have issues running because of their high computing demands. This can sometimes lead to issues where certain areas of a game are essentially unplayable (unusable) because of a lack of computing power, or it can even lead to performance issues that break the functionality of a game. (Backward compatibility vs usability & functionality)",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1312902,
      "meta": {},
      "text": "Functionality vs. Usability:\nIf a system is considered to have high functionality if it has a large number of use cases to which it can be applied. Given a Hospital Information System, a doctor is supposed to pick the name of the patients disease from a list. If this contains a lot of disease it is the system is more functional, since it can be applied to more cases. However an extremely long list (with no filter or search function) would make the system unusable, since it would take forever to find the correct disease on the list or at least the time scrolling through the list is increased. \n\nRapid development vs. Functionality:\nIf a software needs to be developed quickly, there is less time to include a larger number of functions. The Corona-Health-App for example only had very basic functionality in the beginning, since there was enormous pressure to release the app. Over time the number of functionalities increased.\n\nCost vs. Robustness:\nCosts can usually be decreased by limiting the number of hours a development team spends on the development of the increment. This means, that there might be too little time to intensively test the systems robustness. For a workforce management, which is supposed to clock the time at which workers get to and leave from work, it is important to know how to act if a employee forgot to clock out. If there is too little time to test and evaluate, which problems similar to this one can arise, it could lead to a financial imbalance between employer and employee and creates extra cost.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1332644,
      "meta": {},
      "text": "Cost vs reuseability\n\tif you safe time on developing certain parts of your software you safe cost, but also this can result in a sloppy\n\tapproach which is not well documented and very complex so it's not reusable later in development\nFuncionality vs usability\n\tif you implement a lot of complex functions into an user interface to enable the user to do anything he \t\t \n        wants, it could screw up the usability because the interface would be swamped with all the functions and it \t \n        would be hard to manouver through everything without getting lost\nCost vs robustness\n\tif you want to safe cost while developing a software, it could lead to bad security in the system by not having \t \n        implemented a maybe more costly bit more secure approach, also it could be not really safe to changes and \t\t \n        could easily break if the evironment changes because you didn't invest to prepare for certain scenarios ",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1335957,
      "meta": {},
      "text": "Performance vs Maintainability: This trade-off already starts with the choice of technologies. Highly abstract languages such as Python are usually very easy to read, but at the cost of a huge performance difference to machine level and usually rather verbose languages such as C/++ for example. More readable code is naturally more maintainable. If on top of that the code is also optimized through exploitation of complex mathematical tricks or language features, readability is guaranteed to suffer. Take the \"Fast Inverse Sqrt\" for example.\n\nPerformance vs Portability vs Cost: Portability can mainly be achieved through two means: Deploying one instance of a technology that works on multiple platforms or employing one instance of a platform specific technology for each platform. The first naturally comes with higher abstraction away from the specifics of one platform and thus a loss of performance along the way, whereas the latter is obviously more costly. Basically one can optimize for 2 out of 3 here, but not without cost to the third.\n\nSecurity vs Cost: A huge part of Security is Data integrity. All critical data should be backed up. Back ups require storage space and possibly power and/or management. For very critical data, several layers of backups are advisable, further increasing the cost of robust data integrity. Especially with the amounts of data growing ever larger recently, so does the demand for backup space and thus effectively the cost of Security.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1370330,
      "meta": {},
      "text": "A software engineering project involves a lot of different types of people. On the one side, there are the clients who commission a program from a developer. They usually want to keep costs to a minimum to achieve high return rates, but often also want to hop on a trend or be faster than their competitors. Those two goals contradict each other immensely because quicker development time requires a bigger developer team, which means higher costs due to accumulating wages.\nAnother fine line in software engineering is the tradeoff between  usability and functionality. Low functionality often makes a product not worthwhile for consumers due to better options on the market. On the other hand a consumer wishes an easy-to-use product which does not require reading the whole documentation to be able to use the software. Cramming a lot of functionality into a product can often lead to complex interfaces and cryptic options to choose from when using the software for the first time.\n Functionality and quick development are also two opposing design goals. A greater functionality set takes more time to produce or more manpower to accomplish more work in the same amount of time. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1445894,
      "meta": {},
      "text": "one typical design_goal trade-offs is Cost vs. reusability and here the developper may need to think wisely in order to get a good quality, for exemple a smartphone batterie can be be cheap and doesn't hold too long or can be exepnsive and holds for more hours, or the processor can be so expensive( or in premuim quality as said in the lecture) and is able to do tasks much faster but speed is not needed so the developper will buy a cheaper processor and save money.\n\n-Rapid development vs. functionality, so let's say an app should be ready as soon as possible and lately 7 days, that can be made in this range of time but it will cost some functionalities that cannot be implemented, here we can take an example of a chat application; any developper can create this kind of app in a very brief time but it surely won't be as good and contains less functionalities such as good encryption or data sharing...\n\n-Efficiency vs. portability trade-off,  a software can be portable and used in other systems than the system created for without too much rework but a program takes advantage of special hardware capabilities, it becomes at once more efficient and less portable and here the developper must choose one over the other according to the client needs, for exemple there are photoshop softwares thar are portable and for some people it's more convenient because they can use this program in any computer without having to install it every time\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1464044,
      "meta": {},
      "text": "Cost - efficiency\nDesigning a software (for example a game) always comes with trade offs. With lower costs usually comes less efficient software. Less developers, worse enviroments to work in.\nFunctionality - usability\nA software with more functionality usually harder to use. More functionality always means more choices, and more choices results in a less usable system. For example paint is an easy to use program but there is not that much usability compared to phtoshop, however photoshop is hard to use.\nRapid development - maintainability\nWhen a developer team has less time it can result in a worse documentation, not so clean code. And these will result in a harder to maintain and improve software.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1293597,
      "meta": {},
      "text": "Efficiency vs. portability\nHighly efficient code is programmed to tightily fit the targed hardware, this on the other hand limits the portability of the product, since the code only runs (that efficent) on the corresponding plattform/hardware\n\n\nBackward compatibility vs. readability\nWhen trying to achive backward compatibility, old code cant simply be discraded and replaced with the new one, it has to be maintained together with the new code. In a lot of cases this means to rewrite a lot of functions for the still supported old installment of the software or check version number with a lot of if statements to achive the programm flow that corresponds to the old hard/software. This leads to messy and difficult to read code.\n\n Cost vs. robustness\nWhen trying to cut back development costs without reducting the visible quality of a system, the systems rebustness is one of the first things that suffers drawbacks, since thouse faults arent too detectable on a surface level and are therefor neglected when the budget isnt sufficent to build a robust system \n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1333161,
      "meta": {},
      "text": "One design trade-off is functionality vs. usability. Because our software in the company I work in collects and manages data from a car manifacturers factory, the UI is most of the time unintuitive because theses processes are quiet complicated and requiere a lot of buiseness logic. Our focus lies therefor on the correctness of the programm instead on a fancy UI because an error in the wrong place can easily cost thousands of euros.\n\nEvery developer should strive for a robust software and clean code but that comes most of the time at a cost, the cost of development time and money. This one ist mostly a constrain by the client and therefore in conflict whith the developers intrests. Sometimes the client does not want to pay more for extra testing and the developer needs to decide if it compromises robustness for a faster development time. In my company, when wanting extra testing time or new technologies for better development, the questin arraises, where the money will come and if the client wants to pay for it or the company itself.\n\nLastly, often time your see places in your code base that are ineffictient, bad designed or hard to read. Therefor you want the rewrite these places so the next developer (could be you again) has a better time with code changes and understanding the code. But if the extra time spend compromises the development of other functionality that is paied for by the customer, the developer will hit a wall with management and therefor need to be carefull with these changes.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344544,
      "meta": {},
      "text": "Rapid development vs functionality:\nWhile developing a program, more time is needed to analyze and cover all possible functions and aspects this program should be capable to execute. More functions are therefore only possible if more time of developing is provided for coding and testing the program. With rapid development is a big number of functions and its reliability not guaranteed.\n\nEfficiency vs portability:\n\tIn order to write an efficient software, it has to exploit all features of the architecture it is supposed to run on. But not all machine architectures work alike and therefore this software would not be able to run properly in systems that don’t support these features. Meanwhile a more basic software that do not use all capabilities of a certain system, won’t have problems to run on other ones. That’s why a software uses either all features of a system and is not compatible with other, or it is more basic and can run everywhere.\n\nCost vs Robustness: \n\tTesting and debugging a program are a process that requires time and money to achieve a reliable software, which is not prone to bugs or being targeted by cyber-attacks. This implicates also more costs for developing and executes these Test. That is why a robust program cannot be demanded without resorting to extra expenses.\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1353421,
      "meta": {},
      "text": "- Example: Software for work days\n\nFunctionality vs usability: \n\n\t-> A software for work days  is more likely to have multiple functions, e.g. providing the salary, calculating the taxes upon the salary, registering work shifts and breaks. The question is which functions are necessary. A few functions are understandable to get all the information needed considering the employee and his monthly work-time but for example splitting the breaks in lunch breaks and short breaks would make the software more complicate to use. Additionally, it is unnecessary because you can use a single \"work break\" function and register the start and end time. Moreover, the system gets more complex with many functions.\n\nEfficiency vs. portability:\n\t-> Also we need to make sure that the software is efficient. That can be provided with less unnecessary functions. On the other hand, we want that the software can be run on any operating system because not everybody uses the same and that you can use it wherever you want, e.g. home office.\n\nCost vs. reusability:\n\t-> If the software is being designed in a way that classes are connected with one-to-one multiplicity then the code complexity is minimum, the tests are cheap but it is not very reusable. Having it with complex multiplicity increases the cost of the tests and provides complex coding but is gets reusable. For example, you want to manage more employees and different wage categories but with low costs.",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1429392,
      "meta": {},
      "text": "Example 1: Rapid development vs. Functionality\nA good example of this would be the bumpers game. Because of certain reasons I had to develop that game the night before the deadline. Because of the rapidly accelerated development, I had to select only a few core ideas to implement, simplifying other functions of the program as a trade off. If I had been able to get more time for the project (by better scheduling) I might have been able to add more ideas and expand on the already introduced concepts.\nExample 2: Rapid development vs. Maintainability/Readability\nSame example as before, but a different trade off. Sometimes, to meet a deadline, a software engineer might neglect the documentation and cleanliness of the code or write some quite \"hacky\" code that makes the structure of the project more complex and harder to work with. This code would probably be improved and refactored given enough time. On the other hand, one might take more time for a project to write a very clean documentation, to make life easier for other people working with it.\nExample 3: Backward Compatibility vs. Usability/Readability\nThis is pretty self explanatory. By keeping deprecated methods inside a project someone might preserve functionality for someone using an older project with a new version of the system. On the other hand this makes life harder for people using the system to know which functions are up to date and should be used",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1463933,
      "meta": {},
      "text": "A typical trade-off is \"Cost vs robustness\". The Client wants to keep the development costs low, but often at the cost of less developers who can work on a robust system. An example can be seen in the open source field, where often most fundamental libraries are maintained by individuals, that not neccessarily receive money, and have to take up their free time for taking care of the software. \n\nAnother trade-off is having functionality but a low usability. A good user experience requires experienced designers, that know how the actual users interact with digital systems. An example is often seen in open source projects like GIMP. It has a huge amount of features, but is badly structured so new users have to tackle a steep learning curve.\n\nAlso, rapid development often comes at the cost of robustness. An example could be the Luca app, that was developed at a very short time, but was not mature in terms of user privacy and data protection.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1636862,
      "meta": {},
      "text": "Typical design goal trade offs:\n\n*Cost vs robustness\n\nI think this is a design goal trade off for example when a client requests a system that is secure but also has a low cost requirement.\n\n*rapid development vs functionality\n\nCan happen when a client requires too many system requirements to be implemented in a short amount time. so there is not enough time to develop each and test them before adding others. \n\n*Efficiency vs portability\n\nI imagine an example of this could be offline applications, where we expect that the system will work eficiently of and online. For example, google maps that does not give all the funcitonalities when using it offline. ",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1638041,
      "meta": {},
      "text": "Rapid development vs. functionality: End users want more functionality about a software, more features to be able to use as many technical features as possible. \nThe customer, e.g. technology entrepreneur wants rapid development. But if you add more functionality it will take time and rapid development would not be possible. So it is either or principle.\n\nFunctionality vs. usability: End user wants usability. This means, for example, that a program should be easy to use. However, this is possible if a program has a manageable functionality. If you want to include more functionalities, it will not be very usable. So you have to balance between both goals.\n\nCost vs. robustness: End user wants the software to be robust and protected against external attacks. If you want to make a software very robust durable it will cost time and money. Client would like, for example, a technology entrepreneur would like to spend little money. You have to weigh it again you can't have both completely. Either the program is robust then it will be more expensive or cheap but not as robust as the competitor software.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1291532,
      "meta": {},
      "text": "Design goals are a major part of system design. Any non-functional requirement is a design goal, therefore only the RUPS of FURPS can be considered design goals.\n\nCost vs. robustness\nA regular trade-off seen is cost vs. robustness. While wanting to save on the initial cost of a system many companies receive a product less robust because less time went into testing and more into developing it. We all know for example from PGDP-times, that a lack of testing usually results in unwanted errors or exceptions, which make the system less robust.\n\nFunctionality vs. usability\nAnother trade off seen regularly is that a system that has many functionalities usually lacks usability. One only needs to look at the photoshop interface for the fist time and understand nothing, because the program can do so much. Specialized apps, even mobile apps, can special tasks this way more intuitive, but only hold maybe 2% of photoshops functionality. Therefore it sometimes is a big trade-off.\n\nRapid development vs. functionality\nComplex algorithms and large functionality needs time to develop. Larger functionality, even when split between a team, always takes more time to organize and merge the parts. An example for rapid development would be in class coding exercises at EIST, which can be solved within 10-15 Minutes: the function is very limited here. On the other hand implementing a ring-queue based on dynamic arrays while logging all steps in GAD, is a bigger functionality, but also takes me 1.5 days to develop.\n",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1329023,
      "meta": {},
      "text": "One trade - off would be the conflict between functionality and usability. So, when an application provides too many functions the user gets easily confused and most probably is not motivated to learn how to handle them properly. Therefore, the user feels stressed when using the application and stops using it. If for example a word processing software has a main goal of offering as many possibilities as possible to format text and the user just wants to make the text bold, he/she feels overwhelmed if the function he/she searches for is hidden between the multiple other functions the user doesn't understand.\n\nAnother one is the trade-off between cost and robustness. Being cost-efficient also includes reducing the development process. Therefore less testing can be done and the software may be released with bugs and therefore without robustness. An example would be any EA - game from the past 10 years, because they always want to cut costs down and release software that isn't robust at all and full of bugs.\n\nAlso there is the conflict between rapid development and functionality. When a software needs to be produced in a very short amount of time it is obvious that there is less time to implement many function. So, if for example a new niche is found and everyone wants to take their part of it, there normally is not any time to implement many functions and very simple software arrives on the market.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1344477,
      "meta": {},
      "text": "The first trade-off is usually: the budget of the client vs. the functionality or efficiency of the system. Clients nearly always want to keep the costs at a minimum, and therefore also new software systems should be cheap but still high quality. That creates the first trade-off, because to ensure a well build software, with high standards in security, efficiency and robustness developers need a good amount of working hours which means costs for the client, which they oftentimes either can’t or don’t want to cover.\nClients sometimes need their software really fast delivered, which could lead to another trade-off: rapid development vs. minimum amount of errors and readability. In order to produce systems fast developers have less time writing good documentations and testing their software, which can lead to worse readability of the code and more errors. \nAnother common trade-off is: efficiency vs. portability. The more specific the operating system or the hardware device, the produced software should run on, are defined the better a developer can optimize the software for the specific operating system or hardware. But often times clients want their software to be able to run on multiple operating systems or even on mobile devices for example, to have a bigger end user target group for their system. This usually leads to less performance-optimized and efficient software in order to fulfill the portability requirements. \n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1344681,
      "meta": {},
      "text": "To develop the software rapidly the functionaltiy might be compromised due to rapid development. For example during for the competition of the Bumper cars game we had one week to implement our personal design and new collsion types, etc. Due to having other obligations the amount of time necessary to not only fullfill the basic requirements but also exceed them through addtional functionality wasn't manageable for me leading to a lack of functionality.\nSecond, high functionality may mean lower usability. As an example looking at an application such as Anki for creating index cards, as a end user you have different types of index cards to choose from, with different possiblities with additional categories to enter and more. This leads to a lesser usable environment as it becomes difficult to gain an overview of possibilities. \nThird, from the clients perspective you probably will only attain true robustness with higher costs which depending on preferences may be undesireable due to budget reasons. I worked at a startup using SCRUM to develop their app and I witnessed the difficulty of managing bugs and foolproofing the system due to a lack of work power as the budget didn't allow for an additional developer.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1376518,
      "meta": {},
      "text": "In system design you encounter many problems in relation to design goals. There are many design goal trade offs where there's a decision to what has the bigger priority. One of the main trade-offs is efficiency versus portability. When the system should work on multiple platforms it is harder to keep the system simple and efficient, because you have to have more use cases for the different platforms. Although it is probably more important to have a portable system because it is more attractive for the markt. Another trade-off is cost versus robustness, which is pretty simple. If the system requires to be robust it has to have more code, which is getting more expensive to do. Furthermore, especially in this fast-moving time, there is the issue between rapid development and functionality. When the coding is fast, often the functionality has to suffer, because there is a bigger chance somethings forgotten or there's just no time to implement something at all or better. \nThere are a few more trade-offs, which all have to be prioritised.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1466441,
      "meta": {},
      "text": "Design goal trade-offs is a situation that involves losing one quality or aspect of something in return for gaining another quality or aspect as the design goal are highly likely to conflict with one another:\n Functionality vs. usability:  what the system is supposed to do vs. how easily the actors can use the system, a hotel booking app, for example, has the simple goal of allowing the user to book a certain hotel in a certain time period, if the app's design makes it complicated to make a reservation by cluttering up the user interface with additional services or allowing it to be made in too many steps this might harm the interaction between the user and the app and likely leading them to cancel the booking.\nAnother example is the conflict between cost vs. robustness, in order to maximize the flexibility of a system and allow it to maintain a certain function despite certain obstacles that need t to be expected and treated in the design of the system the client must be aware that the end product's cost would also increase, in this case, if a client is committed to a certain budget such functionalities as for example automatically saving the progress of the game when the player unexpectedly shuts the game or enters a wrong input would be hard to implement\nEfficiency vs. portability is also a design trade-off that makes the user choose between these aspects according to his preference: with more dedicated space for more impressive and high-powered hardware, desktop computers generally outperform laptops but the downside is that they are static (stationary) compromising the portability aspect. \n ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1469830,
      "meta": {},
      "text": "One design goal trade-off is for example: Cost vs. Robustness. Since building a system costs you money, on hiring developers and on the infrastructure used. The more time you spend perfecting a system and the more layers of security you have in your infrastructure and code, the more money you will need to spend. The Problem here is that usualy you only have a limited budget, so that you will need. For example if you do not have a big budget, your developers will spend less time searching for the remote bugs or designing the system, which could lead to potential bugs and bad error handlings.\nThe second trade-off can be, for example, Efficiency vs. portability. Most of the times, if you want to be as efficient as possible with a system, you have to code as close as possible to the given architecture. In contrast, the more you go up in levels of abstractions, you lose that given efficiency of resources, but then you can have something like a JVM in Java which compiles the high abstraction OOP code to bytecode and therefore can be ported to other system more easily. If you code on ASM, then you can search for the instructions implemented on your current cpu, but if you want to change to another cpu, you need to make sure that all the instructions are supported, and if not change them to the equivalent\nThe third trade-off can be Functionality vs Usabilty. In this trade-off the problem is that if you implement to many functions, then you can do a lot more things with your system, but then you can get lost, since there could be many ways to do the same thing. In contrast, if you implement only the necessary functions, then you can structure your proyect way better, and later on coordinate better with your team on how to do things with a given set of functions to implement a system.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1479677,
      "meta": {},
      "text": "Cost vs. Security\nMobile apps usually adhere to releasing new updates with bug fixes to prevent vulnerabilities in the system, and so does for example Apple with its frequent releases of software updates. However, the development process requires teams of software developers or companies to invest time and money, which results in this tradeoff of cost vs. security. \n\nEfficiency vs Readability\nIt's especially noticeable to me that when coding in C or x86-64 Assembly, the more you optimize your code, the less readable it becomes. If you take a look at a program which has been optimized by a compiler, even the loops aren't visible in their classic form (where we often use the instructions JMP, Jcc, CMP etc.) but are replaced by another instruction (LEA). In software engineering, if you and your team are developing a system; aiming for the most amount of optimization and efficiency will most likely make your project less readable. If one prioritizes design goals such as maintainability and rapid development, it may be that they chose readability over efficiency.\n\nEfficiency vs. Safety \nThreads are a good example of the tradeoff between efficiency and safety, as they make the program more efficient by splitting up the tasks. Their usage however can cause deadlocks or livelocks, if the programmer or software developer has decided to risk thread safety in order to achieve a faster program. I've experienced this dilemma last semester in one of the PGdP tasks while implementing a Binary Search Tree for a fish shop ran by Claudia and Karl-Heinz and decided to opt for efficiency over safety.  ",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1292766,
      "meta": {},
      "text": "1. Functionality vs. Usability\nBumpers should have many functionalities like choosing the type of the car, the color of the car, the crash sound, the evaluation method etc. The more functions and possibilities a system offers the more the usability suffers. These different functions might decrease the usability.\n\n2. Cost vs. Robustness\nBumpers should have a low cost design. The small budget might influence robustness in a negative way. Once I have choosen the cars color, the input is set. A wrong user input cannot be corrected immediatelly. I need to close the game before I can start it again and choose the color I wanted.\n\n3. Cost vs. reusability\nI would like to reuse my implemented Bumpers classes for other games. Therefore I cannot only concentrate on my current game, I need to think about reusing the code by including many-many multiplicities. These extra efforts result in higher costs and additional testing.",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1296841,
      "meta": {},
      "text": "When we develop a software system, it is possible that we come into a dilemma. It means we may have to sacrifice a design goal to achieve another. At this moment, the team has to make a trade-off and decide which goal they would prefer to chase.\nFor example, we want to reduce the cost of our software. As a result, we only hire some students without good experiences in software development, because we do not have to pay much salary to them. However, due to the limited experiences and knowledge, the students can merely design a software which only has a few functionality and is far from the development and design requirement. It can be attracked easily as well.\nIf we want to develop a shopping software, the main purpose is of course to sell as many products as we can. The customers would like to view as much information about the product as they want. Assuming we are selling clothes, we create functionalities like showColor(), showSize(), showPrice()... Those functionalities make sure that the customers can view any detail. But if the customers want to know every information, it will need too many clicks.\nMoreover, if the developing time is limited, it will also affects the quality of the software. For example, the average duration of a game development is 3 months. However, this time the chef gives the team only 2 weeks to develop a game. This will prevent many functions from being implemented.\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1302373,
      "meta": {},
      "text": "Three typical design goal trade-off in the context of software engineering are:\n1. Memory vs. Performance: If the software (Game) has to meet a certain response time or frame rate, more memory can be added to increase the performance of the software (caching, more parts in RAM). If the Game takes up too much memory, data can be compressed or only loaded when needed, but at the cost of performance.  \n\n\n2. Backward compatibility vs. Cost: If the software(Game) is written for a new hardware, but also keeps a mode or setting that lets it run on older hardware, but more people are needed to implement it. Or ignore backward compatibility and deliver the Game with less people and lower costs. \n\n\n3. Delivery Time vs. Quality: If the software (Game) project runs behind schedule, the company can still choose to deliver it on time, but with the known bugs and errors. And possibly at a later time use resources to patch the software to fix essential bugs. Or deliver the software later with fewer bugs. A good example of this is Fallout 4, delivered with bugs and later patched.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1344546,
      "meta": {},
      "text": "As there are multiple stakeholders are involved in a software engineering project, namely the end user, the client and the developer, the goals pursued differ from one another.\nA first example is costs vs reusability. While it is the customer's goal to keep the costs low, the developer aims to work on a solution that could partly serve for other customers / in future projects. Hereby the developer could seek to generalize the problem statement further by investing more time and developing a reusable interface, which would not only be applicable in the underlying problem but also in other projects. This would however go hand in hand with more test cases and time to implement a more abstract instead of a very concrete and problem-adjusted solution. In turn this would increase the costs for the customer, who himself is not interested in the reusability but wants to keep costs for himself low and prefers a quicker solution.\nA further example is costs vs robustness. While it is in the end user’s interest to have a robust solution, which keeps working in case of changes the end user undertakes (doing an update on his operating system for example), again the customer aims to keep the costs of the solution low. A more robust system will translate into higher costs, as further features will have to be required from the developer to make the system robust against different changes in the environment. A more robust system in turn can achieve higher end user satisfaction as the system does not get interrupted. \nAnother example for conflicting goals is rapid development vs functionality. While it is in the interest of the customer to get a rapid solution for the underlying problem statement as it may provide the customer with a competitive advantage or a change in the environment is requiring a quick solution, the end user wants a well-functioning system with various features in it. One example would be the beginning of the Covid pandemic and the first lockdown. Many local stores had to close and could not sell products in person. In that case being able to provide an online shop to its customers (faster than other local stores) gave the store a competitive advantage. However, a very rapid development limits the functionalities the store can offer. The end-user might for example be interested to have the possibility to choose among different payment options such as Credit card, paypal or by invoice which could not be considered in a very rapid development. \n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1364623,
      "meta": {},
      "text": "1. Functionality vs usability:\ne.g. Bumpers game: \nIf you want to introduce the tank as a new \"car\" and you want the tank to be able to shoot different missiles, you have to do a trade-off between functionality and usability because if you add e.g. 10 missiles that the user can choose from, the game becomes confusing when the user has to choose a missile every time he wants to shoot one.\n\n2. Cost vs. robustness\nIf you want your software to be very robust, you have to finance multiple test rounds and/or hire more/more qualified developers. If you just want a product, you don´t have to worry that much about coping with specific errors etc. Thats the cost-robustness trade-off.\n\n3. Rapid development vs. functionality\ne.g. Bumpers game:\nIf you want the game to be finished very fast you have to think about not getting all the functions on your wishlist because of the time constraint. So if you have a deadline in 3 days you will get a different and perhaps \"simpler\" game than when you set the deadline in 2 months.\n\n",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1401238,
      "meta": {},
      "text": "One of the typical design goal trade-offs is cost versus robustness. It means, that costs of designing a completely robust system could be really high. Is is necessary to write many tests in order to eliminate all errors and that could be time-consuming, which could lead to a higher cost of a system engineering. One of the examples that came to my mind, is a software system that is used in the planes. That has to be really robust and therefore it takes ages for developing such a system, that leads to very high costs. \n\nAnother trade-off could be functionality versus usability. The problem here is that a very functional program could be very complex and user could have difficulties finding out where the desires functionality is. I was studying Physics and one of the main tools to build graphs and diagrams was a program called Origin. It was very functional and had so many tools, but because of that it was completely unclear where the necessary functions are. \n\nThe other possible trade-off could be efficiency vs. portability. Some systems that are really efficient in solving their problems could be either really big and not portable. I have heard of a DNA-encrypting machine, that has a software so complex, that this machine is really big and is not portable. Neither is the software that is used there. But the system is really efficient in solving its goal.\n",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1654504,
      "meta": {},
      "text": "Typical design goal trade-offs\n• Functionality vs. usability:\n- Usability is the ease of use of an interface. Functionality is the set of operations that an interface supports. They are often seen as a design tradeoff. A large number of functions in one user interface can make interface harder to learn and use, while removing some functions generally makes interface less powerful. \n- For example: A powerful multifunctional photo editing app like Photoshop could takes months to get use to with, while the builded-in editing function in smartphones or computer is relatively easy to use. ",
      "score": 33.3,
      "language": "ENGLISH"
    },
    {
      "id": 1291067,
      "meta": {},
      "text": "1 space  vs. speed\nBsp:  Sortierung von Elementen kann mit unterschiedlichen Algorithmen gelöst werden. Einige davon sind zwar Zeiteffizient, aber nehmen dafür viel Speicherplantz ein.   \n\n2. schnelle Entwicklung vs. Funktionalitäten. Die Implementierung jeder Funktionalität erfordert auch Zeit Durch vorgegebene Fristen kann diese Umsetzung in manchen Fällen unrealistisch sein.\nBsp: Bearbeitung von Teilaufgaben in der Klausur <==> Zeitdruck \n \n\n3.Fuktionalität vs. Benutzer Freundlichkeit.   Durch zu viele Funktionalitäten kann die Benutzeroberflächer sehr unübersichtlich werden. \nBsp:  Eine überladene IDE mit zu vielen Funktionslitäten, sodass der Nutzer mit der Bedienung der Benutzeröberfläche überfordert ist. ",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1291325,
      "meta": {},
      "text": "1->Functionality vs Usability :In general increasing functionality leads to decreasing usability. Example: The simpler the website design, the easier it is to use. The more functionality a website has, the more useful it is but harder to understand . In other words it becomes hard for user to find the features as it become clustered due to a lot of functionality.  In addition to that user needs to understand these features to perform some tasks. \n\n2->Cost vs robustness: If a client requires a robust system, a system that is adaptable to the outer environment and is stable against wrong inputs, it costs a lot of research and testing. Example: A client requires an ATM ,which should  function smoothly even at 50 degree celsius and can handle wrong inputs. To meet such a requirement it costs some extra money for a special material that withstands high temperature, extra testing to handle wrong inputs.  This example clearly shows that to achieve robustness one needs to compromise with costs.\n\nRapid development vs Functionality: If one needs a lot of functionality ,sufficient time for implementing the functionality in an efficient way is also required. When a client wants rapid development of software i.e development in short time ,he/she needs to compromise with functionality as in given amount of time only basic functionality can be provided.  Example: If a client wants his online shopping app to provide live tracking of the order ,but provides half amount of time to develop the app, it is not possible to provide the functionality in short amount of time as the required feature should be connected to database of different departments which can take a lot of time for coordination with other departments and legal constraints.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291524,
      "meta": {},
      "text": "One typical design goal trade-off is \"flexibility vs. usability\". If you want to have as many features as possible in your e.g. app than you have to deal with an application that is way more complex (e.g. all features can be reached with 3 clicks) than an application with just one feature. For example a Lufthansa application that only shows you the airports near your city is less complex that an app that allows you to book flight, filter them by specific categories and sort them. \n\nAnother trade-off is \"Rapid development vs. functionality\". For example an application (like e.g. the covid app) that needs to be developed as fast as possible, may miss out a few important features that need to be added afterwards by an update. Less time to develop means more features that are not implemented.\n\nA third trade-off is \"Robustness vs cost\". If you want a developer to develop an application, but your budget is not very high, then you will have to deal with the fact that the robustness of your program is going to be lower. This can mean that for example that your app is not going to be as stable as other apps which cost way more money. Less robustness may then result in more crashes while using the app or crashes while performing undefined actions like for example undefined input by your keyboard.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1292115,
      "meta": {},
      "text": "* Rapid development vs. Functionality\n\nImplementation of new features in a software product takes time. And vice versa: you can quickly create a software product (MVP), but it will have only basic functions.\n\n\n\n* Delivery Time vs. Quality\n\nAny project can be completed in a shorter time at the expense of quality. Conversely, better quality requires more time.\nFor example: when developing a software product, you can save time by not doing the necessary amount of code testing. This can consequently lead to potential flaws and reduced quality.\n\n",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1302051,
      "meta": {},
      "text": "1) efficiency vs. portability:\nin general efficiency and portability are in conflict with each other because they require a different approach in system design to provide these aspects. Considering a particular situation we can look at the layered architectural style: If one wants to have an efficient application he should choose the open architectural style whereas one should go with an closed architectural style if he is looking for a portable application. \n\n2) rapid deployment vs. functionality:\nThese two design goals are more or less in conflict with each other because it takes time building a fully functional application, whereas in rapid deployment some parts of an application might not be fully functional (i.e. containing some bugs).\nGiving an example we can think of a following scenario: due to 4 weeks of time until the shipment deadline the development team does not have enough time to create and run all unit tests why some serious bugs can arise.\n\n3) cost vs. robustness:\nSince the extent of development time, work and used tools are highly related to the given budget, developing longer or using \"better\" tools cost more. Apart from this, building a robust system (in general) means designing and developing more or using more robust tools or hardware.\nAs an example we can think of a situation where the server should be able to handle millions of user interaction: when the budget is low, it is hardly possible to finance a right server for this requirement.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1308865,
      "meta": {},
      "text": "- Cost vs. Robustness : The cheaper a system, usually the less robust it is. This can be seen for example with Google : The company is of course worth many billions of dollars and is thus very robust to cyber-attacks.\n\n- Backward compatibility vs. readability : Having to keep a code backward-compatible will often have a negative effect on readability. For example, Java lambdas were introduced quite recently and obviously had to keep their language backward-compatible. This led to many situations where lambdas seem \"artificial\", notably the concept of functional interfaces.\n\n- Functionality vs. usability : Wanting its program to solve a lot of different problems and be the most efficient possible poorly affects usability. Usability often requires the program to be intuitive and ergonomic. Having a lot of different functionalities often worsen usability. An example could be an app that informs you about public transport schedules. It is not rare to see some with way too many options to choose from to show you the incoming trains/buses. The user can be annoyed when using it",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1339566,
      "meta": {},
      "text": "While designing a software system a software developer should not only think about what he wants but also consider what the other stakeholders aim for. One of the typical trade-offs is the “ cost vs the robustness”: a system that is developed with a very low budget or has a cheap price when buying is for sure not a robust one he can´t maybe check for errors or maintain its function when the user enters a wrong Data for example or when there is a change in the environment that the system works in. As an example for that a low software system of  budget smartphone risks losing  its functionalities when the customer uses it for example  under the rain or the water. In the other side we can consider “ the rapid development vs the functionality” as famous trade : the client wants sometimes  his product(software system )to  be prepared in a very short amount of time what  can lead to a system that is not very functional and maybe contains a variety of issues which contradict with the functionality that the end user aims for. As an example of that is the latest Battlefield game (Battlefield 2042) taking only a 18 months of development which lead to game full bugs and sometime not even playable(#cyberpunk 2077).the tradeoff is “the Backward compatibility vs readability”: the main problem here is that achieving backward compatibility can be sometimes hard and maybe effects the readability of the system (or the code ) and mountain the complexity as more functionality is added an e.g. for that is the difficulty to achieve backward compatibility in a system due to the different hardware parts.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1351801,
      "meta": {},
      "text": "Efficiency vs. portability: \nIf you program the flight system in EIST, it is much easier to program the system only for desktop operation systems than programming it for smartphones (Android, IOS) as well. For example for designing the system, you can ignore the design of the system for portrait orientation(Hochformat). Therefore, you don't have to code it for portrait orientation and focus on the landscape format design and make it more efficient. But if you  want to make the system portable, you have to make everything work for both. Furthermore, the processors and the software in computers differ from the ones in smartphones, so you cannot make it more efficient for just one kind of processor/ software.\n\nCost vs. robustness:\nWith less cost comes less effort in developing and less testing. If you reduce the costs in Bumpers, the game wouldn't be playable fluently with at least 20fps and there would be many edge cases which wouldn't have been detected because of less testing.\n\nFunctionality vs. usability: \nIf a calculator has hundreds of operations like root, x power of y, logarithm etc., the programmers focussed on the functionality. But if there are hundreds of buttons for hundreds of different operations, you can't call it a minimalistic design. If you want to make the calculator easier to use, the amount of buttons definitely have to be reduced. But with less buttons, the functionality is being reduced as well.",
      "score": 91.7,
      "language": "ENGLISH"
    },
    {
      "id": 1378887,
      "meta": {},
      "text": "Fast development vs. Minimum of Errors:\nUsually, the client expects a fast development of the software. And of course, the developer tries his best to fit produce the expected result in the given timeframe. But this is not always possible.\nPart of the job of a dev. is to deliver a system which is as bug-free as possible. let's say he encounters a problem in the late stages of the development, which would need a lot more time to be fixed than is available. Do you ship the product as is, or delay the delivery day and try to fix the issues. The responsible thing would be to delay, but this will cost money as well as a loss of the professional face the companies tries to keep. (Looking at you, EA and CDProjectRED)\n\nCustom Software vs adaptability\nMost often than not the client wants a piece of software that is custom-designed to their needs, but such a development would be costly and time expensive. So usually the Developer tries to retrofit a piece of already existing to the client's wishes. So again it's a tradeoff between the expensive long route of development or the faster but maybe slightly unfitting software.\nFor example, the school I was at should really have gotten sth which was better fitted to their needs (They choose the fast route ... the result was bad)\n\nFlexibility vs Ease of Learning\nThe end-user wants to learn the software as fast as possible, which is easier when the programme is rather simple.\nThe client on the other hand would love it if the software could do everything.\nThis is actually a point for my old school since the system for the end user was most of the time easy to understand",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1381416,
      "meta": {},
      "text": "3 important trade-offs:\n1. Flexibility vs Simplicity\nSome software needs more flexibility, because sometimes you will start from a small idea in a project, and to expand that idea you need the expandility and the flexibility of a software. While others can need different things, such as a straightforward implementation of a designated problem.\n\n2. Space vs Time\nMaybe some software wants to provide the speed to process the data, in which they compress the data. Others want the ability to process a large sum of data, sacrificing the processing time for the amount of raw calculation.\n\n3. Latency vs Throughput\nThis is in my opinion of the most debated problems in the software engineering industry. Which optimization is better, the time for the program to get the first result, or the number of results you can get in a certain period of time? To understand this, I made this analogy. Let's just say if we want to move people for 1 km, do you need a bus to move a lot of people to get to that distance, or a motorcycle to get a single person to that amount of distance?",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1485970,
      "meta": {},
      "text": "The first design goal trade-off to explain is the \"Functionality vs. usability\".  For example; when we look at the design of digital scoreboards in basketball, it is easy to see that some of them include lots of functionalities such as attack time, score, number of fouls of players and teams, etc. And while presenting functionality, it is less useful for the user due to its complex structure. Lots of functionality makes it really hard for the user to understand the scoreboard clearly at first.\n\nThe second design goal trade-off to mention is the \" efficiency vs portability \". As an example; you are a game producer and you want your game to be portable on different devices. But that also means you have to satisfy all the requirements with your game for the different software such as IOS or Windows. Then it means you usually need to have a trade-off from your efficiency because you are restricted to fulfill the requirement of different software and systems within your game, which makes it less efficient.\n\nFinally, the last design goal trade-off to mention is the \"cost vs robustness\". It is still not easy to find a system that is low in price and very robust. To make your system function properly under stressful conditions you need to reduce the possibility of fault. And in the software context, that means much more testing of your code for example to discover these. And it is costly for the developer.\n\n",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1633635,
      "meta": {},
      "text": "1) Client wants his app available in many languages to attract people from different countries to use it. Developer argues that supporting so many language versions will be hard to maintain and will definitely delay any major update in the future. Trade-off: They agree to three language version.\n\n2)\"functionality vs usability\": In drawing/painting app developer can easily add hundreds of different brushes. Although it can be nice for marketing, end user will most definitely be lost when using app. Trade-off here could be for example: leaving only those brushes that alpha-version users liked during testing-phase.\n\n3) On the one hand client wants to have app with many functions etc. but for some end users it can be then to big to consider downloading it. The more portable is the app, the more users it will attract.",
      "score": 50,
      "language": "ENGLISH"
    },
    {
      "id": 1634845,
      "meta": {},
      "text": "Cost vs. robustness: The more you want to pay for the development of your product, the more time can be invested into it and the better professionals you'll be able to hire. The more time developers invest into your project, the more bugs and vulnerabilities they will be able to find and fix, which will make the product more robust. For example: The development of “Cyberpunk 2077” was rushed due to time and cost issues, and the game was filled with tons of bugs.\n\nEfficiency vs. portability: To make a software suitable for all kinds of devices, you'll usually have to program them separately, because they use different tech stacks for development. But there are some compilers that will take your code for one device and convert it into the code of another device. For example: You can use React Native to convert your web app into a mobile app, but it wouldn't be as efficient as a natively developed mobile app in Swift or Android Studio.\n\nCost vs. reusability: Similar to the first one, “money equals time” and the more time developers have, the fewer components they have to hard code which then can only be used in one project instead of several. For example: You could create a function that will add 1 and 2 faster than a function that would add any numbers together, although the second one would be more useful if you'll have to add other numbers at some point.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291513,
      "meta": {},
      "text": "Cost vs Robustness: Like in the real world, where cheaper products often imply less quality (german saying: wer billig kauft kauft teuer), the same can be applied to software product. Lower cost often mean less time for the project, or less people working on it. To reduce cost, you could for example just skip two weeks of testing or just not hire any testers at all. The product will be cheaper, because less time and less people, but the robustness will also suffer. Maybe some bugs, which have not been found yet, wont be fixed and weird edge cases have not been found.\n\nFunctionality vs Usability: I think a good example for this are video games. If you start a game, and you get overwhelmed by all the things you can do (maybe all featrues are free to use from the beginning, and there are several worlds and an arena and things to upgrade your character, your gear, your pet etc., you just get overwhelmed by the amout of functionality). An game with less functionalities would be way easier to use.\n\nEfficiency vs portability: Maybe you make a game for the PS5, and you know the hardware etc. perfectly, then you could really use that knowledge and make a really efficient game, which runs very fast because it uses the right way of multi threads, datastructures etc. On the other hand, if you want to expand that game for the nintendo switch, it would be hard because you made the implementation so specific for the PS5.",
      "score": 75,
      "language": "ENGLISH"
    },
    {
      "id": 1292701,
      "meta": {},
      "text": "1. Efficiency vs Portability: there are many different computer architectures, so if you want to make your program more portable it's better to use for example a language like java where you have a virtual machine through which you can run your code on any architecture that has a Java VM. The trade off is that you miss out on optimization aka efficiency which complex instructions (that are different from architecture to architecture) would provide.\n2. Cost vs Reusability: when aiming for Reusability you often find yourself taking the extra time to - for example - develop interfaces for classes that you should be able to replace, document your code and use more inheritance which also needs more expensive testing. But more time spent equals more cost, so when the cost should be low, these are one of the first things getting cut. \n3. Functionality vs usability: if you want to implement more functionality in your application, it's very likely that your user interface gets more and more jammed with long lists of buttons, submenues and confusing symbols. Thus the user experience / usability shrinks. On the other hand if you want your application to be very user friendly, you make it as simplistic as possible with reduced features, where you can get to every functionality in a very small time. For example on Android apps with many features you often find yourself confused, because many functions are hidden behind multiple layers of submenues, while apps with fewer functions often come across with only 1 layers of submenues.",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1344446,
      "meta": {},
      "text": "1. Usability vs. Functionality: The ease of use (usability) and set of operations (functionality) often contradict each other, because with increasing number of functionalities, a system looses the intuitive usage and it becomes more difficult to learn. For example the operation of flying a plane and understanding what each of the buttons does is very complicated to learn, but each of them fulfills a purpose and is therefore needed, however the usability suffers under the many possible actions.\n\n2. Rapid development vs. Functionality: Again the number of functionalities stands against a fast development (rapid) of a system. For example at the beginning of the Covid19 pandemic, it was crucial to get an application to track encounters that could lead to an infection. Over time more and more functionalities were added, but at the beginning it was only the one that was needed the most.\n\n3. Cost vs. robustness: The ability of a system to perform under extreme conditions costs the developers a lot of time and money. An obvious example would be the building of houses that have to endure extreme weather conditions. A cheap house will most likely be demolished during a hurricane, while an expensive one is more likely to survive.",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1350844,
      "meta": {},
      "text": "- Der Kunde möchte, dass die Software sehr schnell entwickelt wird, aber gleichzeitig sehr robust ist. Das ist ein Problem, denn wenn nur wenig Zeit zur verfügung hat, bleibt einem nicht die Zeit alles ausführlich zu Testen.\n- Der Kunde möchte eine hohe Backward compatibility, aber gleichzeitig auch die neuesten Features und Standards nutzen. Das ist ein Problem, denn soll z.B. eine neue Funktion von Android genutzt werden, z.B. ein neues Framework von Android selber, was die Entwicklung vereinfacht, ist dieses oft nicht für altere Android Versionen verfügbar. \n- Der Kunde möchte, dass alles mögliche wenig kostet aber trotzdem eine gut entwickeltes, user firenly Ui haben, aber was nicht möglich ist ohne viel zu testen und Nutzer zur befragen, was viel kostet",
      "score": 66.7,
      "language": "GERMAN"
    },
    {
      "id": 1378878,
      "meta": {},
      "text": "- A product that is too backward compatible is probably not runtime efficient, and for sure not easily maintainable / readability.\nLet's say I create an app that needs to run with all versions of iOS. However, the system has changed entirely in the last years. This means that we'll have to basically create an entire other application. When some new developers needs to update the app he'll need to understand the entire code base before being able to make changes, which results in a not easily maintainable system.\n- A low cost from the client side will reflect in less time for the developers. As they will probably focus on getting all the requested features working, the documentation won't be as good. This will also influence the system's maintainability and, for the end user, his ease of learning. For example, if some parts of the documentation are missing or deprecated, the user won't be able to learn using the system.\n- To achieve great flexibility, and be able to change to market requirements with ease, the system's architecture shouldn't be complex. On the other hand, one could choose to create a system which is complex and flexible, but it will likely not be as performant. In this case we have three design goals which compete against each other.\nFor example we can think of an OS, which is usually quite complex. To add new features there will be a loose in performance.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1468049,
      "meta": {},
      "text": "1. Cost vs reusability\nIf software is programmed with the objective to not only be specific to this project, but also future projects, this takes more time since the developer has to think about what aspects of his implementation should be written differently to serve later on for other purposes. A german language software that finds grammar mistakes could be set up with the exact grammar rules, so it detects mistakes (faster development), or an AI algorithm that searches the web and learns itself which sentences are right or wrong (can be applied to any language later).\n\n2. Functionality vs usability\nA game that let's users fly an airplane on their laptop. The game creator wants the user to be able to sit virtually behind the cockpit and be able to press 100 buttons. Every button does something else -> trigger announcement, fly fast, fly slow, throw people out the back,...\nThe game is called \"calm down flying\" -> the user wants to chill out in the cockpit and see the relaxing landscape.\nAll these functionalities overwhelm him, he needs hours to find out how the airplane takes off.\n\n3. Rapid development vs functionality:\nThe goal of the software engineering team is to develop fast their software. They want to develop a flight simulator, so they put in 5 buttons: \"Take-off\", \"Land\", \"Go faster\", \"Go slower\", \"Announcement\".\nThey finish the game within 2 days. However, the flight simulator functions are limited, and with slower development they could refine these functions, for example put in a joy stick so people can land their plane moving the joy stick instead of just hitting a button.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1290951,
      "meta": {},
      "text": "One of the most prominent design goal trade-offs is functionality vs. usability, this for example could manifest itself in a too detailed user interface (or at least one that isn't well structured), as the end-user could find it hard to maneuver through too many different options and figuring out which ones are needed by him/her.\nAnother design goal trade-off is the cost vs. robustness aspect, which is very present in many software development projects. Here, for example if the development team doesn't spend enough time/money on a load-balancer for the application, in times of high usage the performance will drop drastically.\nThe third and (for now) last design goal trade-off is efficiency vs. portability. This is seen for example in cloud migration; if a system is perfectly adjusted to the server environment of the development-team, a lot of these adjustments have to be changed or even removed to make the projects work in the new (cloud) environment.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1291664,
      "meta": {},
      "text": "Functionality vs Usability: \n\nCode can be very complex, messy and redundant if not implemented cleanly. While it might function correctly, the usability lacks significantly. For example, the code can not be used by colleague developers, or when a bug is found it is too hard to fix, because of how complex the code is. \n\nCost vs Robustness: \n\nExtensive testing can prevent big problems in code that would have instead only been detected too late. So, testing increases the robustness of code. However, your costs will also increase simultaneously. For example big companies like Facebook need to be extremely robust as so many people use it and it can't  afford to have even little downtime, so their costs for testing will probably be proportionately high. \n\nRapid development vs Functionality: \n\nSoftware projects most likely have a due date, until when the intended functionality must be attained. However, it can be the case that the desired functionality can not be attained in the time given for the project. It is a trade off between delivering a system on time which is incomplete or delivering a complete system but late. Do you prioritize the due date or the functionality of the system? Homework in PGdP is a great example. Often it was the case I submitted my homework without fulfilling all the functionalities. But again I didnt have a chance to not hand it in and keep working on it:/\n\n",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1292086,
      "meta": {},
      "text": "1. Usability vs. functionality: Usability of an application or an interface focuses on the learnability, productivity and the experience offered by it. A large number of functions in one user interface can be annoyance that makes interfaces more difficult to learn and use. Functionality is the set of operations that an interface supports. Removing functions can make an interface less powerful.\nExample:\nIf you want to design an aircraft system for a beginner you should make it easy to pilot the aircraft. If you want to design a well functioning aircraft system you should not leave out the operational and safety features of an aircraft.\n\n2. Cost vs. robustness: To develop a software system can take a lot of effort, for example the cost for implementing or testing the system can be high. Robustness is the ability of a computer system to cope with errors during execution and handle with erroneous input. To achieve high robustness it requires code to handle these erros gracefully by displaying accurate and unambiguous error messages. These error messages allow the user to more easily understand where the error occured.\nExample:\nSome software system just need a simple and straightforward implementation like a easy chat system, where you do not have to take in account of erros that lead to dramatic concequence. A online banking system has to be robust to resist against unexpected erros and interventions.\n\n3. Efficiency vs. portability: An efficient computer programm can use the resources optimally where resources could be memory, CPU, databases etc. While portability is a characteristic attributed to a computer program if it can be used in an operating systems other than the one in which it was created without requiring major rework.\nExample:\nSome computer games are single platform and can only run on the operating system Windows 10 for example, but the user can achieve the full play enjoyment. Some computer games are multi platform and can run on different operating system or even on mobile devices, but the experience can differ from good to bad.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1298208,
      "meta": {},
      "text": "Three typical design goal trade-offs would be, for example: \n\n1. cost vs. robustness\n--> In terms of data management and storage, a more robust software would definitely imply higher costs because of the complexity and capacity of the employed data storage and - management system. From a system design perspective, higher demand for system robustness in data management would mean a trade-off against higher costs. \n\n2. efficiency vs. portability\n--> Portability, defined as the ability to run the system on many different devices and platforms, would mean a trade-off of inefficiency in terms of system design. If, for example, a web-based system is to be optimized for all displays of smartphones, computers, and tablets as well as for iOS and Android, this application is most likely to run slower than an iOS-exclusive web system. \n \n3. functionality vs. usability\n--> Functionality would be defined as the ability of the system to provide many different functions and deliver a variety of results to different operations. A higher functionality sacrifices usability because it diversifies the user interface such that the interaction with the user becomes more complex and less intuitive. If, for example, a system design demands that the system supports many different actions from the same application, the user can easily get lost in the UI and that directly is evaluated as a poor usability score. ",
      "score": 83.3,
      "language": "ENGLISH"
    },
    {
      "id": 1303072,
      "meta": {},
      "text": "Efficiency vs Portability\nFor a program to do some function, the number of resources required for computing is called efficiency.\nThe efficiency is more when the performance is high and the number of resources used is more minor.\nPortability basically means the effort used for a software program to get transferred from one environment to other. The complexity of a task is often more than what software can handle, and this translates into a more demanding system. This is usually done in the cloud or on-site. Eg. Large Scale Storage are no doubt more efficient but not easily portable.\nCost vs Robustness\nThe main goal is to reach the desired performance for the process that manufactures some products, by minimizing the cost of operation in a production process, or the variability of quality characteristics by maximizing the yield of the production process.\nEg. A cheap smartphone mostly lacks many functions and is not suitable for long-term usage.\n\nCost vs Reusability\nThe end-user of a software system is often looking for a high level of usability, while the customer is usually looking for a low development cost. This is usually accompanied by an organization that is interested in reusing parts of the system. Eg. Small businesses often focus more on the cost advantage of reusing existing software solutions. Doing so can help them reduce their overall development and deployment costs. In addition, it can help them train their staff members and improve their system's performance.",
      "score": 16.7,
      "language": "ENGLISH"
    },
    {
      "id": 1314790,
      "meta": {},
      "text": "Imagine you got an app which does cover a lot of your daily tasks and needs. This sounds great at the beginning but considering the fact, that this requires a lot of functions and has to fulfill many requirements, the question is that if such an app will be usable at all. In fact apps like that exist: WeChat for example. WeChat is one of the most popular and essential app for the Chinese society. You can call, chat, read news, watch videos, like pictures, pay and make appointments. It's like a social media, planner and bank app at the same time. Thats an example for a design goal trade-off, specifically functionality vs. usability. According to this principle, the more a software or system has functionality, the less it is usable and vice versa. But apps that focus on more functionality aren't necessarily doomed to fail. WeChat as an app plays a big role in China, it's popular and used everyday. Of course, it is not usable and does not have a simple UI as iMessage or WhatsApp, it is a lot more complicated but the people are fine with it. There is one example which failed by focusing more on functionality than usability. This app is no other than iTunes by Apple. Although it is still available on Windows, the app version for Apples macOS is discontinued. It had too many features, e.g organizing music, movies, books and tv-shows bought from an integrated store in iTunes, managing apps, downloading the app packages from the store, restoring iPhones, iPads and iPods and many more things. To its last days, Apple tried to make the app more usable by removing features but the app was still barely usable and overloaded, which eventually lead to its death. RIP 🪦 . On macOS, iTunes got replaced by a couple of apps, which now host most of the features of iTunes. Going to the trade-off principle of Rapid development vs. functionality, we see this in a lot of consumer software today. OS Upgrades for example. You already heard of Windows 11 right? It got announced in June of 2021 and got released in October 2021. It changed most of the UI elements and added a lot of features. Regarding this short time period of active development, it's a total example of a project team adopting the principle of rapid development and not functionality. Windows 11 still has missing features which got announced during the announcement (lol), e.g. android app support. This feature is still in development and is only available for insiders at the moment. Or the taskbar, which has - compared to Windows 10s taskbar- many missing features, including drag-n-drop of icons to the taskbar. The last principle which I am going to talk about is Cost vs. robustness. Very simple to understand: The more financial support a software developer team gets, the more the team can invest in testing their developed software, resulting in a robust program or a program with very little bugs. If there is less money in the game, there is probably also less developers in the team resulting in a cost-efficient development but less robustness considering that the developers might have to work more and therefore are not able to test more intensively than in a team with more developers. Thank you for reading, I hope I didn't annoy you 🥺",
      "score": 0,
      "language": "ENGLISH"
    },
    {
      "id": 1320191,
      "meta": {},
      "text": "1) Runtime vs flexibility : a program (or page) can work very fast, when the user gives the right informations, but it could crash with only giving wrong informations (e.g; string input instead of int)\n\n2)Security  vs cost: security needs more money. (e.g: one of the biggest cause of the high price of the Apple products is that Apple more secure than the others. it's very difficult to hack an iPhone or to become a virus in your iPhone (as far as i know)\n\n3)Technology vs Backward compatibility: a PS4 CD cannot be compatible for PS5, but PS5 is surely more evolved.",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1321004,
      "meta": {},
      "text": "Quick development vs. Functionality:\nEin Produkt kann nicht gleichzeitig sehr schnell entwickelt werden und eine hohe Funktionalität haben. Programmieren von Funktionen braucht Zeit. Somit kann man zum Beispiel durch weglassen von einer gesamten Funktion des Programms die Fertigstellung beschleunigen.\n\nLow Cost vs. Robustness:\nStabilität kostet immer ihren Preis. Es ist schwer preisgünstig die Funktionen eines Programms am laufen zu halten. So braucht man zum Beispiel bessere und damit teurere Server, wenn man außergewöhnlich hohe Nutzerzahlen aushalten will.\n\nBackward compatibility vs. reusability:\nEin Produkt kann nur sehr schwer so schmal und gut sein, dass man es in Zukunft wiederverwenden kann und gleichzeitig für alle älteren Produkte o. ä. weiterhin anwendbar sein.\nEin gutes Beispiel sind die Windows versionen: Es ist schwer einer Version die neusten Features zu verpassen, die zukünftig als Standard zählen und zu versichern, dass die neue Version auch noch auf älteren, leistungsschwächerer Hardware einigermaßen läuft. Somit muss man entscheiden, ob man in Zukunft auf die Software wieder zurückgreifen kann, da sie schon mit den Features umgehen kann oder ob man diese Features weglässt, um die Software Effizienter zu machen.\n\n",
      "score": 100,
      "language": "GERMAN"
    },
    {
      "id": 1321195,
      "meta": {},
      "text": "Rapid development vs. functionality:\nconflict, because a Client would like to have a fast development of a software to start working with it as early as possible.  On the other hand developers have a tighter schedule, which can influence the amount of fuctionality.\nExample: A client wants a new communication software in which employees can have private text chats and calls with each other but only gives 2 weeks as time and developers only could implement the text chat.\n\nFuntionality vs. usability:\nconflict, because if you want a software with high functionalities the usabilty often gets worse. The software is harder to learn, there are many shortcuts a user doesnt know and the menu is more complicated to understand.\nExample:  Think of software like SAP, it is high functional and a great tool for a company, but its hard to learn and experts in SAP are required to use the software with its full abilities.\n\nEfficiency vs. portability:\nconflict, because if you want a portable software, which means it can handle various different architectures like Windows, Linux... on PC and Android, iOS on smartphones you need to create a software which is more general and can handle different architectures, but at the cost of effiency, because you cant get the full performance out of one architecture or system.\nExample: You want to make a App for PC and mobile so you cant focus on one, it has to work on both, not the maximum effiency on both.",
      "score": 100,
      "language": "ENGLISH"
    },
    {
      "id": 1349773,
      "meta": {},
      "text": "One typical design goal trade off os cost vs. reusability. Imagine the example, where a developer has to deliver a product to a client. The developer could either implement it with older technologies (e.g. programming languages and servers) that are cheaper but will not be compatible with future technologies. So the developer has to decide between cost and future reusability.\n\nAnother design goal trade off could be functionality vs usability. A software developer could either focus on creating a \"clean\" and easy to understand user interfece but with restricted functionality, since e.g. some functionalities would not be displayed for reasons of clarity, or he could just design an user interface where all functionalities are displayed but which is totally overloaded and confusing.\n\nLastly, rapid development vs. usbility could also be in conflict. Imagine the situation, where a software engineer has only a very short period of time to develop a software programm, so he focuses on the parts that are crucial for basic functionality and less on asthetics and usability.\n",
      "score": 66.7,
      "language": "ENGLISH"
    },
    {
      "id": 1499296,
      "meta": {},
      "text": "\nEfficiency vs. portability: If a product responds slowly to the user input, or does not facilitate efficient solutions to problems, then it will be replaced by a superior product. In order to maximize the lifespan, the product should be efficient.(efficiency)\nThe client system should be usable on multiple platforms, and should be easily ported to a new architecture, should the need arise. (portability)\n-> Compared to that portability is not that important and that makes efficiency a high priority item.\n\nFunctionality vs. usability: as any good product, it should be as bug-free as possible. that's more important than the usability\n\nCost vs. robustness: You can get robustness with low cost if you use design patterns",
      "score": 41.7,
      "language": "ENGLISH"
    },
    {
      "id": 1648792,
      "meta": {},
      "text": "1.  Low-cost vs.User-friendliness \ndescribes a situation when the client have a tight budget so he is not able to hire good and experienced developers. Thats why he has to hire cheaper and less experienced ones. A good example are applications from little companys, often they have an ill-conceived user interface wich can cause inconveniences and no one can speak there about user-friendliness\n\n2.  Increased productivity vs. minimum of errors. \n Software engineering is a lot of thinking, planing, modeling and overthinking. If you are pushing your limits there will be mistakes after mistakes. Wich can leed to really poor functionality and a maximum of errors. A good example is the game Cyberpunk 2077, where the game was instantly freezing and bugging.\n\n3.Functionality vs. User-friendliness. \nIts hard to have many functions but still be user friendly. The best example are programs like Adobe photoshop or after effects. You have to work with them a lot of to get all the functions.\n\n",
      "score": 58.3,
      "language": "ENGLISH"
    },
    {
      "id": 1658551,
      "meta": {},
      "text": "Functionality vs Usability: A very common trade off that happens when we want to include as many features and functions in our software as possible but because there is such depth, we make it hard for the user to use these features as it can be perceived as overwhelming. A typical example for this are Microsoft Office Products. Here it was necessary for Microsoft to create a software with that is easy to use for  the \"average users\" but still provides a  lot of additional features and functionality for \"professionals\" to fulfill their tasks. (Excel macros etc.) \n\nCost vs Robustness: Is a very common trade off for a lot of software applications that might interact with a lot of data exchanges or users. Providing additional servers for the data or users might lead to an increased robustness of the software, but also results in extra severs costs for the developers/ company behind the software. Sometimes we need to balances the two or weigh the advantages and disadvantages to make a decision between the two. \n\nEfficiency vs. portability: Efficient software makes the most out of the hardware provided to run as efficient as possible, which sounds good at first but results in problems when we consider that in todays world we have a lot of different devices that might not support that efficiency. When developing games we often prefer that our game runs on as many devices as possibles to have a broader market and increase portability instead of making it as efficient as possible with a given hardware.\n",
      "score": 100,
      "language": "ENGLISH"
    }
  ],
  "bonus_points": 0,
  "example_solution": "- Functionality vs. usability\n    - Many functionalities does not necessarily follow usability heuristics\n    - Users might be overwhelmed with too much functionality\n- Cost vs. robustness\n    - Highly robust systems requires higher costs\n    - Example: error handling, security, etc.\n    - Typical issues/trade-offs for start-ups in the mobile app domain\n- Efficiency vs. portability\n    - Highly portable systems are usually not very efficient\n    - Example: a portable real-time game. Frame rates require special graphic cards, which are still very specific to certain machines/operating systems\n- Rapid development vs. functionality\n    - This trade-off relates to the implementation and delivery of a software. \n    - If there is limited time for design, implementation, and delivery with constrained available resources, the functionalities of the software are reduced, in order to ensure on-time delivery.\n- Cost vs. reusability\n    - Assume you model the association between 2 classes with 1-1 multiplicity\n        > Easy to code, low cost tests, not very reusable\n    - Moving from 1-1 multiplicity to a many-many multiplicity\n        > Additional coding and testing costs\n- Backward compatibility vs. readability\n    - Sometimes it is not easy to achieve backward compatibility e.g. due to different hardware. \n",
  "grading_criteria": [
    {
      "id": 6316,
      "title": null,
      "structured_grading_instructions": [
        {
          "id": 14897,
          "credits": 0,
          "feedback": "Your solution contains 100% copied text from the slides. Please note that we will make a note of this case and reserve the right to exclude you from the bonus at any point.",
          "usage_count": 0,
          "grading_scale": "plagiarism",
          "instruction_description": "The student's solution contains 100% copied text from the slides or the textbook (no or < 10 % self-written text). Please notify the plagiarism subteam"
        }
      ]
    },
    {
      "id": 6317,
      "title": "Assessment of design goal trade-offs (1x per Design-Goal Trade-off)",
      "structured_grading_instructions": [
        {
          "id": 14898,
          "credits": 2,
          "feedback": "Correct explanation of the design-goal trade-off and a good example, well done!",
          "usage_count": 3,
          "grading_scale": "Perfect",
          "instruction_description": "**For each** design goal if the student **has** mentioned and explained the design goal trade-off correctly **and** provided and explained a good example that is different from the lecture slides"
        },
        {
          "id": 14899,
          "credits": 1.5,
          "feedback": "Correct explanation of the design-goal trade-off and a good example, but it is not clear how this is a design-goal trade-off. You need to elaborate more on how your example resembles a conflict with another design goal",
          "usage_count": 3,
          "grading_scale": "Good",
          "instruction_description": "**For each** design goal if the student **has** mentioned and explained the design goal trade-off correctly **but** the design goal trade-off is not clear from the example"
        },
        {
          "id": 14900,
          "credits": 1,
          "feedback": "Correct explanation of the design-goal trade-off, well done! But your example is not suitable / missing. You need to elaborate more on how your example resembles a conflict with another design goal",
          "usage_count": 3,
          "grading_scale": "Good",
          "instruction_description": "**For each** design goal if the student **has** mentioned and explained the design goal trade-off correctly **but** mentioned no (suitable) example"
        },
        {
          "id": 14901,
          "credits": 1,
          "feedback": "Good example of the design-goal trade-off, however, please try to elaborate more on the design-goal trade-off.",
          "usage_count": 3,
          "grading_scale": "Good",
          "instruction_description": "**For each** design goal if the student **has not** mentioned and explained the design goal trade-off correctly **but** provided and explained a good example that is different from the lecture slides"
        },
        {
          "id": 14902,
          "credits": 0.5,
          "feedback": "Good example of the design-goal trade-off, but it is not clear how this is a design-goal trade-off. You need to elaborate more on how your example resembles a conflict with another design goal. Also please try to elaborate more on the design-goal trade-off itself.",
          "usage_count": 3,
          "grading_scale": "Weak",
          "instruction_description": "**For each** design goal if the student **has not** mentioned and explained the design goal trade-off correctly **and** the design goal trade-off is not clear from the example"
        },
        {
          "id": 14903,
          "credits": 0,
          "feedback": "Please try to elaborate more on the design-goal trade-off. Also your example is not suitable / missing. You need to elaborate more on how your example resembles a conflict with another design goal",
          "usage_count": 3,
          "grading_scale": "Insufficent",
          "instruction_description": "**For each** design goal if the student **has not** mentioned and explained the design goal trade-off correctly **and** mentioned no (suitable) example"
        }
      ]
    }
  ],
  "problem_statement": "Explain three typical design goal trade-offs in the context of software engineering in your own words by using your own examples.\n\n\n*Requirement: Use your own words and do not just copy the lecture slides nor internet sources! Limit yourself to around 250 words!*",
  "grading_instructions": "<ins>General Grading Scheme:</ins>\n- up to 2P per Design Goal\n- If the student provides more than 3 Design Goal trade-offs, the worst 3 counts. (You can still provide feedback, but under no circumstances publish the evaluation guidelines)\n\n<ins>General Rules:</ins>\n- The 250-word limit is a soft limit, the hard limit is at 500 words. In such cases, please assess the submission with 0 points and reference to the 250-word limit. **DO NOT** communicate the 500-word limit to the students!\n- In case one submission is suspicious of plagiarism, please report the assessment-link with a brief explanation to the plagiarism subteam on Confluence\n- No points for examples from the lecture"
}