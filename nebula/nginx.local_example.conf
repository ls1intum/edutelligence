# ============================================================================
# NEBULA NGINX CONFIGURATION - LOCAL DEVELOPMENT
# ============================================================================
# This configuration is for developers running services locally (not in Docker)
# Services should be running on:
# - Transcriber: localhost:3870
# - FAQ: localhost:3871
#
# TO USE THIS FILE:
# 1. Copy this file to nginx.local.conf
# 2. Start your services locally:
#    - poetry run uvicorn nebula.transcript.app:app --port 3870
#    - poetry run uvicorn nebula.faq.app:app --port 3871
# 3. Run: docker compose -f docker/nginx-only.yml up
# 4. Access the gateway at http://localhost:3007
# ============================================================================

events {
    worker_connections 1024;
}

http {
    # DNS resolver - use system resolver from /etc/resolv.conf
    resolver local=on valid=30s ipv6=off;

    # ========================================================================
    # USER CONFIGURATION SECTION - EDIT THESE VALUES
    # ========================================================================

    # API Key that clients must send in Authorization header
    # Example: Authorization: your-secret-key-here
    map $http_authorization $api_key_valid {
        default 0;
        "nebula-secret" 1;  # CHANGE THIS to your actual API key for local dev
        # Add more keys if needed:
        # "dev-key-123" 1;
        # "test-key" 1;
    }

    # Upstream service definitions - pointing to host machine
    # host.docker.internal works on Docker Desktop for Mac/Windows
    # For Linux, you might need to use the actual host IP or configure extra_hosts
    upstream transcriber_backend {
        server host.docker.internal:3870;  # Local transcriber service
    }

    upstream faq_backend {
        server host.docker.internal:3871;  # Local FAQ service (note: different port)
    }

    # ========================================================================
    # MAIN SERVER CONFIGURATION
    # ========================================================================
    server {
        # --------------------------------------------------------------------
        # BASIC CONFIGURATION
        # --------------------------------------------------------------------

        # Server configuration for local development
        server_name localhost;
        listen 3007;  # Development port - accessible at http://localhost:3007

        # ====================================================================
        # ENDPOINT DEFINITIONS (DO NOT EDIT BELOW THIS LINE)
        # ====================================================================
        # WARNING: The configuration below contains complex routing logic and
        # Lua scripts. Only modify if you know what you're doing!
        # ====================================================================

        # --------------------------------------------------------------------
        # HEALTH CHECK ENDPOINTS (Public - No API Key Required)
        # --------------------------------------------------------------------

        # Aggregated health check - checks all upstream services
        location /health {
            access_log off;
            default_type application/json;

            content_by_lua_block {
                local cjson = require "cjson"
                local http = require "resty.http"

                local function check_service(name, host, port, path)
                    local httpc = http.new()
                    httpc:set_timeout(2000) -- 2 second timeout

                    -- Connect using host and port separately to use nginx resolver
                    local ok, err = httpc:connect(host, port)
                    if not ok then
                        return {
                            status = "unhealthy",
                            error = err or "Connection failed"
                        }
                    end

                    local res, err = httpc:request({
                        path = path,
                        method = "GET",
                        headers = {
                            ["Host"] = host .. ":" .. port,
                            ["Content-Type"] = "application/json",
                        }
                    })

                    if not res then
                        return {
                            status = "unhealthy",
                            error = err or "Connection failed"
                        }
                    end

                    -- Read the body
                    local body = res:read_body()

                    -- Close the connection
                    httpc:close()

                    if res.status == 200 then
                        -- Try to parse JSON response from service
                        local ok, service_health = pcall(cjson.decode, body)
                        if ok then
                            return service_health
                        else
                            -- If not JSON, just return status
                            return {
                                status = "healthy",
                                response = body
                            }
                        end
                    else
                        return {
                            status = "unhealthy",
                            http_status = res.status,
                            error = body or "HTTP " .. res.status
                        }
                    end
                end

                -- Check each service on localhost ports
                local transcriber_health = check_service("transcriber", "host.docker.internal", 3870, "/transcribe/health")
                local faq_health = check_service("faq", "host.docker.internal", 3871, "/faq/health")

                -- Determine overall status
                local overall_status = "healthy"
                if transcriber_health.status == "unhealthy" or faq_health.status == "unhealthy" then
                    overall_status = "unhealthy"
                elseif transcriber_health.status == "degraded" or faq_health.status == "degraded" then
                    overall_status = "degraded"
                end

                -- Compose response
                local response = {
                    status = overall_status,
                    timestamp = ngx.now() * 1000, -- milliseconds
                    services = {
                        transcriber = transcriber_health,
                        faq = faq_health
                    }
                }

                ngx.status = overall_status == "healthy" and 200 or 503
                ngx.say(cjson.encode(response))
            }
        }

        # --------------------------------------------------------------------
        # PROTECTED API ENDPOINTS (Require Valid API Key)
        # --------------------------------------------------------------------
        location ~ ^/(transcribe|faq)/ {
            # Check if API key is valid (uses map defined above)
            if ($api_key_valid = 0) {
                return 401 '{"error": "Unauthorized - Valid API key required in Authorization header"}\n';
            }

            # Route to appropriate backend service
            if ($uri ~ ^/transcribe/) {
                proxy_pass http://transcriber_backend;
            }

            if ($uri ~ ^/faq/) {
                proxy_pass http://faq_backend;
            }

            # Proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Authorization $http_authorization;

            # Timeout settings for long-running operations
            proxy_connect_timeout 6000s;
            proxy_send_timeout 6000s;
            proxy_read_timeout 6000s;
        }

        # --------------------------------------------------------------------
        # ROOT ENDPOINT (Public Information)
        # --------------------------------------------------------------------
        location / {
            return 200 "Nebula API Gateway (Local Development)\n\nRunning on: http://localhost:3007\n\nAvailable services:\n- /transcribe/ (requires API key) -> localhost:3870\n- /faq/ (requires API key) -> localhost:3871\n- /health (public)\n\nSend API key in 'Authorization' header\n\nMake sure your services are running locally:\n- Transcriber: poetry run uvicorn nebula.transcript.app:app --port 3870\n- FAQ: poetry run uvicorn nebula.faq.app:app --port 3871\n";
            add_header Content-Type text/plain;
        }

        # --------------------------------------------------------------------
        # ERROR PAGES
        # --------------------------------------------------------------------
        error_page 404 /404.html;
        location = /404.html {
            return 404 "Not Found\n";
            add_header Content-Type text/plain;
        }

        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            return 500 "Internal Server Error\n";
            add_header Content-Type text/plain;
        }
    }

    # ========================================================================
    # GLOBAL SETTINGS
    # ========================================================================

    # Logging configuration (stdout/stderr for Docker)
    access_log /dev/stdout;
    error_log /dev/stderr;

    # Security headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Referrer-Policy strict-origin-when-cross-origin;
}
