# ============================================================================
# NEBULA NGINX CONFIGURATION
# ============================================================================
# This configuration uses OpenResty (nginx with Lua support) for advanced
# health checking and API gateway functionality.
#
# TO USE THIS FILE:
# 1. Copy this file to nginx.production.conf (or nginx.local.conf for local dev)
# 2. Edit the configuration values in the USER CONFIGURATION SECTION below
# 3. Run docker compose with your configuration
# ============================================================================

events {
    worker_connections 1024;
}

http {
    # ========================================================================
    # USER CONFIGURATION SECTION - EDIT THESE VALUES
    # ========================================================================

    # API Key that clients must send in Authorization header
    # Example: Authorization: your-secret-key-here
    map $http_authorization $api_key_valid {
        default 0;
        "nebula-secret" 1;  # CHANGE THIS to your actual API key
        # Add more keys if needed:
        # "another-valid-key" 1;
        # "team-key-123" 1;
    }

    upstream transcriber_backend {
        server transcriber:3870;
    }

    upstream faq_backend {
        server faq:3871;
    }

    # ========================================================================
    # MAIN SERVER CONFIGURATION
    # ========================================================================
    server {
        # --------------------------------------------------------------------
        # BASIC CONFIGURATION - EDIT THESE
        # --------------------------------------------------------------------

        # Server name and ports
        server_name localhost;  # CHANGE to your domain (e.g., api.example.com)
        listen 80;

        # Uncomment the following line to enable HTTPS:
        # listen 443 ssl http2;  # CHANGE port if needed

        # --------------------------------------------------------------------
        # SSL/TLS CONFIGURATION - UNCOMMENT AND EDIT FOR HTTPS
        # --------------------------------------------------------------------

        # SSL Certificate paths - REQUIRED for HTTPS
        # ssl_certificate /path/to/your/certificate.crt;  # CHANGE to your cert path
        # ssl_certificate_key /path/to/your/private.key;  # CHANGE to your key path

        # SSL Security Configuration (recommended defaults, usually no need to change)
        # ssl_protocols TLSv1.2 TLSv1.3;
        # ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK;
        # ssl_prefer_server_ciphers on;
        # ssl_session_timeout 1d;
        # ssl_session_cache shared:SSL:50m;
        # ssl_stapling on;
        # ssl_stapling_verify on;

        # --------------------------------------------------------------------
        # OPTIONAL: HTTPS ENFORCEMENT - UNCOMMENT TO FORCE HTTPS
        # --------------------------------------------------------------------

        # Redirect all HTTP traffic to HTTPS
        # if ($scheme = http) {
        #     return 301 https://$server_name$request_uri;
        # }

        # Enable HSTS (tells browsers to always use HTTPS)
        # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        # ====================================================================
        # ENDPOINT DEFINITIONS (DO NOT EDIT BELOW THIS LINE)
        # ====================================================================
        # WARNING: The configuration below contains complex routing logic and
        # Lua scripts. Only modify if you know what you're doing!
        # ====================================================================

        # --------------------------------------------------------------------
        # HEALTH CHECK ENDPOINTS (Public - No API Key Required)
        # --------------------------------------------------------------------

        # Aggregated health check - checks all upstream services
        location /health {
            access_log off;
            default_type application/json;

            content_by_lua_block {
                local cjson = require "cjson"
                local http = require "resty.http"

                local function check_service(name, host, port, path)
                    local httpc = http.new()
                    httpc:set_timeout(2000) -- 2 second timeout

                    -- Connect using host and port separately
                    local ok, err = httpc:connect(host, port)
                    if not ok then
                        return {
                            status = "unhealthy",
                            error = err or "Connection failed"
                        }
                    end

                    local res, err = httpc:request({
                        path = path,
                        method = "GET",
                        headers = {
                            ["Host"] = host .. ":" .. port,
                            ["Content-Type"] = "application/json",
                        }
                    })

                    if not res then
                        return {
                            status = "unhealthy",
                            error = err or "Connection failed"
                        }
                    end

                    -- Read the body
                    local body = res:read_body()

                    -- Close the connection
                    httpc:close()

                    if res.status == 200 then
                        -- Try to parse JSON response from service
                        local ok, service_health = pcall(cjson.decode, body)
                        if ok then
                            return service_health
                        else
                            -- If not JSON, just return status
                            return {
                                status = "healthy",
                                response = body
                            }
                        end
                    else
                        return {
                            status = "unhealthy",
                            http_status = res.status,
                            error = body or "HTTP " .. res.status
                        }
                    end
                end

                -- Check each service (using service container names)
                local transcriber_health = check_service("transcriber", "transcriber", 3870, "/transcribe/health")
                local faq_health = check_service("faq", "faq", 3871, "/faq/health")

                -- Determine overall status
                local overall_status = "healthy"
                if transcriber_health.status == "unhealthy" or faq_health.status == "unhealthy" then
                    overall_status = "unhealthy"
                elseif transcriber_health.status == "degraded" or faq_health.status == "degraded" then
                    overall_status = "degraded"
                end

                -- Compose response
                local response = {
                    status = overall_status,
                    timestamp = ngx.now() * 1000, -- milliseconds
                    services = {
                        transcriber = transcriber_health,
                        faq = faq_health
                    }
                }

                ngx.status = overall_status == "healthy" and 200 or 503
                ngx.say(cjson.encode(response))
            }
        }

        # --------------------------------------------------------------------
        # PROTECTED API ENDPOINTS (Require Valid API Key)
        # --------------------------------------------------------------------
        location ~ ^/(transcribe|faq)/ {
            # Check if API key is valid (uses map defined above)
            if ($api_key_valid = 0) {
                return 401 '{"error": "Unauthorized - Valid API key required in Authorization header"}\n';
            }

            # Route to appropriate backend service
            if ($uri ~ ^/transcribe/) {
                proxy_pass http://transcriber_backend;
            }

            if ($uri ~ ^/faq/) {
                proxy_pass http://faq_backend;
            }

            # Proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Authorization $http_authorization;

            # Timeout settings for long-running operations
            proxy_connect_timeout 6000s;
            proxy_send_timeout 6000s;
            proxy_read_timeout 6000s;
        }

        # --------------------------------------------------------------------
        # ROOT ENDPOINT (Public Information)
        # --------------------------------------------------------------------
        location / {
            return 200 "Nebula API Gateway\nAvailable services:\n- /transcribe/ (requires API key)\n- /faq/ (requires API key)\n- /health (public)\n\nSend API key in 'Authorization' header\n";
            add_header Content-Type text/plain;
        }
    }

    # ========================================================================
    # GLOBAL SETTINGS (Usually no need to edit)
    # ========================================================================

    # Logging configuration (stdout/stderr for Docker)
    access_log /dev/stdout;
    error_log /dev/stderr;

    # Security headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Referrer-Policy strict-origin-when-cross-origin;
}
