id,title,exercise_id,exercise_title,exercise_problem_statement
299,Praktikum: Grundlagen der Programmierung WS23/24,11604,W01P01 - Hello World,"# Hallo Pinguine!

Die Pinguine sind zu ihrer ersten Stunde `Praktikum: Grundlagen der Pinguine` ... äh `Praktikum: Grundlagen der Programmierung` zusammengekommen. Da sie aber sehr schüchtern sind, musst du sie zuerst begrüßen.

### Teil 1: Einrichten der IDE

Installiere dafür zuerst Java und Eclipse oder IntelliJ (bzw. eine andere IDE). Eine Anleitung hierfür gibt es auf Artemis und wird in der Tutorübung besprochen. Stelle sicher, dass alles korrekt installiert ist und die geforderten Einstellungen bezüglich des Encodings gesetzt wurden. Frage bei allen Problemen einen Tutor bzw. sieh im Zulip-Stream [\#PGdP-Technik](https://zulip.in.tum.de/#narrow/stream/1243-PGdP-Technik) nach und frage gegebenenfalls dort nach.

### Teil 2: Hallo sagen

Nun geht es darum die ersten Wörter auszugeben:

1. [task][""Hallo Pinguine!"" auf der Konsole ausgeben]( 155104 )
  Um etwas auszugeben, nutze die Funktion `System.out.println()`. Zwischen den Klammern kannst du in Anführungszeichen eine Zeichenkette angeben, die ausgegeben werden soll. Beim Aufruf eures Programmes wird dann der Code innerhalb der main-Methode ausgeführt. Probiere nun direkt einmal "" Hallo⎵Pinguine! "" mithilfe der Klasse `HelloPenguins` auszugeben.
**Tipp:** Kopiere die auszugebende Nachricht einfach direkt immer aus der Aufgabenstellung. Ersetze dabei das Zeichen ⎵ aber jeweils durch ein Leerzeichen. Fehlerhafte Ausgaben können nämlich zu unnötigem Punktabzug führen!

### Teil 3: Neue Quelldatei ###

Um einen zweiten Satz auszugeben, soll zunächst eine neue Quelldatei erstellt werden:

2. [task][Erstellen einer weiteren Klasse]( 155101 )
   Erstelle eine neue Quelldatei `PracticalCourse.java` im gleichen Verzeichnis wie `HelloPenguins.java`. Kopiere den Code aus `HelloPenguins.java` und passe den Klassennamen an, sodass er zum neuen Dateinamen passt.
3. [task][Weitere Ausgabe]( 155103 )
   Gebe nun mithilfe der neu erstellten Klasse `PracticalCourse` statt "" Hallo⎵Pinguine! "" den neuen Text "" Ich⎵freue⎵mich⎵übermäßig⎵auf⎵PGdP! "" auf der Konsole aus."
299,Praktikum: Grundlagen der Programmierung WS23/24,11657,W02P01 - Funktionen,"# Funktionen

Klone das Template-Repository und fülle in der Klasse `Functions` die leeren Funktionen nach folgenden Beschreibungen aus!

### [task][Funktionen Hoch Drei]( 156718 )

Ergänze die Funktion `cube()` so, dass sie die übergebene Zahl hoch 3 nimmt und das Ergebnis zurückgibt.
Der Aufruf `cube(2)` soll also beispielsweise `8` zurückgeben, der Aufruf `cube(-5)` soll `-125` zurückgeben.

### [task][Eine ganz Durchschnittliche Funktion]( 156720 )

Ergänze die Funktion `average()` so, dass sie den Durchschnitt der übergebenen drei Zahlen `a`, `b` und `c` berechnet.
Du darfst dabei davon ausgehen, dass der Durchschnitt immer eine ganze Zahl ist. D.h. Tripel, bei denen der Durchschnitt keine ganze Zahl ist wie z.B. `a = 1`, `b = 2` und `c = 4` - hier wäre der Durchschnitt `2.33333 ...` - werden in unseren Tests nicht übergeben.

### [task][Pythagoreische Tripel]( 156719 )

Ergänze die Funktion `isPythagoreanTriple()` so, dass diese `true` genau dann zurückgibt, wenn die übergebenen drei Zahlen ein sogenanntes 'Pythagoreisches Tripel' bilden. Ein Tripel $$(a, b, c)$$ is dabei genau dann ein 'Pythagoreisches Tripel', wenn $$a^2 + b^2 = c^2$$.

**Einschränkung:** Benutze beim Lösen dieser Teilaufgabe keine arithmetischen Operationen wie `+`, `-`, `*` und `/`. Nur Vergleiche wie `>`, `<` und `==` sind erlaubt. Greife stattdessen auf die bereits im Template implementierten Methoden `square()` und `sumOfSquares()` zurück.

**Hinweis:** Beachte, dass Reihenfolge des Tupels wichtig ist! $$(3, 4, 5)$$ ist ein Pythagoreisches Tupel, da $$3^2 + 4^2 = 9 + 16 = 25 = 5^2$$, aber $$(3, 5, 4)$$ ist kein Pythagoreisches Tupel, da $$3^2  + 5^2 = 9 + 25 = 34 \neq 16 = 4^2$$."
299,Praktikum: Grundlagen der Programmierung WS23/24,11658,W02P02 - Konstrollstrukturen I,"# Kontrollstrukturen I

Implementiere folgende sechs Funktionen in der Datei `ControlStructuresI` im Code-Template dieser Aufgabe.
Verwende dabei keine Java-Bibliotheken wie `Math`. Die Befehle `System.out.print()` *(übergebenen Text auf Konsole ausgeben)* und `System.out.println()` *(übergebenen Text auf Konsole ausgeben und Zeilenumbruch - ""\n"" - am Ende anfügen)* bilden hierfür Ausnahmen. Sie dürfen (und müssen) verwendet werden. Verwende außerdem keine `for`-Schleifen. Die sind dann in der nächsten Aufgabe dran.
Nutze die vorgegebene `main()`-Methode zum Testen deines Codes. Sie muss für vollständiges Lösen dieser Aufgabe keinen speziellen Inhalt haben.

 

### [task][Collatz-Folge]( 156736 )

Die Collatz-Folge ist eine mathematische Folge, die wie folgt definiert ist:
- Beginne mit irgendeiner natürlichen Zahl $$n > 0$$.
- Ist $$n$$ gerade, so nimm als nächstes $$\frac{n}{2}$$.
- Ist $$n$$ ungerade, so nimm als nächstes $$3 * n + 1$$.
- Wiederhole die Vorgehensweise mit der erhaltenen Zahl.

Die bislang unbewiesene Collatz-Vermutung besagt, dass diese Folge für alle natürlichen Zahlen $$n$$ im Zyklus $$(4, 2, 1)$$ mündet.

Ergänze die Methode `printCollatz()` in `ControlStucturesI.java` so, dass diese die von dem Parameter $$n$$ ausgehende Collatz-Folge berechnet, bis die $$1$$ erreicht wurde. Dein Programm soll alle Zahlen der Folge durch Leerzeichen getrennt am Bildschirm ausgeben. Ist die eingegebene Zahl $$n \leq 0$$, soll "" Eingabe⎵muss⎵größer⎵als⎵0⎵sein! "" ausgegeben werden. Zusätzlich soll dein Programm die Länge der Folge mitzählen und abschließend in einer neuen Zeile "" Länge:⎵ "" sowie die Länge der Folge ausgeben.

*Hinweis:* Benutze `System.out.print()`, um einen Text auf der Konsole ohne Zeilenumbruch danach und `System.out.println()` um einen Text auf der Konsole mit Zeilenumbruch danach auszugeben. Probiere die beiden Befehle in der `main()`-Methode aus!

####Beispiele

1. Ausgabe für Parameter 0:
```text
Eingabe muss größer als 0 sein!
```
2. Ausgabe für Parameter 4:
```text
4 2 1
Länge: 3
```
3. Ausgabe für Parameter 11:
```text
11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
Länge: 15
```
4. Ausgabe für Parameter 27:
```text
27 82 41 124 62 31 94 47 142 71 214 107 322 161 484 242 121 364 182 91 274 137 412 206 103 310 155 466 233 700 350 175 526 263 790 395 1186 593 1780 890 445 1336 668 334 167 502 251 754 377 1132 566 283 850 425 1276 638 319 958 479 1438 719 2158 1079 3238 1619 4858 2429 7288 3644 1822 911 2734 1367 4102 2051 6154 3077 9232 4616 2308 1154 577 1732 866 433 1300 650 325 976 488 244 122 61 184 92 46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1
Länge: 112
```
*Hinweis: Dein Programm soll alle Folgenglieder in einer Zeile ausgeben, die Zeilenumbrüche sind nur der Darstellung halber hier*



 

### [task][Zweier-Potenzen]( 156725 )

Ergänze die Methode `printPowersOfTwoUpTo()` so, dass sie alle Zweierpotenzen (von $$2^0$$ an), die kleiner gleich dem Parameter `n` sind, in aufsteigender Reihenfolge mit je einem Leerzeichen getrennt ausgibt. Am Ende der Textausgabe sollte kein Leerzeichen mehr stehen.
Ist die eingegebene Zahl $$n \leq 0$$, soll "" Eingabe⎵muss⎵größer⎵als⎵0⎵sein! "" ausgegeben werden.

####Beispiele:

1. Ausgabe mit Parameter 0:
```text
Eingabe muss größer 0 sein!
```
2. Ausgabe mit Parameter 7:
```text
1 2 4
```
3. Ausgabe mit Parameter 8:
```text
1 2 4 8
```
4. Ausgabe mit Parameter 9:
```text
1 2 4 8
```
5. Ausgabe mit Parameter 1 000 000:
```text
1 2 4 8 16 32 64 128 256 512 1024 2048 4096 8192 16384 32768 65536 131072 262144 524288
```



 

### [task][Dreiecke aus Sternchen]( 156741 )

Ergänze die Methode `printTriangle()` so, dass sie auf der Konsole ein Dreieck aus '*'-Charakteren mit Seitenlänge `sideLength` ausgibt, wie in den Beispielen gezeigt.

####Beispiele:
1. Ausgabe mit Parameter 0:
```text
Eingabe muss größer als 0 sein!
```
2. Ausgabe mit Parameter 1:
```text
*
```
3. Ausgabe mit Parameter 3:
```text
***
**
*
```
4. Ausgabe mit Parameter 6:
```text
******
*****
****
***
**
*
```



 

### [task][Anzahl Ziffern]( 156722 )

Ergänze die Methode `calculateNumberOfDigits()` so, dass sie für eine übergebene Zahl $$n \geq 0$$ die Anzahl an Ziffern (in dezimaler Schreibweise) dieser zurückgibt. Wie übergebene Werte $$< 0$$ von der Methode behandelt werden, ist irrelevant. Die Tests überprüfen solche Werte nicht.

####Beispiele:
1. Für Eingabe `0` sollte die Zahl `0` zurückgegeben werden.
2. Für Eingabe `7` sollte die Zahl `1` zurückgegeben werden.
3. Für Eingabe `37` sollte die Zahl `2` zurückgegeben werden.
4. Für Eingabe `1 234 567` sollte die Zahl `7` zurückgegeben werden.



 

### [task][Zahlen Umdrehen]( 156724 )

Ergänze die Methode `reverseNumber()` so, dass diese eine übergebene Zahl $$0 \leq n \leq 999\;999\;999$$ umdreht. D.h. es soll die Zahl zurückgegeben werden, die im Dezimalsystem mit genau der gleichen Ziffernfolge, nur in umgekehrter Reihenfolge dargestellt wird. Falls die übergebene Zahl in Nullen endet, sollen diese als führende Ziffern der umgekehrten Zahl weggelassen werden. D.h. 10 kehrt sich zu 01 um, was 1 entspricht, wenn man die führenden Nullen weglässt. Ebenso kehrt sich 100 zu 1 um. Und 1000 und 10000 usw.
Wie übergebene Werte außerhalb des gegebenen Bereiches von der Methode behandelt werden, ist irrelevant. Die Tests überprüfen solche Werte nicht.

####Beispiele:
1. Für Eingabe `0` soll der Rückgabewert `0` produziert werden.
2. Für Eingabe `5` soll der Rückgabewert `5` produziert werden.
3. Für Eingabe `127` soll der Rückgabewert `721` produziert werden.
4. Für Eingabe `6 148 229` soll der Rückgabewert `9 228 416` produziert werden.
5. Für Eingabe `1 200` soll der Rückgabewert `21` produziert werden.



 

### [task][Palindrome]( 156743 )

Ergänze die Methode `isPalindrome()` so, dass diese `true` zurückgibt, wenn die übergebene Zahl in Dezimaldarstellung ein Palindrom ist und `false`, wenn nicht. Ein Palindrom ist eine Zeichenfolge (hier: Ziffernfolge), die von vorwärts und rückwäarts gelesen gleich sind.

####Beispiele:
1. Für folgende Eingaben sollte `true` zurückgegeben werden:
`0`, `1`, `7`, `22`, `616`, `5005`, `1_234_554_321`
2. Für folgende Eingaben sollte `false` zurückgegeben werden:
`21`, `264`, `5015`, `1_212_121_212`

 

# FAQ
### Q: Wofür ist das FAQ?
A: Um häufig gestellte Fragen zu sammeln. Wer trotzdem noch fragt macht Pinguine traurig.
### Q: Was bedeutet `org.opentest4j.AssertionFailedError:[...] ==> expected: <2> but was: <1>`
A: Eine Zeile gilt nur als beendet, wenn ein sogenanntes Endzeichen kommt. 
`\n` Kann in einem String hinzugefügt werden um einen Zeilenumbruch zu verurschen.
Die oben genannte Fehlermeldung bedeutet dass ihr eine Zeile zu wenig ausgebt.
Dies liegt vermutlich daran, dasss ihr `System.out.print()` verwendet welches im Vergleich zu `println()` keinen Zeilenumbruch ausgibt."
299,Praktikum: Grundlagen der Programmierung WS23/24,11659,W02P03 - Kontrollstrukturen II,"# Kontrollstrukturen II

Implementiere die folgenden vier Funktionen in der Datei `ControlStructuresII.java`!

### [task][Three and Seven]( 156764 )

Vervollständige die Methode `threeAndSeven()` so, dass diese die Summe aller positiven Zahlen, die durch 3 oder 7 teilbar und kleiner oder gleich einer gegebenen natürlichen Zahl `n` sind, berechnet und zurückgibt.
Wird eine Zahl $$< 0$$ übergeben, soll dies durch eine Konsolen-Ausgabe bemerkt werden: "" Eingabe⎵muss⎵größer⎵oder⎵gleich⎵0⎵sein! ""
und die Funktion soll `-1` zurückgeben.
Wird z.B. die Zahl 25 übergeben, müssen die Zahlen 3, 6, 7, 9, 12, 14, 15, 18, 21
und 24 summiert werden, was 129 ergibt.

####Beispiele:
1. Eingabe `-2`:
Produziert die Konsolen-Ausgabe
```
Eingabe muss größer oder gleich 0 sein!
```
2. Eingabe `7` $$\rightarrow$$ Ausgabe `16`
3. Eingabe `25` $$\rightarrow$$ Ausgabe `129`
4. Eingabe `92` $$\rightarrow$$ Ausgabe `1822`





### [task][ASCII]( 156744 )

Vervollständige die Methode `printAsciiCodesFor()`. Diese soll für den Character `start` den ASCII-Code mit dem Satz "" Der⎵ASCII-Code⎵von⎵' \ '⎵ist⎵ \ . "" in einer Zeile ausgeben. Dies soll es auch für den nächsten Character (mit dem nächstgrößeren ASCII-Code) machen, bis für `count` Character der ASCII-Code ausgegeben wurde. Man bekommt das ASCII Zeichen, indem man `(char)` vor den Wert setzt. Bei `(char) 97` würde z.B. das kleine a rauskommen.

####Beispiele:
1. `printAsciiCodesFor('a', 5)` soll folgende Ausgabe produzieren:
```text
Der ASCII-Code von 'a' ist 97.
Der ASCII-Code von 'b' ist 98.
Der ASCII-Code von 'c' ist 99.
Der ASCII-Code von 'd' ist 100.
Der ASCII-Code von 'e' ist 101.
```
2. `printAsciiCodesFor('X', 10)` soll folgende Ausgabe produzieren:
```text
Der ASCII-Code von 'X' ist 88.
Der ASCII-Code von 'Y' ist 89.
Der ASCII-Code von 'Z' ist 90.
Der ASCII-Code von '[' ist 91.
Der ASCII-Code von '\' ist 92.
Der ASCII-Code von ']' ist 93.
Der ASCII-Code von '^' ist 94.
Der ASCII-Code von '_' ist 95.
Der ASCII-Code von '`' ist 96.
Der ASCII-Code von 'a' ist 97.
```
3. `printAsciiCodesFor('*', 8)` soll folgende Ausgabe produzieren:
```text
Der ASCII-Code von '*' ist 42.
Der ASCII-Code von '+' ist 43.
Der ASCII-Code von ',' ist 44.
Der ASCII-Code von '-' ist 45.
Der ASCII-Code von '.' ist 46.
Der ASCII-Code von '/' ist 47.
Der ASCII-Code von '0' ist 48.
Der ASCII-Code von '1' ist 49.
```

Folgende [ASCII-Tabelle](https://www.torsten-horn.de/techdocs/ascii.htm) mag für's Testen der Implementierung nützlich sein.





### [task][Multiplikations-Tabelle]( 156745 )

Vervollständige die Methode `printMultiplicationTable()` so, dass diese bei Eingabe `n` eine n*n-Multiplikations-Tabelle wie in den Beispielen gezeigt ausgibt.
Die Tabellen müssen nur bis `n = 30` korrekt formatiert sein. Es reicht also, wenn du nach jeder Zahl/jedem Zeichen in der Tabelle zum nächsten Tab springst. Verwende hierzu den Character `\t`.

Da die genaue Anzahl an Leerzeichen in der Tabelle umständlich zu beschreiben bzw. die Tabelle bei ungenauer Beschreibung schwierig zu testen wäre, gibt es für diese Teilaufgabe keine Unit-Tests.
Du solltest allerdings nach Augenmaß leicht feststellen können, ob deine Tabelle hübsch formatiert ist oder nicht. Eine übersichtliche Formatierung zu erhalten mag ein bisschen Fingerspitzengefühl und Fine-Tuning der genauen Abstände/Anzahl an Strichen verlangen. Wie ihr anhand des zweiten Beispiels seht, kann das selbst Artemis nicht so richtig ;-)

####Beispiele:
1. `printMultiplicationTable(2)` sollte folgende Ausgabe produzieren:
```text
*	|	1	2	
----------------
1	|	1	2	
2	|	2	4	
```
2. `printMultiplicationTable(15)` sollte folgende Ausgabe produzieren:
```text
*	|	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	
--------------------------------------------------------------------
1	|	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	
2	|	2	4	6	8	10	12	14	16	18	20	22	24	26	28	30	
3	|	3	6	9	12	15	18	21	24	27	30	33	36	39	42	45	
4	|	4	8	12	16	20	24	28	32	36	40	44	48	52	56	60	
5	|	5	10	15	20	25	30	35	40	45	50	55	60	65	70	75	
6	|	6	12	18	24	30	36	42	48	54	60	66	72	78	84	90	
7	|	7	14	21	28	35	42	49	56	63	70	77	84	91	98	105	
8	|	8	16	24	32	40	48	56	64	72	80	88	96	104	112	120	
9	|	9	18	27	36	45	54	63	72	81	90	99	108	117	126	135	
10	|	10	20	30	40	50	60	70	80	90	100	110	120	130	140	150	
11	|	11	22	33	44	55	66	77	88	99	110	121	132	143	154	165	
12	|	12	24	36	48	60	72	84	96	108	120	132	144	156	168	180	
13	|	13	26	39	52	65	78	91	104	117	130	143	156	169	182	195	
14	|	14	28	42	56	70	84	98	112	126	140	154	168	182	196	210	
15	|	15	30	45	60	75	90	105	120	135	150	165	180	195	210	225	
```




### [task][Primzahlen Ausgeben]( 156762 )

Vervollständige die Methode `printPrimesUpTo()` so, dass für eine übergebene Zahl `n` alle Primzahlen kleiner gleich dieser Zahl auf der Konsole - mit je einem Leerzeichen getrennt - ausgegeben werden.

####Beispiele:
1. `printPrimesUpTo(1)` sollte folgende Konsolenausgabe produzieren:
```text

```
2. `printPrimesUpTo(7)` sollte folgende Konsolenausgabe produzieren:
```text
2 3 5 7
```
3. `printPrimesUpTo(100)` sollte folgende Konsolenausgabe produzieren:
```text
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
```"
299,Praktikum: Grundlagen der Programmierung WS23/24,11660,W02P04 - Taschenrechner,"# Taschenrechner
Du sollst einen einfachen, konsolenbasierten Taschenrechner implementieren. Dabei soll der Nutzer zuerst nach der Operation gefragt werden, die durchgeführt werden soll. 
Dazu werden die zur Verfügung stehenden Operationen des Taschenrechners `+`,`-`,`*`,`/`, `%` und `Programm beenden` über Zahlen kodiert.
Die Eingabeaufforderung soll wie folgt aussehen:
```
Wählen Sie eine Operation:
1) +
2) -
3) *
4) /
5) %
6) Programm beenden
```

Der Nutzer soll anschließend eine ganze Zahl von `1` bis `6` eingeben, um festzulegen, was getan werden soll.
Falls der Nutzer sich für Option `6` entschieden hat, wird das Programm beendet.
Falls er sich für eine Option von `1` bis `5` entschieden hat, werden die beiden ganzzahligen Operanden mit "" Ersten⎵Operanden⎵eingeben: "" und "" Zweiten⎵Operanden⎵eingeben: "" nacheinander vom Nutzer abgefragt.
Das Programm soll dann das Ergebnis der Operation ausgeben (Hier könnte sich ein `switch` lohnen). Anschließend geht es von vorne los und es wird wieder nach der nächsten Operation gefragt.

Überprüfe jeweils, ob versucht wird, durch 0 zu teilen bzw. den Rest bzgl. 0 zu berechnen! Gib dann die Meldung "" Fehler:⎵Division⎵durch⎵0! "" anstelle des Ergebnisses aus.
Wird bei der Frage nach der auszuführenden Operation eine ganze Zahl kleiner als `1` oder größer als `6` eingegeben, so soll diese Eingabeaufforderung wiederholt werden.
Verwende für die Berechnungen die entsprechenden Operatoren auf dem Datentyp `int`.
Du musst keine Sonderbehandlung für einen etwaigen arithmetischen Überlauf implementieren.

### Beispiele:
1. [task][Programm beenden](testExitProgram)
```
 6
```
2. [task][Addition und Subtraktion](testAdditionAndSubtraction)
```
 1
 65
 34
<99
 2
 34
 -12
<46
 6
```
3. [task][Ungültige Auswahl](testInvalidSelection)
```
 7
 6
```
4. [task][Rest](testRemainder)
```
 5
 -11
 3
<-2
 5
 65
 0
 6
```
5. [task][Division](testDivision)
```
 4
 -34
 5
<-6
 6
```

*Hinweis:* Zur besseren Kenntlichmachung ist in den Beispielen Zeilen, die vom Programm ausgegeben werden, je ein ""<"" vorangestellt. Zeilen mit Nutzereingaben ist ein "">"" vorangestellt. Diese Zeichen gehören nicht zum Programmablauf."
299,Praktikum: Grundlagen der Programmierung WS23/24,11667,W02H01 - Meet and Greet in der Antarktis,"# Meet and Greet in der Antarktis

**Hinweis:** In der ganzen Aufgabe ist das Benutzen der `java.lang.Math` Library (oder anderer ähnlicher Bibliotheken, die den von dir zu leistenden Anteil der Implementierung ersetzen wie `BigInteger`, `BigDecimal`, `StrictMath`, ...) untersagt. Wir behalten uns vor, Abgaben, die diesem Kriterium widersprechen, entweder komplett oder einzelne Teilaufgaben davon mit 0 Punkten zu bewerten.

Die Pinguine haben dich in ihr Zuhause in der Antarktis eingeladen. Sie wollen dir stolz präsentieren, wie sie leben und du willst so viel du kannst über sie erfahren. Da Pinguine intelligent und kompetitiv sind, lassen sie es sich natürlich nicht nehmen, dir ein paar knifflige Aufgaben zu stellen. Als angehedes TUM-Mitglied bist du dieser Situation selbstverständlich bestens gewachsen. Los! Zeig ihnen, was du drauf hast! Viel Spaß!

*Hinweis:* Du darfst in dieser Aufgabe davon ausgehen, dass alle Integer-Parameter der Methoden in den Teilaufgaben 2 bis 5 nicht-negativ sind.

1. [task][Pinguin Informationen]( 157028 )
Implementiere die Methode `penguInfoOut(int)`. Der Methode wird ein Pinguin vom Typ `int` übergeben. Weil Pinguine nie depressiv sind, kennen wir nur *nicht negative* Pinguine. Sollte der Methode ein unbekannter Pinguin übergeben werden, soll in der Konsole die Nachricht "" Penguin⎵ \ ⎵is⎵not⎵a⎵known⎵penguin! "" in einer eigenen Zeile ausgegeben werden. Andernfalls soll die Methode eine kurze Beschreibung des Pinguins ausgeben (ebenfalls direkt in der Konsole). Die erste Zeile der Beschreibung enthält dabei folgenden String: "" Penguin:⎵ \ "". Da selbstverständlich sowohl weibliche als auch männliche Pinguine existieren, möchten wir diese Unterscheiden. Zum Glück ist das sehr einfach, denn während *männliche* Pinguine immer *geradzahlig* sind, lassen sich *weibliche* Pinguine eindeutig als *ungerade Zahlen* identifizieren. Diese Information soll nun in der zweiten Zeile wie folgt ausgegeben werden: "" This⎵penguin⎵is⎵a⎵female. "" (f) oder "" This⎵penguin⎵is⎵a⎵male. "" (m) angepasst an das entsprechende Geschlecht des Pinguins. Hier hast du noch ein paar Beispiele, an denen du dich orientieren kannst:
```text
Beispiel 1:
IN: penguin = -99
OUT 1: ""Penguin -99 is not a known penguin!""

Beispiel 2:
IN:penguin = 1
OUT 1: ""Penguin: 1""
OUT 2: ""This penguin is a female.""

Beispiel 3:
IN: penguin = 2
OUT 1: ""Penguin: 2""
OUT 2: ""This penguin is a male.""
```

2. [task][Evolution der Pinguine]( 157013 )
Implementiere die Methode `penguEvolution(int, int)`. Der Methode wird ein Pinguin vom Typ `int` und eine Anzahl von Jahren (`int`) übergeben. In dieser Aufgabe möchten wir die Evolution eines Pinguins aus einer ganz speziellen Kolonie simulieren (`penguin` $$> 0$$). Jedes Jahr verändert sich ein Pinguin nach den folgenden Regeln: Da *Pinguin-Männer* immer gestresst sind und sich so viel beschweren, *halbieren* männliche Pinguine ihre Zahl. Besonders gestresste *männliche Pinguine* sind Zweierpotenzen ($$ 2^x, x \in \mathbb{N} \setminus \\{ 0 \\}  $$). Anstatt sich nur zu halbieren, werden diese direkt zu einer `1`. *Weibliche Pinguine* hingegen sind so gut gelaunt und tanzen deshalb so viel, dass sie ihre Zahl *verdreifachen und `1` hinzu addieren*. Aus traditionellen Gründen sind die *Pinguin-Damen* am glücklichsten, wenn sie ein Vielfaches von `7` sind, deshalb verbleiben sie in diesem Zustand auch für genau `7` Jahre, ehe sie ihre Evolution fortsetzen. Achte darauf, dass die Pinguine aus unserer speziellen Kolonie dadurch von Jahr zu Jahr ihr Geschlecht ändern könnten. Die Methode soll den Zustand/die Zahl des übergebenen Pinguins (`penguin`) nach der übergebenen Anzahl von Jahren (`years`) zurückgeben. In den Beispielen sind immer nach ""IN: "" die Parameter, nach ""OUT: "" der Rückgabewert, der bei diesen Parametern berechnet werden sollte, sowie nach ""EVO: "" die gesamte Evolution über den übergebenen Zeitraum angegeben. Die Evolution ist zur Verdeutlichung dabei und soll **nicht** extra ausgegeben werden. Der korrekte Rückgabewert reicht.
```text
Beispiel 1:
IN: penguin = 128, years = 2
OUT: 4
EVO: Jahr 0: 128
     Jahr 1: 1
     Jahr 2: 4

Beispiel 2:
IN: penguin = 9, years = 9
OUT: 7
EVO: Jahr 0: 9
     Jahr 1: 28
     Jahr 2: 14
     Jahr 3: 7
     Jahr 4: 7
     Jahr 5: 7
     Jahr 6: 7
     Jahr 7: 7
     Jahr 8: 7
     Jahr 9: 7

Beispiel 3:
IN: penguin = 9, years = 10
OUT: 22
EVO: Jahr  0: 9
     Jahr  1: 28
     Jahr  2: 14
     Jahr  3: 7
     Jahr  4: 7
     Jahr  5: 7
     Jahr  6: 7
     Jahr  7: 7
     Jahr  8: 7
     Jahr  9: 7
     Jahr 10: 22
```

3. [task][Pinguine, die sich selbst testen]( 157002 )
Pinguine sind grundsätzlich sehr vergesslich und müssen sich alles auf einen kleinen Zettel schreiben, den sie unter ihrem linken Flügel aufbewahren. Dort führen sie natürlich auch eine Liste all ihrer Pinguin-Freunde. Zusätzlich zur Zahl ihres Freundes berechnen sie auch noch die Quersumme dieser Zahl, um testen zu können, dass sie die Nummer richtig notiert haben. Die Quersumme einer Zahl ist die Summe aus den einzelnen Ziffern einer natürlichen Zahl. Implementiere nun die Methode `penguSum(int)`. Die Methode soll die Quersumme der übergebenen Pinguin-Zahl (`penguin`) berechnen und zurückgeben.
```text
Beispiel 1:
IN: penguin = 128
OUT: 11

Beispiel 2:
IN: penguin = 1337
OUT: 14
```

4. [task][Permutierende Pinguine]( 157021 )
Pinguine lieben Ordnung und Steine. Am liebsten ordnen sie ihre Steine. Die Kolonie hat eine Menge von `n` vielen Steinen gesammelt. `k` dieser Steine sind identisch, da sie diese von uns geschenkt bekommen haben (d.h. `n` $$\ge$$ `k` $$\ge 1$$). Die anderen sind alle zu diesen `k` und zueinander unterschiedlich. Die Pinguine möchten nun herausfinden wie viele Möglichkeiten es gibt, die Steine in eine Reihe zu legen. Als exzellenter TUMuin fällt dir natürlich sofort eine simple Formel ein, mit der du die Lösung berechnen kannst: $$ \frac{n!}{k!} $$, mit $$ i! = 1 \cdot 2 \cdot \cdot \cdot i = \prod_{k=1}^{i}k $$ (Fakultät). Implementiere die Methode `penguPermutation(long, long)`, der die beiden `long`s `n` und `k` übergeben werden. Achte dabei darauf, dass deine Implementierung **alle** Eingaben richtig bearbeiten muss, deren finales Ergebnis weiterhin in einen `long` passt. Ggf. solltest du dazu noch einmal einen Blick in die Vorlesung werfen, um noch einmal zu wiederholen, welche Werte ein `long` speichern kann.
```text
Beispiel 1:
IN: n = 6, k = 3
OUT: 120

Beispiel 2:
IN: n = 21, k = 19
OUT: 420

Beispiel 3:
```

5. [task][Mächtige Pinguine]( 157008 )
**WICHTIG:** *In dieser Teilaufgabe ist das Benutzen des* `*`*-Operators strikt verboten! Benutzt du ihn, bekommst du 0P auf diese Teilaufgabe.*  
Pinguine sind sehr intelligent. Sie fordern dich zu eine Mathe-Challenge heraus: Gegeben `x` und `i`, berechne $$ x^i $$. ""Haha, wie einfach! :D"" Aber die Pinguine sind noch nicht fertig! Du sollst eine Lösung finden, ohne dabei den `*`-Operator zu benutzen. Schnell erinnerst du dich daran, dass Multiplikation ganz leicht durch Addition berechnet werden kann, denn $$ a \cdot b$$ ist nichts anderes als $$a$$ viele male $$b$$ zu addieren (z.B. $$3 \cdot 2 = 2 + 2 + 2$$). $$x^i$$ lässt sich genau so simpel berechnen, indem man $$i$$-mal $$x$$ multipliziert. Implementiere nun die Methode `penguPowers(int, int)`, ohne den `*`-Operator zu benutzen. Der Methode werden die beiden `int`s `x` und `i` übergeben. Achte auch hier darauf, dass deine Lösung alle Eingaben, deren Ergebnis in einen `long` passt, richtig berechnet.
*Hinweis:* es reicht aus, wenn du dir über *nicht negative* Eingaben gedanken machst. Negative Eingaben können als optional betrachtet werden.
```text
Beispiel 1:
IN: x = 1337, i = 2
OUT: 1787569

Beispiel 2:
IN: x = 3, i = 4
OUT: 81
```

Viel Erfolg!"
299,Praktikum: Grundlagen der Programmierung WS23/24,11668,W02H02 - Penguin Casino,"# Penguin Casino

Du hast dich nach dem Feierabend auf ein Guinness im allseits bekannten Irish Pub in der Antarktis getroffen. Bei einem ist es anscheinend auch nicht geblieben. Am nächsten Morgen erinnerst du dich, wie ihr euch darüber unterhalten habt, ein Kasino zu eröffnen. Oh je! Als Informatiker*in bist du natürlich für die Software zuständig.
Mit einer frischen Tasse Java machst du dich an eine erste Demo-Version ...

In dieser Aufgabe wird eine vereinfachte Version des Glückspiels ""Black Jack"" implementiert. Halte dich genau an die Anweisungen und achte auch auf die Formatierung bei Ausgaben in der Konsole. Wir empfehlen, die Aufgabe zunächst vollständig zu lesen und erst dann mit der Implementierung zu beginnen. In der Angabe wird zunächst das Gesamtkonzept (Folge von mehreren Spielrunden) beschrieben und dann der Verlauf eines einzelnen Spiels.

*Hinweis 1:* Auch in dieser Aufgabe wurden alle Leerzeichen, welche von in den Ausgabe-Strings enthalten sein sollen, durch `⎵` ersetzt, um sie sichtbarer zu machen. Dein Programm  muss jedoch Leerzeichen und nicht `⎵` ausgeben (siehe Beispiele). 
*Hinweis 2:* Über Overflows musst du dir in dieser Aufgabe keine Gedanken machen, d.h. du kannst davon ausgehen, dass die Zahlenwerte nie bedeutend groß werden. 
*Hinweis 3:* In dieser Aufgabe wirst du eine bereits implementierte Klasse (`CardDeck`) benutzen müssen. Natürlich darf diese von dir nicht verändert werden. Ein Blick in die Datei, um etwas zu lernen, ist trotzdem eine gute Idee.

## Gesamtkonzept

### Start

Zum Start des Spiels soll der Nutzer mit der folgenden Nachricht in der Konsole begrüßt werden: "" Welcome⎵to⎵Pengu-BlackJack! "". Ein Spieler beginnt immer mit `1000` Tokens, die er zum Black Jack spielen verwenden kann.
Vor bzw. nach jeder gespielten Runde soll gefragt werden, ob der Nutzer eine weitere Runde spielen möchte oder das Programm beendet werden soll: "" (1)⎵Start⎵a⎵game⎵or⎵(2)⎵exit "". Entsprechend der darauf folgenden Eingabe des Spielers soll dadurch entschieden werden, ob wirklich eine neue Runde gestartet wird oder die Schlusssequenz eingeleitet wird. Einen User-Input kannst du entgegennehmen, in dem du die vorgegebene Methode `readInt()` aufrufst. `int input = readInt()` pausiert das Programm, wartet auf eine Eingabe des Nutzers und legt diese in der Variable `input` ab sobald der Nutzer die Eingabe getätigt hat. Gibt der User den Input `1` will er/sie eine Runde spielen (siehe unten wie), wird eine `2` gelesen, startet die Schlusssequenz. Bei allen anderen möglichen Zahleneingaben soll das Programm sich mit der folgenden Ausgabe über den fehlerhaften Input beschweren: "" What?! "" und den Prozess des Fragens wiederholen.

### Schlusssequenz

Die Schlusssequenz besteht aus 3 Ausgaben in der Konsole. In der ersten Zeile soll dem User der finale Kontostand mitgeteilt werden: "" Your⎵final⎵balance:⎵ <#Tokens>"". In der darauf Folgenden Zeile wird dem Benutzer angezeigt, ob er nach den gespielten Spielen einen (echt positiven) Gewinn erzielt hat ("" Wohooo!⎵Ez⎵profit!⎵:D "") oder nicht ("" That's⎵very⎵very⎵sad⎵:( ""). Als letztes wollen wir uns noch von unserem Nutzer verabschieden mit der folgenden Nachricht: "" Thank⎵you⎵for⎵playing.⎵See⎵you⎵next⎵time. "". Mit dieser Nachricht ist das Spiel beendet.

 
 Beispiel 1: Nutzer mit 123 Tokens 
```text
OUT: Your final balance: 123
OUT: That's very very sad :(
OUT: Thank you for playing. See you next time.
```
 
 
 Beispiel 2: Nutzer mit 1234 Tokens 
```text
OUT: Your final balance: 1234
OUT: Wohooo! Ez profit! :D
OUT: Thank you for playing. See you next time.
```
 


## Eine einzelne Runde

Entscheidet sich der Nutzer dazu, eine Runde starten zu wollen, muss natürlich zuerst der aktuelle Kontostand ausgegeben werden (zu Beginn `1000`): "" Your⎵current⎵balance:⎵ <#Tokens>"". Nun muss der Nutzer seinen Spiel-Betrag wählen können. Dazu muss in der Konsole folgende Frage gestellt werden: "" How⎵much⎵do⎵you⎵want⎵to⎵bet? "". Anschließend kann der User-Input entgegen genommen werden. Dieser Vorgang wird wiederholt, solange die Eingabe nicht strikt positiv ist oder sie den aktuellen Kontostand überschreitet (Frage & Eingabe). Sobald der Betrag feststeht, wird damit begonnen, die Spielerkarten zu ziehen (siehe folgenden Abschnitt).

### Spieler Karten

Als erstes möchten wir dem Spieler mitteilen, dass nun er an der Reihe ist. Deshalb starten wir mit folgender Ausgabe: "" Player⎵cards: "".
Nun werden die ersten beiden Karten gezogen. Für jede gezogene Karte möchten wir in der Konsole sowohl ausgeben, die wievielte Karte diese ist, als auch deren Wert (""\ ⎵:⎵ \ "", *Achtung:* Karten-Nr. starten mit `1`). Um eine Karte vom Stapel (`deck`) zu nehmen musst du die Methode `drawCard()` benutzen: `int card = deck.drawCard()` legt den Wert der gezogenen Karte in die Variable `card`.

Die Werte der Karten sind relevant. Diese werden alle zusammen aufaddiert. Nachdem die ersten `2` Karten gezogen wurden, muss in der Konsole der aktuelle Punktestand ausgegeben werden: "" Current⎵standing:⎵ \ "".
Solange die Summe aller Kartenwerte kleiner als `21` hat der User die Wahl eine weitere Karte zu ziehen (`1`) oder den Zug zu beenden (`2`). Dazu generieren wir folgende Ausgabe: "" (1)⎵draw⎵another⎵card⎵or⎵(2)⎵stay "". Wie schon zu Beginn beschrieben soll das Programm auf die Eingabe entsprechend reagieren. Bei einer nicht definierten Eingabe (nicht `1`/`2`) wird auch hier "" What?! "" ausgegeben und der Process (Frage&Input) wiederholt.

Entscheidet sich der Spieler dazu eine weitere Karte zu ziehen, soll das Programm dieses Umsetzen und sowohl die gezogene Karte (""\ ⎵:⎵ \ "", *Achtung:* fortlaufende Indizes) als auch den danach aufsummierten Punktestand ("" Current⎵standing:⎵ \ "") ausgeben. Dieser Vorgang wird solange wiederholt, bis der User sich gegen eine weitere Karte entscheidet oder die Punktzahl `20` Punkte überschreitet.

Nach dem der Benutzer seinen Zug beendet hat, kann es drei mögliche Szenarien geben.
1. *Punktzahl `21` überschritten:* Der Spieler verliert das Spiel. Dazu geben wir folgenden String in der Konsole aus: "" You⎵lost⎵ \ ⎵tokens. "". Der Kontostand muss dementsprechend angepasst werden.
2. *Punktzahl `21` (Black Jack):* Der Spieler gewinnt den Jackpot (das Doppelte des Spiel-Betrages). Dazu geben wir folgenden String in der Konsole aus: "" Blackjack!⎵You⎵won⎵ \ ⎵tokens. "". Der Kontostand muss dementsprechend angepasst werden.
3. *Weniger als `21` Punkte:* Hier wird es nun etwas schwieriger. Denn jetzt muss der Dealer spielen. Dieser zieht solange Karten, bis er entweder den Punktestand des Spielers überbietet oder bis er selbst einen Punktestand von `21` überschreitet. Zunächst soll dazu die Überschrift "" Dealer⎵cards: "" ausgegeben werden. Für jede gezogene Karte soll auch hier die Karte wie schon zuvor ausgegeben werden: ""\ ⎵:⎵ \ "", *Achtung:* Indizes starten erneut bei 1. Nach dem der Dealer seine Karten gezogen hat, soll noch der Punktestand des Dealers ausgegeben werden: "" Dealer:⎵ \ "". Letztendlich muss noch entschieden werden, ob der Spieler gegen den Dealer gewonnen hat oder nicht. Überschreitet der Punktestand des Dealers `21`, so gewinnt der Spieler und erhält die Ausgabe "" You⎵won⎵ \ ⎵tokens. "". Andernfalls hat der Spieler die Runde und damit auch seine Tokens verloren. Verliert der Spieler, geben wir folgenden String in der Konsole aus: "" Dealer⎵wins.⎵You⎵lost⎵ \ ⎵tokens. "". In beiden Fällen muss der Kontostand entsprechend angepasst werden: Wenn der Spieler gegen den Dealer gewinnt, wird der Spiel-Betrag zum ursprünglichen Kontostand hinzuaddiert. Wenn der Spieler gegen den Dealer verliert, wird der Spiel-Betrag vom ursprünglichen Kontostand abgezogen.

Eigentlich ist damit eine Runde beendet. Wir wollen aber nicht, dass ein Spieler ohne Tokens weiter spielen kann. Hat der Spieler nach einer Runde keine Tokens mehr, dann ist das Spiel für sie/ihn vorbei. In diesem Fall soll nicht gefragt werden, ob er/sie weiterspielen will, sondern direkt der Satz "" Sorry,⎵you⎵are⎵broke.⎵Better⎵Luck⎵next⎵time. "" auf der Konsole ausgegeben werden. Anschließend soll die bekannte Schlusssequenz folgen und das Programm beendet werden. Andernfalls gelangt der Spieler zurück an den Anfang und wird wiederholt gefragt wie sie/er nun fortfahren möchte (siehe Gesamtkonzept oben).

## Seeds, ein ausführliches Beispiel & Tests

### Seeds

Statt wie im Template vorgegeben `CardDeck deck = CardDeck.getDeck()` zu benutzen um einen Kartenstapel zu nehmen, kannst du der Methode auch einen Parameter übergeben `CardDeck deck = CardDeck.getDeck(420)`. Die Zahl wird als Seed für die Zufallsgenerierung benutzt, d.h. bei zwei (oder beliebig vielen) Durchläufen, die mit dem selben Seed starten, werden die selben Karten gezogen. So kannst du das folgende Beispiel testen oder selbst eigene Tests generieren. *ACHTUNG:* den Seed sollst du nur zum Testen verwenden, nicht aber für die finale Abgabe.

### Beispiel

 
 Beispiel: Drei Runden in Folge (Seed: 420) 
```text
OUT:    Welcome to Pengu-BlackJack!
OUT:    (1) Start a game or (2) exit
IN:     1
OUT:    Your current balance: 1000
OUT:    How much do you want to bet?
IN:     69
OUT:    Player cards:
OUT:    1 : 1
OUT:    2 : 8
OUT:    Current standing: 9
OUT:    (1) draw another card or (2) stay
IN:     1
OUT:    3 : 3
OUT:    Current standing: 12
OUT:    (1) draw another card or (2) stay
IN:     1
OUT:    4 : 8
OUT:    Current standing: 20
OUT:    (1) draw another card or (2) stay
IN:     2
OUT:    Dealer cards:
OUT:    1 : 4
OUT:    2 : 2
OUT:    3 : 8
OUT:    4 : 8
OUT:    Dealer: 22
OUT:    You won 69 tokens.
OUT:    (1) Start a game or (2) exit
IN:     1
OUT:    Your current balance: 1069
OUT:    How much do you want to bet?
IN:     420
OUT:    Player cards:
OUT:    1 : 9
OUT:    2 : 5
OUT:    Current standing: 14
OUT:    (1) draw another card or (2) stay
IN:     1
OUT:    3 : 7
OUT:    Current standing: 21
OUT:    Blackjack! You won 840 tokens.
OUT:    (1) Start a game or (2) exit
IN:     1
OUT:    Your current balance: 1909
OUT:    How much do you want to bet?
IN:     1337
OUT:    Player cards:
OUT:    1 : 3
OUT:    2 : 3
OUT:    Current standing: 6
OUT:    (1) draw another card or (2) stay
IN:     1
OUT:    3 : 7
OUT:    Current standing: 13
OUT:    (1) draw another card or (2) stay
IN:     1
OUT:    4 : 10
OUT:    Current standing: 23
OUT:    You lost 1337 tokens.
OUT:    (1) Start a game or (2) exit
IN:     2
OUT:    Your final balance: 572
OUT:    That's very very sad :(
OUT:    Thank you for playing. See you next time.
```
 

### Tests

Hier werden dir die Ergebnisse der automatischen Tests direkt angezeigt:
[task][Öffentliche Tests]( 157061 , 157043 , 157052 ) Testet deine Abgabe vor der Deadline.
[task][Versteckte Tests]( 157049 , 157064 , 157056 , 157063 , 157050 , 157044 , 157060 , 157062 , 157047 , 157048 , 157067 , 157058 , 157053 ) Testet deine Abgabe nach der Deadline.
[task][Grading Tests]( 157065 , 157072 , 157066 , 157069 , 157068 , 157071 ) Testet deine Abgabe nach der Deadline und verteilt Punkte.


Viel Erfolg!"
299,Praktikum: Grundlagen der Programmierung WS23/24,11669,W02H03 - Wurzelhilfe fuer Fortgeschrittene,"# W02H03 - Wurzelhilfe für Fortgeschrittene

Die junge Mathuinin Ruth braucht dringend deine Hilfe. In der Pinguin Schule steht aktuell das schriftliche Quadratwurzelziehen auf dem Stundenplan. Ruth hat auch schon die Grundlagen verinnerlicht. Leider verrechnet sie sich aber noch sehr oft. Um ihre Zwischenschritte überprüfen zu können, bittet sie dich, ein entsprechendes Programm zu implementieren.

## Aufgabe
Implementiere die Methode `sqrt`. Diese erhält einen `double` `n`, dessen Quadratwurzel berechnet werden soll. Dafür soll die Methode des schriftlichen Quadratwurzelziehens verwendet werden, die weiter unten erklärt wird. Außerdem sollen bestimmte Zwischenschritte auf der Konsole ausgegeben werden. Auch dazu findest du weiter unten mehr Informationen. Es gelten folgende Einschränkungen:
- |n| <= Integer.MAX_VALUE = 2,147,483,647
- Für die Berechung sind nur die ersten 4 Nachkommastellen von n relevant. Alle weiteren können (außer in der 1. Ausgabezeile) abgeschnitten werden.
- Die Methode soll das exakte Ergebnis auf 2 Nachkommastellen berechnen. D.h., dass nicht gerundet wird, sondern vor der 3. Nachkommastelle ""abgeschnitten"" wird. (1.347 wird zu 1.34)
- Funktionen aus `java.lang.Math` sind nicht erlaubt

## Schriftliches Quadratwurzelziehen

 

Quadratwurzeln lassen sich wie folgt (schriftlich) berechnen: 
1. Die Zahl muss in Zifferngruppen der Größe 2 geteilt werden, ausgehend vom Dezimalpunkt (also für den ganzzahligen Anteil nach links, für die Nachkommastellen nach rechts). Bei einer ungeraden Anzahl an Ziffern wird mit einer 0 aufgefüllt. 1.234 wird z.B. 01 | 23 | 40 geteilt, nicht 12 | 34)
2. Starte mit der ersten Zifferngruppe als Minuend, mit 1 als Subtrahend. Solange das Ergebnis >= 0 ist, berechne die Differenz und erhöhe den Subtrahend um 2
3. Die Anzahl der unterschiedlichen Subtrahenden, die in Schritt 2 abgezogen wurden, ist die erste Ziffer des Ergebnisses
4. Die übrigen Ziffern des Ergebnisses lassen sich ähnlich berechnen: Nimm den Rest des vorherigen Schritts und hänge die nächste Zifferngruppe an (falls alle Zifferngruppen bereits abgearbeitet wurden, hänge 00 an). Dies ist der neue Minuend. Berechne den neuen Start-Subtrahend indem du eine 1 an das Doppelte des aktuellen Ergebisses anhängst. Solange das Ergebnis >= 0 ist, berechne die Differenz und erhöhe den Subtrahend um 2. Die Anzahl der abgezogenen Subtrahenden ist die nächste Ziffer des Ergebnisses.
5. Schritt 4 solange wiederholen, bis alle Ziffern der Eingabezahl abgearbeitet wurden und der Rest nach einem Schritt 0 ergibt oder die gefragte Genauigkeit erreicht wurde. Der Dezimalpunkt kommt im Ergebnis vor der Ziffer, zu deren Berechnung die erste Zifferngruppe nach dem Komma der Eingabezahl genutzt wurde.

Ruth hat dir auch ein Beispiel vorbereitet (siehe Bild rechts und Animation ganz unten): 

In diesem Beispiel soll die Quadratwurzel von 1049.76 berechnet werden. Dafür wird die Zahl zuerst in Gruppen aufgeteilt (1.): 10 | 49 | 76. Im nächsten Schritt (2.) wird von der 10 erst 1 (Zwischenergebnis: 9), dann 3 (Zwischenergebnis: 6) und schließlich 5 (Zwischenergebnis: 1) abgezogen. 7 kann nicht mehr abgezogen werden, da das Ergebnis sonst negativ wäre. Da also 3 Zahlen abgezogen wurden, ist 3 auch die 1. Ziffer des Ergebnisses (3.). Jetzt kann entsprechend weitergerechnet werden: Zuerst wird an den Rest des letzten Schritts (1) die nächste Zifferngruppe angehängt (49). Der nächste Minuend ist also 149. Der erste Subtrahend ergibt sich aus dem doppelten des bisherigen Ergebnis (2*3 = 6) und einer angehängten 1, also 61. Aus 149 -61 -63 = 25 folgt dann 2 als nächste Ziffer des Ergebnis (aktuell 32) und Rest 25 für den nächsten Schritt. Da nun der Dezimalpunkt erreicht ist, muss er auch im Ergebnis eingefügt werden (32.). Jetzt fehlt noch die letzte Zifferngruppe: neue Zifferngruppe an letzten Rest anhängen -> Minuend 2576. 1 an das doppelte des bisherigen Ergebnis für den neuen Subtrahenden anhängen: 2 * 32 = 64 => Subtrahend 641. Aus 2576 -641 -643 -645 -647 = 0 erhalten wir die neue Ergebnisziffer 4. Außerdem haben wir Rest 0 und keine verbleibende Ziffernfolge. Die Berechnung ist also abgeschlossen und das Ergebnis 32.4 ist exakt.

## Ausgabe
Um ihre Rechnungen zu überprüfen, möchte Ruth, dass dein Programm folgende Ausgabe produziert:
- 1. Zeile: "" Wurzel⎵aus⎵ \ ""
- 2. Zeile leer
- Für jede Zifferngruppe folgenden Block, wobei x die Anzahl der Subtrahenden ist:  
""\   
 \--------   
\-\<1. Subtrahend>  
\-\<...>  
\-\   
 \-------- 
Rest:⎵ \   
 neue⎵Ergebnis⎵Ziffer:⎵ \   
\ ""
- Als letzte Zeile: "" Ergebnis:⎵\ ""
- Für eine negative Zahl soll nur einzige Zeile ausgegeben werden, nämlich: "" Keine⎵negativen⎵Wurzeln! ""
 
 
 Für das obige Beispiel würde sich also folgende Ausgabe ergeben: 
```
Wurzel aus 1049.76

10
--------
-1
-3
-5
--------
Rest: 1
neue Ergebnis Ziffer: 3

149
--------
-61
-63
--------
Rest: 25
neue Ergebnis Ziffer: 2

2576
--------
-641
-643
-645
-647
--------
Rest: 0
neue Ergebnis Ziffer: 4

Ergebnis: 32.4
```
 
 
 Ein weiteres Beispiel für eine Ausgabe: Wurzel aus 4 
```
Wurzel aus 4.0

4
--------
-1
-3
--------
Rest: 0
neue Ergebnis Ziffer: 2

Ergebnis: 2.0
```
 

Ruth hat außerdem noch ein paar Anmerkungen, um dir die Aufgabe zu erleichtern:
- Die Ausgabe der Zahl in der 1. Zeile soll in der standardmäßigen `java`-String-Repräsentation der Zahl entsprechen, also z.b. ""1.0E9"" für eine Milliarde, ""2.0"" für 2 und ""0.1"" für 0.1. Gleiches gilt für die Ausgabe des finalen Ergebnis.
- Es sollen nur Subtrahenden ausgegeben werden, die auch erfolgreich vom Minuenden abgezogen werden können. Wenn es keinen gibt, dann folgen die beiden ""--------""-Zeilen direkt aufeinander.
- 0er-Blöcke sind nicht relevant, wenn sie zum Berechnen der ersten oder letzten Ergebnis-Ziffern genutzt werden. Es muss aber immer mindestens 1 Block ausgegeben werden. Die Ausgabe für Wurzel aus 0.0004 wäre also die selbe wie für Wurzel aus 4 in obigem Beispiel (außer 1. und letzter Zeile natürlich). Die 0er-Blöcke dürfen aber auch ausgegeben werden, wie im nächsten Beispiel.
- Artemis verwendet einen ""."" als dezimales Trennzeichen (vgl. Beispielausgaben) 

 
 Folgende Ausgabe wäre für die Wurzel aus 4 also auch ok: 
```
Wurzel aus 4.0

4
--------
-1
-3
--------
Rest: 0
neue Ergebnis Ziffer: 2

0
--------
--------
Rest: 0
neue Ergebnis Ziffer: 0

0
--------
--------
Rest: 0
neue Ergebnis Ziffer: 0

Ergebnis: 2.0
```
 

Das Beispiel nochmal Schritt für Schritt animiert:

![WurzelBeispielGIF_large_changed.gif](/api/core/files/markdown/Markdown_2022-10-24T11-11-50-516_efa3258c.gif)

### Allgemeine Hinweise
`static` Variablen werden zwischen Testcases nicht zurückgesetzt! Dies ist in PGdP immer so, außer es ist für die Aufgabe sinnvoll. In diesem Fall wäre es allerdings in der Aufgabenstellung vermerkt. Wenn du also nicht 100% weißt, wie sich `static` Variablen verhalten, solltest du besser auf sie verzichten.

Je nach verwendetem Ansatz kann es bei unterschiedlichen Eingabewerten zu Rundungsfehlern im Endergebnis kommen, die sich auf die Funktionsweise von Gleitkommazahlen in Java (und anderen Programmiersprachen) zurcükfühen lassen. Die Tests berücksichtigen diese Fehler bis zu einem Unterschied von 0.00001 zum erwarteten Ergebnis. Die restliche Ausgabe muss aber 1:1 übereinstimmen! 

## Tests
Hier werden dir die Ergebnisse der automatischen Tests direkt angezeigt:
[task][Öffentliche Tests]( 157097 , 157091 ) Testet die beiden Beispiele 4 und 1049.76 sobald du eine Lösung pusht.
[task][Versteckte Tests]( 157089 , 157090 , 157092 , 157087 , 157086 , 157093 ) Testet deine Abgabe nach der Deadline. Für dise Tests bekommst du Punkte.
[task][Grading Tests]( 157115 , 157114 , 157088 , 157085 , 157119 , 157118 ) Diese Tests sind nur dazu da, Punkte für diese Aufgabe zu vergeben und abhängig vom Ergebnis der hidden Tests."
299,Praktikum: Grundlagen der Programmierung WS23/24,11688,W03P01 - Grundlegende Arrayfunktionen,"#Grundlegende Array-Methoden

In dieser Aufgabe sollen einige Funktionen auf Arrays implementiert werden. Verwende dabei keine Methoden aus der Java-Bibliothek (außer der folgenden).
Nutze zur Ausgabe die Methode `System.out.print()`. Gebe also keine Newlines aus.
Implementiere die folgenden Methoden:

- [task][Ausgeben]( 157797 )
`public static void print(int[] a)` - gibt das Array auf der Konsole aus.
Das Array soll mit einer öffnenden geschweiften Klammer beginnen
und mit einer schließenden geschweiften Klammer enden.
Die einzelnen Elemente des Arrays sollen durch ein Komma und ein Leerzeichen getrennt sein.  
Beispiel: `print(new int[] {1, 2, 3, 4, 5})` liefert auf der Konsole die Ausgabe "" {1,⎵2,⎵3,⎵4,⎵5} "".

- [task][Minimum und Maximum]( 157799 )
`public static void minAndMax(int[] a)` - gibt das Minimum und Maximum des Arrays auf der Konsole aus.
Das Array soll in der Methode nur einmal durchlaufen werden. (Dies wird in den Unit-Tests nicht überprüft!)
Beispiel: `minAndMax(new int[] {1, 10, 25, -13, 1000})` liefert auf der Konsole die Ausgabe "" Minimum⎵=⎵-13,⎵Maximum⎵=⎵1000 "".

- [task][Aufsteigende Sortiertheit]( 157802 )
`public static boolean isOrderedAscendingly(int[] a)` - überprüft, ob das übergebene Array aufsteigend sortiert ist. Mehrere aufeinanderfolgende gleiche Einträge sind dabei in Ordnung.
Folgende Arrays gelten beispielsweise als aufsteigend sortiert:
```text
{1, 2, 3, 4, 5}
{-1, -1, 3, 4, 4, 5, 5, 5, 19}
{1, 1, 1, 1, 1}
{}
```
Folgende Arrays gelten als nicht aufsteigend sortiert:
```text
{1, 2, -3, 4, 5}
{1, 2, 3, 2, 3, 4}
{1, 1, 1, 1, 2, 1, 1}
```
Es soll genau dann `true` zurückgegeben werden, wenn das übergebene Array aufsteigend sortiert ist und genau dann `false`, wenn nicht.

 - [task][Invertieren]( 157801 )
`public static void invert(int[] a)` - invertiert die Elemente von `a`, sodass sie in umgekehrter Reihenfolge sind. Da kein Rückgabewert erwartet wird, muss das ganze in-place, also im Array selber passieren. 
Beispiel: `invert(new int[] {0, 1, 2, 3})` invertiert das Array zu `{3, 2, 1, 0}`.

 - [task][Größenänderung]( 157994 )
`public static int[] resize(int[] a, int length)` - gibt ein neues Array zurück,
welches Platz für genau `length` Elemente hat und die Elemente vom Array `a` in der gleichen Reihenfolge und so viele wie möglich enthält.
Sollte das zurückgegebene Feld größer sein als das übergebene, sollen die zusätzlichen Positionen den Wert 0 haben. Sollte length <= 0 sein, so soll ein leeres Array zurückgegeben werden.
Beispiel: `resize(new int[] {1, 2, 3}, 2)` liefert ein Array `{1, 2}`
und `resize(new int[] {1, 2, 3}, 5)` liefert ein Array `{1, 2, 3, 0, 0}`.

- [task][Nur die Geraden]( 157796 )
`public static int[] filterEvenNumbersFrom(int[] a)` - soll ein neues Array erzeugen und zurückgeben, welches nur die geradzahligen Einträge von `a` enthält. Diese sollen aber alle (also auch Duplikate) und in der gleichen Reihenfolge vorhanden sein. Die Länge des Ausgabe-Arrays muss natürlich entsprechend angepasst werden.
Hier ein Paar Beispiele:
```text
Aus {1, 2, 2, 1, 3, 4, 5, 6} soll {2, 2, 4, 6} werden.
Aus {-2, -4, 0, 1, -1, 3, 5, 4} soll {-2, -4, 0, 4} werden.
Aus {1, 3, 5, 7, 9} soll {} werden.
```

- [task][Einzigartig]( 157800 )
`public static int[] distinct(int[] a)` - soll ein neues Array erzeugen und zurückgeben, dass alle Zahlen aus `a` genau einmal enthält. Dabei soll nur das erste Vorkommen einer Zahl in `a` erhalten bleiben, alle weiteren werden gestrichen. Die Länge des Ausgabe-Arrays muss natürlich entsprechend angepasst werden.
Hier ein Paar Beispiele:
```text
Aus {1, 2, 3, 4, 5} soll {1, 2, 3, 4, 5} werden.
Aus {1, 1, 1, 1, 1} soll {1} werden.
Aus {1, 1, 2, 1, 3, 2, 1, 0, 1, 3, 1, 2, 0} soll {1, 2, 3, 0} werden.
```"
299,Praktikum: Grundlagen der Programmierung WS23/24,11689,W03P02 - Grundlegende Arrayfunktionen im Mehrdimensionalen,"#Grundlegende Array-Methoden

In dieser Aufgabe sollen einige Funktionen auf Arrays implementiert werden. Verwende dabei keine Methoden aus der Java-Bibliothek.
Implementiere die folgenden Methoden:

 - [task][Minima und Maxima]( 157852 )
`public static int[][] minsAndMaxs(int[][] a)` - berechnet für jedes innere Array `a[i]` das Minimum und das Maximum und schreibt diese als ein zweielementiges Array in das Output-Array an Stelle `i`. Dabei soll der `0`-te Eintrag des zweielementigen Arrays dem Minimum und der `1`-te dem Maximum entsprechen. Für das Eingabe-Array `a == {{1, 2, 3, 4}, {5, 4, 3, 2}, {1, -2, 4, 3, 3}}` soll also z.B. das Array `{1, 4}, {2, 5}, {-2, 4}` zurückgegeben werden, da das erste innere Array `a[0]` als Minimum die `1` und als Maximum die `4` hat, das zweite innere Array `a[1]` als Minimum die `2` und als Maximum die `5` und das letzte innere Array als Minimum die `-2` und als Maximum die `4`.

- [task][Transponieren]( 157860 )
`public static int[][] transpose(int[][] a)` - berechnet für ein ""rechteckiges 2D-Array"", d.h. eines, bei dem alle inneren Arrays die gleiche Länge haben, ein weiteres ""rechteckiges 2D-Array"", bei dem Zeilen und Spalten vertauscht sind.
Für die Eingabe
```text
{
    {1, 2, 3, 4},
    {5, 6, 7, 8}
}
```
soll so z.B. die Ausgabe
```text
{
    {1, 5},
    {2, 6},
    {3, 7},
    {4, 8}
}
```
produziert werden.

 - [task][Linearisieren]( 157857 )
`public static int[] linearize(int[][] a)` - gibt ein neues, eindimensionales Array zurück, welches die Werte des übergebenen zweidimensionalen Arrays `a` enthält.
Die Zeilen des Arrays `a` sollen dabei nacheinander in der ihrem Zeilenindex entsprechenden Reihenfolge in dem eindimensionalem Array abgelegt werden.
Beachte, dass Zeilen nicht gleich lang sein müssen.  
Beispiel: `linearize(new int[][] {{1, 3}, {25}, {7, 4, 6, 9}})` liefert ein Array `{1, 3, 25, 7, 4, 6, 9}`.

- [task][Kreuzworträtsel]( 157859 )
`public static boolean crossword(char[][] letterGrid, char[] word)` - soll in einem ""rechteckigen 2D-Array"" von Buchstaben nachsehen, ob das durch das 1D-Char-Array beschriebene Wort `word` in diesem von links nach rechts, von oben nach unten oder von links oben nach rechts unten diagonal zu lesen ist.
So soll z.B. das Wort `new char[]{'P', 'I', 'N', 'G', 'U'}` in folgenden Kreuzworträtseln als darin vorkommend erkannt werden:
```text
PINGU
AAAAA
AAAAA
AAAAA
AAAAA
```
```text
PAAAA
IAAAA
NAAAA
GAAAA
UAAAA
```
```text
PAAAA
AIAAA
AANAA
AAAGA
AAAAU
```
In folgenden Kreuzworträtseln aber nicht:
```text
PAAAA
AINAA
AAAGU
AAAAA
AAAAA
```
```text
UGNIP
AAAAA
AAAAA
AAAAA
AAAAA
```
```text
AAAAU
AAAGA
AANAA
AIAAA
PAAAA
```


Die inneren Arrays in `letterGrid` stellen dabei die Zeilen des Kreuzworträtsels dar.
D.h. das Rätsel
```text
PINGU
IAAAA
ZAAAA
ZAAAA
AAAAA
```
wird durch das Array
```text
{
    {'P', 'I', 'N', 'G', 'U'},
    {'I', 'A', 'A', 'A', 'A'},
    {'Z', 'A', 'A', 'A', 'A'},
    {'Z', 'A', 'A', 'A', 'A'},
    {'A', 'A', 'A', 'A', 'A'}
}
```
beschrieben."
299,Praktikum: Grundlagen der Programmierung WS23/24,11690,W03P03 - Switch,"#Switches

In dieser Aufgabe sollen einige Funktionen implementiert werden, die die Nutzung des Java-Schlüsselworts `switch` einüben sollen.
**Verwende daher in der gesamten Aufgabe keine Kontrollstrukturen außer `switch`. Insbesondere darfst du also nicht die Schlüsselwörter `if`, `else`, `for`, `while`, `do` und den ternären Operator `? :` benutzen. Auch Streams gehen am Sinn der Aufgabe vorbei.**
(Ob du dies jedoch tatsächlich tust, werden wir nicht testen. Dies ist schließlich eine P-Aufgabe, die nur zum Üben da ist. Die Tests der Aufgabe überprüfen nur, ob deine Methoden das korrekte Input-Output-Verhalten aufweisen.)


[task][Locations der Hörsaal]( 157888 )
`public static String locationOfLectureHall(String hall)` - gibt einen String zurück, der beschreibt, wo sich der übergebene Hörsaal `hall` der TUM befindet.
Wir kennen dabei nur die 7 Hörsäle, in denen die Zentralübungen stattfinden:
"" MI⎵HS⎵2 "", 
"" MW0001 "", 
"" MW2001 "", 
"" Interims⎵I⎵1 "", 
"" Interims⎵II⎵2 "", 
"" Carl-von-Linde "", 
"" N1190 "".

Diese befinden sich an den folgenden 4 möglichen Locations (die Interimshörsäle werden je dem nächstgelegenen Gebäude zugeordnet):
"" Informatik "", 
"" Maschinenwesen "", 
"" Chemie "", 
"" Innenstadt "".

Sollte ein unbekannter Hörsaal übergeben werden, wird "" Unbekannter⎵Hörsaal "" zurückgegeben.



[task][Einschlüsse]( 157887 )
`public static int inclusions(char c)` - berechnet für den übergebenen Character, wie viele abgeschlossene Flächen dieser (im Font [Consolas](https://www.fileformat.info/info/unicode/font/consolas/grid.htm)) enthält.
So enthält das `A` eine eingeschlossene Fläche, das `B` zwei und das `C` keine.

Die Methode soll für alle lateinischen Groß- und Kleinbuchstaben (ohne Varianten wie `Ä`, `Á` usw.) und die arabischen Ziffern von `0` bis `9` die korrekte Anzahl an Einschlüssen zurückgeben. Für alle weiteren Zeichen soll der Fehlerwert `-1` zurückgegeben werden.



[task][Formatiertes Datum]( 157886 )
`public static String formatDate(int day, int month, int weekday)` - soll das übergebene Datum `day`.`month`. und den übergebenen Wochentag `weekday` (wobei hier `1` für den Montag, `2` für den Dienstag use. steht) in folgendem Format zusammenfassen:
""\ ,⎵den \ .⎵ \ "".

So soll Beispielsweise für die Werte `day == 2`, `month == 11` und `weekday == 3` der `String` "" Mittwoch,⎵den⎵2.⎵November "" zurückgegeben werden.

Wenn der Monat `month` oder der Wochentag `weekday` ""out of bounds"" sind, soll stattdessen der `String` "" Undefiniertes⎵Datum "" zurückgegeben werden.

*Hinweis:* Es muss **nicht** überprüft werden, ob `day` und `month` zusammen ein valides Datum bilden. Nur, ob `month` und `weekday` kleiner 1 bzw. größer 12 bzw. 7 sind.



[task][Tage im Februar]( 157885 )
`public static int daysInFebruary(int year)` - soll für die übergebene Jahreszahl zurückgeben, wie viele Tage der Februar in diesem Jahr hat. Für die Jahre `2020` und `2400` soll also beispielsweise `29`, für die Jahre `2021` und `2100` soll `28` zurückgegeben werden.

Für diese Methode ist es nicht ""natürlich"", (nur) `switch` als Kontrollstruktur zu verwenden, sie ist aber alleine damit lösbar. Versuche es also der Übung halber dennoch!



[task][Restliche Tage im Jahr]( 157884 )
`public static int daysLeftInYearAfter(int day, int month, int year)` bekommt ein Datum in Form eines Tages `day`, Monats `month` und Jahres `year` übergeben. Es soll die Anzahl an Tagen im Rest des Jahres **ausschließlich** dem übergebenen Tag berechnet werden. Achte hier insbesondere nochmal darauf, dass du auch keine Schleifen, nicht nur keine `if`-Statements und `? :`'s, verwenden sollst.

Als Beispiel sind am 20.12.2021 noch 11 Tage des Jahres übrig, am 02.11.2022 noch 59 Tage und am 01.01.2023 noch 364 Tage.

Im Falle, dass für den Monat `month` ein ungültiger Wert übergeben wurde, soll stattdessen der Fehlerwert -1 zurückgegeben werden.

*Hinweis:* Du darfst davon ausgehen, dass wenn der Integer `month` einen validen Monat beschreibt, der Tag `day` auch innerhalb der Grenzen des Monats liegt. Wir übergeben dir in unseren Tests also nicht den 35.05. oder den 30.02. oder den 29.02.2021, sondern nur gültige Daten. Hier wäre die Überprüfung mit `switch` allein wohl zu umständlich. Nur der Monat `month` selbst kann auch ""out of bounds"" (also kleiner 1 oder größer 12) sein. Damit musst du umgehen."
299,Praktikum: Grundlagen der Programmierung WS23/24,11758,W03H01 - Array Funktionen,"# W03H01 - Array Fun(ktionen)

Die Pinguine Happy und Snappy haben von deiner tollen Leistung in der W03P01 und W03P02 gehört und wollen unbedingt, dass du ihnen hilfst, noch weitere Funktionen zu schreiben.

Implementiere daher die folgenden statischen Methoden in `ArrayFunctions`.



[task][Sichere Summe]( 160193 )

Die Methode `public static long sumOfSquares(int[] array)` berechnet die Summe der Quadrate der einzelnen Einträge des Arrays `array`, also in anderen Worten das Quadrat der Länge des Vektors `array`.
Sie soll den korrekten Wert dieser Summe zurückgeben, insofern dieser noch in einen `long` passt. Wenn dies nicht der Fall ist, soll der `String` "" Overflow! "" auf der Konsole ausgegeben und der Fehlerwert `-1` zurückgegeben werden. Achte also auf Overflows, sowohl von Integern als auch von Longs.

Die Summe des leeren Arrays ist für diese Aufgabe als $$0$$ definiert.

*Hinweis:* Integer können Werte zwischen jeweils einschließlich $$-2^{31}$$ und $$2^{31} - 1$$, Longs Werte zwischen jeweils einschließlich $$-2^{63}$$ und $$2^{63} - 1$$ darstellen.



[task][Reißverschluss]( 160164 )

Die Methode `zip()` hat die Signatur `int[] zip(int[] a, int[] b)`.
Der Rückgabewert ist ein Array mit allen Werten aus `a` und `b`. Dabei wechseln sich Werte aus `a` und `b` immer ab, beginnend mit `a`.
Mit `a=[1,3]` und `b=[2,4]` ist also das Ergebnis `[1,2,3,4]`. 
Wenn die Arrays unterschiedliche Länge haben, werden die fehlenden Zahlen des schon vollständig übernommenen Arrays übersprungen und nur noch Zahlen aus dem längeren Array angehängt.



[task][Reißverschlüsse]( 160168 )

Die Methode `zipMany()` verhält sich ähnlich zu `zip()`, nur hat es n verschiedene Arrays als Eingabe.
Die Signatur ist folglich `int[] zipMany(int[][] arrays)`.
Auch hier sollen die Zahlen aus den Eingabe-Arrays der Reihe nach abwechselnd in das Ergebnis-Arrays eingefügt werden. 
Ebenso sollen bereits vollständig bearbeitete Arrays dabei übersprungen werden, bis alle Werte der Eingabe-Arrays verbraucht wurden.
Wenn das Eingabe-Array leer ist, wird ein leeres Array zurückgegeben.

Beispiel: mit `arrays=[[1,4],[2,5],[3,6]]` ist das Ergebnis `[1,2,3,4,5,6]`.



[task][Filtern]( 160196 )

Die Methode `public static int[] filter(int[] array, int min, int max)` entfernt Zahlen aus dem Array, die nicht innerhalb eines angegeben Intervalls sind.
Das Intervall wird durch 2 integer angegeben, die jeweils den größten und kleinsten erlaubten Wert inklusiv darstellen.
Das zurückgegebene Array ist, wenn alle Zahlen außerhalb des Intervals herausgefiltert wurden, entsprechend kleiner, die Reihenfolge der erlaubten Zahlen bleibt aber gleich.
Wenn der größte erlaubte Wert kleiner als der kleinste erlaubte Wert ist, kann kein Wert dieses Kriterium erfüllen und das Ergebnis ist ein leeres Array.



[task][Rotieren]( 160189 )

Die Methode `public static void rotate(int[] array, int amount)` soll die Einträge von `array` um `amount` nach hinten rotieren. D.h. alle Einträge sollen um `amount` nach hinten verschoben werden, wobei das hinterste Element beim um 1 Rotieren wieder nach vorne an die erste Stelle kommt. Wenn man also z.B. das Array
```text
[1, 2, 3, 4, 5]
```
um `2` rotiert, erhält man das Array
```text
[4, 5, 1, 2, 3]
```
`1`, `2` und `3` wurden um 2 nach hinten bewegt, `4` und `5` wären aus den Bounds des Arrays gefallen, landen also wieder ganz vorne.

Rotation um eine negative Zahl entspricht dabei einer Rotation in die andere Richtung (nach links), Rotation um eine Zahl mit Betrag $$\geq$$ `array.length` rotiert es einfach mehrfach komplett.
Wenn man z.B.
```text
[1, 2, 3, 4, 5]
```
um `-1` rotiert, erhält man das Array
```text
[2, 3, 4, 5, 1]
```

Wenn man
```text
[1, 2, 3, 4, 5]
```
um `6` rotiert, erhält man das Array
```text
[5, 1, 2, 3, 4]
```

Für `amount` kann also jeder beliebige `int` übergeben werden, es kommt immer eine valide Rotation heraus.



[task][Zählen]( 160185 )

Die Methode `public static int[][] quantities(int[] array)` soll die Anzahl an Vorkommen jeder im Array `array` überhaupt vorkommenden Zahl zählen. Dabei soll die Anzahl `#x` von Vorkommen der Zahl `x` durch das Array `{x, #x}` repräsentiert werden.
Die Methode gibt nun ein Array von derartigen Arrays zurück. Für jede in `array` vorkommende Zahl soll ein solcher Eintrag erstellt werden und zwar in der Reihenfolge, in der die Zahlen in `array` jeweils zum ersten Mal vorkommen.

Hier ein Beispiel: Das Array
```text
ex1 = [1, 1, 2, 1, 3, 2, 1]
```
enthält 4-mal die `1`, 2-mal die `2` und 1-mal die `3`, was durch die Arrays `{1, 4}`, `{2, 2}` und `{3, 1}` dargestellt wird.
Das erste Vorkommen von der `1` steht vor dem ersten Vorkommen der `2`, welches wiederum vor dem ersten Vorkommen der `3` steht.
Der Rückgabewert von `quantities(ex1)` ist daher
```text
[
  [1, 4],
  [2, 2],
  [3, 1]
]
```

Hier noch ein weiteres Beispiel: Für das Array
```text
ex2 = [2, 0, 3, 0, 2, 5, 5, 3, 2, 0, 0, 0]
```
wäre der Rückgabewert von `quantities(ex2)`
```text
[
  [2, 3],
  [0, 5],
  [3, 2],
  [5, 2]
]
```"
299,Praktikum: Grundlagen der Programmierung WS23/24,11759,W03H02 - Seam Carving,"# W03H03 - Seam Carving

Happy und Snappy waren vor kurzem im Urlaub. Dabei hat Snappy einige Bilder von Happy geschossen. Doch die einzelnen Elemente der Bilder sind Happy zu weit auseinander. Du sollst nun ein kleines Bildbearbeitungsprogramm schreiben, dass das korrigiert.

Glücklicherweise hast du nach etwas suchen einen Algorithmus gefunden, mit dem du die Bilder wie gewünscht editieren kannst: Seam Carving.

![image.png](/api/core/files/markdown/Markdown_2022-11-02T00-15-05-059_de467ada.png)  
(Hier eines der Bilder von Happy)


## Allgemeine Hinweise

- In [java.lang.System](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/System.html) und [java.util.Arrays](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Arrays.html) finden sich ein paar hilfreiche Methoden zur Arbeit mit Arrays.
- Die übergebenen Arrays sind immer mindestens so lang, wie durch die anderen Parameter angegeben. Die Arrays können aber auch immer länger sein als für die aktuellen Bilder notwendig ist. Wenn z.B. eine Länge und Breite angegeben ist, hat das zugehörige Array mindestens die Länge $$\text{Länge}\cdot\text{Breite}$$.
- Bilder werden als eindimensionales Array dargestellt. Dabei wird das Bild Zeilenweise gespeichert. Das sieht in der Praxis wie folgt aus:  
![image-layout.svg](/api/core/files/markdown/Markdown_2022-11-02T00-04-37-730_34f2f48c.svg)  
Der Ursprung ist dabei oben links, die X Achse wächst nach rechts und die y Achse nach unten.(Überlege welches Index `i` den Pixel `(x, y)` representiert. Das kannst du bei der Lösung mithilfe einer Methode übersetzen)
- Alle Bilder haben immer eine Größe und Länge $$\geq0$$
- Wenn für die Implementierung frühere Methoden wiederverwendet werden sollen, werden diese, falls falsche Ergebnisse geliefert wurden, ein zweites mal getestet, wobei die benutzten Methoden mit richtigen Versionen ersetzt werden. Dadurch werden richtig implementierte Methoden, die jedoch fehlerhafte gefordert Methoden nutzen, als richtig erkannt.

## Der Algorithmus 

Die grobe Funktionsweise wird nun anhand dieses Bildes erklärt  
![Orignal Bild](https://upload.wikimedia.org/wikipedia/commons/e/e2/BroadwayTowerSeamCarvingA.png)

Um deine Bilder mit Seam Carving zu bearbeiten, musst du 3 wesentliche Schritte implementieren:

1. Finde wichtigere und unwichtigere Pixel. Man kann dafür verschiedene Algorithmen nutzen, wir werden für diese Gewichtung die Gradient Magnitude nutzen. Wichtigeren Pixeln wird dabei ein größerer Wert zugewiesen.  
![Wichtigere Pixel sind heller](https://upload.wikimedia.org/wikipedia/commons/5/53/BroadwayTowerSeamCarvingB.png)

2. Generiere aus diesen Gewichten die namensgebenden Seams. Das sind im Grunde Linien, die sich durch das Bild ziehen und von Regionen, die im Voraus als unwichtig eingestuft wurden, angezogen werden, wobei sie sich mit maximal 45° seitlich bewegen können. Dabei wird die Gewichtung der einzelnen Pixel, durch die die Linie geht, addiert.  
![Auswahl von Seams durch besonders unwichtige Pixel](https://upload.wikimedia.org/wikipedia/commons/9/97/BroadwayTowerSeamCarvingC.png)

3. Entferne so lange die unwichtigsten Seams, bis die gewünschte Breite erreicht ist.  
![Ergebnis Bild](https://upload.wikimedia.org/wikipedia/commons/3/33/BroadwayTowerSeamCarvingE.png)

(Quelle der Bilder: [Wikipedia](https://en.wikipedia.org/wiki/Seam_carving)/[Newton2](https://en.wikipedia.org/wiki/User:Newton2))

## Bildformat

Die Bilder werden als eindimensionales Array von `int`s gespeichert. 
Dabei repräsentiert jedes int einen Pixel im rgb format.
Ein schwarzer Pixel sieht wie folgt aus:  
$$\begin{array}{|c|c|c|c|c|}\hline0x&\alpha\alpha&00&00&00 \\\\& \alpha & g & b & r \\\\ \hline\end{array}$$  
Das heißt das erste Byte $$\alpha$$, das zweite Byte der Wert im Grün-Kanal u.s.w. Der mit $$\alpha$$ beschriebene Bereich enthält die Transparenz und wird von uns hier ignoriert.  
Es ist empfehlenswert Helpermethoden zu implementieren, die diese Werte zurückgeben. Für `v = 1000490` wäre z.B. `g=15`, `b=68` und `r=42`. (`100049 = 0x000f442a`, `g=0x0f`, `b=0x44`, `c=0x2a`)

## Gradient Magnitude

Gradient Magnitude misst die Veränderung des lokalen Farbverlaufes in x oder y Richtung und ist dadurch in komplexeren Bildbereichen größer.
Definiert ist es wie folgt:  
$$\begin{array}{|c|c|c|}\hline a & b & c \\\\ \hline d&e&f \\\\\hline g&h&i\\\\\hline\end{array}$$  
Bei e ist für ein Farbband (der r,b und g Kanal) die Magnitude $$(b-h)^2+(d-f)^2$$, wobei wir die Magnituden der 3 Bänder addieren.

An den Rändern des Bildes fehlen jedoch für die Berechnung relevante Werte. 
Alle Pixel, für die diese Formel dadurch keinen Wert liefert, setzen wir auf den Maximalwert eines `int`s. 
Ein Beispiel für einen solchen Punkt wäre folgendes:  
$$\begin{array}{|c|c|}\hline  &   \\\\ \hline x& \\\\\hline &\\\\\hline\end{array}$$  
Der Punkt x grenzt an einen der Bildränder, wodurch wir das Gewicht des Punktes nicht berechnen können. Deshalb Setzen wir x wie beschrieben auf den Maximalwert von `int`.

### Methoden

Die Berechnung wird auf 2 Schritte aufgeteilt.
1. `computeGradientMagnitude`
   Diese Methode bekommt 2 Pixelwerte als Integer Parameter und berechnet die Gradient Magnitude zwischen ihnen mit der bekannten Formel. Es wird also nicht die gesamte Gradient Magnitude über 4, sondern nur für 2 gegenüberliegende Pixel berechnet. Man muss also immer 2 Aufrufe dieser Methode für die Berechnung der vollständigen Magnitude addieren.
2. `togradientMagnitude`
   Diese Methode berechnet wie beschrieben die Gradient Magnitude und schreibt die Ergebnisse in das 2. übergebene Array (`gradientMagitude`). D.h. für jedes Pixel wird die berechnete Magnitude in die gleiche Position geschrieben.
   
## Manuelle Korrekturen

Manchmal kommt es vor, dass man bestimmte Bildteile erhalten möchte, die jedoch für den genutzten Gewichtungsalgorihmus eine geringe Relevanz haben. Deshalb ist es sinnvoll, das gezielt manuell überschreiben zu können.

Umgesetzt wird das, indem zusätzlich zum zu bearbeitenden Bild noch eine Maske mitgegeben wird. Darin ist jeder Pixel, der behalten werden soll, mit Schwarz (alle 3 Kanäle auf 0) markiert.  
Das Gewicht dieser Pixel sollen den Maximalwert `Integer.MAX_VALUE` bekommen.
Umgesetzt wird das in `combineMagnitudeWithMask`, indem in die Indizes, die bei `mask` einen Wert für Schwarz haben, in `gradientMagnitude` auf `Integer.MAX_VALUE` gesetzt werden.

Man kann davon ausgehen, dass beide Arrays groß genug sind.

## Seams

Die Seams sind Linien durch das Bild die aus jeder Zeile genau ein Pixel enthalten und sich mit maximal 45° Neigung durch das Bild ziehen.

Wir bauen die Seams iterativ Reihe für Reihe auf. An jedem Punkt der ersten Bildzeile beginnt ein Seam. Den Weiteren Verlauf des Seams bestimmen wir wie folgt:  
- Von den 3 Pixel unterhalb des vorherigen Pixels wird der mit dem geringsten Gewicht gewählt.  
![seam-right.svg](/api/core/files/markdown/Markdown_2022-09-28T22-22-55-453_0a5d35c7.svg)  
Wenn der linke und rechte Pixel das gleiche Gewicht hat, wird der linke gewählt  
![seam-left.svg](/api/core/files/markdown/Markdown_2022-09-28T22-01-47-160_381d0282.svg)  
Wenn der mittlere einer der Pixel mit minimalem Gewicht ist, wird immer er gewählt.  
![seam-mid.svg](/api/core/files/markdown/Markdown_2022-09-28T22-23-02-501_4169d0c4.svg)  


Das wird mit jedem Seam in jeder Zeile durchgeführt und dabei die Gewichte aufaddiert und x Positionen der Punkte gespeichert. Die Gewichte werden in einem `long` array und die Punkte in einem zweidimensionalen `int` Array gespeichert. Dabei wird das äußere Array mit der x Position des Startpixels des Seams geindexed und das innere mit der y Koordinate der einzelnen Punkte des Seams.

An den Rändern des Bildes sind eventuell nicht alle benötigten Pixel vorhanden.
Der Seam kann natürlich nicht über den Rand hinaus gehen. Es bleiben also dementsprechend weniger Optionen für den nächsten Pixel übrig.

Implementiert wird das in `buildSeams`.

## Seams entfernen

Nun fehlt noch der letzte Schritt: Das Entfernen eines Seams aus dem Bild.
Als Parameter bekommt man ein Array mit allen x Koordinaten des Seams, ein Bild Array und die aktuelle Höhe und Breite.
Deine Aufgabe ist es, die Pixel in diesem Array so zu verschieben, dass ein 1 Pixel schmäleres Bild zurückbleibt mit den Seam Pixel entfernt.
Dabei soll das Ergebnis im als Parameter übergebenen Bild Array stehen.
Die größe des Arrays kann und muss dabei **nicht** angepasst werden, die ungenutzten nach dem Verkleinern sollen dabei am Ende des Arrays sein.
Implementiert wird das in `removeSeam`.

## Alles Zusammen

Es ist nun Zeit, die bisherige Funktionalität zu kombinieren.
Die Zahl der Seams, die entfernt werden soll, ist durch die Differenz von `width` und `newWidth` gegeben.
Es wird immer der Seam entfernt, der das minimale Gewicht hat. 
Wenn mehrere das gleiche Gewicht haben, wird der erste (kleinster Index) gewählt.
Für jeden zu entfernenden Seam muss die Gradient Magnitude neu berechnet werden, mit der Maske kombiniert und die Seams neu berechnet werden.
Das Ergebnis soll am Ende **mit** angepasster Länge zurückgegeben werden.

## Ein kleiner Test

Im Repository ist bereits ein kleiner Ausschnitt des Bildes zusammen mit einer Maske enthalten.
Außerdem ist das Ergebnis, wenn man das Bild um 1 Pixel verkleinert enthalten. 
Mithilfe von `SimpleMain` könnt ihr euer Programm testen. Dort stehen in `Strings` am Anfang der `main` die Dateinamen der Ein- und Ausgabedateien. Aktuell sind diese die Beispieldateien, die im Repo dabei sind. 
Zudem gibt es `GradleMain`, die dasselbe Verhalten hat, aber `args` für die Eingaben der Pfade benutzt. Das ist etwas schöner, da dann andere Nutzer den Sourcecode nicht verändern müssen, um andere Bilder auszuprobieren. Hier soll es aber nur als Beispiel dienen, wie man es implementieren kann, für euer eigenes Testen reicht `SimpleMain` aber vollkommen aus.
Das Ergebnis kann man dann z.B. mit ImageMagicks `compare` vergleichen.

![example.png](/api/core/files/markdown/Markdown_2022-11-02T00-08-28-343_96d49d00.png)  
Der Bildausschnitt

[task][Natürlich gibt es dafür auch einen Test]( 160209 )

### Bild Quelle
By Klearchos Kapoutsis from Paleo Faliro, Athens, Greece. - Баба Вида, CC BY 2.0, https://commons.wikimedia.org/w/index.php?curid=7678413"
299,Praktikum: Grundlagen der Programmierung WS23/24,11768,W04P01 - Rekursion,"# Rekursive Mathematik

In dieser Aufgabe lernst du das Prinzip der Rekursion anhand einiger mathematischer Probleme und anderer Funktionen kennen. Um es dir leichter zu machen, enthält das Template bereits iterative Beispiel-Implementierungen für zwei der vier hier zu implementierenden Funktionen.

*Hinweis:* Du solltest in dieser Aufgabe außer für die Methode `permutations()` keine Schleifen verwenden. Vermeide also die Schlüsselwörter `for` und `while`. Streams gehen auch am Lernziel dieser Aufgabe vorbei, solltest du sie schon kennen. Bei der letzten Methode in Schleifen o.k., da diese sonst recht unübersichtlich wird. Achte allerdings auch hier darauf, das Problem geeignet auf ein Teilproblem mit einem kleineren Eingabe-Array herunterzubrechen und dieses dann in einem rekursiven Aufruf zu lösen.

### Rekursion

Starte mit einer rekursiven Implementierung der folgenden Probleme: 
- [task][binomCoeffRecursive]( 160425 )
Vervollständige die Methode `binomCoeffRecursive(int n, int k)`, sodass sie den Binomialkoeffizienten berechnet. Falls du dich nicht mehr an deine Schulzeit erinnerst, ist das kein Problem, die Rekursive Definition lautet nämlich $$\binom{n}{k} = \binom{n - 1}{k - 1} + \binom{n - 1}{k}$$. Außerdem gilt:
    - $$\binom{n}{n} = \binom{n}{0} = 1$$ für nicht-negative n
    - für $$k>n$$ soll *0* zurückgegeben werden
    - andere fehlerhafte Eingaben werden nicht getestet. Du musst sie also nicht behandeln.
- [task][fibonacciRecursive]( 160421 ){}
Vervollständige die Methode `fibonacciRecursive(int n)`, sodass sie die n-te Fibonacci-Zahl ausgibt. Die n-te Fibonacci-Zahl berechnet sich durch $$f\_n=f\_{n-1}+f\_{n-2}$$.
    - Als Startwerte nehmen wir $$f\_0=0$$ und $$f\_1=1$$

Nun implementiere noch rekursiv folgende beiden Methoden:
- [task][differenceAsBs]( 160422 )
Übernimmt ein beliebiges Character-Array `word` und berechnet dafür die Differenz der Anzahl an 'A's und an 'B's, die in diesem vorkommen. Für `{'A', 'B', 'B', 'A', 'A'}` sollte also $$3 - 2 = 1$$ zurückgegeben werden, für `{'A', 'B', 'B', 'B'}` $$1 -3 = -2$$.
Implementiere hier nur die Hilfsmethode `differenceAsBs(char[] word, int from)`, die diese Differenz für alle Einträge ab dem Index `from` berechnet und diese zurückgibt. Verwende keine Schleifen, Streams oder String-Methoden, um über das Array zu iterieren.
- [task][permutations]( 160426 )
Nimmt ein Integer-Array `array` (von dem du ausgehen darfst, dass es keine Zahl mehrfach enthält) entgegen und gibt ein Array zurück, bei dem jeder Eintrag genau einer Permutation von `array` entspricht. Jede Permutation sollte auch einmal enthalten sein. Hier darfst du Schleifen verwenden, da die Lösung sonst sehr unübersichtlich würde. Achte jedoch darauf, dennoch einen geeigneten rekursiven Aufruf in deiner Methode zu haben."
299,Praktikum: Grundlagen der Programmierung WS23/24,11790,W04P02 - Gnome Sort,"# Sortieren mit Gartenzwergen

Gartuine lieben Gartenzwerge, besonders Gnom-artige. Deshalb hat die Gartuingruppe der örtlichen Pinguinschule auch einen Gartenzwerg Roboter in Gnomform gebaut. Jetzt wollen sie dem Roboter beibringen, Blumentöpfe nach Größe zu sortieren. Natürlich wollen sie dafür den namentlich passenden `Gnome Sort`-Algorithmus verwenden, bei dessen implementierung sie deine Hilfe brauchen.

[task][GnomeSort]( 161926 , 161925 , 161920 , 161922 , 161924 )
Implementiere die Methode `gnomeSort`, die das übergebene `int`-Array `a` mittels GnomeSort sortieren soll. Die sortierte Folge soll wieder in `a` stehen.  
GnomeSort funktioniert wie folgt:  
Der Gnom steht vor eine Reihe von Blumentöpfen, die der Größe nach sortiert werden soll. Er startet beim Blumentopf ganz links.  
Sollte er beim ersten Blumentopf stehen, oder der aktuelle Blumentopf ist größer (oder gleich groß) als der Blumentopf links daneben, so geht der Gnom einen Blumentopf nach rechts.  
Sollte dies nicht der Fall sein, vertauscht der Gnom die beiden Blumentöpfe und geht einen Blumentopf nach links.  
Wenn der Gnom mit seinem Schritt nach rechts den letzten Blumentopf hinter sich gelassen hat, dann sind alle Töpfe sortiert und der Algorithmus endet."
299,Praktikum: Grundlagen der Programmierung WS23/24,11791,W04P03 - Rekursives Sortieren,"# Rekursives Sortieren

In dieser Aufgabe sollst du einige Ansätze zum Sortieren von Arrays rekursiv Implementieren. Das Eingabe-Ausgabe-Verhalten der folgenden drei Tasks ist - bis auf eine Kleinigkeit - immer das gleiche: Parameter ist ein potentiell unsortiertes Array von Integern, Ausgabe ist ein Array, welches die gleichen Integer aber in aufsteigender Sortierung enthält.
Die eben genannte ""Kleinigkeit"" ist, dass `int[] mergeSort(int[] array)` das sortierte Array jeweils zurückgeben soll, während `void stoogeSort(int[] array)` und `void selectionSortRec(int[] array)` die übergebenen Arrays in-Place, also in dem ihnen übergebenen Array-Objekt, sortieren sollen. Sie haben daher keinen separaten Rückgabewert.

*Hinweis:* Die Tests dieser Aufgabe überprüfen jeweils nur, ob der in die jeweilige Methode geschriebene Code das übergebene Array korrekt sortiert. Du passt also alle Tests, wenn du drei Mal iteratives BubbleSort implementierst. Automatisiert zu überprüfen, ob du das korrekte Verfahren zum sortieren anwendest, ist nicht möglich bzw. feasible. Die Tests sind also nur dazu da, dir Feedback zu geben, was an deiner Implementierung noch falsch sein könnte. Wie du sie verwendest, liegt in deiner Verantwortung.

[task][MergeSort]( 161941 )

Das erste Verfahren, das du implementieren sollst, ist das MergeSort-Verfahren aus den ZÜ-Folien.

[task][StoogeSort]( 161936 )

Das zweite Verfahren ist StoogeSort. Dieses geht bei der Sortierung eines Arrays folgendermaßen vor:
 - Wenn das übergebene Array von Länge 2 oder kürzer ist, ist Sortierung trivial: Direkt abbrechen bzw. einmal potentiell die beiden Einträge swappen.
 - Wenn das übergebene Array mehr als 2 Einträge hat, wird es in drei gleichgroße Blöcke zerlegt (bzw. kann der mittlere 1 oder 2 Elemente mehr enthalten, wenn die Länge nicht durch 3 teilbar ist). Dann
     - werden die ersten zwei Drittel sortiert. Dann
     - werden die zweiten zwei Drittel sortiert. Damit ist dann das größte Drittel der Elemente des Gesamtarrays ganz hinten in sortierter Reihenfolge. Dann müssen also nur noch
     - die ersten zwei Drittel sortiert werden, um das Array komplett zu sortieren.

Die Sortierung der kleineren Arrays erfolgt je über einen rekursiven Aufruf von `stoogeSort()`.

[task][Rekursives SelectionSort]( 161934 )

Zuletzt sollst du noch SelectionSort implementieren, allerdings mit dem Twist, dass du dabei keinerlei Schleifen (Schlüsselwörter `for` und `while` sind verboten) oder Streams oder Ähnliches verwenden sollst, sondern lediglich Rekursion.
SelectionSort ist ein Verfahren, das ähnlich zu BubbleSort funktioniert. Anstatt allerdings alle Paare einzeln zu swappen, läuft es beim ersten Durchlauf einmal über das ganze zu sortierende Array und ermittelt dabei die Position des größten Eintrags.
Dieser wird dann mit dem letzten geswappt. Danach wird der größte Eintrag im Array vom ersten bis zum vorletzten Element ermittelt und mit dem vorletzten geswappt, dann wird der größte Eintrag im Array vom ersten bis zum vorvorletzten Element und mit dem vorvorletzten Element geswappt usw.

Beispiel:
Erster Durchlauf:
```
{3, 5, 4, 1, 2}
```
Betrachtetes Teilarray: Indizes 0-4
Index des Größten: 1
Index des Letzten: 4
=> swap(1, 4)
```
{3, 2, 4, 1, 5}
```
Betrachtetes Teilarray: Indizes 0-3
Index des Größten: 2
Index des Letzten: 3
=> swap(2, 3)
```
{3, 2, 1, 4, 5}
```
Betrachtetes Teilarray: Indizes 0-2
Index des Größten: 0
Index des Letzten: 2
=> swap(0, 2)
```
{1, 2, 3, 4, 5}
```
Betrachtetes Teilarray: Indizes 0-1
Index des Größten: 1
Index des Letzten: 1
=> swap(1, 1) (bzw. kein swap())
```
{1, 2, 3, 4, 5}
```
Done!"
299,Praktikum: Grundlagen der Programmierung WS23/24,11833,W04H02 - Mega Merge Sort,"# Mega Merge Sort

Nachdem du den Gartuinen mit ihrem Gnomroboter geholfen hast, sind immer mehr naturliebende Schuloine der Gruppe beigetreten. Darüber freut sich die Gruppe natürlich. Jetzt steht der alljährliche Planzenwettbewert vor der Tür und die Verantwortlichen mussten feststellen, dass ein Gnomroboter nicht mehr mit den Sortieren hinterher kommt. Glücklicherweise konnten der Roboter mehrfach nachgebaut werden. Alles was jetzt noch fehlt ist ein Sortieralgorithmus, der auch mehrere Roboter effektiv einsetzen kann. Und natürlich brauchen die Gartuine dafür wieder deine Hilfe!




## Aufgabe

In dieser Aufgabe geht es darum, MegaMergeSort zu implementieren. Dabei handelt es sich um eine Variante des bekannten Divide-and-Conquer Sortieralgorithmus MergeSort. Bei MergeSort werden die zu sortierenden Elemente zuerst in möglichst gleichgroße Bereiche geteilt, indem jeder Bereich immer wieder halbiert wird. Anschließend werden diese Bereiche wieder zusammengeführt (gemergt), wobei sie sortiert werden. MegaMergeSort funktioniert sehr ähnlich, allerdings werden Bereiche nicht halbiert, sondern in eine festgelegte Anzahl an Teilbereiche zerlegt.

[task][Mergen zweier Arrays]( 163042 , 163038 , 163036 , 163033 , 163043 )
Zuerst sollst du die Methode `int[] merge(int[], int[])` implementieren, die die beiden übergebenen Arrays zu einem neuen zusammenfügt (merget) und dieses zurückgibt. Das Mergen funktioniert dabei wie bei normalem MergeSort: Man beginnt bei beiden Arrays beim ersten Element, vergleicht diese und fügt das kleinere im Ausgabe-Array ein. Das eingefügte Element überspringt man nun im Eingabe-Array und wiederholt die Prozedur, bis alle Elemente in der Ausgabe eingefügt wurden. Die Länge des zurückgegebenen Arrays entspricht natürlich der Summe der Längen der beiden Eingabearrays.

 
  Beispiel für das Mergen zweier Arrays  
```
merge([1, 3], [2, 4])

Vergleiche 1 und 2 -> füge 1 in die Ausgabe ein: [1]
Vergleiche 3 und 2 -> füge 2 in die Ausgabe ein: [1, 2]
Vergleiche 3 und 4 -> füge 3 in die Ausgabe ein: [1, 2, 3]
Nur 4 ist noch übrig -> füge 4 in die Ausgabe ein: [1, 2, 3, 4]
```
 

[task][Mergen mehrerer Arrays]( 163041 , 163039 , 163047 , 163044 )
Jetzt sollst du `int[] merge(int[][], int, int)` implementieren. Diese Methode soll rekursiv die inneren Arrays aus `arrays` im Indexbereich `from` (inklusiv) bis `to` (exklusiv) mergen (also `arrays[from]`, `arrays[from + 1]`, ... und `arrays[to - 1]` sollen gemerget werden) und das daraus resultierende Array zurückgeben. Falls der Bereich `[from, to[` leer ist, soll ein Array der Länge `0` zurückgegeben werden. Die genaue Mergereihenfolge siehst du in folgendem Beispiel:

 
  Beispiel für das Mergen mehrerer Arrays  
```
merge([[1], [2], [3], [4]], 0, 4)

merge von [3] und [4] -> [3, 4]
merge von [2] und [3, 4] -> [2, 3, 4]
merge von [1] und [2, 3, 4] -> [1, 2, 3, 4]
```
 

[task][MegaMergeSort]( 163040 , 163034 , 163035 , 163037 )
Als Letztes fehlt noch die Methode `int[] megaMergeSort(int[], int, int, int)` (die zugehörige Methode `int[] megaMergeSort(int[], int)`, mit der MegaMergeSort ausgeführt wird, ist schon gegeben). Diese Methode sortiert das `array` im Bereich `[from, to[` mit MegaMergeSort, wobei das Array in jeder Ebene in `div`-Teile aufgeteilt werden soll. Auch hier soll, falls `[from, to[` leer ist, ein Array der Länge `0` zurückgegeben werden. Beim Aufteilen gibt es Folgendes zu beachten: Es wird rekursiv aufgeteilt, bis ein Bereich maximal `1` Element enthält. Falls die Länge des zu sortierende Bereichs nicht restlos durch `div` teilbar ist, so sollen die ersten Teilbereiche entsprechend um 1 größer sein. Im Beispiel sieht das wie folgt aus:

 
  Beispiel für das Splitten eines Arrays  
```
megaMergeSort([1, 2, 3, 4, 5, 6, 7, 8], 3, 0, 8)

8/3 = 2 Rest 2
Split der 1. Ebene: [1, 2, 3], [4, 5, 6], [7, 8]
Split der 2. Ebene: 
  für [1, 2, 3]: 3/3 = 1 Rest 0 => [1], [2], [3]
  für [4, 5, 6]: 3/3 = 1 Rest 0 => [4], [5], [6]
  für [7, 8]: 2/3 = 0 Rest 2 => [7], [8], []
```
 

### Hinweis
- In der gesamten Aufgabe sind Methoden aus `java.util.Arrays` verboten.
- Wie du nach dem Klonen der Aufgabe sehen wirst, tragen die Methoden in dieser Aufgabe nicht die uns bekannten Köpfe `public static int[] merge(..)` o.Ä., sondern stattdessen Köpfe wie `protected int[] merge(..)`. Dies ist eine Notwendigkeit dafür, wie unsere Tests aufgebaut sind. Du kannst von einer der drei Methoden aus die anderen wie gewohnt mit einem Call wie `merge(.. parameter ..)` aufrufen. Von der `main()`-Methode aus kannst du das allerdings nicht mehr genauso. Daher haben wir dir die `main()`-Methode bereits implementiert. Um dein Verfahren zu testen, musst du nur noch `arr` und den zweiten Parameter im Call darunter entsprechend abändern. Was dieser neue Methodenkopf genau bedeutet, weißt du dann in Woche 07."
299,Praktikum: Grundlagen der Programmierung WS23/24,11906,W04H01 - Rekursive Pinguologie,"# Rekursive Pingulogie

Die Forschuine der PUM (Pingu Universität München) haben vor kurzem große Fortschritte in ihrer Forschung gemacht. Einige ihrer Thesen müssen aber noch überprüft werden und dafür brauchen sie - natürlich - deine Hilfe! Da es sich bei der PUM aber um eine Exzellenzuniversität handelt, haben die Forschuine einige Anforderungen an dich, die du unter den einzelnen Aufgaben findest.


## Allgemeine Anforderungen
- Jede Teilaufgabe **muss** rekursiv gelöst werden. Insbesondere sind Schleifen in der gesamten Aufgabe verboten und eine Verwendung dieser führt zu einer Bewertung mit 0 Punkten bei den entsprechenden Teilaufgaben. Das Gleiche gilt für Streams (wer diese schon kennt).
- Die Signatur der vorgegebenen Methoden (Name, Rückgabetyp, Parametertypen) darf **nicht** verändert werden. Es dürfen weitere Methoden auch mit gleichem Name und unterschiedlicher Signatur hinzugefügt werden.

## Aufgaben

[task][Aufgabe 1 - Rekursive Pinguin Reihe]( 163491 , 163497 , 163503 , 163493 , 163504 )
Als Erstes musst du die neuste Pinguin Reihe implementieren. Diese ist abhängig von einem Start-Vektor $$p = (p0, p1, p2)$$ und folgt dieser Berechnungsvorschrift:  
$$\text{pinguSequenceRec}(0) = p0$$  
$$\text{pinguSequenceRec}(1) = p1$$  
$$\text{pinguSequenceRec}(2) = p2$$  
$$\text{pinguSequenceRec}(n) = 2 * \text{pinguSequenceRec}(-n), \text{falls } n < 0$$  
$$\text{pinguSequenceRec}(n) = \text{pinguSequenceRec}(n-1) - \text{pinguSequenceRec}(n-2) + 2*\text{pinguSequenceRec}(n-3), \text{sonst} $$  
Für deine Implementierung geben dir die Forschuine den Vektor komponentenweise mit, sodass deine Methode insgesamt vier Parameter übernimmt. Außerdem gelten folgende Einschränkungen:
- -122 < n < 145
- Bei getesteten Kombinationen aus n und p wird es beim Ergebnis nicht zu long-Overflows kommen. 

Implementiere erstmal einen einfachen Ansatz, der rekursiv die richtigen Werte berechnet. Damit wirst du bereits die ersten Tests in dieser Teilaufgabe bestehen.
Dieser Ansatz wird aber für große n (>30) zu lange brauchen, weshalb du deine Herangehensweise noch verbessern musst. Ändere daher deinen bisherigen Ansatz wie folgt ab: 
Das Problem ist, dass bei großen n sehr viele Rekursive Aufrufe mehrfach berechnet werden müssen, was zu viel Zeit braucht. Daher sollen alle Berechnungen für positive n in einem Array abgespeichert werden.
- Erstelle ein `long` Array, wo du die schon berechnete Werte speicherst, sodass du für das gleiche `n` nicht mehrmals die Berechnung durchführen musst.
- Benutze dazu ein `boolean` Array, in dem die Information steht, ob du für das jeweilige `n` an dem Index bereits den berechneten Wert abgespeichert hast.
- Erstelle eine Hilfsmethode, der du alle nötigen Parameter und die beiden Arrays übergibst. Falls im Array bereits das Ergebnis abgespeichert ist, kannst du es direkt zurück geben. Ansonsten musst du wie bisher das Ergebnis normal rekursiv berechnen und dann vor der Rückgabe aber noch im Array abspeichern, damit es für zukünftige rekursive Aufrufe bereits gespeichert ist.
- Falls du freiwillig mehr zu diesem Ansatz lesen willst, kannst du im Internet nach ""Memoisation"" suchen. Das ist der Fachbegriff dafür.

 
 Beispiel für $$\text{pinguSequenceRec}$$ mit $$p=(1, 1, 2)$$. (`main`-Methode mit testTask = 1 ausführen) 
```
Task 1 example output
0: 1
1: 1
2: 2
3: 3
4: 3
5: 4
6: 7
7: 9
8: 10
9: 15
10: 23
11: 28
12: 35
13: 53
14: 74
15: 91
16: 123
17: 180
18: 239
19: 305
20: 426
21: 599
22: 783
23: 1036
24: 1451
25: 1981
26: 2602
27: 3523
28: 4883
29: 6564
30: 8727
31: 11929
32: 16330
33: 21855
34: 29383
35: 40188
36: 54515
37: 73093
38: 98954
39: 134891
40: 182123
41: 245140
42: 332799
43: 451905
44: 609386
45: 823079
46: 1117503
47: 1513196
48: 2041851
49: 2763661
50: 3748202
51: 5068243
52: 6847363
53: 9275524
54: 12564647
55: 16983849
56: 22970250
57: 31115695
58: 42113143
59: 56937948
60: 77056195
61: 104344533
62: 141164234
63: 190932091
64: 258456923
65: 349853300
66: 473260559
67: 640321105
68: 866767146
69: 1172967159
70: 1586842223
71: 2147409356
72: 2906501451
73: 3932776541
74: 5321093802
75: 7201320163
76: 9745779443
77: 13186646884
78: 17843507767
79: 24148419769
80: 32678205770
81: 44216801535
82: 59835435303
83: 80975045308
84: 109573213075
85: 148269038373
86: 200645915914
87: 271523303691
88: 367415464523
89: 497183992660
90: 672815135519
91: 910462071905
92: 1232014921706
93: 1667183120839
94: 2256092342943
95: 3052939065516
96: 4131212964251
97: 5590458584621
98: 7565123751402
99: 10237091095283
100: 13852884513123
101: 18746040920644
102: 25367338598087
103: 34327066703689
104: 46451809946890
105: 62859420439375
106: 85061743899863
107: 115105943354268
108: 155763040333155
109: 210780584778613
110: 285229431153994
111: 385974927041691
112: 522306665444923
113: 706790600711220
114: 956433789349679
115: 1294256519528305
116: 1751403931601066
117: 2370014990772119
118: 3207124098227663
119: 4339916970657676
120: 5872822853974251
121: 7947154079771901
122: 10754165167113002
123: 14552656795289603
124: 19692799787720403
125: 26648473326656804
126: 36060987129515607
127: 48798113378299609
128: 66034072902097610
129: 89357933782829215
130: 120920087637330823
131: 163630299658696828
132: 221426079587024435
133: 299635955202989253
134: 405470474933358474
135: 548686678904418091
136: 742488114377038123
137: 1004742385339336980
138: 1359627628771135039
139: 1839861472185874305
140: 2489718614093413226
141: 3369112399449808999
142: 4559116729728144383
143: 6169441558465161836
144: 8348549627636635451
```
 

[task][Aufgabe 2 - Pingu Zwillinge]( 163492 , 163501 , 163496 )
Als Nächstes musst du für die Forschuine die Zwillingsreihe `pinguF` und `pinguM` implementieren, die sich wie folgt berechnet:  
$$\text{pinguF}(0) = 1 $$  
$$\text{pinguF}(n) = n - \text{pinguM}(\text{pinguF}(n-1)), \text{falls } n>0 $$  
$$\text{pinguM}(0) = 0 $$  
$$\text{pinguM}(n) = n - \text{pinguF}(\text{pinguM}(n-1)), \text{falls } n>0 $$  
Die Forschuine verichern dir außerdem, dass die Eingabe `n` niemals negativ sein wird und beim Ergebnis zu keinem `int`-Overflow führen wird.

 
 Beispiel für $$\text{pinguF}$$ und $$\text{pinguM}$$ mit $$n=0...9$$. (`main`-Methode mit testTask = 2 ausführen) 
```
Task 2 example output
pinguF: 1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 
pingM: 0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 
```
 

[task][Aufgabe 3 - Der Pingu Code]( 163489 , 163500 )
Im Land der Pinguine gilt der ""Pingu Code"" als eins der am schwersten zu verstehenden Geheimnisse. Die Forscher der PUM haben jüngst einen Ansatz gefunden, diesen Code zu berechnen.  
Das Ergebnis ist von zwei Eingabezahlen `n` und `m` abhängig und lässt sich außerdem rekursiv unter Beachtung des Zwischenergebnisses berechnen. Anfangs ist das Zwischenergebnis natürlich 0. Falls $$n=0$$ gilt, so ist das Endergebnis die Summe aus `m` und dem Zwischenergebnis. Ansonsten muss unterschieden werden, ob die Summe aus `n` und dem Zwischenergebnis gerade ist oder nicht. Falls es gerade ist, wird rekursiv weitergerechnet, wobei das neue `n` den Wert von `m` erhält und das neue `m` die Hälfte des alten `n` (abgerundet). Außerdem werden `n`-halbe (altes `n`, abgerundet) zum Zwischenergebnis addiert. Falls obige Summe ungerade ist, wird auch rekursiv weitergerechnet. In diesem Fall wird jedoch `m` zum Zwischenergebnis addiert, `n` um eins reduziert und `m` halbiert (abgerundet).  
Auch bei dieser Aufgabe werden nur nicht-negative Eingaben verwendet und es wird nicht zu `int`-Overflows kommen. ""Abgerundet"" meint in dieser Aufgabe das normal Java-Rundungsverhalten (Richtung 0).

 
 Beispiel für pinguCode mit $$n=0...9, m=0...9$$. (`main`-Methode mit testTask = 3 ausführen) 
```
Task 3 example output
0, 0: 0
0, 1: 1
0, 2: 2
0, 3: 3
0, 4: 4
0, 5: 5
0, 6: 6
0, 7: 7
0, 8: 8
0, 9: 9
----------
1, 0: 0
1, 1: 1
1, 2: 3
1, 3: 4
1, 4: 6
1, 5: 7
1, 6: 9
1, 7: 10
1, 8: 12
1, 9: 13
----------
2, 0: 2
2, 1: 1
2, 2: 2
2, 3: 3
2, 4: 4
2, 5: 3
2, 6: 6
2, 7: 8
2, 8: 8
2, 9: 7
----------
3, 0: 2
3, 1: 1
3, 2: 3
3, 3: 4
3, 4: 6
3, 5: 7
3, 6: 9
3, 7: 11
3, 8: 12
3, 9: 13
----------
4, 0: 4
4, 1: 5
4, 2: 4
4, 3: 5
4, 4: 6
4, 5: 9
4, 6: 9
4, 7: 9
4, 8: 10
4, 9: 14
----------
5, 0: 4
5, 1: 3
5, 2: 7
5, 3: 6
5, 4: 8
5, 5: 9
5, 6: 11
5, 7: 11
5, 8: 14
5, 9: 15
----------
6, 0: 6
6, 1: 5
6, 2: 7
6, 3: 5
6, 4: 7
6, 5: 7
6, 6: 9
6, 7: 10
6, 8: 11
6, 9: 13
----------
7, 0: 6
7, 1: 5
7, 2: 7
7, 3: 8
7, 4: 11
7, 5: 9
7, 6: 11
7, 7: 13
7, 8: 15
7, 9: 17
----------
8, 0: 8
8, 1: 10
8, 2: 8
8, 3: 10
8, 4: 10
8, 5: 12
8, 6: 11
8, 7: 15
8, 8: 14
8, 9: 16
----------
9, 0: 8
9, 1: 7
9, 2: 12
9, 3: 10
9, 4: 12
9, 5: 14
9, 6: 16
9, 7: 15
9, 8: 18
9, 9: 19
----------
```
 

[task][Aufgabe 4 - Pingu DNS]( 163498 , 163499 , 163502 , 163494 , 163495 )
Zu guter Letzt musst du den Forschuinen noch helfen, die DNS eines Pinguins zu bestimmen, bei dem nur die Pingu-Werte der Eltern (`f` und `m`) bekannt sind. Für die rekursive Berechnung ist vor allem die binäre Darstellung dieser Werte relevant, die dir in Form eines (nicht negativen) `int` übergeben wird.  
Zur Bestimmung des DNA-`Strings` haben die Forscher folgende Prozedur gefunden:  
Sollten die Pingu-Werte beider Eltern 0 sein, so ist die resultierende DNS der leere `String` """".  
Falls nur `f` 0 ist, so wird für jedes Bit von `m` abzüglich führender 0er-Bits ein "" A "" angehängt, im ungekehrten Fall (nur `m`=0) ein "" T "". `pinguDNA(0,2)` gibt also "" AA "" zurück, da 2=10b entspricht. Für `pinguDNA(10,0)` ist die Lösung "" TTTT "", da 10=1010b ist.  
Interessant wird es, falls beide Pingu-Werte nicht 0 sind. In diesem Fall muss zuerst unterschieden werden, ob `f` und `m` mit dem selben Bitwert enden (Tipp: gerade/ungerade).  
Falls ja hängt das Basenpaar davon ab, ob `f` > `m` ("" GT ""), `f` < `m` ("" GA "") oder `f` = `m` ("" GC "") gilt.  
Falls nein, ist es relevant, welcher Pingu-Wert mit einem 1-er Bit endet. Sollte `f` so enden, wird "" TC "" angehängt, sonst "" AC "".  
Jedes Bit wird für genau eine Nukleinbase im Ausgabestring verwendet und kann daher für die Rekursion verworfen werden (Tipp: Division durch 2).  
Ein Schritt-für-Schritt Beispiel findest du, wenn du das folgende Beispiel aufklappst.

 
 Beispiel für `pinguDNA` mit Erklärung. (`main`-Methode mit testTask = 4 ausführen) 
```
pinguDNA(21, 25) = GCACTCGAGA
```
21 in binär ist ""10101b""  
25 in binär ist ""11001b""  

1. 21 != 0 != 25, beide enden mit 1er Bit und 21 < 25 => "" GA ""
2. Bits entfernen => f=""1010b""=10, m=""1100b""=12
3. f,m != 0, enden mit 0er Bit, f  "" GA "" => insgesamt "" GAGA ""
4. Bits entfernen => f=""101b""=5, m=""110b""=6
5. f,m != 0, enden mit unterschiedlichem Bitwert, m ist durch 2 teilbar => "" TC "" => insgesamt "" TCGAGA ""
6. Bits entfernen => f=""10b""=2, m=""11b""=3
7. f,m != 0 enden mit unterschiedlichem Bitwert, f ist durch 2 teilbar => "" AC "" => insgesamt "" ACTCGAGA ""
8. Bits entfernen => f=""1b""=1, m=""1b""=1
9. f,m != 0, enden mit 1er Bit und sind gleich => "" GC "" => insgesamt "" GCACTCGAGA ""
10. Bits Entfernen => f=0, m=0 => """", fertig => insgesamt "" GCACTCGAGA ""
 

## Hinweise
- Allgemeine Anforderungen findest du über den Aufgaben.
- Es wird nicht getestet, ob du die Probleme tatsächlich rekurisv löst.
- Falls ein Test ""Es gibt ein Problem mit den Tests selbst!"" ausgibt, wurde eine Exception geworfen. Dies liegt dann an deiner Abgabe, die mit einer getesteten Eingabe Probleme hat."
299,Praktikum: Grundlagen der Programmierung WS23/24,11919,W04H03 - PenguHull,"# PenguHull - Tales of a (very) drunk Penguin

Die globale Erwärmung macht den Pinguinen zu schaffen. Die exzellent studierten Pinguine der PUM haben nach reichlich Analyse festgestellt, dass sie damit beginnen müssen Nutztiere zu halten, um für ausreichend Nahrung zu sorgen. Da Pinguine am liebsten Fische verzehren, haben sie sich sehr schnell darauf geeinigt, ein Gebiet im Wasser abgrenzen zu wollen, um dort die Fische zu züchten und anschließend leichter fangen zu können. Die Forschuine haben zum Glück schon seit Generationen hinweg aufwändig Karten erstellt, um zu wissen, wo sich die Fischschwärme in der Regel aufhalten. Um nun schon von Beginn an Fische in ihrer Zucht zu haben, möchten sie nun um eine Gruppierung solcher Positionen einen Zaun im Wasser spannen und mit der Zucht beginnen.

Die Forschuine haben bei einer Umfrage auch schon ermittelt, welche Fischschwärme am besten schmecken und damit steht fest: Wir können morgen starten die leckersten Fische zu züchten! ... (Eine PinguUniParty im Irish Pub später) ... Oh jeh! Der übereifrige Pinguin Max scheint wohl ein Guinness zu viel getrunken zu haben. Max hat alle vorhandenen Pfähle willkürlich im Meeresboden verankert und es gibt keine Möglichkeit, diese wieder heraus zu holen. Es gibt nur eine Möglichkeit: Wir müssen den Zaun entlang der bereits gesetzten Pfähle bauen. Aber wie zäunen wir mit den vorhanden Pfählen die größtmögliche Fläche ein? Du kannst doch bestimmt ein Programm schreiben, um das herauszufinden. Oder?

## Erklärung
In dieser Augabe entwickeln wir gemeinsam ein Programm, das annähernd konvexe Hüllen berechnen soll. Um die mathematische Komplexität zu reduzieren, wird die Angabe recht informell gehalten. Solltest du dich also mehr über das Thema lernen wollen, oder mathematische Definitionen bevorzugen, kannst du gerne [hier (Convex Hulls of Finite Sets of Points in Two and Three Dimensions - Maximilian Anziger)](/api/core/files/markdown/Markdown_2022-10-07T14-21-15-115_2e8038d8.pdf) nachsehen.

Das oben formulierte Problem kannst du dir vereinfacht wie ein Brett voller Nägel vorstellen. Die Lösung, nach der wir suchen, entspricht dem, was passieren würde, wenn du um ALLE Nägel ein Gummiband spannst. Sieh dir dazu folgendes Beispiel an:

   

Die Punkte (X) entsprechen den Pfählen/Nägeln, die fest verankert sind. Die farbig eingezeichneten Kanten zeigen, wie der Zaun/das Gummiband entlang der Pfähle/Nägel verlaufen sollte. Wir berechnen also ein möglichst kleines Vieleck (d.h. mit möglichst geringem Umfang), das alle gegebenen Punkte einschließt. Streng genommen sollte eine ""echte"" konvexe Hülle dabei die beiden Strecken von $$(1, 1)$$ zu $$(1, 2)$$ und von $$(1, 2)$$ zu $$(1, 4)$$ durch eine einzelne Strecke von $$(1, 1)$$ nach $$(1, 4)$$ ersetzen. Um das Problem zu vereinfachen, ignorieren wir diese Bedingung in dieser Aufgabe.


###Punkte und Liste von Punkten 
Ein Punkt und eine Liste von Punkten werden in unserem Programm folgendermaßen dargestellt:
- Ein Punkt $$(x, y)$$ wird durch ein Integer-Array mit zwei Einträgen dargestellt: `{x, y}`. Dabei entspricht der Eintrag 0 der x-, der Eintrag 1 der y-Koordinate.
- Eine Liste von Punkten wird als ein 2D-Array (`int[][] points`) dargestellt. Dabei haben die inneren Arrays alle zwei Einträge und stellen auf die eben beschriebene Weise die einzelnen Punkte dar.

Die Punktwolke

   


kann also z.B. durch folgendes Array dargestellt werden:
```text
{
    {1, 1},
    {2, 3},
    {1, 4},
    {-1, 2}
}
```



###Geraden

Oft werden wir im Folgenden die durch zwei **ungleiche** Punkte `p` und `q` aufgespannte Gerade referenzieren. Damit meinen wir die Gerade, die durch die beiden Punkte verläuft. Wenn wir von ""links der Geraden"" oder ""rechts der Geraden"" reden, stellen wir uns vor, wir stünden auf `p` und würden in Richtung `q` blicken. Was dann von uns aus links ist, befindet sich ""links von der Geraden"", was dann von uns aus rechts ist, ""rechts von der Geraden"":

   






###Darstellung konvexer Hüllen
Die konvexe Hülle einer Punktwolke wird durch eine Liste von Punkten (also ein 2D-Array) all jener Punkte dargestellt, die auf dieser Hülle liegen. Die Punkte sollen dabei jeweils von einem Startpunkt aus gegen den Uhrzeigersinn in der Punktauflistung eingetragen sein. Dabei sind zwei Varianten zu unterscheiden:
 
**Offene Hüllen:** Noch offene (sozusagen unfertige) konvexe Hüllen, wie sie in der Methode `quickHullLeftOf()` gehandhabt und zurückgegeben werden, beziehen sich immer auf ein Punktpaar $$P, Q$$. Sie beschreiben die Hülle um alle Punkte links von der durch $$P$$ und $$Q$$ aufgespannten Geraden. Die Hülle wird dann am rechten Rand durch die Gerade selbst abgegrenzt. Solch eine Hülle wird durch die Liste `{Q, ..., P}` aller Punkte auf der Hülle von $$Q$$ aus gegen den Uhrzeigersinn bis zu $$P$$ dargestellt.
 
So würde beispielsweise die im folgenden Bild auf die Gerade durch `p` und `q` bezogene offene Hülle durch das Array `{q, r0, r1, r2, p}` dargestellt werden:

    
 
Also explizit durch
```text
{
    {4, 3},
    {3, 5},
    {1, 6},
    {-2 ,5},
    {-3, 2}
}
```

**Geschlossene Hüllen:** Eine bereits abgeschlossene Hülle, wie sie letzten Endes von `quickHull()` zurückgegeben werden soll, bezieht sich nicht auf eine Gerade, sondern hat nur einen Startpunkt $$P$$. Die Hülle wird dann wieder durch die Auflistung aller Punkte auf ihr gegen den Uhrzeigersinn dargestellt, diesmal aber mit $$P$$ sowohl als erstem als auch als letztem Punkt: `{P, ..., P}`.

So würde beispielsweise die im folgenden Bild dargestellte Hülle mit Startpunkt $$p$$ durch das Array `{p, r0, r1, r2, r3, r4, r5, r6, p}` dargestellt werden:

    
 
Also explizit durch
```text
{
    {-3, 2},
    {-2, 1},
    {-1, 0},
    {3, -1},
    {4, 3},
    {3, 5},
    {1, 6},
    {-2 ,5},
    {-3, 2}
}
```





## Die Aufgabe

###1. Die Hilfsmethode
Die Methode `int[][] combineHulls(int[][] firstHull, int[][] secondHull)` nimmt zwei offene Hüllen entgegen, bei denen davon ausgegangen werden darf, dass der Endpunkt `firstHull[firstHull.length - 1]` der ersten gleich dem Startpunkt `secondHull[0]` der zweiten ist. Sie kombiniert diese zu einer Hülle. Diese kombinierte Hülle kann dann selbst offen sein, wenn der Endpunkt in `secondHull` ungleich dem Startpunkt in `firstHull` ist, oder geschlossen, wenn beide gleich sind. Die kombinierte Hülle wird zurückgegeben.
Aus einer Hülle der Form `{p, s0, s1, s2, s3, q}` und einer weiteren der Form `{q, t0, t1, t2, r}` würde also z.B. die Gesamthülle `{p, s0, s1, s2, s3, q, t0, t1, t2, r}` gemacht werden.

###2. Das Herzstück
Implementiere die Methode `int[][] quickHullLeftOf(int[][] points, int[] p, int[] q)`.
Diese Methode berechnet **rekursiv** die konvexe Hülle aller Punkte, die links von der durch `p` und `q` aufgespannten Gerade liegen, sowie `p` und `q` selbst. Sie ist also daher eine noch offene Hülle bezogen auf das Punktpaar `p` und `q`. Dabei wird folgendermaßen vorgegangen:

Wir wählen den Punkt `r` aus `points` links der Geraden durch `p` und `q`, der die größte (absolute) Distanz zu dieser Geraden hat. Da es keine Punkte gibt, die weiter entfernt liegen, wissen wir, dass dieser Punkt auch ein äußerster Punkt des Geheges ist (Punkt der konvexen Hülle). Existiert solch ein Punkt, können wir unser Problem mit folgender Idee rekursiv herunterbrechen:
Die Punkte `p`, `q` und `r` spannen ein Dreieck auf, das die Punkte in `points` links von der Geraden durch `p` und `q` in drei disjunkte Mengen partitioniert: Die Punkte links von $$\vec{pr}$$, die Punkte rechts von $$\vec{qr}$$ und die Punkte, die in oder auf dem Dreieck $$\Delta pqr$$ liegen. Die Punkte im Dreieck wären bereits alle innerhalb der Hülle `{q, r, p}`, auf den beiden ersten Partitionen müssen wir unsere Hülle allerdings noch erweitern. Rufe dazu `quickHullLeftOf()` je mit den richtigen Parametern erneut auf. Mach dir dabei auch Gedanken darüber, ob die Reihenfolge der Parameter `p` und `q` eine Rolle spielt und wie die Rekursion beendet wird.

   

Im Bild sieht man eine Illustration des Aufrufs `quickHullLeftOf(points, p, q)`. Es soll eine offene Hülle (bezogen auf die Gerade durch `p` und `q`, die diese dann von rechts (bzw. unten) her abschließt) um alle Punkte oberhalb der Geraden durch `p` und `q` gelegt werden. Dazu wird der in Blickrichtung der Geraden am weitesten linke Punkt `r` gesucht. Nun kann man sich eine Parallele zur ursprünglichen Geraden durch `r` vorstellen. Alle anderen Punkte müssen (in Blickrichtung `p` nach `q`) rechts von dieser liegen, da `r` ja der am weitesten linke Punkt ist. Alle Punkte, um die in diesem Methodenaufruf eine Hülle gelegt wird, liegen also zwischen den beiden Geraden.
Dieser Bereich zerfällt nun in drei Teile:
 - (I): Links von $$\vec{pr}$$. In diesem Bereich muss noch eine (offene) konvexe Hülle gefunden werden.
 - (II): Innerhalb des Dreiecks $$\Delta pqr$$. Liegt innerhalb von `{q, r, p}`.
 - (III): Rechts von $$\vec{qr}$$. In diesem Bereich muss noch eine (offene) konvexe Hülle gefunden werden.

*Hinweis:* Du solltest diese Methode rekursiv lösen. D.h. insbesondere, dass Schleifen, also die Schlüsselwörter `for` und `while` (sowie Streams) in dieser Teilaufgabe verboten sind. In den anderen beiden Methoden `quickHull()` und `combineHulls()` darfst du sie jedoch verwenden.




###Bereits Implementierte Methoden
Um dir die Implementierung zu vereinfachen, haben wir dir einige hilfreiche Methoden bereits zur Verfügung gestellt (du wirst sie vermutlich nicht alle für deine Implementierung benötigen, wir erklären sie hier aber alle, sodass du am Ende selbst entscheiden kannst, welche du davon wo verwenden willst):
- `int[] findPointFurthestLeftFrom(int[][] points, int[] firstLinePoint, int[] secondLinePoint)` betrachtet das zweite und dritte Argument (immer ein Array mit genau zwei Einträgen) als zwei Punkte, die wie eben erklärt eine Gerade aufspannen, das erste als eine Punktauflistung, wie oben erklärt.
Nun bestimmt `findPointFurthestLeftFrom()` den Punkt in `points`, der am weitesten links von unserer Geraden liegt. Also aus allen Punkten links von der Geraden sucht es denjenigen mit der größten Distanz zu ihr. Wenn es in `points` keinen Punkt links von der Geraden gibt, wird `null` zurückgegeben. Wenn es mehrere ""linkeste"" Punkte gibt, wird irgendeiner von ihnen zurückgegeben.
- `int[] findLeftmostPoint(int[][] points)` findet in der Punktauflistung `points` den Punkt, mit der kleinsten x-Koordinate. Wenn es mehrere gibt, wird irgendeiner zurückgegeben. Wenn `points` leer ist, wird eine Exception geworfen. Du solltest diese Methode also nur mit nicht-leeren Punktauflistungen aufrufen.
- `int[] findRightmostPoint(int[][] points)` findet in der Punktauflistung `points` den Punkt, mit der größten x-Koordinate. Wenn es mehrere gibt, wird irgendeiner zurückgegeben. Wenn `points` leer ist, wird eine Exception geworfen. Du solltest diese Methode also nur mit nicht-leeren Punktauflistungen aufrufen.
- `boolean isPointLeftOf(int[] point, int[] firstLinePoint, int[] secondLinePoint)` interpretiert `firstLinePoint` und `secondLinePoint` wieder als eine Gerade aufspannend. Es wird genau dann `true` zurückgegeben, wenn das erste Argument `point` echt links von dieser Gerade liegt. Wenn `point` rechts von oder auf der Gerade liegt, wird stattdessen `false` zurückgegeben.
- `boolean existsPointLeftOf(int[][] points, int[] firstLinePoint, int[] secondLinePoint)` gibt genau dann `true` zurück, wenn mindestens einer der Punkte in `points` echt links von der durch `firstLinePoint` und `secondLinePoint` aufgespannten Gerade liegt.
- `double signedDistance(int[] point, int[] firstLinePoint, int[] secondLinePoint)` gibt die Distanz von `point` zu der durch `firstLinePoint` und `secondLinePoint` aufgespannten Gerade zurück. Dabei bekommt diese Distanz ein negatives Vorzeichen, wenn `point` links von der Geraden, ein positives wenn er rechts von ihr liegt.
- `String pointsToPlotString(int[][] points)` gibt dir einen String zurück, mit der du dir das übergebene Array von Punkten auf folgender Seite visualisieren kannst - [Geodrafter](https://www.matheretter.de/calc/geodrafter). Kopiere dazu den String einfach in das Inputfeld. Unter der Eingabe wirst du dann einen Plot erhalten.




###3. Der Start
Implementiere die Methode `int[][] quickHull(int[][] points)`.
Diese Methode erhält als Übergabewert ein Array aus den Koordinaten aller Punkte (`{{x0, y0}, {x1, y1}, ...}`), mit denen du das Gebiet abgrenzen sollst. Zurückgegeben wird die konvexe Hülle mit dem linkesten Punkt in `points` (dem, der von `findLeftmostPoint(points)` zurückgegeben wird) als Startpunkt. Dies ist dann also eine geschlossene Hülle. Suche dir zudem noch den rechtesten Punkt in `points` und starte dann den Algorithmus mit geeigneten Aufrufen von `quickHullLeftOf()`.




###Tests


[task][Tests zur Hilfsmethode combineHulls()]( 163563 )

[task][Tests, ob quickHull() richtig funktioniert]( 163567 , 163562 , 163561 , 163560 )"
299,Praktikum: Grundlagen der Programmierung WS23/24,12038,W05P01 - Eigene Datentypen definieren,"# Eigene Datentypen

In dieser Aufgabe sollst du einige eigene Datentypen nach gegebener Anleitung implementieren.
Sie besteht aus drei Teilaufgaben, die je in einem eigenen Package gelöst werden sollen.
Die Package-Struktur ist dabei im Template vorgegeben.

Alle Methoden in dieser Aufgabe sollten den Modifier `public` tragen.
Die Attribute sollten keinen (Zugriffs-)Modifier tragen.


*Hinweis:* Da die Tests sich an den Namen der Klassen, Methoden und Attribute und deren genauen Signaturen orientieren, musst du (wenn du die Tests zu passen bringen willst) dich an die Benennungen aus der Angabe halten.
An sich hat man aber beim Definieren von eigenen Typen die Wahl, wie man die Typen selbst und deren Member bezeichnen möchte.
Generell macht es allerdings Sinn, Bezeichner zu wählen, die es anderen und auch einem selbst leicht machen, den Code (auch nach einiger Zeit noch) zu verstehen und die Nutzung der definierten Datentypen intuitiv macht.

###[task][Rationale Zahlen]( 165447 , 165450 , 165448 , 165455 , 165459 , 165438 , 165492 , 165489 , 165468 , 165446 )

Im Package `pgdp.datatypes.rationals` soll eine eigene Repräsentation von Brüchen entstehen: Die Klasse `Rational`.
Erzeuge also eine neue Klasse mit diesem Namen und gib ihr folgende Member:

#### Attribute

Ein Bruch wird durch zwei ganze Zahlen beschrieben. Einen Zähler (`numerator`) und einen Nenner (`denominator`).

#### Konstruktor

Der Konstruktor nimmt Zähler und Nenner als Parameter entgegen und setzt die Attribute entsprechend.
Wenn als Nenner `0` übergeben wird, soll auf der Konsole eine Warnung ausgegeben werden, dass das eben erzeugte Objekt nicht genutzt werden sollte. Diese soll lauten:
"" A⎵Rational-Object⎵with⎵'denominator'⎵zero⎵was⎵created.⎵Do⎵NOT⎵use! ""
Wie man tatsächlich mit einer solchen falschen Eingabe im Konstruktor umgehen könnte, lernen wir später im Kurs.

#### Methoden

`Rational` soll sechs Methoden zur Verfügung stellen.

- `void multiplyBy(Rational other)`, `void divideBy(Rational other)`, `void add(Rational other)` und `void subtract(Rational other)` sollen die grundlegenden arithmetischen Operationen *, /, + und - für Brüche implementieren. Dabei soll das Objekt, auf dem die Methode aufgerufen wird, modifiziert werden. D.h. bei einem Aufruf `a.multiplyBy(b)` soll danach in `a` das Produkt `a * b` stehen. `b` soll unverändert bleiben; die Methode(n) soll(en) auch keinen Wert zurückgeben.
- `double toDouble()` konvertiert die durch `this` dargestellte Zahl in einen `double` (so genau, wie das eben möglich ist; die Tests testen mit einem kleinen Error-Margin).
- `String toString()` soll den Bruch in einen `String` konvertieren. Dieser soll die Form
""\ ⎵/⎵ \ ""
haben.



###[task][Geometrie-Bibliothek]( 165493 , 165460 , 165461 , 165491 , 165439 , 165452 , 165456 , 165471 , 165440 , 165454 , 165496 , 165469 , 165437 , 165462 , 165474 , 165467 , 165444 , 165497 , 165441 , 165495 , 165442 , 165449 , 165490 )

Hier sollst du eine kleine Geometrie-Bibliothek erstellen, die Punkte (`Point`), Vektoren (`Vector`), Kreise (`Circle`) und Rechtecke (`Rectangle`) darstellen kann.

#### `Point`

Diese Klasse wird durch eine x-Koordinate (`x`) und eine y-Koordinate (`y`) dargestellt.
Sie unterstützt einen Konstruktor, welcher beides als Parameter übernimmt und in das jeweilige Attribut schreibt.
Sie unterstützt des Weiteren zwei Methoden:
 - `double getDistanceToOrigin()` berechnet die Distanz des dargestellten Punktes zum Ursprung (dem Punkt $$(0, 0)$$).
 - `Vector getVectorTo(Point other)` gibt den Vektor beginnend bei `this` und endend bei `other` zurück.


#### `Vector`

Diese Klasse wird ebenso durch eine x-Koordinate (`x`) und eine y-Koordinate (`y`) dargestellt.
Sie unterstützt ebenso einen Konstruktor, welcher beides als Parameter übernimmt und in das jeweilige Attribut schreibt.
Allerdings hat sie nur eine Methode `double getLength()`, welche die Länge des repräsentierten Vektors zurückgibt.

#### `Circle`

Diese Klasse stellt einen Kreis als Mittelpunkt `center` und Radius `radius` dar. Radien sind dabei ganzzahlig, für den Mittelpunkt solltest du dir selbst überlegen, wie man diesen mit allem Bisherigen aus dieser Teilaufgabe darstellen kann.
Es gibt einen Konstruktor, der (in dieser Reihenfolge) den Mittelpunkt und den Radius übernimmt und diese in die entsprechenden Attribute schreibt und zwei Methoden `double getCircumference()` und `double getArea()`.

#### `Rectangle`

Zu guter Letzt soll es noch die Klass `Rectangle` geben, die ein Rechteck als den unteren linken Punkt desselben (`bottomLeftCorner`), sowie seine Breite (`width`) und Höhe (`height`) speichert.
Der Konstruktor übernimmt die drei und setzt sie.
Es gibt wieder zwei Methoden `int getCircumference()` und `int getArea()`, diesmal mit ganzzahligen Rückgabewerten **(!!)**.



###[task][Terminkalender]( 165464 , 165457 , 165470 , 165445 , 165465 , 165436 , 165458 , 165473 , 165499 , 165453 , 165494 , 165443 , 165463 , 165451 , 165488 , 165466 , 165472 )

Als Letztes für die gesamte Aufgabe wollen wir das Grundgerüst für einen kleinen Terminkalender setzen. Dieser unterstützt eine Darstellung einer Tageszeit (`TimeOfDay`), eines Datums (`Date`) und eines bestimmten Termins (`Appointment`).

### `TimeOfDay`

Eine `TimeOfDay` besteht aus Stunde (`hour`), Minute (`minute`) und Sekunde (`second`). Der Konstruktor übernimmt und setzt alles und führt keine weiteren Überprüfungen durch.
Eine Methode `double hoursUntil(TimeOfDay other)` berechnet die genaue Anzahl an Stunden zwischen `this` und `other`. Liegt `other` vor `this` soll eine negative Stundenzahl zurückgegeben werden.
Beispiel: Von 12:15:00 bis 19:45:00 sind es `7.5` Stunden. Von 14:30:00 bis 13:15:00 sind es `-1.25` Stunden.

Nun gibt es noch zwei `toString()`-Methoden. Einmal die ""normale"" `String toString()`, die die Uhrzeit als
""\ : \ : \ ""
zurückgibt.
Dann gibt es noch `String toStringTwelveHourClock()`, die Uhrzeiten mit ""am"" und ""pm"" ausdrückt. Dort ist beispielsweise ""15:20:31"" dann "" 3:20:31 pm "" und ""10:10:10"" ist "" 10:10:10 am "".

### `Date`

Ein Datum wird durch Tag (`day`), Monat (`month`) und Jahr (`year`) dargestellt.
Es unterstützt die Methode `String toString`, die das Datum im regulären Format mit Punkten getrennt ausgibt. Also z.B.  15.11.2022  für den 15. November im Jahr 2022.

Zudem hat Datum eine `static`-Methode mit dem Kopf `public static boolean isValidDate(int day, int month, int year)`. Diese gibt genau dann `true` zurück, wenn das übergebene Datum gültig ist. Wenn also dieser Methode der 35. Mai 2022 oder der 29. Februar 2001 oder der -4.13.1981 übergeben wird, gibt sie `false` zurück.

Der Konstruktor von `Date` nimmt auch hier wieder die drei Attribute als Parameter entgegen und setzt diese. Wenn die übergebenen Attribute allerdings zusammen kein valides Datum formen, wird auf der Konsole eine Warnung ausgegeben, dass dieses `Date`-Objekt nicht benutzt werden sollte:
"" Not⎵a⎵valid⎵date.⎵Do⎵NOT⎵use⎵this⎵object! "".

#### `Appointment`

Ein Termin hat ein Datum (`date`), an dem er stattfindet, eine Start- (`start`) und Endzeit (`end`) und eine Beschreibung (`description`). Der Konstruktor nimmt und setzt alles.
Zudem hat `Appointment` noch eine Methode `toString()` die einen Termin folgendermaßen als Text zusammenfasst:

\   
\   
\   
\ ⎵h 

Die Zeilenumbrüche sind dabei genau wie hier gezeigt in den Rückgabe-String zu übernehmen. Ganz am Anfang und ganz am Ende des Rückgabe-Strings sollte kein Zeilenumbruch mehr stehen."
299,Praktikum: Grundlagen der Programmierung WS23/24,12042,W05P02 - Rechtecke ohne Kapselung,"# Vierecke ohne Kapselung

Im Template zu dieser Aufgabe findest du zwei Packages: `pgdp.encapsulation.geometry` und `pgdp.encapsulation.geometryuser`.
Ersteres soll eine von dir und deinem Team entwickelte Geometrie-Bibliothek darstellen, die einige Datentypen wie Punkte und Rechtecke zur Verfügung stellt.
Ein Rechteck wird dabei als linker unterer Punkt `bottomLeftCorner`, sowie Breite (`width`) und Höhe (`height`) dargestellt.
Letzteres Package repräsentiert den Code eines fremden Entwickler-Teams, das eure Bibliothek verwendet (hier: ein Rechteck erstellt und einige Eigenschaften davon auf der Konsole ausgibt).

### Aufgabe

Aus internen Gründen wollt ihr nun die innere Darstellung der Rechtecke ändern: Ein Rechteck soll nicht mehr durch den linken unteren Eckpunkt und die beiden Seitenlängen,
sondern durch den linken unteren Eckpunkt (`bottomLeftCorner`) und den oberen rechten Eckpunkt (`topRightCorner`) dargestellt werden.
Der alte Konstuktor und die alten Methoden sollen nach wie vor funktionieren.

Deine Aufgabe ist es nun, die Änderung in der internen Repräsentation vorzunehmen, also `Rectangle` entsprechend anzupassen, sodass der Code in `pgdp.encapsulation.geometryuser` nach wie vor funktioniert.
Letzteren Code darfst du dabei natürlich nicht anfassen, da er außerhalb eures Teams entwickelt wird.

Auf was für Probleme stößt du dabei?"
299,Praktikum: Grundlagen der Programmierung WS23/24,12043,W05P03 - Rechtecke mit Kapselung,"# Vierecke mit Kapselung

Im Template zu dieser Aufgabe findest du wieder die zwei Packages: `pgdp.encapsulation.geometry` und `pgdp.encapsulation.geometryuser`.
Ersteres soll wieder eine von dir und deinem Team entwickelte Geometrie-Bibliothek darstellen, die einige Datentypen wie Punkte und Rechtecke zur Verfügung stellt.
Ein Rechteck wird dabei als linker unterer Punkt `bottomLeftCorner`, sowie Breite (`width`) und Höhe (`height`) dargestellt.
Letzteres Package repräsentiert den Code eines fremden Entwickler-Teams, das eure Bibliothek verwendet (hier: ein Rechteck erstellt und einige Eigenschaften davon auf der Konsole ausgibt).
Diesmal sind aber die Attribute korrekt gekapselt. Darauf hat sich dann auch der Geometry-User eingestellt.

### Aufgabe

Aus internen Gründen wollt ihr nun wieder die innere Darstellung der Rechtecke ändern: Ein Rechteck soll nicht mehr durch den linken unteren Eckpunkt und die beiden Seitenlängen,
sondern durch den linken unteren Eckpunkt (`bottomLeftCorner`) und den oberen rechten Eckpunkt (`topRightCorner`) dargestellt werden.
Der alte Konstuktor und die alten Methoden sollen nach wie vor funktionieren.

Deine Aufgabe ist es nun, die Änderung in der internen Repräsentation vorzunehmen, also `Rectangle` entsprechend anzupassen, sodass der Code in `pgdp.encapsulation.geometryuser` nach wie vor funktioniert.
Letzteren Code darfst du dabei natürlich nicht anfassen, da er außerhalb eures Teams entwickelt wird.

Stößt du immer noch auf dieselben Probleme wie eben?"
299,Praktikum: Grundlagen der Programmierung WS23/24,12044,W05P04 - UML to Code,"# Zug-Modell

Das Transport-Unternehmen ""Antarctic Railways"" möchte eine neue Kontroll-Software für ihre Zugflotte schreiben. Dafür braucht es erst einmal ein gutes Modell eines einzelnen Zuges. Kannst du ihm dabei helfen?

###Aufgabe

Übersetze folgendes UML-Diagramm geeignet in Java-Code:

@startuml

class Train {
    
    + Train(Locomotive)
    + getLocomotive(): Locomotive
    + getCarriages(): Carriage[]
    + setLocomotive(Locomotive): void
    + getTotalWeight(): int
    + getNumberOfPassengers(): int
    + appendCarriage(Carriage): void
}

class Carriage {
    - isRestaurantCarriage: boolean
    - emptyWeight: int
    
    + Carriage(boolean, int)
    + isRestaurantCarriage(): boolean
    + getEmptyWeight(): int
    + getPassengers(): Person[]
    + boardPeople(Person[]): void
}

class Locomotive {
    - emptyWeight: int
    
    + Locomotive(int, Person)
    + getEmptyWeight(): int
    + getDriver(): Person
    + setDriver(Person): void
}

class Person {
    - weight: int
    - name: String
    
    + Person(int, String)
    + getWeight(): int
    + getName(): String
}

Train ""1"" o-- ""n"" Carriage : carriages
Train ""1"" o-- ""1"" Locomotive : locomotive
Carriage ""1"" o-- ""n"" Person : passengers
Locomotive ""1"" o-- ""1"" Person : driver

hide empty fields
hide empty methods

@enduml


###Tests

Hier eine Auflistung aller Tests, sodass du siehst, welche Klassen bereits wie erwünscht funktionieren.

[task][Train]( 165596 , 165557 , 165594 , 165560 , 165576 , 165572 , 165592 , 165595 , 165604 , 165599 )

[task][Carriage]( 165590 , 165570 , 165598 , 165586 , 165588 , 165602 , 165593 , 165600 )

[task][Locomotive]( 165574 , 165601 , 165578 , 165568 , 165591 , 165603 , 165589 )

[task][Person]( 165582 , 165580 , 165584 , 165583 , 165597 , 165587 )"
299,Praktikum: Grundlagen der Programmierung WS23/24,12045,W05P05 - Heads and Tails,"# Heads and Tails

Unsere erfolgreiche Zusammenarbeit mit den Forschungs-Pinguinen hat dazu geführt, dass die Pinguine eine Zweigstelle PUM (die Pingu-Universität München) eröffnet haben. Durch die Kooperation mit der TUM entdecken sie nun immer mehr Teilgebiete der Informatik. Die kürzlich gegründete Fakultät für Pingu Algorithms and Datastructures möchte zur Eröffnungszeremonie die erste Implementierung einer Liste präsentieren. Du hilfst ihnen bei der Entwicklung!

## Element
Wie du weißt, kann man sich eine Liste wie eine Kette vorstellen. Viele Implementierungen nutzen dafür Arrays. Wir wollen jedoch unser Wissen zur OOP nutzen. Daher Modellieren wir unsere Liste durch einzelne Elemente (einzelnes Ketten-Segment) und bilden eine Kette durch das aneinander hängen der einzelnen Elemente. Jedes Element speichert dabei einen entsprechenden ganzzahligen Wert der Liste im privaten Attribut `value` und seinen Nachfolger im privaten Attribut `next`. Implementiere nun die beiden fehlenden Konstruktoren der inneren Klasse `List.Element`.

1. [task][Element - Konstruktor 1]( 165612 )
Konstruktor 1: Der erste Konstruktor initialisiert ein `Element` ohne Nachfolger. Er bekommt ausschließlich eine Ganzzahl übergeben. Diese soll als `value` des Elements gespeichert werden. Da kein Nachfolger bekannt ist, muss die Referenz `next` auf `null` gesetzt werden.
2. [task][Element - Konstruktor 2]( 165609 )
Der zweite Konstruktor initialisiert ein `Element` dessen Nachfolger bekannt ist. Er bekommt eine Ganzzahl und die Referenz zu seinem Nachfolger übergeben. `value` und `next` müssen dementsprechend passend zugewiesen werden.

## List
Da lose Elemente für andere Entwickler nicht benutzerfreundlich sind, versteckt die Implementierung die Klasse `Element` im inneren. Ein Nutzer kann so auf der Liste einfach Operationen ausführen, ohne dass ihm oder ihr bewusst sein muss, wie genau du diese komplexe Datenstruktur implementiert hast. Zusätzlich kannst du auch im nachhinein Änderungen vornehmen, ohne dass ein anderer Entwickler davon beeinflusst wird, solange das Verhalten identisch bleibt.
Unsere `List` hat drei private Objektattribute: `size` welches immer die aktuelle Länge der Liste speichert, `head` als Referenz zum ersten `Element` der Liste und `tail` als Referenz zum letzten `Element` der Liste. Ist die Liste leer zeigen die Referenzen auf `null`.
Implementiere nun die fehlenden Code-stellen in der Klasse `List`.

3. [task][List - Konstruktor]( 165613 )
Konstruktor: Der Konstruktor von `List` erstellt eine Leere liste. Eins fällt dir bestimmt jetzt schon auf: Obwohl im Template kein einziges Statement im Konstruktor steht, schlägt der entsprechende Test nicht fehl? Woran liegt das? Diskutiere dies mit deinen Kommilitonen/innen und dem Tutor.
4. [task][isEmpty]( 165610 )
`isEmpty` soll zurückgeben, ob die Liste aktuell leer ist. Wenn ja gibt sie den Boolean `true` zurück, ansonsten `false`.
5. [task][clear]( 165608 )
`clear` soll die Liste unabhängig von den aktuell gespeicherten Daten leeren. D.h. nach einem Aufruf von `clear` soll die Datenstruktur danach alle Eigenschaften einer leeren Liste erfüllen. Achte dabei auf die zuvor beschriebenen Kriterien.
6. [task][add 1]( 165605 )
`add(int element)` soll den übergebenen `int` an das Ende der Liste anhängen. Hier siehst du auch wieso die Referenz `tail` so hilfreich ist. Eine Diskussion mit deinen Nachbarn oder dem Tutor ist hier bestimmt sinnvoll. Überlegt euch welche Nachteile eine Implementierung ohne `tail` hätte.
7. [task][add 2]( 169747 )
`add(int index, int element)` fügt ein neues `Element` mit dem Wert `element` an der Stelle `index` ein. Unsere Liste beginnt dabei bei Index  0 , d.h. möchte man eine Zahl ganz am Anfang der Liste einfügen nutzt man den Index  0 , um eine Zahl nach der ersten Zahl einzufügen, nutzt man Index  1 , ... . Eine Zahl ganz an das Ende der Liste anzuhängen ist auch erlaubt (Welcher Index wird hierfür benutzt?). War das Einfügen der neuen Zahl erfolgreich, gibt die Methode `true` zurück, andernfalls `false`.
8. [task][get]( 165607 )
Mit `get` soll der Wert des durch den `index` spezifizierten Elements zurückgegeben werden. Existiert solch ein Element nicht, geben wird der Defaul-Wert  -2147483648  zurück. Weiterhin beginnt unsere Liste mit dem Index  0 .
9. [task][remove]( 165611 )
Um auch Einträge aus der Liste entfernen zu können implementieren wir zuletzt die Methode `remove`. Diese soll das Element an der Stelle `index` aus der Datenstruktur entfernen. Weiterhin beginnt unsere Liste mit dem Index  0 . Negative Eingaben für `index` sollen kein Element entfernen.

Viel Erfolg!"
299,Praktikum: Grundlagen der Programmierung WS23/24,12128,W05H02 - Eismobile Modellieren,"# Text zu UML

Die Pinguine in der Antarktis sind bereits seit Langem Pioniere innovativer und klimaneutraler Transporttechniken. 
Aktuell sind Eisrutschen die beliebteste Fortbewegungsmethode. 
Diese haben nur leider ein entscheidendes Problem: Jeden Meter den man rutscht, muss man auch wieder hochlaufen.

Um sich diesen Aufwand zu sparen, wollen sich die Pinguine jetzt am Menschen orientieren und auf Fahrzeuge umstellen.
Damit sie ihre verschiedenen Entwicklungen und Prototypen besser speichern können, möchten sie, dass du ihnen hilfst, das grobe Konzept eines Fahrzeuges in einem UML Diagramm fest zu halten.

## Hinweise

- Diese Aufgabe wird *NICHT* manuell bewertet. Ihr habt die Möglichkeit selbst eure Abgabe mit der Musterlösung unten zu vergleichen
- Verwende für Beziehungen zwischen den Klassen stets die Aggregation (Kante von Klasse A zu Klasse B ziehen; darauf doppelklicken; Aggregation als Typ auswählen)
- Physikalische Größen sollten in dieser Aufgabe immer als Zahl dargestellt werden
- Alle Eigenschaften, welche nicht als Zahl dargestellt werden können, werden als Zeichenkette repräsentiert.
- Zahlen sollen stets als `int` repräsentiert werden, auch wenn sie kontinuierliche Größen wie räumliche Position oder Temperatur beschreiben.
- Achte in der Modellierung auch auf das in der Zentralübung kennengelernte Konzept der Datenkapselung (Getter und Setter müssen *nicht* modelliert werden!).

## Anforderungen

Grundlage ist eine Klasse, welche das Auto als Ganzes repräsentiert und die Karosserie enthält.

Alle weiteren Elemente sind der Karosserie zugeordnet.
Die Karosserie soll differenziert sein in Karosserietyp, Gewicht, Farbe und eine Material ID.

In einer Karosserie können beliebig viele Sitze enthalten sein. Sitze können unterschiedlich aussehen. Hierzu soll für jeden Sitz eine textuelle Beschreibung hinterlegt werden. Sie können auch verschiedene Materialien haben, die wieder durch ihre ID dargestellt werden.
Sitze müssen zudem in der Lage sein, verschiedene Zustände zu überprüfen:
Es soll abgefragt werden können, ob der Sitz belegt ist und zudem, ob der Anschnallgurt geschlossen ist.
Außerdem soll es möglich sein, die Position des Sitzes in drei verschiedenen Dimensionen zu setzen.
Desweiteren soll die Temperatur einer Sitzheizung gesetzt werden können.

Der wichtigste Bestandtteil eines Fahrzeuges ist der Motor, der auch der Karosserie zugeordnet wird.
Man muss in der Lage sein, zwischen verschiedenen Motormodellen zu unterscheiden. Das Modell wird dabei über seinen Typ-Namen dargestellt.
Es soll zudem die Art des Antriebes gespeichert werden. 
So kann man klimafreundliche Elektromotoren von den Verbrennern unterscheiden.
Zu guter Letzt ist für die Pinguine auch die mögliche Leistung des Motors relevant.
Die Pinguine beschränken sich auf einfache Fahrzeuge, weswegen jedes nur einen Motor hat.

Manche Pinguine finden sich in den weißen Weiten der Antarktis nicht immer zurecht, weswegen ein Navigationssystem immens wichtig ist. 
Hier ist es wichtig zu wissen, welche Software Version läuft und was für Module freigeschaltet sind. Einzelne Module werden als Strings dargestellt.
Das Navigationssystem muss logischerweise in der Lage sein, eine Adresse entgegen zu nehmen und zu dieser zu navigieren.
Außerdem kann das Navigationsystem die Funktion eines Tempomaten übernehmen und somit die Geschwindigkeit des Fahrzeuges bestimmen.
So wie beim Motor gibt es nur ein Navi pro Fahrzeug.

## Aufgabe

Entwerfe ein UML-Diagramm, das obige Anforderungen sinnvoll in einer Klassenstruktur abbildet! 

# FAQ
### Q: Wofür ist das FAQ?
A: Um häufig gestellte Fragen zu sammeln. Wer trotzdem noch fragt, macht Pinguine traurig."
299,Praktikum: Grundlagen der Programmierung WS23/24,12129,W05H03 - The Pingu Network,"# The Pingu Network

Der Pinguin Mark freut sich darüber, dass er so viele neue Freunde an der PUM findet. 
Leider muss er feststellen, dass die bisherige Methode, mit der er seine Freunde verwaltet, nicht mehr ausreicht. 
Der Zettel unter seinem Flügel ist schon sehr voll und man kann teilweise die Einträge nicht mehr richtig lesen. 

Um sich das Ganze zu vereinfachen, hat Mark ein soziales Netz erdacht.
Hier hat er eine Übersicht über seine Freunde und kann sich mit ihnen austauschen.

Zur Umsetzung des Projektes hat Mark bereits ein UML-Diagramm entworfen, das das soziale Netz modellieren soll.
Zudem hat er eine Spezifikation verfasst, was die jeweiligen Klassen tun sollen.
Er hat auch einige Teile davon schon implementiert, hängt jetzt aber an ein Paar noch übrig gebliebenen Teilen des Diagramms fest.
Kannst du ihm da weiterhelfen?

## Diagramm

Das folgende Diagramm stellt die Klassenstruktur des Netzwerks dar. 
Alle Attribute, welche mehrere Elemente speichern können, sollen als Array implementiert werden.
Jedes Array ist genau so groß wie die Anzahl an Elementen, die es enthält. 
Somit gibt es keine leeren Stellen und bei Veränderungen muss ein neues Array erstellt werden.
Der Konstruktor für jede Klasse soll alle Attribute, welche keine Arrays sind, als Parameter übernehmen und zwar in genau der Reihenfolge, in der sie im UML-Diagramm aufgelistet sind.
Die Arrays sollen als leere Arrays mit Größe 0 initialisiert werden. Diese beiden Dinge gelten natürlich nur dann, wenn die Spezifikation nicht explizit Anderes verlangt.

### *Hinweise:* 
- Das Programm soll absturzsicher geschrieben werden. Insbesondere betrifft das die verwendeten Arrays. Egal, welche `User`-, `Post`- etc. Objekte also den jeweiligen `add` und `remove` Methoden übergeben wird, sollte sichergestellt sein, dass das Array nie an unzulässigen Stellen (`< 0` und `>= array.length`) zugegriffen werden.
- Die im Diagramm farbig hervorgehobenen Member müssen noch implementiert werden. Sie sind  grau  oder  rot , solange sie noch nicht vorhanden sind,  grün , sobald sie vorhanden sind.  Grüne  Farbe bedeutet also nur, dass der korrekte Methodenkopf erkannt wurde und noch nicht, dass die Methode auch korrekt implementiert wurde. Das musst du selbst testen.
- Du solltest die bereits im Template implementierten Methoden (d.h. solche, die nicht leer sind und bei denen nicht explizit ein `TODO` dransteht) nicht verändern. Wenn du das doch tust, tust du es auf eigene Gefahr hin, dass bestimmte Tests dann nicht mehr funktionieren.
- Konstruktoren und Attribute musst du teils anpassen; teils musst du auch neue Methoden hinzufügen.
- Ihr dürft bei allen übergebenen Objekten davon ausgehen, dass diese nicht `null` sind.
- Die Tests sind nicht 100% unabhängig von einander. Es kann also vorkommen, dass ein User Test failed, der Fehler aber in einer anderen Klasse liegt.

@startuml

class Picture {
     169699 )>-location: String 
 169699 )>-width: int 
 169699 )>-height: int 
 169699 )>-data: int[][] 
}

class Group {
    -name: String
    -description: String
    -owner: User
    
    +addUser(User) : void
     169698 )>+removeUser(User) : void 
}

class Post {
    -title: String
    -content: String
    
    +addInteraction(Interaction) : void
    +removeInteraction(Interaction) : void
    +addComment(Post) : void
    +removeComment(Post) : void
}

class Interaction {
     169697 )>-user: User 
 169697 )>-interactionType: int 
}

class User {
    -name: String
    -description: String
    
    +addFriend(User) : void
    +removeFriend(User) : void
    +joinGroup(Group) : void
    +leaveGroup(Group) : void
     169695 )>+interact(Post, int) : void 
 169700 )>+post(String, String) : void 
 169700 )>+comment(Post, String, String) : void 
}

User ""1"" o-- ""n"" User : friends
User ""1"" o-- ""n"" Group : groups
User ""n"" --o ""1"" Group : members
User ""1"" o-- ""1"" Picture :  169696 )>profilePicture 
User ""1"" o-- ""n"" Post : posts

Post ""1"" o-- ""n"" Post : comments
Post ""1"" o-- ""n"" Interaction : interactions

Group ""1"" o-- ""1"" Picture :  169696 )>picture 

Picture ""1"" o-- ""n"" Picture : thumbnails

hide empty fields
hide empty methods

@enduml

## Kurzbeschreibung der einzelnen Klassen

Hier findest du eine kurze Beschreibung der verschiedenen im UML-Diagramm dargestellten Klassen und von deren Membern. Sowohl der bereits implementierten Teile, als auch der noch zu implementierenden.
Wenn beim Einfügen in Arrays überprüft werden soll, ob ein Objekt bereits vorhanden ist, kann das einzufügende Objekt mit den vorhandenen mit `==` verglichen werden. Es gilt also nur, herauszufinden,
ob wirklich das exakt gleiche Objekt bereits im Array ist.

###Klasse `User`

1. Zusätzlich zu den im Diagramm beschriebenen Methoden sollen Getter für alle Attribute und Setter für alle Attribute, welche keine Arrays sind, existieren.  
2. Die `addFriend`/`removeFriend` Methoden fügen den spezifizierten Nutzer zur eigenen Freundesliste hinzu bzw. entfernen ihn wieder. 
Am anderen Nutzer ändert sich nichts.
Derselbe Nutzer (Objektgleichheit!) soll nicht doppelt gespeichert werden falls er wiederholt hinzugefügt wird.  
3. Ähnlich fügen die `joinGroup`/`leaveGroup` Methoden die spezifizierte Gruppe zu der Liste an beigetretenen Gruppen hinzu oder entfernt sie. 
Zudem wird der Nutzer den Mitgliedern der Gruppe hinzugefügt bzw. aus diesen entfernt.
Dieselbe Gruppe (simile) soll nicht doppelt gespeichert werden, falls sie wiederholt hinzugefügt wird.   
4. Die `interact` Methode erstellt eine neue `Interaction` mit dem übergebenen `int` `interactionType` und fügt diese dem übergebenen Post hinzu.  
5. Mit der `post` Methode wird ein neuer `Post` mit einem übergebenen Titel und Inhalt erstellt und zum Array eigener Posts hinzugefügt.  
6. Die `comment` Methode funktioniert wie die `post` Methode, nur dass der neu erstellte `Comment` zudem als Kommentar dem übergebenen `Post` angefügt wird.

###Klasse `Post`

1. Zusätzlich zu den im Diagramm beschriebenen Methoden sollen Getter für alle Attribute und Setter für alle Attribute, welche keine Array sind, existieren.  
2. Mit `addInteraction`/`removeInteraction` wird die übergebene Interaktion in das Array der Interaktionen des Posts hinzugefügt oder aus dieser entfernt. 
Dieselbe Interaktion soll nicht doppelt gespeichert werden, falls sie wiederholt hinzugefügt wird.  
3. Gleiches gilt für `addComment`/`removeComment`, nur eben mit übergebenen Posts.

###Klasse `Group` 

Hier gibt es auch Getter für alle Attribute und Setter für alles außer die Mitglieder.
 `addUser`/`removeUser` sind dazu da, um neue Nutzer der Gruppe und dem Array an Mitgliedern hinzuzufügen oder aus dieser zu entfernen.  
Derselbe Nutzer soll nicht doppelt beitreten können.  
Falls bei `removeUser` der `owner` entfernt wird, soll der neue `owner` der erste Eintrag im Array der Mitglieder werden.
Gibt es keine verbleibende Mitglieder in der Gruppe, ist der `owner` `null`.  
Wird der Owner manuell gesetzt, muss dieser natürlich auch vorher in der Gruppe sein.  
Falls der zu setzende `owner` kein Mitglied ist, passiert nichts.
Der Konstruktor dieser Klasse übernimmt, ganz nach der oben beschriebenen Regel, den `owner` dieser als Parameter.
Dieser soll, wie gehabt, in das entsprechende Attribut gesetzt werden. Allerdings muss er dann natürlich auch als Mitglied der Gruppe zu `members` hinzugefügt werden.

###Klasse `Interaction`

Die Klasse `Interaction` hat lediglich Getter für alle ihre Attribute. 
Sonst sind keine Methoden vorhanden.


###Klasse `Picture`

`Picture` soll als Methoden alle Getter (einschließlich für `data`) und zusätzlich noch einen Setter für Thumbnails beinhalten.  
Zudem sollen im Konstruktor die Attribute `location` und `data` übergeben werden. 
Höhe und Breite müssen aus dem `data` Feld erschlossen werden.
Ein Array `int[2][3]` hat zum Beispiel Höhe 2 und Breite 3.
Das `data` Array ist immer ein valides Array, wessen Teilarrays alle die gleiche Länge haben.

## Aufgaben

###Nutzer aus Gruppe Entfernen

In der Klasse `Group` fehlt noch die Implementierung der Methode `void removeUser(User)`. Diese soll das übergebene `User`-Objekt aus dieser Gruppe entfernen.
Falls dabei der `owner` der Gruppe entfernt wird, soll der erste im `members`-Array der neue `owner` werden.

###Nutzer-Operationen mit Kommentaren

In der Klasse `User` sind die drei Methoden `void interact(Post, int)`, `void post(String, String)` und `void comment(Post, String, String)` noch leer.
Implementiere diese, sodass sie das in der Spezifikation geforderte Verhalten aufweisen!

###Inhalt der `Interaction`-Klasse

Die Klasse `Interaction` ist noch komplett leer. Fülle diese, wie in der Spezifikation verlangt.

###Bilder

Zur Implementierung der Klasse `Picture` ist Mark leider gar nicht mehr gekommen. Füge diese Klasse sowie all ihre Verwendungen in `User` und `Group`, wie in der Spezifikation (und dem UML-Diagramm) verlangt, hinzu.
(Du wirst in `User` und `Group` also evtl. neue Attribute, Getter und Setter erstellen müssen.)



# FAQ
### Q: Wofür ist das FAQ?
A: Um häufig gestellte Fragen zu sammeln. Wer trotzdem noch fragt macht Pinguine traurig."
299,Praktikum: Grundlagen der Programmierung WS23/24,12130,W05H04 - A Messenger is Still on the List,"#W05H04 - Ein Messenger steht noch auf der Liste

Der Saisonstart der Formel 1 rückt näher und unser Team Alfa Südpoleo ist schon Dank deiner Tests gut aufgestellt. 
Leider muss noch ein schwerwiegendes Problem gelöst werden: Teamchef Günther Steinbock hat immer noch keine gute Möglichkeit, seine Mitarbeiterinnen und Mitarbeiter zu kontaktieren. Sein Fahrer Valtteri Ottas ist im Urlaub in Spa und ebenfalls unerreichbar.
Ohne seine rauen Anweisungen können die Raceuine nicht arbeiten. Da du die letzte Aufgabe so toll gelöst hast, wurdest du beauftragt, einen Text-Messenger zu programmieren, welcher auf allen Handys zwangsinstalliert werden soll. 
Einen Namen haben sich die Raceuine auch schon überlegt: Pingu Talk.
Sie haben bereits ein UML-Diagramm entworfen, welches die Umsetzung des Messengers beschreibt, sowie eine Spezifikation der einzelnen Klassen. Und sie haben sogar schon mit dem Coden angefangen, hängen nun allerdings noch an einigen der schwierigeren Teile. Kannst du ihnen weiterhelfen?


####Allgemeine Hinweise:
- Zu jeder Klasse werden die Behavioral Tests der Methoden (also die Tests, die das Verhalten der jeweiligen Methode überprüfen) erst ausgeführt, wenn der zugehörige Structural Test der Klasse (also der Test, welcher überprüft, ob bspw die Methoden vorhanden sind und die korrekte Signaturen tragen) durchläuft. Das schließt alle vorhandenen Attribute und Methoden ein, sowie funktionierende Getter und Setter und den Konstruktor.
- Die Klasse `LocalDateTime` entstammt dem Package `java.time`. Sie ist eine bereits vom JDK zur Verfügung gestellte Klasse und repräsentiert einen Zeitpunkt bestehend aus einem Datum und einer Uhrzeit. [Hier](https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html) findest du die Dokumentation. Methoden, die für dich nützlich sein könnten, sind `LocalDateTime.isBefore(LocalDateTime)`, `LocalDateTime.isEqual(LocalDateTime)` und `LocalDateTime.isAfter(LocalDateTime)`.
- Das komplette Package `java.util` ist für diese Aufgabe verboten. Wer es trotzdem verwenden will, macht die Raceuine traurig :( und die FIA kommt vorbei und wird nicht nur deine Factory schließen ...
- Achte auch in dieser Aufgabe wieder auf die Prinzipien der Datenkapselung, wie du sie in der Zentralübung kennengelernt hast.
- Die Public Tests testen die Struktur der Klassen (also Signaturen der Methoden, Attribute, etc) sowie jede Methode anhand eines einfachen Beispiels.


##Diagramm:
Das Programm soll folgendermaßen aufgebaut sein. Beachte, dass Getter und Setter nicht explizit im Diagramm aufgeführt werden, aber dennoch grundsätzlich implementiert werden sollen (außer es steht weiter unten etwas anderes):

@startuml
class User {
    - id: long
    - name: String
    + User(long, String, User)
    + addEmployee(User): void
    + deleteEmployee(long): User
    + toString(): String
}

class UserArray {
    + UserArray(int)
     170423 )>+ addUser(User): void 
 170430 )>+ deleteUser(long): User 
 170429 )>+ size(): int 
}

class Message {
    - id: long
    - timestamp: LocalDateTime
    - content: String
    + Message(long, LocalDateTime, User, String)
    + toString(): String
}

class Topic {
    - id: long
    - name: String
    {static}- messageID: long
    + Topic(long, String)
    + writeMessage(LocalDateTime, User, String): void
    + pinMessage(long): void
    + deleteMessage(long): Message
    + editMessage(long, String): boolean
    + toString(): String
    + pinnedToString(): String
}

class PinguTalk {
    {static}- topicID: long
    {static}- userID: long
    + PinguTalk(int, int)
     170426 )>+ addMember(String, User): User 
 170419 )>+ deleteMember(long): User 
 170422 )>+ createNewTopic(String): Topic 
 170420 )>+ deleteTopic(long): Topic 
}

class ListElement {
    + ListElement(Message, ListElement)
}

class List {
    - size: int
    + isEmpty(): boolean
    + insertAt(int, Message): void
    + add(Message): void
    + delete(Message): void
    + size(): int
    + getByIndex(int): Message
     170428 )>+ getByID(long): Message 
    {static} 170427 )>+ megaMerge(List...): List 
 170425 )>+ filterDays(LocalDateTime, LocalDateTime): List 
 170424 )>+ filterUser(User): List 
 170421 )>+ toString(): String 
}

UserArray ""1"" --o ""1"" User : employees
UserArray ""1"" o-- ""n"" User : users
User ""1"" o-- ""1"" User : supervisor
Message ""1"" o-right- ""1"" User : author
Topic ""1"" o-left- ""1"" List : messages, pinnedMessages
PinguTalk ""1"" o-left- ""n"" Topic : topics
PinguTalk ""1"" o-down- ""1"" UserArray : members
ListElement ""1"" o-- ""1"" ListElement : next
ListElement ""1"" o-- ""1"" Message : message
List ""1"" o-down- ""2"" ListElement : head, tail

hide empty fields
hide empty methods
@enduml




##Kurzbeschreibung der einzelnen Klassen.

(Einige der hier aufgelisteten Klassen/Funktionalitäten sind bereits implementiert. Wir stellen dennoch eine vollständige Liste zur Verfügung, sodass du einen Überblick hast, was die einzelnen Komponenten des Programms tun.)

 

###UserArray
Die Klasse `UserArray` ist ein Wrapper für das `User[]` (für diese Teilaufgabe gilt im Folgenden `User[]`=`Array`). Ein neues `UserArray` soll mit der übergebenen Startlänge initialisiert werden. Dabei soll das `Array` immer mindestens mit der Länge  1  initialisiert werden. Außerdem soll die Klasse Folgendes können:
- `addUser()` soll den übergebenen `User` an der ersten freien Stelle im `Array` speichern. Falls das `Array` voll ist, so soll vor dem Speichern die Größe des `Array`s verdoppelt werden. Wenn der `User null` ist, soll nichts passieren.
- `deleteUser()` soll den zur übergebenen `id` passenden `User` finden, aus dem `Array` entfernen und zurückgeben. Die dabei entstandene Lücke darf bleiben. Falls kein User zu der `id` passt, soll `null` zurückgegeben werden.
- `size()` gibt die Anzahl der gespeicherten `User` zurück.

 

###User
Diese Klasse ist bereits implementiert und verwaltet Informationen zu einem `User`. Ein neuer `User` wird mit einer übergebenen `id`, einem `name` und einem `supervisor` initialisiert, und initialisiert `employees` als `UserArray` der Größe  10 . Außerdem kann die Klasse Folgendes:
- `addEmployee()` bekommt einen `user` übergeben und fügt diesen in das `UserArray` ein.
- `deleteEmployee()` löscht den zur übergebenen `id` passenden `User` aus dem `UserArray`.
- `toString()` gibt eine `String`-Repräsentation des `Users` nach folgendem Schema zurück: ""\ : \ "".

 

###Message
Diese Klasse ist bereits implementiert und verwaltet Informationen zu einer `Message`. Eine neue `Message` wird mit einer übergebenen `id`, einem `timestamp`, einem `author` und einem `content` initialisiert. Außerdem kann die Klasse Folgendes:
- `toString()` gibt eine `String`-Repräsentation der `Message` nach folgendem Schema zurück:
  ""\ ;⎵ \ ;⎵ \ :⎵ \ "".
  Falls der `author` nicht existiert, wird die   durch "" No⎵Author⎵Available "" ersetzt.
  Falls der `timestamp` nicht existiert, wird der   durch "" No⎵Time⎵Available "" ersetzt.
  Die anderen Bestandteile des Strings bleiben ansonsten gleich.

 


###List
Die `List`e benutzen wir, um `Message`s eines Chats zu speichern. Die Implementierung sollte dir schon grob aus der P-Aufgabe bekannt vorkommen. Unsere `List`e besteht aus einer Kette einzelner `ListElement`s. Dabei wird für die `List`e der Default-Konstruktor verwendet und Getter/Setter werden gar nicht benötigt. Deine Aufgabe ist es nun die Funktionalität um fünf kleine Methoden zu erweitern. Ändere die vorgegebenen Methoden daher **nicht**:
- `getByID()` gibt zur übergebenen `id` die zugehörige `Message` zurück. Falls die `Message` nicht existiert, soll `null` zurückgegeben werden.
- `megaMerge()` ist eine statische Methode und nimmt beliebig viele nach `timestamp` aufsteigend sortierte `List`en an (auch gar keine sind möglich), welche unterschiedlich lang sein können. Zurück gibt sie eine `List`e, in der alle `Message`s aller `List`en sortiert gemergt wurden. Was mit den Input-`List`en passiert bleibt dir überlassen. Falls keine `List`e übergeben werden, so ist das Ergebnis eine leere `List`e.
- `filterDays()` bekommt zwei `LocalDateTime`s (`start` und `end`) übergeben. Sie gibt eine neue `List`e zurück, die die Nachrichten in selber Reihenfolge wie die ursprüngliche sortierte `List`e enthält. Aber zusätzlich müssen diese `Message`s zwischen `start` (inklusiv) und `end` (exklusiv) liegen. Falls einer der Parameter `null` ist oder `end` vor `start` liegt, soll eine leere `List`e zurückgegeben werden. Die ursprüngliche `List`e darf dabei nicht verändert werden.
- `filterUser()` funktioniert genauso wie `filterDays()` mit dem Unterschied, dass wir jetzt nach dem übergebenen `User` filtern. Achte auch hier darauf, die ursprüngliche `List`e nicht zu verändern.
- `toString()` eine String-Repräsentation der `List`e und gibt diese zurück, indem einfach die String-Repräsentationen der `Message`s der einzelnen `ListElement`s getrennt durch ein Zeilenumbruch konkateniert werden (Zeilenumbruch auch am Ende). Falls die Liste leer ist, soll ein `leerer String` zurückgegeben werden.

 

###Topic
Diese Klasse ist bereits implementiert und verwaltet einen Chat. Ein neues `Topic` wird mit einer übergebenen `id` und einem `name` initialisiert, und initialisiert die beiden `List`en `messages` und `pinnedMessages`. Mit `messageID` soll nichts passieren. 
- Das statische Attribut `messageID` sorgt dafür, dass jede `Message` auch über mehrere `Topic`s hinweg eine eindeutige `id` bekommt. Einzig `messageID` bekommt weder Getter noch Setter.
- `writeMessage()` erstellt aus der aktuellen `messageID`, sowie den übergebenen Parametern `timestamp`, `author` und `content` ein neues `Message`-Objekt und fügt das in die `messages`-Liste ein. Nach jeder neuen `Message` wird die `messageID` inkrementiert.
- `pinMessage()` sucht in `messages` nach der zur `id` gehörenden `Message` und fügt diese in die `pinnedMessages`-Liste ein, ohne neue `Message`-Objekt dabei zu erzeugen. Falls die Message nicht existiert, wird nichts zu `pinnedMessages` hinzugefügt.
- `deleteMessage()` löscht in beiden Listen eine zur `id` gehörenden `Message`, und gibt diese Message zurück. Falls die `Message` nicht existiert, wird `null` zurückgegeben und mit den `List`en passiert logischerweise nichts.
- `editMessage()` soll den `content` der zur `id` passenden `Message` durch den übergebenen `String` ersetzen, falls die `Message` existiert. Bei Erfolg wird `true`, ansonsten `false` zurückgegeben.  
- `toString()` gibt eine `String`-Repräsentation des `Topic`s nach folgendem Schema zurück:
  "" Topic⎵' \ ':\n \ ""
- `pinnedToString()` gibt eine String-Repräsentation der gepinnten Nachrichten des Topics nach folgendem Schema zurück:
  "" Pinned⎵messages⎵in⎵Topic⎵' \ ':\n \ ""

 

###PinguTalk
In dieser Klasse wird nun letztendlich alles zusammengeführt. Ein neuer `PinguTalk` bekommt die Startlänge des `UserArrays` und die Größe des `Topic[]` in dieser Reihenfolge übergeben. Beide Arrays (`UserArray` und `Topic[]`) sollen dabei mit mindestens Größe  1  initialisiert werden.
- Auch hier sind wieder 2 statische Attribute `topicID` und `userID` zur eindeutigen Unterscheidung vorhanden. Sie benötigen ebenfalls keine Getter/Setter.
- `addMember()` erstellt aus der aktuellen `userID`, sowie den übergebenen Parametern `name` und `supervisor` ein neues `User`-Objekt, fügt das in das `UserArray` ein und gibt den neuen `User` zurück. Nach jedem neuen `User` soll die `userID` inkrementiert werden.
- `deleteMember()` löscht den zu einer `id` zugehörigen `User` im `UserArray` und gibt ihn zurück. Falls der `User` nicht existiert, soll `null` zurückgegeben werden.
- `createNewTopic()` erstellt ein neues `Topic` mit dem übergebenen `name`, fügt ihn an der ersten freien Stelle in `Topic[]` ein und gibt das neue `Topic` zurück. Falls kein Platz mehr frei ist, soll nichts passieren und `null` zurückgegeben werden. Nach jedem neuen eingefügten `Topic` soll die `topicID` inkrementiert werden.
- `deleteTopic()` löscht das zur `id` passenden `Topic` im Array und gibt dieses Topic zurück. Falls das `Topic` nicht vorhanden ist, soll `null` zurückgegeben werden.
 
 



## Aufgabe

Implementiere die noch fehlenden Teile im Code!

[task][UserArray]( 168844 , 170423 , 170430 , 170429 )

In der Klasse `UserArray` sind die Methodenköpfe bereits vorhanden, allerdings fehlt noch deren Inhalt. Attribute, sowie Getter und Setter dieser Klasse fehlen auch noch. Implementiere `UserArray`, sodass die Klasse obiger Spezifikation entspricht.

[task][PinguTalk]( 168839 , 170426 , 170419 , 170422 , 170420 )

In der Klasse `PinguTalk` fehlt noch alles. Implementiere auch hier alles, sodass die Klasse obiger Spezifikation entspricht.

[task][List-Funktionen]( 170428 , 170427 , 170425 , 170424 , 170421 )

In der Klasse `List` sind die fünf Methoden `getByID()`, `megaMerge()`, `filterDays()`, `filterUsers()` und `toString()` noch nicht vorhanden. Implementiere auch diese!



 

(Quelle: Ein Pinguinküken, das lieber zeichnet anstatt PGdP zu machen)


# FAQ
### Q: Wofür ist das FAQ?
A: Um häufig gestellte Fragen zu sammeln. Wer trotzdem noch fragt macht Pinguine traurig.

### Q: Sind die IDs von Message, Topic und User eindeutig?
A: Ja.

### Q: Sind die Input-Listen von `megaMerge` und den beiden `filter`-Methoden in sich nach `timestamp`s sortiert?
A: Ja.

### Q: Für welche Attribute müssen Getter und Setter implementiert werden?
A: Für alle, außer es steht explizit was anderes da.

### Q: Was soll passieren, wenn derselbe User mehrmals hinzugfügt wird?
A: Dieser Fall wird nicht getestet. Jeder User wird höchstens einmal in einem UserArray vorkommen.

### Q: Wofür sind userID, messageID und topicID gut?
A: Diese 3 static Variablen haben den Wert der ID, die das nächste neue Objekt dieser Klasse bekommen würde. Da sie static sind, ist die Einzigartigkeit bswp. für die Messages über mehrere Topics hinweg garantiert."
299,Praktikum: Grundlagen der Programmierung WS23/24,12132,W05H01 - Rechtecke,"```text
Siehe #PGdP-Organisation auf Zulip
Liebe Studierende,
Weil wir oft das Feedback bekommen haben, dass manche auch mit den Easy-Aufgaben Probleme hatten und sich einen einfacheren Einstieg jeweils in die wöchentlichen Themen wünschen, starten wir ein Experiment in W5.

Diese Woche gibt es eine H-Aufgabe, die als Warmup markiert ist. Die Idee wäre Aufgaben zu haben, die entweder P Aufgaben sehr ähnlich sind, und/oder inhaltlich einfacher. Die Aufgabenbeschreibung kann troztdem lang sein, aber die Lösungen sind simpel.

Wenn ihr mit Easy aufgaben gut klar kommt, könnt ihr die Warmups ruhig überspringen.

Bitte gebt uns Feedback ob das hilft. Wir haben natürlich im Gegensatz zu den anderen Schwierigkeitsgrads keine Aufgaben im Voraus vorbereitet, das heißt wir werden damit auf Best-Effort Basis weitermachen. Die Priorisierung hängt von eurem Feedback an.
```

# Rechtecke
In dieser Aufgabe werden wir eine Datenstruktur für Rechtecke implementieren. Folge dazu den Anweisungen Schritt für Schritt.

## Vektoren
Als aller Erstes möchten wir die Klasse `Vector2D` entwickeln. Diese soll uns das Arbeiten mit Vektoren vereinfachen. Die Verwendung einer solchen Klasse ist in vielerlei hinsicht sinnvoll, z.B. wird dadurch ein Programm strukturiert und leichter nachvollziehbar. Auch die (komplexe) Implementierung von häufig genutzen Operationen kann elegant in den Methoden der Klasse versteckt werden, so dass andere Entwickler nicht jedes mal einen eigenen Algorithmus entwickeln müssen.
- [task][Objektattribute]( 169045 )
Erstelle zuerst die beiden privaten Attribute `x` und `y`, diese verwenden wir um die x- bzw. y-Koordinaten des Vektors zu speichern. Da wir uns nicht auf ganzzahlige Koordinaten beschränken möchten, sollen beide Attribute vom Typ `double` sein.
- [task][Konstruktor]( 169044 )
Um eine Instanz eines Vektors erstellen zu können muss ein entsprechender Konstruktor implementiert werden. Der Konstruktor erwartet die Attribute des Objekts (in der entsprechenden Reihenfolge: x, y) als Parameter.
- [task][Getter & Setter]( 169048 )
Erstelle nun für jedes der Attribute die passenden *Getter* und *Setter*.
- [task][add]( 169048 )
Desweiteren soll die Klasse die Vektorenaddition unterstützen. Implementiere diese Funktionalität als Methode `add`, welche einen `Vector2D` als Parameter erwartet. Die Objektattribute des Vektors bei dem die Methode aufgerufen wurde, werden entsprechend modifiziert. Es darf kein neuer `Vector2D` erstellt werden.
- [task][toString]( 169048 )
Zuletzt möchten wir dazu in der Lage sein eine String-Repräsentation eines Vektors erstellen zu können. Dies wird in der Methode `toString` umgesetzt. Der String soll dabei wie Folgt formatiert sein: "" [ \ ,  \ ] "". Der Vektor mit x-Koordinate:  4.0  und y-Koordinate:  5.0  würde also folgenden String zurück geben: "" [4.0, 5.0] "". Achte dabei auch auf das Leerzeichen. Um zu Testen ob deine Formatierung mit den Anforderungen entspricht kannst du die main-Methode in der Klasse `Vector2D` ausführen.

## Rechtecke
Endlich kommen wir zum eigentlichen Ziel der Aufgabe: die Implementierung der `Rectangle`-Klasse. Natürlich haben wir `Vector2D` nicht umsonst entwickelt. Diese werden wir dazu benutzen um die Eckpunkte des Rechtecks zu speichern.
- [task][Objektattribute]( 169051 )
Im allgemeinen sind Rechtecke durch drei fixe Punkte eindeutig beschrieben. Unsere Implementierung wird sich jedoch auf Rechtecke, deren Kanten ausschießlich horizontal und vertikal verlaufen, beschränken. Daher benötigen wir nur noch zwei Punkte `topLeft` und `bottomRight`. Für diese privaten Attribute nutzen wir selbstverständlich unsere eigene Datenstruktur `Vector2D`.
- [task][Konstruktor]( 169049 )
Auch für `Rectangle` erstellen wir einen Konstruktor. Dieser erwartet zwei `Vector2D` als Parameter: als erstes den oberen linken und als zweites den unteren rechten Punkt. Du musst dir also keine Gedanken über degenerierte Fälle oder fehlerhafte Eigaben machen. Die Benutzer (und Testfälle) werden die Datenstruktur immer sachgemäß verwenden und die vordefinierte Reihenfolge einhalten. D.h. sie werden als zweites Argument immer einen Punkt übergeben, welcher tatsächlich rechts und unterhalb des ersten Argumentes liegt.
- [task][toString]( 169050 )
Zur Visualisierung wird auch `Rectangle` eine `toString`-Methode implementieren. Der String soll dabei wie Folgt formatiert sein: "" Rectangle spanned by points  \  and  \ . "".Ein Rechteck mit den Vektoren "" [0.0, 1.0] "" und "" [2.0, 0.0] "" würde also folgenden String zurück geben: "" Rectangle spanned by points [0.0, 1.0] and [2.0, 0.0]. "". Achte dabei auch auf die Leerzeichen. Um zu Testen ob deine Formatierung mit den Anforderungen entspricht kannst du die main-Methode in der Klasse `Rectangle` ausführen.

Jetzt können wir uns endlich den interessanteren Methoden widmen, die `Rectangle` bereit stellen soll.
- [task][calculateArea]( 169050 )
Zuerst wollen wir eine Methode (`calculateArea`) zur Bestimmung des Flächeninhaltes erstellen. Die Methode gibt den berechneten Flächeninhalt als `double` zurück. Dabei helfen dir folgende Tipps:
1. Unsere Rechtecke haben ausschließlich horizontale bzw. vertikale Kanten (Breite und Höhe des Rechtecks)
2. Die Wahl der Vektoren die das Rechteck repräsentieren (oben-links $$ \vec{tl} $$, unten-rechts $$ \vec{br} $$) erlaubt es uns die Breite ($$ \Delta x $$)/Höhe ($$ \Delta y $$) des Rechtecks durch die Differenz der x-/y-Werte zu ermitteln: $$\Delta x = \vec{br}\_x - \vec{tl}\_x $$ und $$ \Delta y = \vec{tl}\_y - \vec{br}\_y $$
3. Der Flächeninhalt lässt sich dann schnell aus dem Produkt der Breite und Höhe berechnen: $$A = \Delta x \cdot \Delta y $$.
- [task][shiftBy]( 169050 )
Zu guter Letzt wollen wir auch noch dazu in der Lage sein Rechtecke im Koordinatensystem zu verschieben. Dazu implementieren wir die Methode `shiftBy`, die das Rechteck um einen übergebenen `Vector2D` verschiebt.  
Betrachte dazu folgendes Beispiel:

 

Hier hast du zu Beginn das Rechteck gespannt von den Punkten "" [1.0, 2.0] "" und "" [3.0, 1.0] "" (makiert mit dem Index `old`). Dieses soll um den Vektor `shift` ("" [2.5, 1.5] "") im Koordinatensystem verschoben werden. Wie du siehst handelt es sich dabei um simple Vektoraddition. **Hinweis:** Diese hast du bereits zuvor implementiert.
Durch die Verschiebung ergibt sich die neue Position des Rechtecks (markiert mit dem Index `new`).
**WICHTIG:** Erstelle keine neuen Vektoren bzw. kein neues Rechteck. Es ist wichtig, dass lediglich die bereits vorhandenen Daten **modifiziert** werden."
299,Praktikum: Grundlagen der Programmierung WS23/24,12182,W06P01 - Doppelt Verkettete Liste,"# Doppelt Verkettete Liste

Doppelt verkettete Integer-Listen bestehen aus einer Kette von Elementen. Im Gegensatz zur einfach verketteten Liste von letzter Woche hat jedes Element neben der Referenz auf den Nachfolger (`next`) zusätzlich eine Referenz auf den Vorgänger (`prev`) (und natürlich den im Element gespeicherten `int`). Das letzte Element hat `null` als Nachfolger, das erste `null` als Vorgänger.

## Klassen, Attribute und Methoden
Zuerst muss du die benötigten Klassen mit ihren Attriubten implementieren. Anschließend bietet es sich an, schonmal alle geforderten (leere) Methoden in die Klassen zu schreiben, damit du nach jeder Teilaufgabe bereits Feedback von den Tests bekommst (die Funktionalität wird in dieser Aufgabe erst getestet, nachdem alle strukturellen Tests erfolgreich abgeschlossen wurden).
- [task][Klasse `DoublyLinkedListElement`]( 171803 , 171802 , 171867 )
Erstellen eine Klasse `DoublyLinkedListElement`, welche ein Listenelement repräsentiert.  
Implementiere einen passenden Konstruktor, der die Attribute `private info`, `public next` und `public prev` initialisiert.  
*Zusatz: Überlegen dir, warum hier public-Modifikatoren für `next` und `prev` sinnvoll sind*
- [task][Klasse `DoublyLinkedList`]( 171804 , 171868 , 171865 ) 
Implementiere eine Klasse `DoublyLinkedList`, welche eine Folge von Listenelementen repräsentiert.
Dazu verfügt sie über eine Referenz auf das erste (`head`) und letzte (`tail`) Element der Liste.
Die Listenelemente sollen nach außen hin nicht sichtbar sein!

## Methoden Implementierungen
Alle Methoden sollen in der Klasse `DoublyLinkedList` implementiert werden und `public` sein. Du darfst der Klasse dafür private Hilfsmethoden hinzufügen. Ebenso darfst du die Klasse `DoublyLinkedListElement` um weitere Methoden (public und private) erweitern.
- [task][append]( 171812 , 171814 , 171816 , 171813 )
Implementiere die Methode `void append(int)`, die ein neues Listenelement mit der übergebenen Zahl als `info` am Ende der aktuellen Liste anfügt.

- [task][size]( 171844 , 171809 , 171806 , 171851 )
Implementiere die Methode `int size()`, die die Anzahl der Elemente der Liste zurückgibt. Da diese Methode häufiger gebraucht wird, sollte sie das Ergebnis zurückliefern, ohne alle Elemente durchzuzählen. Es ist also ratsam, sich dieses auch als privates Attribut der Liste zu merken.

*Hinweis für `get` und `remove`: Man verwendet Listen gerade dann, wenn ein Zugriff über einen Index selten nötig ist, da Arrays für diese Art von Zugriff weitaus effizienter sind. Überlege dir eine sinnvolle Reaktion, falls die übergebene Position ungültig ist. Vermeide unkontrollierte Abstürze!*

- [task][get]( 171838 , 171860 , 171858 , 171840 , 171847 , 171857 )
Implementiere die Methode `int get(int)`, die den `info`-Wert des Elements an der übergebenen Position (natürlich 0-indexiert) zurückgibt.

- [task][remove]( 171837 , 171811 , 171855 , 171805 , 171850 , 171862 )
Implementiere die Methode `void remove(int)`, die das Element an der übergebenen Position aus der Liste entfernt. Nach dem Entfernen muss die Listeneigenschaft wiederhergestellt sein.

- [task][toString]( 171807 , 171861 , 171835 )
Implementiere die Methode `String toString()`, die alle Elemente der Liste getrennt durch ein Komma ' , ' als String zurückgibt, also z.B. "" 1,2,3 "".  
*Hinweis: Konkatenation von `String`s mit `+` ist sehr ineffizient, wenn man
(wie bei dieser Liste) möglicherweise sehr viele `String`s konkateniert. Für solche Zwecke dient die Klasse
[`StringBuilder`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/StringBuilder.html) mit den Methoden
`append` (fügt etwas an die momentan gespeicherte Zeichenkette an) und `toString()` (Wandelt die gespeicherte Zeichenkette in einen String um). Nutze für diese Aufgabe einen `StringBuilder`!*

- [task][appendList]( 171845 , 171841 , 171853 )
Implementiere die Methode `void appendList(DoublyLinkedList)`, die die Elemente der übergebenen Listen in gleicher Reihenfolge an die aktuelle Liste anhängt. Dabei sollen die Elemente der anderen Liste weiterverwendet werden und keine neuen Elemente angelegt werden.

- [task][isEqual]( 171846 , 171852 , 171839 , 171843 , 171856 )
Implementiere die Methode `boolean isEqual(DoublyLinkedList)`. Zwei Listen gelten als gleich, wenn ihre Elemente die gleichen Werte in der gleichen Reihenfolge beinhalten.

- [task][sum]( 171810 , 171864 , 171848 )
Implementiere die Methode `int sum()`, die die Summe aller Listenelemente zurückgibt.

- [task][copy]( 171808 , 171849 , 171863 )
Implementiere die Methode `DoublyLinkedList copy()`, die die Liste kopiert und die Kopie zurückgibt."
299,Praktikum: Grundlagen der Programmierung WS23/24,12183,W06P02 - Doppelt Verkettete Liste - Rekursiv,"# Doppelt Verkettete Liste - Rekursiv

Implementiere nun noch einmal eine doppelt verkettete Liste. Verwende diesmal allerdings für die gesamte Implementierung (d.h. weder in der Klasse `DoublyLinkedList` noch in der Klasse `DoublyLinkedListElement`) Schleifen. Vermeide also die Schlüsselwörter `for` und `while`. Verwende auch keine Streams, falls du diese schon kennst.
Stattdessen soll in dieser Aufgabe die Listenmethoden in `DoublyLinkedList` mithilfe geeigneter rekursiver Hilfsmethoden in `DoublyLinkedListElement` gelöst werden. Wie und wo genau du solche Hilfsmethoden verwenden willst und welche Signatur diese haben sollen, ist dir überlassen.

## Implementierung

Einige Teile der Liste sind diesmal bereits implementiert. Es bleiben fünf Methoden auszufüllen:

[task][getElement]( 171900 , 171922 , 171920 , 171902 , 171913 , 171923 , 171903 , 171877 , 171921 , 171871 , 171912 , 171924 )
Implementiere die Hilfsmethode `DoublyLinkedListElement getElement(int index)`, die die Referenz auf das `DoublyLinkedListElement`-Objekt an `index`-ter Stelle der Liste (wie immer von 0 an gezählt) zurückgibt, `null`, falls der Index außerhalb der Liste liegt. Diese Methode kann dann dazu verwendet werden, um `get()` und `remove()` ohne weitere Schwierigkeiten zu implementieren. Dies ist dann im Template bereits für dich gemacht worden.

[task][toString]( 171873 , 171927 , 171901 )
Implementiere wieder die Methode `String toString()`, die alle Elemente der Liste getrennt durch ein Komma ' , ' als String zurückgibt, also z.B. "" 1,2,3 "".

[task][isEqual]( 171908 , 171914 , 171905 , 171909 , 171918 )
Implementiere die Methode `boolean isEqual(IntDoubleLinkedList)`. Zwei Listen gelten als gleich, wenn ihre Elemente die gleichen Werte in der gleichen Reihenfolge beinhalten.

[task][sum]( 171872 , 171926 , 171910 )
Implementiere die Methode `int sum()`, die die Summe aller Listenelemente zurückgibt.

[task][copy]( 171870 , 171915 , 171929 )
Implementiere die Methode `IntDoubleLinkedList copy()`, die die Liste kopiert und die Kopie zurückgibt.



## Bereits Implementierte Methoden

[task][Bereits Implementiert]( 171932 , 171934 , 171933 , 171931 , 171935 , 171930 , 171879 , 171874 , 171878 , 171876 , 171911 , 171907 , 171919 , 171906 , 171875 , 171869 , 171917 )
Dieser Task erlaubt es dir nur, zu überprüfen, ob du etwas am Template kaputt gemacht hast. Er sollte mit dem, was im Template mitgeliefert wurde, bereits passen."
299,Praktikum: Grundlagen der Programmierung WS23/24,12184,W06P04 - Queue,"# Queue

Implementiere eine Queue, die nach außen hin folgende Funktionalität zeigt:

@startuml

class Queue {
    
    + push(int): void
    + pop(): int
}

class QueueElement {
    - value: int
}

Queue ""1"" o-- ""1"" QueueElement : first
QueueElement ""1"" o-- ""1"" QueueElement : next

hide empty fields
hide empty methods

@enduml


## Methoden

Queues folgen dem FIFO (First-In-First-Out) Prinzip. D.h. der erste, der gepusht wurde, ist derjenige, der beim ersten Pop zurückgegeben und aus der Queue herausgenommen wird.

[task][Push]( 171938 )

[task][Pop]( 171937 )"
299,Praktikum: Grundlagen der Programmierung WS23/24,12185,W06P03 - Zeichenkettenlisten,"# Zeichenkettenlisten

Objekte der Klasse `String` sind nicht veränderbar. Aufrufe von Methoden, wie z.B. `concat(String other)`, modifizeren den String nicht, 
sondern liefern als Resultat einen neuen String zurück. Bei einem Aufruf der Methode `concat` auf Strings müssen daher die beiden aneinanderzuhängenden Zeichenketten Zeichen für Zeichen in ein neues Array kopiert werden.

In dieser Aufgabe soll die Klasse `MyString` implementiert werden, welche einige Funktionalitäten ähnlich denen von `String` bereitstellen soll, die Konkatenation von
Zeichenketten aber ohne das Kopieren aller Zeichen umsetzt. Dabei setzt `MyString` eine Listenstruktur um. Ein `MyString` kennt sein `MyStringElement first`, wobei ein `MyStringElement` über ein `next`-Attribut vom selben verfügt,
das auf den Nachfolger verweist, falls dieser vorhanden ist.
Die Konkatenation eines `char`-Arrays an einen `MyString` kann dann über Anhängen eines neuen `MyStringElement`-Objekts, welches das übergebene Array speichert, an das Ende der Liste umgesetzt werden.
Die durch einen `MyString` dargestellte Zeichenkette entspricht dann der Aneinandereihung der `char`-Arrays die in den einzelnen Listenelemente gespeichert werden.

## Hinweise:
 - Damit die Aufgabe nicht zu einfach wird, darfst du als einzige Methode aus der Klasse String nur den Konstruktor `String(char[] value)` benutzen.
Du darfst in der gesamten Aufgabe *keine* weiteren Methoden auf Strings, StringBuilder oder StringBuffer verwenden.
Insbesondere darfst du *nicht* die Methoden `equals`, `length`, `indexOf`, `lastIndexOf`, `substring`, `concat` (auch in Form `+` bzw. `+=`) auf Objekten der Klassen String, StringBuilder, oder StringBuffer verwenden.
- Nur bei der Implementierung der Methode `toString()` darfst du die einzelnen Elemente von `char`-Arrays in andere Arrays kopieren.
- Verwende keinerlei Imports.
- Achte darauf, alle Methoden- und Attributnamen sowie Methodenköpfe genau wie angegeben zu deklarieren (sonst funktionieren die funktionalen Tests nicht).
- Erst wenn *alle* Attribute und Methoden angelegt wurden, werden die Verhaltenstests durchgeführt.
- Hilfsmethoden sind erlaubt.

## Implementierung
Gehe bei der Implementierung wie folgt vor:

1. Lege in der Klasse `MyString` ein Attribut `MyStringElement first` an. Auf dieses Attribut soll von anderen Klassen aus nicht zugegriffen werden können.
2. Lege den Konstruktor `public MyString(char[] data)` an, welcher eine Liste mit einem Element erzeugt, welches `data` enthält. Du kannst davon ausgehen, dass der Parameter `data` nicht `null` ist.
3. Lege die Methode `public int length()` an, welche die Länge der durch die Liste repräsentierten Zeichenkette zurückgibt. 
4. Lege die Methode `public void concat(char[] data)` an, die ein neues `MyStringElement` erstellt, indem es den Konstruktor von `MyStringElement` mit `data` aufruft, und das erstellte Objekt an das Ende der Liste anhängt. Du kannst davon ausgehen, dass der Parameter nicht `null` ist. Auch wenn `data` die Länge 0 hat, soll ein `MyStringElement` erzeugt und angefügt werden.
4. Lege die Methode `public String toString()` an, die eine `String`-Darstellung der die durch die Liste repräsentierte Zeichenkette zurückliefert. Um den zurückzugebenden String zu erzeugen, verwende den Konstruktor `String(char[] value)`.
5. Lege die Methode `public boolean equals(MyString other)` an, welche `true` zurückgibt, falls die beiden Listen die gleiche Zeichenkette darstellen und andernfalls `false`. Falls der Paramter `other` gleich `null` ist, dann soll `false` zurückgegeben werden. 
7. Lege die Methode `public int indexOf(char c)` an, welche den Index (mit 0 indiziert) des ersten Auftretens des übergebenen Zeichens `c` in der durch die Liste dargestellte Zeichenkette zurückgibt. Falls `c` nicht in der Zeichenkette vorkommt, soll -1 zurückgegeben werden.
8. Lege die Methode `public int lastIndexOf(char c)` an, welche den Index (mit 0 indiziert) des letzten Auftretens des übergebenen Zeichens `c` in der durch die Liste dargestellte Zeichenkette zurückgibt.  Falls `c` nicht in der Zeichenkette vorkommt, soll -1 zurückgegeben werden.

### Tests:
[task][Klasse, Attribute und Methoden angelegt]( 171971 , 171972 , 171980 )

**Konstruktor**
Beispiel
```java
MyString myString = new MyString(new char[]{'a','b','c','d'});
```
**Konkatenation**
Beispiel
```java
MyString str = new MyString(new char[]{'a','b','c','d'});
str.concat(new char[]{'e','f'});
```
[task][Länge]( 171998 , 171987 )
Beispiel
```java
MyString str = new MyString(new char[]{'a','b','c','d'});
str.concat(new char[]{'e','f'});
str.length(); // 6 
```
[task][toString()]( 172000 , 171992 )
Beispiel
```java
MyString str = new MyString(new char[]{'a','b','c','d'});
str.concat(new char[]{'e','f'});
str.toString(); // ""abcdef"" 
```
[task][equals()]( 171994 , 172002 , 171991 , 172001 )
Beispiel
```java
MyString str1 = new MyString(new char[]{'a','b','c','d'});
str1.concat(new char[]{'e','f'});
MyString str2 = new MyString(new char[]{'a','b','c','d','e','f'});
str1.equals(str2); // true 
```

[task][indexOf()]( 171993 , 171986 , 171996 , 171997 )
Beispiel 1
```java
MyString str = new MyString(new char[]{'d','b','c','d'});
str.concat(new char[]{'e','f'});
str.indexOf('d'); // 0
```
Beispiel 2
```java
MyString str = new MyString(new char[]{'d','b','c','d'});
str.concat(new char[]{'e','f'});
str.indexOf('f'); // 5
```

[task][lastIndexOf()]( 171989 , 171999 , 171988 , 171979 )
Beispiel 1
```java
MyString str = new MyString(new char[]{'d','b','c','d'});
str.concat(new char[]{'e','f'});
str.lastIndexOf('d'); // 3
```
Beispiel 2
```java
MyString str = new MyString(new char[]{'d','b','c','d'});
str.concat(new char[]{'e','f'});
str.concat(new char[]{'g'});
str.lastIndexOf('g'); // 6
```"
299,Praktikum: Grundlagen der Programmierung WS23/24,12186,W06P05 - Stack,"# Stack

Implementiere einen Stack, der nach außen hin folgende Funktionalität zeigt:

@startuml

class Stack {
    
    + push(int): void
    + pop(): int
}

class StackElement {
    - value: int
}

Stack ""1"" o-- ""1"" StackElement : first
StackElement ""1"" o-- ""1"" StackElement : next

hide empty fields
hide empty methods

@enduml


## Methoden

Stacks folgen dem LIFO (Last-In-First-Out) Prinzip. D.h. der letzte, der gepusht wurde, ist derjenige, der beim ersten Pop zurückgegeben und aus der Queue herausgenommen wird.

[task][Push]( 172014 )

[task][Pop]( 172013 )"
299,Praktikum: Grundlagen der Programmierung WS23/24,12187,W06P06 - Drama in der Deque,"# Drama in der Deque

Die äußerst organisierten Pinguine haben für ihren Supermarkt eine Queue implementiert, damit die an der Kasse wartenden Pinguine in einer organisierten Warteschlange stehen können. Leider hat eine herkömmliche Warteschlange einige Probleme. Pinguine die am Ende der Schlange warten und bemerken, dass eine andere Kasse schneller arbeitet, möchten natürlich zu dieser wechseln. Eine einfache Queue erlaubt das natürlich nicht. Kein Problem! Zeit eine Deque für unsere Frack tragenden Freunde zu entwickeln.

## Die innere Struktur

Eine Standard FIFO-Queue (Warteschlange) kennst du bereits. Wir möchten nun eine Deque erstellen, diese erlaubt es uns sowohl Elemente am Anfang als auch am Ende der Deque hinzuzufügen, zu entfernen und einzusehen.
Unsere Implementierung der `Deque` wird intern eine Doubly Linked List benutzen um die einzelnen Werte in `Element`s zu speichern. Jedes `Element` hat die beiden Refferenzen `prev` und `next` um auf die entsprechenden Vor-/Nachfolger zu verweisen. Die `Deque` selbst muss sich nur den Anfang (`head`) und das Ende (`tail`) der Doubly Linked list speichern.

## Aufgaben

0. [task][Struktur Test]( 172038 )
Wie schon in der ersten P-Aufgabe werden auch bei dieser Aufgabe die Verhaltens-Tests erst ausgeführt, wenn die Struktur-Tests erfolgreich waren. Du solltest also zuerst die (leeren) Methoden in die Klasse einfügen.

1. [task][ 172025 ]( 172025 )
Erstelle die Methode `isEmpty()`, die einen entsprechenden `boolean` zurückgeben soll (`true` - die `Deque` ist leer, `false` - die `Deque` enthält mindestens ein Element).
2. [task][ 172040 ]( 172040 )
Erstelle die Methode `size()`, die die Anzahl der in der `Deque` gespeicherten Werte als `int` zurückgeben soll.

Zunächst kümmern wir uns um die Methoden, die am Anfang (`head`) der `Deque` operieren sollen.
3. [task][ 172023 ]( 172023 )
Erstelle die Methode `addFirst(int)`. Die Methode erwartet als Eingabe das `int`-value, das an den Beginn der `Deque` gelegt werden soll.
4. [task][ 172019 ]( 172019 )
Erstelle die Methode `removeFirst()`. Die Methode löscht das erste Element der `Deque` aus der Datenstruktur und gibt dessen Wert (`int`) zurück. Existiert solch ein Element nicht, wird die Datenstruktur nicht weiter verändert und der Default-Wert `Integer.MIN_VALUE` wird zurückgegeben.
5. [task][ 172018 ]( 172018 )
Erstelle die Methode `getFirst()`, die den Wert des ersten Elements (`int`) zurückgeben soll. Ist die `Deque` leer erwarten wir den Default-Wert `Integer.MIN_VALUE`.

Und nun fehlen nur noch die Methoden, die am Ende (`tail`) der `Deque` operieren sollen.
6. [task][ 172027 ]( 172027 )
Erstelle die Methode `addLast(int)`. Die Methode erwartet als Eingabe das `int`-value, das an das Ende der `Deque` gelegt werden soll.
7. [task][ 172039 ]( 172039 )
Erstelle die Methode `removeLast()`. Die Methode löscht das lezte Element der `Deque` aus der Datenstruktur und gibt dessen Wert (`int`) zurück. Existiert solch ein Element nicht, wird die Datenstruktur nicht weiter verändert und der Default-Wert `Integer.MIN_VALUE` wird zurückgegeben.
8. [task][ 172020 ]( 172020 )
Erstelle die Methode `getLast()`, die den Wert des ersten Elements (`int`) zurückgeben soll. Ist die `Deque` leer erwarten wir den Default-Wert `Integer.MIN_VALUE`.
9. [task][Eine Reihe von Operationen]( 172041 )"
299,Praktikum: Grundlagen der Programmierung WS23/24,12206,W07Memes - Memey Christmas,"Trotz der tristen Winterzeit möchten die Pinguine nicht nur an graue Wolken und Temperaturen denken müssen, die selbst den abgehärtetesten Pinguin zum Bibbern bringen. Deshalb führen sie auch dieses Jahr wieder einen Meme-Wettbewerb durch, bei dem jeder Jungpinguin (lies: Student bzw. Studentin) ein eigenes Meme erstellen darf. Die erfahreneren Pinguine (lies: Übungsleitung, Tutorinnen und Tutoren) schauen sich diese anschließend mit einem fröhlichen Schnattern an und erheitern so ihre Nachmittage. Als Motivation verteilen sie zudem kleine Aufkleber an die Jungpinguine mit den lustigsten Abgaben.

- - -

Lade hier dein Meme als Bild (PNG/JPG/JPEG) oder Video (MP4) hoch.
Wenn du gleich mehrere Memes abgeben willst, dann als PDF, wovon die erste Seite dein ""bestes"" Meme sein soll, das bewertet wird.
Wichtig: Im Gegensatz zu letztem Jahr erhältst du dafür KEINE Bonuspunkte, nimmst aber am Stickerwettbewerb teil.

Wird dein Meme von einem Tutor oder einer Tutorin als besonders gut bewertet, erhältst du auf Zulip eine Direktnachricht um abzuklären, wo du deinen ultrakrassen und extrem seltenen Sticker abholen kannst.

Wenn sich dein Meme auf bestimmte Personen bezieht, dann bitte nur Teile der Übungsleitung oder Tutorschaft, nicht andere Studentinnen und Studenten! Wir möchten nicht, dass sich jemand durch den Witz eines Anderen angegriffen fühlt. Wichtig: Humor ist zwar subjektiv, diese Competition ist aber kein Raum für Beleidigungen, auch nicht gegen Tutorinnen und Tutoren oder die ÜL!

Nach der Deadline wird dein Meme für alle PGdP-Studentinnen und -Studenten zugängig gemacht, vorausgesetzt, es erfüllt obige Anforderungen. Es ist nicht auszuschließen, dass diese dein Meme speichern oder anderen Personen zeigen. Stelle also gegebenenfalls sicher, keine persönlichen Informationen auf deinem Meme zu zeigen."
299,Praktikum: Grundlagen der Programmierung WS23/24,12222,W06H02 - Listige Launemacher,"# Listige Launemacher

Die Clownuine der lokalen Pinguinschule haben sich das erste Mal seit längerer Zeit wieder getroffen. Leider haben sie in der Zwischenzeit vergessen, wie sie andere Pinguine am besten zum Lachen bringen können, weshalb sie sehr deprimiert sind. Um aus diesem Loch zu kommen, haben sie beschlossen, ihrem zweitliebsten Hobby zu folgen: Programmieren. Ihr Ziel war die Implementierung einer objektorientierten, rekursiven Liste für Ganzzahlen. Die einfachsten Methoden, die du auch im Template findest, haben sie schnell geschafft. Doch leider ist jetzt die Luft raus und sie verzweifeln an den letzten Methoden. Du musst ihnen dringend helfen, sonst könnte die Freude im Pinguinland für immer verschwinden!

## Allgemein
- Die Basisimplementierung der doppelt verketteten Liste bestehend aus `RecIntListElement`s findest du in `RecIntList`
- Alle Teilaufgaben müssen in der Klasse `RecIntList` implementiert werden
- Alle Teilaufgaben müssen rekursiv implementiert werden, d.h. zur Lösung einer Teilaufgabe muss die Methode selbst oder eine genutzte Hilfsmethode sich selbst aufrufen. Schleifen sind nur in der `main`-Methode und den vorgegebenen `toString`s erlaubt.
- Es dürfen Hilfsmethoden in `RecIntList` und `RecIntListElement` hinzugefügt werden.
- Andere Änderungen am Template geschehen auf eigene Gefahr und können zu Punktverlust führen, falls dadurch die Tests nicht mehr funktionieren! Insbesondere `static` Variablen können zu Problemen führen.
- Wie immer bei einfachen Aufgaben gilt: Punkte werden mit den Public Tests verteilt und es gibt pro Teilaufgabe einen Public Test. Nach der Deadline kann es nur dann Punktabzug geben, wenn die Aufgabe nicht rekursiv gelöst wurde.

## Aufgaben
[task][countThresh]( 173196 )
Implementiere die Methode `countThresh`, die einen `int` übernimmt und die Summe der Werte in der Liste, die kleiner, gleich groß, bzw. größer dem übergebenen Wert sind, berechnet. Die Summen sollen in einem Array in entsprechender Reihenfolge (kleiner, gleich, größer) zurückgegeben werden. Die Methode kann auf jeder möglichen Liste aufgerufen werden, aber es kommt in unseren Tests nicht zu `long`-Overflows. Außerdem sollte die Liste beim Aufruf nicht zerstört werden. Beispiel:
```text
Input: [1,2,3,4,5], threshold = 3
Output: [3,3,9]
```
 
[task][kinguinSort]( 173197 )
Implementiere die Methode `kinguinSort`, die die Liste mit Hilfe des Lieblingssortieralgorithmus des Kinguins Konrad sortiert: KinguinSort. Dabei wird die Liste einmal von vorne nach hinten durchlaufen und jedes Element, das der Sortierung widerspechen würde, wird einfach entfernt. Die Methode übernimmt zusätzlich einen Parameter, der angibt, ob aufsteigend (`true`) oder absteigend (`false`) sortiert werden soll. Gleich große Werte sind in jedem Fall ok und sollen nicht entfernt werden. Die Methode kann auf jeder möglichen Liste aufgerufen werden. Beispiel:
```text
Input: [3,2,4,7,1,6,5,9,8]
Ergebnis (increasing = true): [3,4,7,9]
denn: 3>2 -> widerspricht der Sortierung; 3<4 -> OK; 4<7 -> OK; 7<1 -> widerspricht der Sortierung; usw.
Ergebnis (increasing = false): [3,2,1]
denn: 3>2 -> OK; 2<4 -> widerspricht der Sortierung; 2<7 -> widerspricht der Sortierung; 2>1 -> OK; usw.
```
 
[task][reverse]( 173195 )
Implementiere die Methode `reverse`, die die Reihenfolge der Liste umdreht, d.h. das ursprünglich letzte Element soll jetzt das erste sein und andersrum. Wichtig dabei ist, dass keine neuen `RecIntListElement`-Instanzen erstellt werden und die `value`-Attribute der bestehenden Instanzen nicht verändert werden. Außerdem soll das Ganze effizient passieren, die Liste darf also nur einmal durchlaufen werden. Die Methode kann auf jeder möglichen Liste aufgerufen werden. Beispiel:
```text
Input: [1,2,3,4,5]
Output: [5,4,3,2,1]
```
(Auf Nachfrage in Zulip: Getestet wird mit 10000 Elementen, aber denk daran: Artemis Build Clients sind langsam und ausschlaggebend für die Tests)

[task][zip]( 173194 )
Implementiere die `static` Methode `zip`, die zwei Listen übernimmt und diese wie folgt zu einer Liste zusammenführt. Das Ergebnis soll in der ersten übergebenen Liste gespeichert werden, die zweite Liste darf bei der Ausführung zerstört werden. Auch hier sollen wie bei `reverse` keine neuen `RecIntListElement`-Instanzen erstellt oder `value`-Attribute verändert werden. Es können alle möglichen Listen übergeben werden und du darfst davon ausgehen, dass die übergebenen Listen unterschiedlich und nicht `null` sind.  
Liste l: $$l\_0, l\_1, l\_2, ...$$  
Liste m: $$m\_0, m\_1, m\_2, ...$$  
Liste l nach zip(l, m): $$l\_0, m\_0, l\_1, m\_1, l\_2, m\_2, ...$$  
Die Listenelement wechseln sich also immer zwischen den Listen ab. Sollten einer Listen die Elemente ausgehen, werden nur noch die übrigen Elemente der anderen Liste verwendet. Beispiel:
```text
Input:
 l1: [1,3,5,7,8]
 l2: [2,4,6]
Ergebnis l1: [1,2,3,4,5,6,7,8]
(nach 6 ist l2 leer, daher werden die restlichen Elemente von l1 ohne Änderungen der Reihenfolge angehängt)
```
Vergiss nicht, auch die `prev`-Zeiger der einzelnen Elemente korrekt zu setzen!

####Hinweis:
Sollten alle ""xxx - public feedback"" Tests vor der Deadline passen, gibt es 100% der Punkte (sofern Rekursion zum Lösen der Aufgaben verwendet wurde).

## Hidden Tests
Diese Tests werden nach der Deadline Feedback anzeigen und sind inhaltlich gleich mit den Pubilc Tests.
- [task][countThresh Hidden Tests]( 173179 , 173185 , 173172 , 173166 , 173170 , 173182 , 173184 )
- [task][kinguinSort Hidden Tests]( 173189 , 173192 , 173188 , 173193 , 173190 , 173191 , 173186 )
- [task][reverse Hidden Tests]( 173180 , 173168 , 173181 , 173187 )
- [task][zip Hidden Tests]( 173169 , 173175 , 173167 , 173133 )



# FAQ
### Q: Wofür ist das FAQ?
A: Um häufig gestellte Fragen zu sammeln. Wer trotzdem noch fragt macht Pinguine traurig.

### Q: Was bedeutet es eine neue Instanz zu erstellen?
A: Man erstellt mit `new` immer eine neue Instanz. Lokale Variablen sind erlaubt, solange sie nur Referenzen auf bereits existierende Objekte speichern."
299,Praktikum: Grundlagen der Programmierung WS23/24,12224,W06H03 - PUM Server Upgrade,"# PUM Server Upgrade

Die Forschuine der PUM sind begeistert von unserem LRZ. Um noch besser forschen zu können, wollen sie nun auch einen eigenen Hochleistungsrechner bauen. Die Softwareuine wurden beauftragt, einige notwendige Komponenten zu implementieren. Als exzellenter Freund unterstützt du sie dabei.

## RingBuffer

Um Daten asynchron zwischen den Server-Nodes hin und her zu senden, benötigen die Pinguine einen effizienten Buffer, genauer einen `RingBuffer`. Ein `RingBuffer` wird mit seiner Kapazität initialisiert (das ist die maximale Anzahl an Einträgen, die gespeichert werden kann). In den `RingBuffer` können dann Werte gelegt (`put(int)`) und aus ihm wieder entnommen (`get()`) werden.

Hier siehst du eine Visualisierung eines `RingBuffer`s:

   

Wie du siehst, speichern wir die Werte in einem Array (`mem`). Um festzuhalten, in welchem Bereich valide Daten gespeichert sind, benutzen wir die beiden Felder `in` und `out`. `in` speichert dabei den Index, an dem der nächste Wert, der via `put(int)` eingefügt werden soll, in `mem` abgespeichert wird. `out` zeigt auf den Index, von dem bei der nächsten `get()`-Operation gelesen wird. Durch eine Sequenz von `put`- und `get`-Operationen kann dieser Bereich also durch das Array ""wandern"", auch über die Grenzen des Arrays hinaus. Dazu musst du dir vorstellen, dass das Array ein Ring ist. Wir interpretieren also `mem[0]` als Nachfolger von `mem[mem.length-1]` und `mem[mem.length-1]` als Vorgänger von `mem[0]`.

Die folgenden Teilaufgaben beschreiben die Implementierung step-by-step:

1. [task][Als aller Erstes!]( 173255 )
Lies dir zunächst die folgenden Teilaufgaben durch und erstelle erst die erforderten Methoden, um sie anschließend zu implementieren. So hast du schonmal Code, den Artemis kompilieren und testen kann. Dies bezieht sich auch auf die Methoden, die in `MultiStack` implementiert werden müssen.
2. [task][ 173245 ]( 173245 )
Erstelle die Methode `isEmpty`, die einen `boolean` zurückgeben soll: `true` - keine Einträge im `RingBuffer` gespeichert, `false` - einer oder mehr Einträge im `RingBuffer` gespeichert.
3. [task][ 173235 ]( 173235 )
Erstelle die Methode `isFull`, die einen `boolean` zurückgeben soll: `true` - der `RingBuffer` speichert die maximale Anzahl von Einträgen, `false` - der `RingBuffer` speichert weniger als die maximale Anzahl von Einträgen.
4. [task][put]( 173231 , 173238 , 173239 )
Erstelle die Methode `put`, die einen `int` erwartet, um diesen im `RingBuffer` zu speichern. Sollte der Buffer voll sein, dürfen keine Werte in den Buffer eingefügt werden, stattdessen akzeptiert der `RingBuffer` den neuen Wert nicht. Ist das Speichern erfolgreich, soll der `boolean` `true` zurückgegeben werden, andernfalls `false`.
5. [task][get]( 173233 , 173237 )
Erstelle die Methode `get`, die einen `int` zurückgeben soll. Wenn möglich soll der Wert zurück gegeben werden, der am längsten im `RingBuffer` liegt - dieser wird dann auch aus dem aktuellen Speicherbereich des Buffers entfernt - andernfalls erwarten wir den Default-Rückgabewert `Integer.MIN_VALUE`.
6. [task][Konstruktor & Performance]( 173232 , 173225 )
Der erste Test dient nur als Sicherheit, damit du sofort erkennst ob du ausversehen den Konstruktor verändert hast. Die Performance wird dir erst nach der Deadline angezeigt. Mach dir aber nicht zu viele Gedanken. Entscheidend ist nur, dass du nicht zu viele irrelevante Operationen ausführst (z.B. Kopien des Arrays erstellst).

## MultiStack

Die Pinguine möchten auf ihrem HPC natürlich viele Java-Programme ausführen. Um komplexere Programme entwickeln zu können, benötigen sie einen Stack, der mehr Daten speichern kann. Ein erster Prototyp dafür soll in den folgenden Teilaufgaben entwickelt werden.

`MultiStack` nutzt die Klasse `Stack`, in der die Daten gespeichert werden. Jeder `Stack` ist dabei wie ein Listen-Element und enthält, abgesehen von dem Array `mem` (zum Speichern der Daten) und `top` (um auf den obersten Wert dieses `Stack`s zu zeigen), auch eine Referenz auf einen (möglichen) Nachfolger-`Stack`. Der Beginn dieser Liste von `Stack`s wird als Referenz `stacks` in `MultiStack` gespeichert.

   


1. [task][Als aller Erstes!]( 173252 , 173250 )
Lies dir zunächst die folgenden Teilaufgaben durch und erstelle erst die erforderten Methoden, um sie anschließend zu implementieren. So hast du schonmal Code, den Artemis kompilieren und testen kann.
2. [task][push]( 173256 , 173230 , 173227 )
Erstelle die Methode `push`, die einen `int` auf den `MultiStack` legen soll. Dabei soll wie folgt vorgegangen werden: Da der Wert in der Liste aus `Stack`s gespeichert wird, müssen wir zunächst den Ort finden, an dem der Wert abgelegt werden soll. Dazu starten wir bei dem ersten `Stack`. Ist dieser bereits gefüllt, führen wir unsere Suche im Nachfolger (`next`) fort bis wir uns im passenden `Stack` befinden. Sollten alle `Stack`s gefüllt sein, müssen wir einen neuen `Stack` mit der doppelten Kapazität des Vorgängers erstellen (Je weiter du durch die Liste iterierst, desto größer werden die Stacks - Faktor 2). Da wir nun den richtigen `Stack` gefunden oder initialisiert haben, können wir in dem entsprechenden `Stack` den Wert in `mem` speichern und das Feld `top` anpassen. *Tipp:* Dieses Verfahren kann am einfachsten rekursiv implementiert werden, d.h. der `MultiStack` ruft die gleichnamige rekursive Methode in `Stack` auf. (Rekursion ist hier aber nicht unbedingt verlangt.)
3. [task][top]( 173234 , 173240 , 173242 )
Erstelle die Methode `top`, die den Wert (`int`) zurückgeben soll, der ganz oben auf dem `MultiStack` liegt. (Das ist der Wert, der als letztes eingefügt wurde.) Der Wert soll dabei *NICHT* entfernt werden. Ist der Stack leer, erwarten wir den Default-Rückgabewert `Integer.MIN_VALUE`. *Tipp:* Auch diese Teilaufgabe lässt sich sehr einfach rekursiv lösen.
4. [task][pop]( 173229 , 173241 , 173236 )
Erstelle die Methode `pop`, die den Wert (`int`) zurückgeben *UND* entfernen soll, der ganz oben auf dem `MultiStack` liegt. (Das ist der Wert der als letztes eingefügt wurde.) Ist der letzte Stapel der `Stack`-Liste leer, soll dieser aus der Liste gelöscht werden. Ausgenommen ist davon der erste Stack mit Kapazität `1`. Dieser soll immer erhalten bleiben, auch wenn er aktuell keine Werte speichert. (Mach dir gerne Gedanken darüber, warum.) Ist der Stack leer, erwarten wir den Default-Rückgabewert `Integer.MIN_VALUE`. *Tipp:* Wie du dir bestimmt denken kannst, kannst du auch diese Teilaufgabe durch eine rekursive Methode in `Stack` lösen.
5. [task][Konstruktor]( 173243 )
Der Test dient nur als Sicherheit, damit du sofort erkennst ob du ausversehen den Konstruktor verändert hast.


[task][Öffentliche Tests]( 173245 , 173235 , 173231 , 173233 , 173232 , 173243 , 173256 , 173230 , 173229 , 173241 , 173252 , 173255 , 173250 ) Testet deine Abgabe nach jedem Push. Hier siehst du, ob du bereits alle öffentlichen Tests bestehst bzw. welche du noch nicht bestehst.
[task][Versteckte Tests]( 173238 , 173239 , 173237 , 173225 , 173227 , 173236 , 173234 , 173242 ) Testet deine Abgabe nach der Deadline. Diese Tests sind auch in die obigen Tasks an den entsprechenden Stellen integriert.
[task][Grading Tests]( 173249 , 173248 , 173244 , 173251 , 173246 , 173247 ) Testet deine Abgabe nach der Deadline und verteilt Punkte.

Viel Erfolg!"
299,Praktikum: Grundlagen der Programmierung WS23/24,12225,W06H04 - Fun with Graphs,"# Fun with Graphs

Obwohl der neue Super-Rechner der PUM noch nicht fertig gebaut ist, überlegen die Forschuine schon jetzt, was sie alles in Zukunft ausprobieren wollen. Sehr beliebt sind dabei Graphen und die unzähligen Algorithmen, die man auf ihnen ausführen kann. In dieser Aufgabe willst du ihnen ein paar Prototypen zeigen, wie du Graphen implementieren würdest.

*Wichtig:* In dieser Aufgabe lassen wir dir ""künstlerische"" Freiheit, wie du die geforderte Aufgabe umsetzt. Wichtig ist nur, dass du auch wirklich alle Anforderungen erfüllst.

## Graphen

### Was sind (gerichtete) Graphen?

Ein Graph besteht aus Knoten und Kanten. Stell dir am besten das ÖPNV-Netz vor. Die verschiedenen Haltestellen entsprechen den Knoten eines Graphen. Zwischen zwei Haltestellen existiert eine Kante genau dann, wenn ein Bus von einer zur anderen Haltestelle fährt. In dieser Aufgabe fokussieren wir uns ausschließlich auf gerichtete Graphen, das bedeutet man kann entlang einer Kante nur in eine Richtung gehen, aber nicht zurück.

Sieh dir dazu folgendes Beispiel an:

   
[Quelle](https://en.wikipedia.org/wiki/Directed_graph#/media/File:Directed_graph_no_background.svg)  

In diesem Netz kannst du von der `1` direkt zur `3` gehen, in die entgegengesetzte Richtung jedoch nicht. Um in beide Richtungen gehen zu können, muss der Graph sowohl eine Hin- als auch eine Rückkante enthalten, wie z.B. zwischen `3` und `4`.


### Verschiedene Implementierungen

Um Netzwerke zu speichern, gibt es viele Möglichkeiten, diese zu modellieren. Einige wenige davon werden dir hier erklärt. Aus diesen darfst du dann auch wählen, um diese Aufgabe zu lösen. Überlege dir dabei jeweils, welches Modell sinnvoll für die jeweilige Teilaufgabe ist. Hast du schon forgeschrittenes Wissen über Graphen, kannst du selbstverständlich auch andere Varianten wählen (die hier nicht aufgelistet sind). Solange du die Anforderungen erfüllst, ist hier alles erlaubt.

1. Objektorientiert:  
Als eifrige Java-Pinguine lieben wir die Objektorientierte Programmierung. Deshalb wollen wir unser Graphen als aller erstes mit Objekten modellieren. Um unser Netzwerk zu modellieren, brauchen wir zunächst Objekte für unsere Knoten. Kanten zwischen den Knoten können nun z.B. wiederum durch Objekte organisiert werden. Einfacher ist es jedoch, wenn ein Knoten selbst seine Nachbarn abspeichert, entweder als Referenzen auf die jeweiligen Knoten-Objekte der Nachbarn oder einfacher noch über die ID des Knoten. Letzteres kann man z.B. mithilfe der von uns zur Verfügung gestellten Klasse `SimpleSet` machen. Wie du in der Aufgabe sehen wirst, haben die Knoten einen Namen (ihre `id` startet dabei von `0`, `1`, `2`, usw.).  
*Tipp:* In diesem Modell speichern wir nur das, was wir wirklich brauchen. Denk aber daran, dass das Erstellen von Objekten Speicher verbraucht.  
2. Adjazenz Matrix:  
Sieh dir folgende Matrix an:  
$$ A = \begin{pmatrix}
0 & 1 & 1 & 0 \\\ 
0 & 0 & 0 & 0 \\\ 
0 & 1 & 0 & 1 \\\ 
0 & 0 & 1 & 0
\end{pmatrix} $$ 
Das ist die Adjazenzmatrix die zu dem Netz aus dem Bild von zuvor passt. Jede `1` in der Matrix entspricht genau einer Kante aus dem Bild. Kannst du jetzt schon erraten wie? Jede Zeile&Spalte der Matrix entspricht einem Knoten. Ist in einer Zeile $$i$$ der $$j$$-te Eintrag eine 1 (`true`?), also $$A\_{ij}=1$$, dann existiert eine Kante von $$i$$ nach $$j$$.  
*Tipp 1:* Wir Info-Pinguine lieben Matrizen, weil man sie so schön in zwei dimensionalen Arrays abspeichern kann.  
*Tipp 2:* Die Größe der Matrix steigt also quadratisch zur Anzahl der Knoten des Graphen, ist aber unabhängig von der Anzahl der Kanten. 
3. Inzidenz Matrix:  
Sieh dir folgende Matrix an:  
$$ I = \begin{pmatrix}
-1 & -1 & 0 & 0 & 0 \\\ 
1 & 0 & 1 & 0 & 0 \\\ 
0 & 1 & -1 & -1 & 1 \\\ 
0 & 0 & 0 & 1 & -1
\end{pmatrix} $$ 
Das ist die Inzidenzmatrix die zu dem Netz aus dem Bild von zuvor passt. Sie ist sehr ähnlich zur Adjazenzmatrix, hier entspricht jedoch jede Zeile einem Knoten währen jede Spalte eienr Kante zuzuordnen ist. Jeder Wert in einer Spalte der nicht $$0$$ ist bedeutet, dass der Knoten der entsprechenden Zeile teil der Kante ist. Anhand des Vorzeichens erkennen wir die Richtung der Kante (von nagativ, nach positiv). Eine Kante von $$i$$ nach $$j$$ haben wir also genau dann, wenn $$I\_{is}=-1$$ und $$I\_{js}=1$$ ist ($$s$$ ist dabei der Index einer Spalte - Kante).  
*Tipp:* Mach dir Gedanken darüber was passiert, wenn du eine neue Kante zum Graphen hinzufügen möchtest. 

## Unser Template

In dem Code-Template, welches wir dir über Artemis zur Verfügung stellen, sind bereits einige Funktionalitäten implementiert, die du zum Lösen der Aufgabe verwenden kannst bzw. die wir zum Testen benötigen. Im Folgenden wird dir kurz erklärt, wie du damit umgehen sollst:

### Die Klasse `SimpleSet`

`SimpleSet` ist eine Menge (von Integern), wie du sie aus der Mathematik kennst: Du kannst Zahlen hinzufügen (`add(int)`) und abfragen ob die Menge eine Zahl enthält (`contains(int)`). `toArray()` gibt dir ein Array bestehend aus allen Zahlen die in diesem `SimpleSet` gespeichert sind zurück. Intern verwendet `SimpleSet` Konstrukte, die du vermutlich noch nicht kennst/noch nicht kennen musst. Darum brauchst du dir aber keine Gedanken zu machen. Verwende ein `SimpleSet` einfach, indem du mit `new SimpleSet()` eine neue, erstmal leere Menge erzeugst und dann die drei eben beschriebenen Methoden darauf anwendest, um Zahlen hinzuzufügen, zu überprüfen, ob eine gegebene Zahl vorhanden ist bzw. ein Array aller enthaltenen Zahlen zu generieren.

### Das Interface `Graph`

Java-Interfaces musst du zu diesem Zeitpunkt noch nicht verstehen. Verständis von `Graph` ist nicht notwendig (oder hilfreich), um diese Aufgabe zu lösen. Wir benötigen `Graph` hauptsächlich für unsere Implementierung des im nächsten Punkt beschriebenen Dijkstra-Algorithmus. Ignoriere diese Datei, sowie die Add-Ons `implements Graph` hinter `public class SparseGraph` und `public class DenseGraph` also gerne einfach.

### Dijkstra

Im Template findest du die Klasse `Dijkstra`. *Hierzu gibt es keine Aufgaben! Die Implementierung ist nur zum Spielen gedacht! Um diese Aufgabe zu lösen, kannst du `Dijkstra.java` also gerne auch einfach ignorieren, wir wollen aber zu Neugier ermutigen.* Einfach nur Netze zu modellieren, wäre zu langweilig, deshalb hast du in dieser Klasse einen Algorithmus, der den kürzesten Pfad zwischen zwei Knoten bestimmen kann (Jede Kante hat bei unserem simplen Netz Länge `1`, deshalb ist der kürzeste Pfad, der Weg vom Start zum Ziel mit der minimalen Anzahl von Knoten/Kanten). Der Dijkstra Algorithmus gehört zum kleinen 1x1 der Informatik und wird dir noch in mehreren Vorlesungen begegnen, aller spätestens kommendes Semester in ""Grundlagen Algorithmen und Datenstrukturen"".
Wenn du deine Implementierungen einmal für Dijkstra nutzen möchtest, kannst du das wie folgt tun:

```java
Graph g = new DenseGraph(10);                       // oder SparseGraph
int start = 0;                                      // die ID des Knoten von dem aus wir losgehen möchten
int target = 7;                                     // die ID des Knoten den wir erreichen möchten
int[] path = Dijkstra.dijkstra(g, start, target);   // der kürzeste Pfad
System.out.println(Arrays.toString(path));          // eine Ausgabe in der Konsole
```

## Sparse Graphen

Einen Graphen nennen wir ""sparse"", wenn er nur sehr wenige Kanten enthält. Im Folgenden sollst du die Klasse `SparseGraph` implementieren. Diese Datenstruktur soll für das Speichern von sparse Graphen optimiert sein. Natürlich muss die Datenstruktur dennoch DAU-safe (Dümmster anzunehmender User) sein, d.h. es soll dennoch möglich sein, beliebige Graphen in der Datenstruktur zu speichern. Überlege dir also, welche der obigen Implementierungen auch für Graphen mit mehreren Millionen Knoten, aber nur einigen wenigen Kanten pro Knoten, noch effizient (bzgl. Laufzeit der Methoden und Speicherverbrauch) ist.

`SparseGraph` implementiert das Interface `Graph`. Du kanst dir `Graph` gerne schon für die kommende Woche ansehen, jetzt ist es aber noch nicht notwendig zu verstehen was ein Java-Interface ist.

1. [task][Konstruktor]( 173311 )
Der Konstruktor erwartet `nodes` (`int`), die Anzahl der Knoten des Graphen. Die Knoten werden im Folgenden über ihre ""id""/""Namen"" betitelt. Dazu sind die Knoten nummeriert (`0` - `nodes-1`). Passe den Konstruktor für deine Implementierung entsprechend an.
2. [task][getNumberOfNodes]( 173263 )
Die Methode `getNumberOfNodes()` soll die Anzahl der Knoten des Graphen zurückgeben. Dem Konstruktor wurde diese Zahl bei der Initialisierung übergeben (`nodes`).
3. [task][addEdge]( 173341 , 173337 )
Die Methode `addEdge(int, int)` erwartet die beiden `int`-Werte `from` und `to`. Dabei handelt es sich um zwei Knoten, zwischen denen wir eine Kante hinzufügen möchten. Enthält der `SparseGraph` noch keine gerichtete Kante von `from` nach `to`, soll diese nun erstellt werden.
4. [task][isAdj]( 173314 , 173278 , 173340 )
Die Methode `isAdj(int, int)` erwartet die beiden `int`-Werte `from` und `to` und soll einen `boolean` zurückgeben. Dabei handelt es sich um zwei Knoten. die Methode soll `true` returnen, wenn eine Kante von `from` nach `to` existiert, andernfalls `false`.
5. [task][getAdj]( 173331 , 173339 )
Die Methode `getAdj(int)` erwartet den `int`-Wert `id` (ein Knoten des Graphen). Existiert dieser Knoten im `SparseGraph`, soll ein Array aller benachbarten Knoten zurückgegeben werden (Array aus Knoten-IDs). Ein Knoten gilt als benachbart, wenn es eine gerichtete Kante von `id` zu diesem anderen Knoten gibt. Ist der Knoten `id` nicht im Graph enthalten, soll die Methode `null` zurück geben.

### Public Test Summary
Hier werden dir die Ergebnisse der Public Tests zusammenfassend angezeigt. Um auf die Teilaufgabe ""Sparse Graphen"" Punkte zu bekommen, müssen diese alle passen. Die Punkte gibt's dann auf die drei Methoden `addEdge()`, `isAdj()` und `getAdj()`, wenn die Public Tests durchlaufen und die gewählte Implementierung von `SparseGraph` eine für sparse Graphen effiziente ist.
[task][Public Tests]( 173311 , 173263 ,Sparse - Can Store Dense Graph)
Testet deine Abgabe nach jedem Push neu.

### Optimiert für Sparsity
Hier werden dir die Ergebnisse der automatischen Tests, ob korrekt auf Sparsity optimiert wurde, nach der Deadline angezeigt:
[task][Hidden Tests]( 173329 )
Testet deine Abgabe nach der Deadline.

## Dense Graphen

Einen Graphen nennen wir ""dense"", wenn er sehr viele Kanten enthält. Im Folgenden sollst du die Klasse `DenseGraph` implementieren. Diese Datenstruktur soll für das Speichern von dense Graphen optimiert sein. Natürlich muss die Datenstruktur dennoch DAU-safe (Dümmster anzunehmender User) sein, d.h. es soll dennoch möglich sein, beliebeige Graphen in der Datenstruktur zu speichern. Überlege dir also, welche der obigen Implementierungen auch für Graphen mit nicht ganz so vielen Knoten (vllt. einige zehntausend), aber dafür von jedem Knoten aus Kanten zu einem großen Anteil der anderen Knoten, noch effizient (bzgl. Laufzeit der Methoden und Speicherverbrauch) ist.

`DenseGraph` implementiert das Interface `Graph`. Du kanst dir `Graph` gerne schon für die kommende Woche ansehen, jetzt ist es aber noch nicht notwendig zu verstehen was ein Java-Interface ist.

1. [task][Konstruktor]( 173264 )
Der Konstruktor erwartet `nodes` (`int`), die Anzahl der Knoten des Graphen. Die Knoten werden im Folgenden über ihre ""id""/""Namen"" betitelt. Dazu sind die Knoten nummeriert (`0` - `nodes-1`). Passe den Konstruktor für deine Implementierung entsprechend an.
2. [task][getNumberOfNodes]( 173280 )
Die Methode `getNumberOfNodes()` soll die Anzahl der Knoten des Graphen zurückgeben. Dem Konstruktor wurde diese Zahl bei der Initialisierung übergeben (`nodes`).
3. [task][addEdge]( 173335 , 173333 )
Die Methode `addEdge(int, int)` erwartet die beiden `int`-Werte `from` und `to`. Dabei handelt es sich um zwei Knoten, zwischen denen wir eine Kante hinzufügen möchten. Enthält der `DenseGraph` noch keine gerichtete Kante von `from` nach `to`, soll diese nun erstellt werden.
4. [task][isAdj]( 173315 , 173309 , 173334 )
Die Methode `isAdj(int, int)` erwartet die beiden `int`-Werte `from` und `to` und soll einen `boolean` zurückgeben. Dabei handelt es sich um zwei Knoten. Die Methode soll `true` zurückgeben, wenn eine Kante von `from` nach `to` existiert, andernfalls `false`.
5. [task][getAdj]( 173338 , 173336 )
Die Methode `getAdj(int)` erwartet den `int`-Wert `id` (ein Knoten des Graphen). Existiert dieser Knoten im `DenseGraph`, soll ein Array aller benachbarten Knoten zurückgegeben werden (Array aus Knoten-IDs). Ein Knoten gilt als benachbart, wenn es eine gerichtete Kante von `id` zu diesem anderen Knoten gibt. Ist der Knoten `id` nicht im Graph enthalten, soll die Methode `null` zurückgeben.

### Public Test Summary
Hier werden dir die Ergebnisse der Public Tests zusammenfassend angezeigt. Um auf die Teilaufgabe ""Dense Graphen"" Punkte zu bekommen, müssen diese alle passen. Die Punkte gibt's dann auf die drei Methoden `addEdge()`, `isAdj()` und `getAdj()`, wenn die Public Tests durchlaufen und die gewählte Implementierung von `DenseGraph` eine für dense Graphen effiziente ist.
[task][Public Tests]( 173264 , 173280 )
Testet deine Abgabe nach jedem Push neu.

### Optimiert für Density
Hier werden dir die Ergebnisse der automatischen Tests, ob korrekt auf Density optimiert wurde, nach der Deadline angezeigt:
[task][Hidden Tests]( 173332 )
Testet deine Abgabe nach der Deadline.


## Beispiele & `toGraphviz()`

Beide von dir zu implementierenden Klassen bieten die Methode `toGraphviz()` an. Diese gibt einen `String` zurück (du musst dazu schon die Methode `getAdj(int)` implementiert haben). Diesen `String` kannst du auf [dieser Website](https://dreampuf.github.io/GraphvizOnline) in das linke Textfeld kopieren. Auf der rechten Hälfte des Bildschirms solltest du jetzt einen Plot des Graphen sehen. Oben siehst du das Drop-Down-Menu `Engine`, hier kannst du verschiedene Optionen ausprobieren, damit der Graph leserlich repräsentiert wird (`circo` ist häufig eine gute Wahl :) ).

### Beispiel: Sparse Graph

[Sparse Graph](https://dreampuf.github.io/GraphvizOnline/#digraph%20G%20%7B%0D%0A0%20%5Bshape%3Dcircle%5D%0D%0A0%20->%203%0D%0A0%20->%204%0D%0A1%20%5Bshape%3Dcircle%5D%0D%0A1%20->%200%0D%0A1%20->%201%0D%0A2%20%5Bshape%3Dcircle%5D%0D%0A2%20->%203%0D%0A3%20%5Bshape%3Dcircle%5D%0D%0A3%20->%200%0D%0A3%20->%204%0D%0A4%20%5Bshape%3Dcircle%5D%0D%0A4%20->%201%0D%0A4%20->%202%0D%0A4%20->%205%0D%0A5%20%5Bshape%3Dcircle%5D%0D%0A5%20->%206%0D%0A5%20->%207%0D%0A6%20%5Bshape%3Dcircle%5D%0D%0A6%20->%207%0D%0A6%20->%208%0D%0A6%20->%209%0D%0A7%20%5Bshape%3Dcircle%5D%0D%0A7%20->%2019%0D%0A8%20%5Bshape%3Dcircle%5D%0D%0A8%20->%2010%0D%0A8%20->%206%0D%0A9%20%5Bshape%3Dcircle%5D%0D%0A10%20%5Bshape%3Dcircle%5D%0D%0A10%20->%209%0D%0A10%20->%2011%0D%0A11%20%5Bshape%3Dcircle%5D%0D%0A11%20->%2012%0D%0A12%20%5Bshape%3Dcircle%5D%0D%0A12%20->%2013%0D%0A13%20%5Bshape%3Dcircle%5D%0D%0A13%20->%2014%0D%0A13%20->%2015%0D%0A14%20%5Bshape%3Dcircle%5D%0D%0A14%20->%2012%0D%0A14%20->%2016%0D%0A15%20%5Bshape%3Dcircle%5D%0D%0A15%20->%2016%0D%0A16%20%5Bshape%3Dcircle%5D%0D%0A16%20->%2017%0D%0A17%20%5Bshape%3Dcircle%5D%0D%0A17%20->%2018%0D%0A18%20%5Bshape%3Dcircle%5D%0D%0A18%20->%2019%0D%0A19%20%5Bshape%3Dcircle%5D%0D%0A%7D)

20 Knoten; 30 Kanten
-> viele Knoten, aber nicht viel mehr Kanten als Knoten

### Beispiel: Dense Graph

[Dense Graph](https://dreampuf.github.io/GraphvizOnline/#digraph%20G%20%7B%0D%0A0%20%5Bshape%3Dcircle%5D%0D%0A0%20->%201%0D%0A0%20->%202%0D%0A0%20->%203%0D%0A0%20->%204%0D%0A0%20->%205%0D%0A0%20->%206%0D%0A0%20->%207%0D%0A0%20->%208%0D%0A0%20->%209%0D%0A1%20%5Bshape%3Dcircle%5D%0D%0A1%20->%200%0D%0A1%20->%201%0D%0A1%20->%202%0D%0A1%20->%203%0D%0A1%20->%204%0D%0A1%20->%206%0D%0A1%20->%207%0D%0A1%20->%209%0D%0A2%20%5Bshape%3Dcircle%5D%0D%0A2%20->%200%0D%0A2%20->%201%0D%0A2%20->%203%0D%0A2%20->%204%0D%0A2%20->%205%0D%0A2%20->%207%0D%0A2%20->%208%0D%0A2%20->%209%0D%0A3%20%5Bshape%3Dcircle%5D%0D%0A3%20->%200%0D%0A3%20->%201%0D%0A3%20->%202%0D%0A3%20->%204%0D%0A3%20->%206%0D%0A3%20->%208%0D%0A3%20->%209%0D%0A4%20%5Bshape%3Dcircle%5D%0D%0A4%20->%200%0D%0A4%20->%201%0D%0A4%20->%202%0D%0A4%20->%203%0D%0A4%20->%205%0D%0A4%20->%206%0D%0A4%20->%207%0D%0A4%20->%208%0D%0A5%20%5Bshape%3Dcircle%5D%0D%0A5%20->%200%0D%0A5%20->%202%0D%0A5%20->%203%0D%0A5%20->%206%0D%0A5%20->%209%0D%0A6%20%5Bshape%3Dcircle%5D%0D%0A6%20->%200%0D%0A6%20->%201%0D%0A6%20->%202%0D%0A6%20->%203%0D%0A6%20->%204%0D%0A6%20->%205%0D%0A6%20->%207%0D%0A6%20->%208%0D%0A7%20%5Bshape%3Dcircle%5D%0D%0A7%20->%200%0D%0A7%20->%201%0D%0A7%20->%202%0D%0A7%20->%203%0D%0A7%20->%204%0D%0A7%20->%205%0D%0A7%20->%206%0D%0A7%20->%208%0D%0A7%20->%209%0D%0A8%20%5Bshape%3Dcircle%5D%0D%0A8%20->%200%0D%0A8%20->%202%0D%0A8%20->%205%0D%0A8%20->%206%0D%0A8%20->%208%0D%0A8%20->%209%0D%0A9%20%5Bshape%3Dcircle%5D%0D%0A9%20->%200%0D%0A9%20->%201%0D%0A9%20->%202%0D%0A9%20->%203%0D%0A9%20->%204%0D%0A9%20->%205%0D%0A9%20->%206%0D%0A%7D)

10 Knoten; 75 Kanten
-> nicht so viele Knoten, dafür aber viele Kanten pro Knoten

Viel Erfolg!!!"
299,Praktikum: Grundlagen der Programmierung WS23/24,12228,W06H01 - Fisch fuer Pinguine,"# Fisch für die Pinguine
Die Pinguine beschäftigen schon sich seit einer Woche mit Listen, und sie brauchen erst mal Verstärkung in Form von Fisch, bevor sie sich mit den neuen Datenstrukturen beschäftigen können. Als allererstes dürfen sich die jüngsten Pinguine bedienen und deshalb müsst ihr ihnen jetzt helfen, sich auf pinguingerechte Art zu sortieren.
Das heißt, dass die Pinguine sich eins nach dem anderen einsortieren werden.

### Part 1: An die richtige Stelle

Wir werden später die Alter von Pinguine in einer Liste speichern. Wir ergänzen aber erst mal die bestehende List-Implementierung. 

In W05P05 wurde die `add(int value, int index)` Methode implementiert. Jetzt fügen wir die `insertIntoSorted(int value)` Methode hinzu. Hier wird angenommen, dass die Liste bereits sortiert ist, und ein Element an der richtigen Stelle hinzugefügt wird. Das geht so:
1. Ist die Liste leer, wird einfach ein Element mit dem Value hinzugefügt. Das läuft analog zu `add`, wenn die Liste leer ist.
2. Ist die Liste nicht leer, wird immer das nächste Element angeschaut, bis (engl. while) ein Element gefunden wird, dessen Wert größer ist. Dann wird das neue Element davor hinzugefügt.
    1. Es kann sein das man kein größeres Element findet. Das merkt man unter anderem daran, dass das `.next` auf das aktuell angeschaute Element `null` wird. In dem Fall wird das neue Element ganz am Ende hinzugefügt. Bei der Liste nicht vergessen `tail` richtig zu setzen!
    2. Es kann sein das bereits das erste Element größer ist. Bei der Liste nicht vergessen `head` richtig zu setzen.
    3. Man kann sich auch einfach das Index von dem letzten kleineren Element merken, und die `add` Funktion verwenden. Dann ist man sicher, dass die richtige Änderungen in der Liste gemacht werden. Eine Hilfsmethode, die diesen Index zurückgibt, ist sicher auch hilfreich. (Soll diese Methode lieber `private` oder `public` sein?)
        1. Wenn man sich für diese Variante entscheidet, kann die Hilfsmethode ohne Rest der Implementierung getestet werden. Fehler rechtzeitig zu erkennen spart viel Zeit?
        2. Was ist der Nachteil dieser Variante?

Um diese Methode zu testen, empfiehlt sich eine sortierte Liste zu erstellen, indem ihr erst eine leere Liste erstellt, und eins nach dem anderen Elemente in aufsteigender Reihenfolge mit `add` hinzufügt.
Danach könnt ihr einzelne Elemente per `insertIntoSorted` hinzufügen und schauen ob die Liste weiterhin richtig sortiert ist. Folgende sind interessante Test-Cases:
1. Insert in eine leere Liste
2. Insert ein Element, das weder größer noch kleiner als alle bestehenden Elemente ist.
3. Insert ein Element, das kleiner ist als alle bestehenden Elemente.
4. Insert ein Element, das größer ist als alle bestehenden Elemente.

Wenn das alles funktioniert, sind die Pinguine bereit für die nächste Aufgabe!
1. [task][Insert into sorted]( 173409 , 173405 , 173410 , 173411 , 173414 )
Implementiere die Methode `insertIntoSorted` in der Klasse `List`

### Part 2: Alle an die richtigen Stellen
Nun wollen wir die Pinguine nach ihrem Alter sortieren. Dabei fangen wir mit einem Array von Alter an und gehen wie folgt vor:
1. Eine leere Liste wird erstellt.
2. Alle Pinguinalter werden eins nach dem anderen an die richtige Stelle mit `insertToSorted` hinzugefügt. Dadurch bleibt die Liste immer sortiert.

*Hinweis:* Funktioniert das nicht wie erwartet, ist es sicher eine gute Idee, sich die Liste nach jedem hinzufügen ausdrucken zu lassen und zu schauen, wann was schief läuft.


2. [task][Sort Penguins]( 173413 , 173417 , 173408 , 173415 , 173412 , 173406 , 173416 , 173418 )
Implementiere die Methode `sortPenguins` in der Klasse `SortedPenguins`.
 
Sind alle Pinguine satt, geht es weiter mit der nächsten Aufgabe!"
299,Praktikum: Grundlagen der Programmierung WS23/24,12253,W07P01 - Text zu UML - Pingu Game,"# Pingu Game

In dieser Aufgabe wollen wir die Klassenhierarchie für ein kleines Spiel entwerfen.

Im Spiel gibt es mehrere verschiedene Arten von Game-Objects. Ein Game-Object hat dabei eine ID und eine Position. Man kann es rendern und eine Kollision mit einem anderen Game-Object auflösen.
Um Letzteres berechnen zu können, muss natürlich jedes Game-Object eine Hitbox haben. Hitboxen gibt es in zwei Varianten: Quadratische Hitboxen und kreisförmige Hitboxen können beide eine Kollision mit einer anderen Hitbox feststellen, wie genau diese Kollision dann aber berechnet wird, hängt natürlich von der Art von Hitbox ab.

Der Spieler selbst ist auch ein Game-Object. Er hat mehrere Input-Listener für all die verschiedenen Arten, auf die der Nutzer ihn steuern kann. Input-Listener unterscheiden sich darin, ob sie auf Inputs (i.e. Bewegungen) von der Maus hören oder ob sie auf Tastendrücke auf der Tastatur hören. Alle Input-Listener führen, wenn das von ihnen erwartete Input kommt, eine bestimmte Aktion aus.

Außer dem Spieler gibt es noch Monster, die auch Game-Objects sind. Es gibt Boss-Monster und gewöhnliche Monster. Beides sind Monster.

Desweiteren sind noch Items und Wände weitere Game-Objects."
299,Praktikum: Grundlagen der Programmierung WS23/24,12254,W07P02 - UML zu Code - Alle Jahre Wieder,"# Alle Jahre Wieder

Prismen oder Zylinder sind geometrische Körper, die durch Parallelverschiebung ihrer Grundfläche im Raum entstehen. 

Prismen sind durch ihre Höhe und ihre jeweilige Grundfläche bestimmt. 
Als Grundflächen in Frage kommen (zum Beispiel):
- regelmäßige n-Ecke, bestimmt durch die Anzahl der Ecken und die Seitenlänge
- Kreise, bestimmt durch ihren Radius 
- Rechtecke, bestimmt durch Breite und Höhe

An Operationen muss eine Grundfläche die Berechnung von Umfang und Flächeninhalt zur Verfügung stellen, ein Prisma die Berechnung von Oberfläche und Volumen. Das alles wird in folgendem UML-Diagramm zusammengefasst
(Getter und Setter wurden der Übersichtlichkeit halber weggelassen, füge sie nach Bedarf hinzu):

@startuml

hide circle

class BaseArea {
    + circumference(): double
    + area(): double
    + isSquare(): boolean
    + toSquare(): Square
}

class Prism {
    - height: double
    + surface(): double
    + volume(): double
    + isCube(): boolean
}

class Circle {
    - radius: double
}

class Rectangle {
    - width: double
    - height: double
}

class Square {
    - length: double
}

class RegularPolygon {
    - n: int
    - length: double
}

BaseArea ""1"" -left-o ""1"" Prism : -base
BaseArea <|-- Circle
BaseArea <|-- Rectangle
BaseArea <|-- Square
BaseArea <|-- RegularPolygon

@enduml

Dabei soll die Methode `toSquare()` ein Quadrat gleicher Seitenlänge zurückgeben, falls die Fläche ein Quadrat ist und `null`, falls die Fläche kein Quadrat ist. Dies ist relevant für die Klasse `Rectangle`, da diese implizit ein Quadrat darstellen kann, wenn Breite und Höhe gleich sind.

In dieser Aufgabe soll eine Klassenhierarchie für diese geometrischen Körper in Java implementiert werden.

Gehen Sie wie folgt vor:
- Implementiere alle angegebenen Klassen und Methoden außer `Prism`! Überschreibe die Methoden von `BaseArea` in
den jeweiligen Unterklassen! Vergiss nicht, geeignete Getter und Setter hinzuzufügen!
- Implementiere zuletzt die Klasse `Prism`!

*Hinweis 1: Die Fläche eines regelmäßigen n-Ecks mit Seitenlänge a ist*
$$\frac{n * a^2}{4 * \tan (\frac{\pi}{n})}$$.  
*Hinweis 2: Die Konstante `Math.PI` und die Methode `Math.tan` (Siehe [Math](https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html)) sind möglicherweise hilfreich*."
299,Praktikum: Grundlagen der Programmierung WS23/24,12255,W07P03 - Text zu UML - Zoo,"#Text zu UML

In dieser Aufgabe sollst du üben, aus einer Ausgangssituation ein passendes UML zu erstellen. Überlege dir dabei immer, welche Klasse voneinander erben sollten und welche davon abstrakt sein sollten. Versuche weiterhin, gemeinsame Eigenschaften und Methoden in Interfaces zu platzieren. Du kannst die Namen der Klassen, Attribute und Methoden sowohl auf Deutsch als auch auf Englisch wählen. Der Lösungsvorschlag in dieser Aufgabe ist wirklich nur als Vorschlag gemeint. Es gibt viele Möglichkeiten, dieses gegebene Szenario zu modellieren.

###Ansichten der Natur

Jedem Tier kann ein Name, ein Alter und ein Gewicht zugewiesen werden. Es isst, schläft und macht Geräusche. Tiere kann man noch weiter in Vögel, Säugetiere und Fische aufteilen, d.h. jeder Vogel, jedes Säugetier und jeder Fisch ist ein Tier. Dabei muss man beachten, dass nicht alle Vögel fliegen können. Jedoch sollen alle Vögel in der Lage sein, Eier zu legen. Spezielle Arten von Vögeln sind zudem Papageien oder Pinguine. Säugetiere hingegen säugen ihren Nachwuchs mit Milch. Dabei ist es interessant zu wissen, ob ein Säugetier gerade in der Lage ist, ein Junges zu säugen. Katzen und Delfine gehören bspw. zur Kategorie der Säugetiere. Zuletzt möchten wir auch noch Fische wie Haie oder Goldfische betrachten können.

Alle fliegenden und schwimmenden Tieren sollen auch in der Lage sein, zu schwimmen bzw. zu fliegen. Manche Tiere kann man auch zähmen. Diese Tiere kann man auch ohne Bedenken streicheln.

[Lösungsvorschlag](https://apollon.ase.in.tum.de/urbtNRa9WLbPGsQdG16V?view=SEE_FEEDBACK)"
299,Praktikum: Grundlagen der Programmierung WS23/24,12256,W07P04 - UML zu Code - Zoo,"# UML zu Code - Zoo

Nun soll ein reduziertes UML-Diagramm der Aufgabe W07P01 implementiert werden. Erstelle also alle benötigten Klassen, Interfaces, Attribute und Methoden. Auch wenn die Konstruktoren im UML-Diagramm fehlen, so sollen alle Attribute der Klassen im Konstruktor übergeben werden. Versuche dabei redundanten Code zu vermeiden und gemeinsame Funktionalitäten der Methoden in Interfaces und Oberklassen zu implementieren.

*Hinweis*: Die Methode `makeSound()` ist eine abstrakte Methode.

![ClassDiagram (1).svg](/api/core/files/markdown/Markdown_2021-11-15T22-15-57-755_ef6c0450.svg)

[Link zu Apollon](https://apollon.ase.in.tum.de/S2FEuxtWhpwuxZvCChNy?view=SEE_FEEDBACK)

Die Tests testen lediglich die Struktur. Du kannst also die Methoden selbst leer lassen oder selbstständig gewisse Funktionalitäten ergänzen."
299,Praktikum: Grundlagen der Programmierung WS23/24,12257,W07P04 - Polymorphie,"# Polymorphie

Besprecht mit eurem Tutor folgende Begriffe: Statischer Typ, dynamischer Typ, Methodensignatur,
Überschreiben, Überladen, dynamic Dispatch.

Schaut euch anschließend folgendes Programm an und bestimmt, welche Ausgabe die jeweiligen Aufrufe
erzeugen unter der Annahme, dass jeweils nur ein Ausdruck einkommentiert ist.

Begründet außerdem euer Ergebnis, indem ihr eine Tabelle mit folgenden Spalten ausfüllt:
- Aufruf (die im Kommentar angegebene Nummer)
- Zeilennummer (die Zeilennummer des Aufrufs, der gerade behandelt wird)
- statischer Typ (der statische Typ des Objekts, auf dem aufgerufen wird)
- kompatible Methoden (die Zeilennummern aller Methoden, die gemäß statischem Typ aufgerufen werden könnten)
- statisch gewähle Methode (die Zeilennummer derjenigen Methode, die statisch ausgewählt wird)
- Signatur (die Methodensignatur der statisch gewählten Methode, z.B. `f(B)`)
- Begründung (z.B. `speziellste Signatur` oder `Eindeutig`)
- dynamischer Typ (der dynamische Typ des Objekts, auf dem aufgerufen wird)
- zur Laufzeit ausgeführt (die Zeilennummer derjenigen Methode, die letzendlich ausgeführt wird)
- Begründung (z.B. `static, kein Dispatch` oder `statischer Typ = dynamischer Typ`)
- Ausgabe (die Ausgabe, die durch den Aufruf verursacht wird)

```
01 | public class Poly {
02 |     static class A {
03 |         int x() {
04 |             return 0;
05 |         }
06 | 
07 |         int y = 3;
08 | 
09 |         static void f(A a) {
10 |             System.out.print(a.x() + ""-"");
11 |             a.g(a);
12 |         }
13 | 
14 |         static void f(B b) {
15 |             System.out.print(b.y + ""-"");
16 |             b.g(b);
17 |         }
18 | 
19 |         void g(A a) {
20 |             System.out.println(a.y);
21 |         }
22 | 
23 |         void g(B b) {
24 |             System.out.print(b.y + ""-"");
25 |             this.f(this);
26 |         }
27 |     }
28 | 
29 |     static class B extends A {
30 |         int x() {
31 |             return 1;
32 |         }
33 | 
34 |         int y = 9;
35 | 
36 |         static void f(A a) {
37 |             System.out.print(a.y + ""-"");
38 |             (new A()).g(a);
39 |         }
40 | 
41 |         static void f(B b) {
42 |             System.out.print(b.y + ""-"");
43 |             ((B) b).f((A) b);
44 |         }
45 | 
46 |         void g(A a) {
47 |             System.out.print(a.y + ""-"");
48 |             a.f((B) a);
49 |         }
50 | 
51 |         void g(B b) {
52 |             System.out.print(b.x() + ""-"");
53 |             b.f(b);
54 |         }
55 |     }
56 | 
57 |     public static void main(String[] args) {
58 |         A a1 = new A();
59 |         A a2 = new B();
60 |         B b = new B();
61 | 
62 |         b.f(b); // Aufruf 1
63 |         a1.g(b); // Aufruf 2
64 |         a2.f(b); // Aufruf 3
65 |         a2.g(a1); // Aufruf 4
66 |         a2.f(a2); // Aufruf 5
67 |     }
68 | }
```

*Anmerkung: Zugunsten einer kompakten Darstellung wurden die Klassen alle als Innere Klassen von `Poly` definiert;
damit Sie nur einmal definiert werden und nicht einmal pro Objekt von `Poly`, müssen sie `static` sein.
Das hat aber auf die Ausführung keinen Einfluss. Die Klassen könnten ebenso in getrennten Dateien sein.*


[Lösungsvorschlag](/api/core/files/markdown/Markdown_2022-11-09T10-38-22-906_2db7fea2.pdf)"
299,Praktikum: Grundlagen der Programmierung WS23/24,12259,W07H02 - Text zu UML,"#W07H02 Text zu UML
Nach anfänglichen Erfolgen versinkt die Entwicklung des Autos im Chaos. Bauteile und Raceuine fliegen kreuz und quer durch die Fabrik, weil jeder überall arbeitet, nur nicht eben da, wo er soll. Und es dauert nicht mehr lange bis Saisonbeginn! Deshalb wollen die Raceuine etwas Struktur in ihr Team bringen. Dabei sind sie der Meinung, dass sich das am besten in einem UML-Klassendiagramm darstellen lässt.

##Allgemeine Hinweise:
- In dieser Aufgabe geht es darum, (abstrakte) Klassen, Interfaces und Vererbung sinnvoll zu verwenden.
- Grundsätzlich sollen, wo es sinnvoll ist, Integer und Doubles verwendet werden, sonst Strings.

#Aufgabe
Jeder Raceuin ist ein **Mitarbeiter** und hat eine ID, einen Namen, einen Geburtstag und ein Gehalt. Zudem hat jeder Mitarbeiter einen Manager/Abteilungschef.

####Nun zu den einzelnen Abteilungen:
Zum einen gibt es natürlich den **Teamchef**. Dieser hat die Aufgabe, das Team zu leiten. Der Teamchef ist natürlich selbst ein Mitarbeiter.

Des Weiteren haben wir unsere **Fahrer**, die im Gegensatz zu den anderen Jobs ein festes Vertragsende haben. Zudem sind sie natürlich in der Lage, unsere schnellen Boliden zu fahren.

Aber damit wir überhaupt ein schnelles Auto haben, brauchen wir noch die **Designer**, welche offensichtlich designen können, und **Aerodynamiker**, die das Auto dann im Windkanal bis zur Perfektion testen können.

Da beide aber nur in der Fabrik arbeiten, brauchen wir natürlich auch **Mechaniker**, die zu den Rennen mitkommen. Sie haben die Aufgabe, das Auto zu reparieren, falls es zu einem Schaden kommt, und das Setup vom Auto zu ändern, damit wir immer die optimale Abstimmung haben.

Auch **Renningenieure** spielen eine wichtige Rolle. Sie werten Daten aus und geben die Ergebnisse ihrer Analysen als String weiter. Des Weiteren gibt es **3 Arten** von Renningenieuren:
- Der **Stratege** kann die Reifen eines übergebenen Teams beobachten und behält auch das Wetter im Auge. Beide Beobachtungen soll er dabei als kurze Textnachricht zurückgeben können.
- Der **Dateningenieur** analysiert das Getriebe, insbesondere die Gänge, und die Motordrehzahl, da es sehr kritische Komponenten sind. Auch hier sollen beide Analysen zurückgegeben werden.
- Der **Streckeningenieur** misst die Streckentemperatur und den Wind, da sie einen sehr großen Einfluss auf die Performance des Autos haben, und gibt diese zurück.

Als Letztes sollen noch Renningenieure, Teamchef und Fahrer in der Lage sein, per Funk miteinander zu kommunizieren. Sie haben also alle das gleiche Verhalten ""eine Funknachricht versenden"".
Designer und Aerodynamiker hingegen können beide das Auto (weiter-)entwickeln.

 

(Quelle: Ein Pinguinküken, das lieber zeichnet anstatt PGdP zu machen)"
299,Praktikum: Grundlagen der Programmierung WS23/24,12260,W07H03 - Sicherheit Geht Vor,"#W07H03 - Sicherheit geht vor!
Nach der Blamage der FIA beim Regenrennen des Großen Preises von Japan in Suzuka sind sich alle Raceuine einig, dass Änderungen eingeführt werden müssen. 
Alle Raceuine? Nein, Max Whalestappen (Fahrer für das Gegnerteam Red Polar Bear) ist natürlich der Meinung, dass man im Regen wunderbar sehen kann. Natürlich lässt er dabei außer Acht, 
dass er ganz vorne war und seine Sicht nicht durch die Gischt anderer Raceuine getrübt wurde. Allerdings schenkt niemand seiner arroganten Meinung Beachtung
und du wurdest nun dazu beauftragt, das optische Signalsystem zu überarbeiten. Natürlich ist auch der FIA bewusst, dass es zu viele Flaggen und Regeln gibt.
Deswegen wollen sie dich erst mal nur mit den paar Grundfunktionen beauftragen.

##Allgemeine Hinweise:
- Im Diagramm kursiv dargestellte Methoden sind abstrakte Methoden.
- Bevor die Behavioral Tests ausgeführt werden, müssen erst die Structural Tests durchlaufen. Die Structural Tests sind alle public und testen, ob alle geforderten Klassen, Methoden und Attribute vorhanden sind. Zudem testen sie, ob Getter, Setter und Konstruktor funktionieren.
- Diese Aufgabe enthält recht viel Erklärungen u.a. zu den beiden Zustandsdiagrammen, damit hoffentlich alle Fragen geklärt werden. Nicht abschrecken lassen!
- Achtung: Es gibt 2 Textpassagen, die fast gleich ausschauen. Sie sind aber nicht gleich, sonst könnte man sie weglassen.
- Im Template sind 2 implementierte Klassen gegeben:
    - `Helper` kann mit der Methode `static String changeColors(String depiction)` die übergebene `depiction` passend einfärben, damit das Debugging leichter wird. Ob du diese Methode benutzen willst, bleibt dir überlassen. Die Tests akzeptieren beides. Was die `depiction` ist, erfährst du später.
    - `Main` hat eine main-Methode, die ein kleines Beispiel enthält, das du ausführen kannst, wenn du fertig bist. Den korrekten Output findest du zum Vergleich ganz unten.

##Folgendes Diagramm soll von dir implementiert werden:
@startuml
class Track {
    + Track(int)
    + setAll(String, boolean): void
    + setRange(String, boolean, int, int): void
    + createHazardAt(int, int): void
    + removeHazardAt(int, int): void
    + createLappedCarAt(int): void
    + removeLappedCarAt(int): void
    + printStatus(): void
}

abstract SignalPost {
    - postNumber: int
    - depiction: String
    - level: int
    {abstract}+ up(String): boolean
    {abstract}+ down(String): boolean
    + toString(): String
}

class LightPanel {
    + LightPanel(int)
    + up(String): boolean
    + down(String): boolean
    + toString(): String
}

class FlagPost {
    + FlagPost(int)
    + up(String): boolean
    + down(String): boolean
    + toString(): String
}

class FinishPost {
    + FinishPost(int)
    + up(String): boolean
    + down(String): boolean
    + toString(): String
}

Track o-right- ""*"" SignalPost : posts
SignalPost <|-down- LightPanel
SignalPost <|-down- FlagPost
FlagPost <|-down- FinishPost

hide empty fields
hide empty methods
@enduml


###Klasse `SignalPost`:
Die abstrakte Klasse `SignalPost` hat eine `postNumber`, die seine Position (beginnend bei  0 , allerdings muss nicht auf negative Werte geachtet werden) speichert, eine `depiction`, die die aktuelle Darstellung des `SignalPost`s speichert, sowie ein `level`, welches das aktuelle Level des `SignalPost` speichert. 
Was es mit dem Level auf sich hat, wird bei den Unterklassen erklärt. Denke daran, die Getter und Setter zu den Attributen zu implementieren. Die Signatur der Klasse stimmt noch nicht und muss von dir angepasst werden.
Ein neuer `SignalPost` wird mit der übergebenen `postNumber`, sowie `level`= 0  und `depiction`="""" initialisiert. Die beiden abstrakten Methoden `up()` und `down()` werden durch die Unterklassen implementiert. Allerdings darfst du weitere Hilfsmethoden implementieren, falls du sie brauchst.
Die `toString()` soll einen `String` nach folgendem Schema zurückgeben: "" Signal⎵Post⎵ \<`postNumber`> :⎵ \<`level`> ⎵ \<`depiction`>""

###Klasse `LightPanel`:
Die Klasse `LightPanel` ist unsere erste von `SignalPost` erbende Klasse. Sie wird genauso wie ihre Oberklasse initialisiert. Hier kommen jetzt konkret das `level` und die `depiction` zum Einsatz.

 

Im oben stehenden Diagramm siehst du alle Zustände, in denen sich ein `LightPanel` befinden kann + die Transitionen für die Methode `up()`. Jeder Zustand besteht aus einem `level` und einer `depiction`. Eine detaillierte Beschreibung der Level findest du nochmals weiter unten. 
Du kannst davon ausgehen, dass sich das `LightPanel` für die folgenden Methoden immer in einem gültigen Ausgangszustand befindet. Benutze keine weiteren Variablen zur Speicherung der Zustände außer denen, die vorgegeben sind. Sonst könnten Fehler entstehen. Konstanten sollten keine Probleme machen.
Kommen wir nun zu den drei Methoden, die wir überschreiben müssen:
- `boolean up(String type)` bekommt einen String `type` übergeben. Folgende Eigenschaften soll die Methode (wie im Diagramm zu sehen) erfüllen:
    - Ein gültiger `type` entspricht einem der Strings aus { green ,  blue ,  yellow ,  doubleYellow ,  [SC] ,  red ,  end }.
    - Der Zustand des `LightPanel`s wird analog zum Diagramm oben geändert. Die `type`s entsprechen demnach ihrem Zielzustand. Mit `type`=""green"" geht es also in den Zustand green in Level 1, mit `type`=""doubleYellow"" geht es in den Zustand doubleYellow in Level 3, usw. Mit `type`=""end"" geht es in Level 5 (siehe oben).
    - Das Wechseln soll allerdings nur in Pfeilrichtung von einem beliebigen Zustand in einen beliebigen Zustand weiter rechts möglich sein. Also nur, wenn sich das Level erhöht oder innerhalb eines Levels dem Vorrang entsprechend der Zustand geändert wird. 
    - Das Diagramm ist komplett transitiv, man kann also bspw. aus dem Zustand  green  (Level 1) mit `type`=""red"" direkt zu  red  (Level 4) gehen. Von  blue  zu  green  oder von  red  zu  yellow  sollen beispielsweise nicht möglich sein, da sie entgegen der Pfeilrichtung sind. 
    - Setze nicht nur die `depiction` korrekt, sondern auch das `level`.
    - Gebe dabei  true  zurück, falls sich der Zustand geändert hat, ansonsten  false . 
    - Falls der Parameter einem anderen String als den gültigen Strings entspricht, so soll nichts passieren und  false  zurückgegeben werden.
- `boolean down(String type)` bekommt ebenfalls einen String `type` übergeben, der allerdings nur einem der gültigen Strings aus { clear ,  green ,  blue ,  danger } entsprechen kann. Bei allen anderen Strings soll die Methode nichts machen und  false  zurückgeben. 
   Gebe auch hier  true  zurück, falls sich der Zustand ändert, ansonsten  false . Außerdem soll sie sich folgendermaßen verhalten:
    - mit `type`=""clear"" kann aus jedem Zustand in das `level`= 0  mit `depiction`= """"  gewechselt werden.
    - mit `type`=""green"" wird in das `level`= 0  mit `depiction`= """"  gewechselt, sofern sich das `LightPanel` zuvor im Zustand  green  befunden hat.
    - mit `type`=""blue"" wird in das `level`= 0  mit `depiction`= """"  gewechselt, sofern sich das `LightPanel` zuvor im Zustand  blue  befunden hat.
    - mit `type`=""danger"" wird in das `level`= 1  `depiction`= green  gewechselt, sofern sich das `LightPanel` zuvor im Zustand  yellow ,  doubleYellow ,  [SC]  oder  red  befunden hat. Beachte hierbei, dass das  yellow  aus Level 5 nicht gemeint ist.
- `String toString()` soll einen `String` nach folgendem Schema zurückgeben. Ob du dafür die `depiction` mit der vorgegebenen Hilfsmethode färbst oder nicht, bleibt dir überlassen. Die Tests akzeptieren beides: 
    - falls `level`= 0 : "" Signal⎵post⎵ \<`postNumber`> ⎵of⎵type⎵light⎵panel⎵is⎵in⎵level⎵ \<`level`> ⎵and⎵is⎵switched⎵off "".
    - sonst: "" Signal⎵post⎵ \<`postNumber`> ⎵of⎵type⎵light⎵panel⎵is⎵in⎵level⎵ \<`level`> ⎵and⎵is⎵blinking⎵ \<`depiction`>"".

Die `level` mit den zugehörigen `depiction`s (die relevanten Informationen stehen vor den ""-----""):
- Level  0 : `depiction`="""". ----- Die Strecke ist an diesem LightPanel frei, die Raceuine können Gas geben.
- Level  1 : `depiction`="" green "" oder "" blue "". Dabei hat ""blue"" Vorrang vor ""green"". ----- Die Strecke ist hier entweder nach einem Hindernis/einer Störung wieder freigegeben (green) oder ein langsamer Raceuin wird zum Überholen lassen aufgefordert (blue).
- Level  2 : `depiction`="" yellow "". ----- Hier befindet sich auf der Strecke ein Hindernis/eine Störung und die Raceuine müssen vorsichtig vorbeifahren und dürfen nicht überholen.
- Level  3 : `depiction`="" doubleYellow "" oder "" [SC] "". Dabei hat ""[SC]"" Vorrang vor ""doubleYellow"". ----- Eine noch strengere Form von Level 2. Die Raceuine müssen zusätzlich vom Gas gehen (doubleYellow). Wenn zudem das Safety Car rausgeschickt wird, so müssen alle Raceuine diesem langsam hinterherfahren ([SC]).
- Level  4 : `depiction`="" red "". ----- Das Hindernis/die Störung ist so groß, dass das Rennen unterbrochen werden muss.
- Level  5 : `depiction`="" yellow "". ----- Das Ende des Rennens ist erreicht, der Sieger steht fest.

 

###Klasse `FlagPost`:
Die Klasse `FlagPost` ist unsere andere Klasse, die von `SignalPost` erbt. Sie funktioniert ähnlich wie das `LightPanel`, aber hat kleine Unterschiede, da diese Klasse imstande ist, mehrere Farben gleichzeitig zu zeigen. Ein `FlagPost`-Objekt soll wie die Oberklasse implementiert werden.

 

Im oben stehenden Diagramm siehst du alle Zustände, in denen sich ein `FlagPost` befinden kann + die Transitionen für die Methode `up()`. Eine detaillierte Beschreibung der Level findest du nochmals weiter unten (es gibt kleine Änderungen, wie du schon dem Diagramm entnehmen kannst). 
Du kannst davon ausgehen, dass sich der `FlagPost` für die folgenden Methoden immer in einem gültigen Ausgangszustand befindet. Benutze keine weiteren Variablen zur Speicherung der Zustände außer denen, die vorgegeben sind. Sonst könnten Fehler entstehen. Konstanten sollten keine Probleme machen.
Kommen wir nun zu den drei Methoden, die wir überschreiben müssen:
- `boolean up(String type)` bekommt einen String `type` übergeben. Im Vergleich zum `LightPanel` gibt es folgende Änderungen:
    - Das Diagramm ist auch hier transitiv, allerdings gibt es eine Ausnahme: Der Übergang von Level  0  zu  green/blue  ist als einziger **nicht** direkt möglich. Allerdings kann man durch mehrfaches Aufrufen von `up()` mit  blue  zu blue und dann mit  green  zu green/blue gehen, oder alternativ mit  green  zu green und dann mit  blue  zu green/blue gehen.
    - Zudem gibt es zur `depicition`= doubleYellow/[SC]  kein zugehöriges `type`. Hier soll man mit `type`= [SC]  zu doubleYellow/[SC] wechseln können.
- `boolean down(String type)` bekommt ebenfalls einen String `type` übergeben. Sie soll sich ähnlich wie in `LightPanel` verhalten, aber mit paar Ausnahmen bei bestimmten Zuständen:
    - mit `type`=""clear"" kann aus jedem Zustand in das `level`= 0  mit `depiction`= """"  gewechselt werden.
    - mit `type`=""green"" wird in das `level`= 0  mit `depiction`= """"  gewechselt, sofern sich der `FlagPost` zuvor im Zustand  green  befunden hat. Oder aber die `depiction` wird zu  blue  und das Level bleibt bei 1, sofern sich der `FlagPost` in Zustand  green/blue  befunden hatte.
    - mit `type`=""blue"" wird in das `level`= 0  mit `depiction`= """"  gewechselt, sofern sich das `FlagPost` zuvor im Zustand  blue  befunden hat. Oder aber die `depiction` wird zu  green  und das Level bleibt bei 1, sofern sich der `FlagPost` in Zustand  green/blue  befunden hat.
    - mit `type`=""danger"" wird in das `level`= 1  mit `depiction`= green  gewechselt, sofern sich das `FlagPost` zuvor im Zustand  yellow ,  doubleYellow ,  doubleYellow/[SC]  oder  red  befunden hat.
- `String toString()` soll einen `String` nach folgendem Schema zurückgeben. Ob du dafür die `depiction` mit der vorgegebenen Hilfsmethode färbst oder nicht, bleibt dir überlassen. Die Tests akzeptieren beides. **Achte auf die doppelten Leerzeichen um ""flag post"", ""waving"" herum und vor ""doing""**. Sie dienen der Formatierung für bessere Lesbarkeit auf der Konsole: 
    - falls `level`= 0 : "" Signal⎵post⎵ \<`postNumber`> ⎵of⎵type⎵⎵flag⎵post⎵⎵is⎵in⎵level⎵ \<`level`> ⎵and⎵is⎵⎵doing⎵nothing "".
    - sonst: "" Signal⎵post⎵ \<`postNumber`> ⎵of⎵type⎵⎵flag⎵post⎵⎵is⎵in⎵level⎵ \<`level`> ⎵and⎵is⎵⎵waving⎵⎵ \<`depiction`>"".

Auch hier gibt es wieder die `level` und die zugehörigen `depiction`s mit kleinen Unterschieden bei Level 1, 3 und 5 (die relevanten Informationen stehen vor den ""-----""):
- Level  0 : `depiction`="""". ----- Die Strecke ist an diesem `FlagPost` frei, die Raceuine können Gas geben.
- Level  1 : `depiction`="" green "" oder "" blue "" oder "" green/blue "". ----- Die Strecke ist hier entweder nach einem Hindernis/einer Störung wieder freigegeben (green) oder ein langsamer Raceuin wird zum Überholen lassen aufgefordert (blue), oder sogar beides gleichzeitig (green/blue).
- Level  2 : `depiction`="" yellow "". ----- Hier befindet sich auf der Strecke ein Hindernis/eine Störung und die Raceuine müssen vorsichtig vorbeifahren und dürfen nicht überholen.
- Level  3 : `depiction`="" doubleYellow "" oder "" doubleYellow/[SC] "". Dabei kann ""[SC]"" nicht ohne ""doubleYellow"" sein und hat Vorrang vor nur ""doubleYellow"". ----- Eine noch strengere Form von Level 2. Die Raceuine müssen zusätzlich vom Gas gehen (doubleYellow). Wenn zudem das Safety Car rausgeschickt wird, so müssen alle Raceuine diesem langsam hinterher fahren (doubleYellow/[SC]).
- Level  4 : `depiction`="" red "". ----- Das Hindernis/die Störung ist so groß, dass das Rennen unterbrochen werden muss.
- Level  5 : `depiction`="" green/yellow/red/blue "". ----- Das Ende des Rennens ist erreicht, der Sieger steht fest.

 

###Klasse `FinishPost`:
Die Klasse `FinishPost` erbt von `FlagPost`, da sie bis auf 2 kleine Unterschiede genau die gleiche Funktionalität wie `FlagPost` hat. Folgende Methoden musst du überschreiben:
- falls `type`= end , soll `boolean up(String type)` die `depiction` zu "" chequered "" ändern und das Level zu  5  ändern. In allen anderen Fällen verhät sich die Methode wie in der Oberklasse `FlagPost`.
- `String toString()` soll einen `String` nach folgendem Schema zurückgeben. Ob du dafür die `depiction` mit der vorgegebenen Hilfsmethode färbst oder nicht, bleibt dir überlassen. Die Tests akzeptieren beides. **Achte auf die doppelten Leerzeichen um ""waving"" herum und vor ""doing""**. Sie dienen der Formatierung:
    - falls `level`= 0 : "" Signal⎵post⎵ \<`postNumber`> ⎵of⎵type⎵finish⎵post⎵is⎵in⎵level⎵ \<`level`> ⎵and⎵is⎵⎵doing⎵nothing "".
    - sonst: "" Signal⎵post⎵ \<`postNumber`> ⎵of⎵type⎵finish⎵post⎵is⎵in⎵level⎵ \<`level`> ⎵and⎵is⎵⎵waving⎵⎵ \<`depiction`>"".

 

###Klasse `Track`:
Nun wollen wir unsere ganzen `SignalPosts` in der Klasse `Track` steuern. Ein neues `Track`-Objekt initialisiert ein `SignalPost[]` mit der übergebenen Größe nach folgendem Schema: Beginnend mit der ersten Stelle im Array wird alle 3 Stellen der `SignalPost` als `LightPanel` initialisiert, sonst als `FlagPost`. Die `postNumber`s sollen bei 0 beginnen und aufsteigend zählen.
Der allerletzte `SignalPost` wird aber als `FinishPost` initialisiert. Sollte der Parameter des Konstruktors <=  0  sein, soll das Array mit 10 initialisiert werden. Implementiere auch hier Getter und Setter. Im weiteren Verlauf können aber beliebige Anordnungen von `SignalPost`s durch den Setter gegeben werden. Es ist aber garantiert, dass das Array nicht `null` ist, dass es keinen `SignalPost` gibt, der `null` ist und dass das Array auch nicht `leer` ist.
 
 Beispiel zum Initialisieren 
```
Array wird mit 10 initialisiert.
SignalPost (kurz SP) 0 ist ein LightPanel
SP 1 ist ein FlagPost
SP 2 ist ein FlagPost
SP 3 ist ein LightPanel
SP 4 ist ein FlagPost
SP 5 ist ein FlagPost
SP 6 ist ein LightPanel
SP 7 ist ein FlagPost
SP 8 ist ein FlagPost
SP 9 ist ein FinishPost
```
 
Zudem soll die Klasse folgende Methoden implementieren. Du kannst davon ausgehen, dass die übergebenen String-Parameter != `null` sind und die int-Parameter innerhalb der Array-Grenzen sind ( >= 0 und < posts.length):
- `void setAll(String type, boolean up)`: Wenn `up`= true  ist, soll auf allen `SignalPost`s `up(type)` mit dem übergebenen `type` aufgerufen werden, ansonsten `down(type)`.
- `void setRange(String type, boolean up, int start, int end)`: Wenn `up`= true  ist, soll auf allen `SignalPost`s im Bereich zwischen `start` und `end` (beide inklusive) `up(type)` mit dem übergebenen `type` aufgerufen werden, ansonsten `down(type)`. Beachte, dass `start` auch nach `end` liegen kann. In dem Fall beginnt man bei `start`, geht bis zum Ende vom Array und fängt dann vorne wieder an, bis man bei `end` angekommen ist (Ein Kreis hat keinen Anfang und kein Ende).
- `void createHazardAt(int start, int end)` ruft auf allen `SignalPost`s im Bereich zwischen `start` und `end` (beide inklusive) `up(""yellow"")` auf. Auf dem `SignalPost` an der Stelle `end` soll allerdings direkt `up(""green"")` aufgerufen werden. Die Regeln für die Grenzen aus `setRange()` gelten hier auch.
- `void removeHazardAt(int start, int end)` ruft auf allen `SignalPost`s im Bereich zwischen `start` und `end` (beide inklusive) `down(""danger"")` auf. Auch hier gelten dieselben Bedingungen für die Grenzen.
- `void createLappedCarAt(int post)` ruft auf dem an `post` liegenden `SignalPost` sowie auf den 3 folgenden `SignalPost`s `up(""blue"")` auf. Falls das am Ende vom Array passiert ... nun ja, mittlerweile solltest du wissen, was zu tun ist.
- `void removeLappedCarAt(int post)` ruft auf dem an `post` liegenden `SignalPost` sowie auf den 3 folgenden `SignalPost`s `down(""blue"")` auf.
- `void printStatus()` printet nach folgendem Schema einen String auf die Konsole: Für jeden `SignalPost` im Array werden die Strings der einzelnen `SignalPost`s getrennt durch "" \n "" konkateniert und geprintet (den Zeilenumbruch auch am Ende einfügen, sodass eine Leerzeile entsteht, wenn man printStatus mehrmals aufrufen würde. Im Beispiel unten ist das nochmal gut zu sehen). Ob die Strings durch die Hilfsmethode gefärbt sind oder nicht, bleibt dir überlassen.

##Aufgabe:
[task][Structure]( 174458 , 174455 , 174447 , 174482 )
Implementiere das gegebene UML-Diagramm.

[task][SignalPost]( 174439 ) 
Implementiere die Klasse `SignalPost`, wie oben beschrieben. Hier wird nur die `toString()` getestet, da Konstruktor, Getter und Setter bei Structure untergebracht sind und die anderen beiden Methoden durch die Unterklassen implementiert werden.

[task][LightPanel]( 174431 , 174484 , 174432 )
Implementiere die Klasse `LightPanel` wie oben beschrieben.

[task][FlagPost]( 174441 , 174481 , 174464 )
Implementiere die Klasse `FlagPost` wie oben beschrieben.

[task][FinishPost]( 174460 , 174456 , 174450 )
Implementiere die Klasse `FinishPost` wie oben beschrieben.

[task][Track]( 174443 , 174449 , 174434 , 174480 , 174462 )
Implementiere die Klasse `Track` wie oben beschrieben.

 
 Beispiel aus der main-Methode 
```
Signal post 0 of type light panel is in level 0 and is switched off
Signal post 1 of type  flag post  is in level 0 and is  doing nothing
Signal post 2 of type  flag post  is in level 0 and is  doing nothing
Signal post 3 of type light panel is in level 0 and is switched off
Signal post 4 of type  flag post  is in level 0 and is  doing nothing
Signal post 5 of type  flag post  is in level 0 and is  doing nothing
Signal post 6 of type light panel is in level 0 and is switched off
Signal post 7 of type  flag post  is in level 0 and is  doing nothing
Signal post 8 of type  flag post  is in level 0 and is  doing nothing
Signal post 9 of type finish post is in level 0 and is  doing nothing

Signal post 0 of type light panel is in level 0 and is switched off
Signal post 1 of type  flag post  is in level 0 and is  doing nothing
Signal post 2 of type  flag post  is in level 1 and is  waving  blue
Signal post 3 of type light panel is in level 1 and is blinking blue
Signal post 4 of type  flag post  is in level 1 and is  waving  blue
Signal post 5 of type  flag post  is in level 1 and is  waving  blue
Signal post 6 of type light panel is in level 0 and is switched off
Signal post 7 of type  flag post  is in level 0 and is  doing nothing
Signal post 8 of type  flag post  is in level 0 and is  doing nothing
Signal post 9 of type finish post is in level 0 and is  doing nothing

Signal post 0 of type light panel is in level 0 and is switched off
Signal post 1 of type  flag post  is in level 0 and is  doing nothing
Signal post 2 of type  flag post  is in level 0 and is  doing nothing
Signal post 3 of type light panel is in level 0 and is switched off
Signal post 4 of type  flag post  is in level 0 and is  doing nothing
Signal post 5 of type  flag post  is in level 0 and is  doing nothing
Signal post 6 of type light panel is in level 0 and is switched off
Signal post 7 of type  flag post  is in level 0 and is  doing nothing
Signal post 8 of type  flag post  is in level 0 and is  doing nothing
Signal post 9 of type finish post is in level 0 and is  doing nothing

Signal post 0 of type light panel is in level 0 and is switched off
Signal post 1 of type  flag post  is in level 0 and is  doing nothing
Signal post 2 of type  flag post  is in level 0 and is  doing nothing
Signal post 3 of type light panel is in level 2 and is blinking yellow
Signal post 4 of type  flag post  is in level 2 and is  waving  yellow
Signal post 5 of type  flag post  is in level 2 and is  waving  yellow
Signal post 6 of type light panel is in level 1 and is blinking green
Signal post 7 of type  flag post  is in level 0 and is  doing nothing
Signal post 8 of type  flag post  is in level 0 and is  doing nothing
Signal post 9 of type finish post is in level 0 and is  doing nothing

Signal post 0 of type light panel is in level 0 and is switched off
Signal post 1 of type  flag post  is in level 0 and is  doing nothing
Signal post 2 of type  flag post  is in level 0 and is  doing nothing
Signal post 3 of type light panel is in level 1 and is blinking green
Signal post 4 of type  flag post  is in level 1 and is  waving  green
Signal post 5 of type  flag post  is in level 1 and is  waving  green
Signal post 6 of type light panel is in level 1 and is blinking green
Signal post 7 of type  flag post  is in level 0 and is  doing nothing
Signal post 8 of type  flag post  is in level 0 and is  doing nothing
Signal post 9 of type finish post is in level 0 and is  doing nothing

Signal post 0 of type light panel is in level 3 and is blinking [SC]
Signal post 1 of type  flag post  is in level 3 and is  waving  doubleYellow/[SC]
Signal post 2 of type  flag post  is in level 3 and is  waving  doubleYellow/[SC]
Signal post 3 of type light panel is in level 3 and is blinking [SC]
Signal post 4 of type  flag post  is in level 3 and is  waving  doubleYellow/[SC]
Signal post 5 of type  flag post  is in level 3 and is  waving  doubleYellow/[SC]
Signal post 6 of type light panel is in level 3 and is blinking [SC]
Signal post 7 of type  flag post  is in level 3 and is  waving  doubleYellow/[SC]
Signal post 8 of type  flag post  is in level 3 and is  waving  doubleYellow/[SC]
Signal post 9 of type finish post is in level 3 and is  waving  doubleYellow/[SC]

Signal post 0 of type light panel is in level 0 and is switched off
Signal post 1 of type  flag post  is in level 0 and is  doing nothing
Signal post 2 of type  flag post  is in level 0 and is  doing nothing
Signal post 3 of type light panel is in level 0 and is switched off
Signal post 4 of type  flag post  is in level 0 and is  doing nothing
Signal post 5 of type  flag post  is in level 0 and is  doing nothing
Signal post 6 of type light panel is in level 0 and is switched off
Signal post 7 of type  flag post  is in level 0 and is  doing nothing
Signal post 8 of type  flag post  is in level 0 and is  doing nothing
Signal post 9 of type finish post is in level 0 and is  doing nothing

Signal post 0 of type light panel is in level 5 and is blinking yellow
Signal post 1 of type  flag post  is in level 5 and is  waving  green/yellow/red/blue
Signal post 2 of type  flag post  is in level 5 and is  waving  green/yellow/red/blue
Signal post 3 of type light panel is in level 5 and is blinking yellow
Signal post 4 of type  flag post  is in level 5 and is  waving  green/yellow/red/blue
Signal post 5 of type  flag post  is in level 5 and is  waving  green/yellow/red/blue
Signal post 6 of type light panel is in level 5 and is blinking yellow
Signal post 7 of type  flag post  is in level 5 and is  waving  green/yellow/red/blue
Signal post 8 of type  flag post  is in level 5 and is  waving  green/yellow/red/blue
Signal post 9 of type finish post is in level 5 and is  waving  chequered


```
 
 
 Der selbe Output mit Farbe 
![image.png](/api/core/files/markdown/Markdown_2022-11-21T17-04-10-581_e66d0513.png)
 
 

(Quelle: Ein Pinguinküken, das lieber zeichnet anstatt PGdP zu machen)



#FAQ
### Q: Was bedeutet der Fehler `Attribute [postnumber] of class pgdp.security.SignalPost was not called on a matching object.`?
A: Das heißt, dass du in deiner Klassenstruktur aufgrund von Vererbung einen Fehler bei dem Attribut hast.

### Q: Was soll passieren, wenn bei createLappedCarAt das Array zu klein ist?
A: Du kannst davon ausgehen, dass das Array immer groß genug sein wird.

### Q: Was bedeutet der Fehler `Post is not abstract and does not override abstract method toString() in SignalPost` und woher kommt die Klasse Post?
A: Die Klasse Post kommt aus den Tests, um die toString von SignalPost zu testen. Wenn die toString in der Klasse SignalPost allerdings abstract ist, kommt es zu diesem Buildfail, da sie nicht abstract sein soll.

### Q: Was bedeutet der Fehler `""SignalPost at position 0 has the wrong type. ==> expected:   but was:  "".`?
A: Der Fehler liegt im Konstruktor der Klasse Track. Da wird das Array nicht richtig initialisiert, da an der Stelle 0 der falsche Typ SignalPost ist.

### Q: Wie entsteht der Buildfail aufgrund der ominösen Klasse LightPanelOracle?
A: Die Klasse LightPanelOracle (sowie andere Klassen, die Oracle im Namen haben) kommen von den Tests. Sie erben von eurer Klasse SignalPost. Wenn da also irgendwelche Signaturen nicht mit den geforderten Signaturen übereinstimmen (siehe UML-Klassendiagramm), dann funktioniert die Vererbung nicht und es entsteht ein Buildfail."
299,Praktikum: Grundlagen der Programmierung WS23/24,12261,W07H04 - Pingu Sim,"# Pingu Sim

Den Lehruinen ist aufgefallen, dass die teils sehr komplexen Zusammenhänge einzelner Populationen in einem gemeinsamen Lebensraum bisher nur rein theoretisch besprochen wurden. Dabei wäre ein einfaches Interaktives Beispiel sehr viel einfacher. Deshalb haben sie die Gameunine beauftragt, ein kleines Spiel zu entwickeln. Während einer der Gameuine an der graphischen Oberfläche arbeitet, sollst du schon mal die Logik implementieren.

In dieser Aufgabe sollst du ein Programm schreiben, das die Entwicklung von Populationen verschiedener Lebewesen (genauer: Pflanzen, Hamstern, Pinguinen und Wölfen) sehr vereinfacht simuliert. Dafür werden die Lebewesen mit Hilfe von Interfaces und Vererbung modelliert.

### 1. Allgemeines

1. Alle Lebewesen nehmen eine Zelle auf dem Spielfeld ein. Es gibt, wie gesagt, Pflanzen, Hamster, Pinguine und Wölfe.
2. Das Spielfeld ist als eindimensionales Array gespeichert. Der Ursprung ist oben links.
3. Alle geforderten Methoden und Attribute sind auch wie gefordert zu implementieren und werden auch einzeln bewertet.
4. `width` und `height` sind immer $$>0$$. Außerdem haben die den Methoden `tick()`, `place()`, `eat()` und `move()` mitgegebenen Arrays immer genau die Größe $$\text{width}\cdot\text{height}$$ und die übergebenen Parameter `x` und `y` dieser Methoden beschreiben immer valide Positionen im Array.
5. `null` repräsentiert eine leere `Cell` im Spielfeld. Dementsprechend kann `null` als `Cell` Parameter gegeben werden und soll entsprechend behandelt werden. Insbesondere ist eine leere Zelle beispielsweise kein `Pingu`.
6. Wenn gefordert ist, die Zugehörigkeit zu einer gewissen Klasse zu prüfen, soll das nicht auf der Implementierung dieser Klasse oder der Existenz anderer Basieren. Zum Beispiel sollen dafür nicht Instanzen von `CellSymbol` verglichen werden. Sie soll auch funktionieren, wenn zu einem späteren Zeitpunkt weitere `Cell` Untertypen hinzugefügt werden, obwohl diese nicht Teil der Aufgabe sind.
7. Es ist immer genau festgeschrieben, wann `RandomGenerator` benutzt werden soll, und wie das Ergebnis Interpretiert werden soll. Daher soll mit gleichem Seed auch immer das Ergebnis gleich sein.
8. Abstrakte Methoden werden mit einem ~ davor markiert.
9. Die Public Tests decken nur die Struktur, also das Vorhandensein der richtigen Klassen, Methoden und Attributen an den richtigen Stellen mit den richtigen Signaturen ab. Funktionalität wird erst nach der Deadline getestet bzw. musst du selbst testen.
### 2. Übersicht

Deine Aufgabe ist es, dieses Spiel zu vervollständigen.
Dazu hier eine kurze Übersicht über die einzelnen Komponenten des Spiels.
1. `SimConfig` enthält einige globale Variablen, mit denen einzelnen Aspekte des Spiels eingestellt werden können. Hier musst und sollst du nichts ändern.
2. `Simulation` enthält das Spielfeld als ein eindimensionales Array. Die `tick()` Methode führt Operationen auf allen `Cell`s auf dem Spielfeld aus. Der Parameter `cells` von `tick()` repräsentiert dabei das alte Feld, der Parameter `newCells` das neue.
3. `Cell` wird von allen Zellen implementiert und definiert gemeinsame Operationen. Außerdem ist die `place()` Methode schon implementiert. Sie wird benutzt, um neue Zellen auf dem Spielfeld zu platzieren und kann natürlich als Inspiration benutzt werden. Wenn `place()` auf einem Objekt, dessen Typ `Cell` implementiert, aufgerufen wird, wird dieses zufällig auf dem übergebenen Spielfeld `newCells` platziert. Wenn dabei eine Zelle zum Setzen gewählt wird, die schon belegt ist, wird das Objekt nicht platziert und `false` zurückgegeben. Wenn eine Zelle gewählt wird, die noch frei ist, wird das Objekt in diese platziert und `true` zurückgegeben. An `Cell` musst du nichts mehr ändern.
4. `Plant` ist eine Zelle die sich nicht bewegen kann aber dafür passiv Nahrung generiert. Sie wird von Hamstern und Pinguinen als Nahrung benutzt.
5. `MovingCell` ist eine Oberklasse, die gemeinsames Verhalten der sich bewegenden Zellen implementiert. Dazu gehört das Essen anderer Zellen, Bewegung, Vermehrung und anders als bei `Plant` eine kontinuierliche Abnahme der *""gespeicherten""* Nahrung. Sie können also anders als Pflanzen verhungern.
6. `Hamster` sind effizienter im Essen von `Plant`, dafür können sie von `Wolf` gegessen werden.
7. `Pingu` sind weniger effizient im Essen von `Plant`, würden also von `Hamster` verdrängt werden. Dafür sind sie nicht auf dem Speiseplan eines `Wolf`.
8. `Wolf` können keine `Plant` Zellen essen, dafür `Hamster`.
9. `CellSymbol` wird benutzt, um das Symbol zu definieren, das für die Zelle gerendert werden soll. Auch an dieser Klasse musst du nichts ändern.
10. `RandomGenerator` gibt eine Zufallszahl zurück. Bei gleichem Seed und gleicher Reihenfolge der Aufrufe sind auch die zurückgegebenen Zufallszahlen identisch. Auch an dieser Klasse musst du nichts ändern.

### 3. Das Interface `Cell`

Wir deklarieren nun ein paar Prototypen, die wir später in den Unterklassen implementieren.

1. `~getSymbol(): CellSymbol`
    gibt das Symbol für diese Zelle an.
2. `~priority(): int`
    wird beim Erstellen neuer Zellen benötigt.
3. `~tick(Cell[] cells, Cell[] newCells,int width,int height,int x,int y)`
    wird in jeder Runde der Simulation aufgerufen. Hier wird in den Unterklassen implementiert, wie diese sich jeweils in einem Tick verhalten (Vermehrung, Bewegung, Wachstum etc.).

Das Interface `Cell` ist bereits vollständig implementiert. Hier musst du nichts mehr tun.

@startuml

interface Cell {
   174911 )>~+getSymbol(): CellSymbol 
 174916 )>~+priority(): int 
 174934 )>~+tick(Cell[] cells, Cell[] newCells,int width,int height,int x,int y) 
}

hide empty fields
hide empty methods

@enduml

### 4. [task][Plant]( 174520 , 174564 , 174502 , 174929 , 174912 , 174935 , 174542 )

`Plant` implementiert `Cell`.

1. [task][growth:long]( 174502 )
    Dieses Feld speichert den aktuellen Wachstumswert dieser Zelle. Sie wird beim Erstellen einer neuen `Plant` auf 0 initialisiert.

2. [task][getSymbol(): CellSymbol]( 174929 )
    Diese Methode gibt lediglich `CellSymbol.PLANT` zurück.

3. [task][priority(): int]( 174912 )
    Diese Methode gibt lediglich `0` zurück.

4. [task][tick(...)]( 174935 )
    Diese Methode führt die folgenden Schritte aus: 
    1. Setze die mit `x` und `y` beschriebene Position in `newCells` auf `this` (eine `Plant` bewegt sich nicht).
    2. Addiere einen Integer zwischen `SimConfig.plantMinGrowth` und `SimConfig.plantMaxGrowth` (exklusiv) zu `growth`. Nutze dafür `RandomGenerator`. (Das simuliert ein zufälliges Wachstum der `Plant`.)
    3. Wenn danach `growth`$$\geq$$`SimConfig.plantReproductionCost` gilt, platziere eine neue `Plant` Zelle in `newCells` mit `Cell.place()`. Falls das erfolgreich war (Rückgabewert von `place()` war `true`), ziehe die `plantReproductionCost` von `growth` ab. Wiederhole Schritt 3 solange, bis entweder `growth` nicht groß genug ist, um weiter zu machen oder `place()` einmal nicht erfolgreich war.

@startuml

interface Cell {
   174911 )>~+getSymbol(): CellSymbol 
 174916 )>~+priority(): int 
 174934 )>~+tick(Cell[] cells, Cell[] newCells,int width,int height,int x,int y) 
}
class Plant {
   174502 )>growth: long 
 174929 )>+getSymbol(): CellSymbol 
 174912 )>+priority(): int 
 174935 )>+tick(Cell[] cells, Cell[] newCells,int width,int height,int x,int y) 
}

Cell <|-down- Plant #testsColor( 174542 )
hide empty fields
hide empty methods

@enduml

### 5. [task][MovingCell]( 174537 , 174565 , 174495 , 174926 , 174922 , 174917 , 174905 , 174915 , 174913 , 174936 , 174932 , 174933 , 174897 , 174496 )
`MovingCell` ist eine abstrakte Klasse, die `Cell` implementiert. Sie ist Oberklasse aller `Cell`s, die sich bewegen können, also für uns hier von `Hamster`, `Pingu` und `Wolf`.

1. [task][food: long]( 174495 )
    Dieses Feld speichert die aktuelle Nahrung dieser Zelle. Sie wird auf den Rückgabewert von `initialFood()` initialisiert.

Die Methoden 2. bis 7. sind abstrakt und werden erst in den Unterklassen implementiert.

2. [task][~canEat(Cell other): boolean]( 174926 )
    Diese abstrakte Methode sagt aus, ob die übergebene Zelle von der Zelle, auf der die Methode aufgerufen wird, gegessen werden kann.

3. [task][~foodConsumption(): int]( 174922 )
    Diese abstrakte Methode gibt die Menge an Nahrung zurück, die diese Zelle bei jedem Aufruf von `tick` verbraucht.

4. [task][~consumedFood(): int]( 174917 )
    Diese abstrakte Methode gibt die Menge an Nahrung zurück, die diese Zelle bei dem Verspeisen einer anderen Zelle bekommt.

5. [task][~reproductionCost(): int]( 174905 )
    Diese abstrakte Methode gibt die Menge an Nahrung zurück, die diese Zelle für die Vermehrung benötigt.

6. [task][~initialFood(): int]( 174915 )
    Diese abstrakte Methode gibt die Menge an Nahrung zurück, die jede Zelle diesen Types hat, direkt nach dem sie sich vermehrt hat.

7. [task][~getNew(): Cell]( 174913 )
    Diese abstrakte Methode gibt eine neue Instanz der nicht abstrakten Subklasse zurück.

Die Methoden 8. bis 11. erhalten bereits in `MovingCell` eine Implementierung.

8. [task][move(Cell cells, Cell newCells,int width, int height, int x, int y)]( 174936 )
    Diese Methode bewegt diese `Cell`. Dabei werden die folgenden Schritte ausgeführt:
    1. Wähle ein zufälliges Feld im 3 mal 3 Feld mit der Zelle im Mittelpunkt. Nutze dafür *eine* Zahl aus dem `RandomGenerator` Die Felder sind dabei wie folgt durchnummeriert.  
        ![moves.svg](/api/core/files/markdown/Markdown_2022-11-28T12-39-54-397_059d1a2f.svg)

    2. Wenn dieses Feld innerhalb des Spielfelds ist und die Position in `cells` *und* `newCells` frei ist, wird in `newCells` an dieser Position diese Zelle eingetragen und die bisherige Position in `cells` als frei markiert. Falls nicht, wird die Zelle an der bisherigen Position in `newCells` gespeichert (in anderen Worten: dann konnte sich die `Cell` nicht bewegen).

9. [task][eat(...)]( 174932 ) 
    Diese Methode isst umliegende Zellen. Dabei wird wie folgt vorgegangen: Für jede Zelle innerhalb des 3 mal 3 Quadrats um diese Zelle innerhalb der Grenzen des Spielfelds:
    1. Überprüfe mit `canEat` ob die Zelle an dieser Position in `cells` gegessen werden kann. Falls ja:
    2. Setze diese Position der gegessenen `Cell` in `newCells` auf `null`
    3. Addiere den Rückgabewert von `consumedFood()` zu `food`

Diese 2 `Cell` Arrays `cells` und `newCells` sind notwendig, um nicht Zellen, die weiter oben oder links sind, zu bevorzugen.

10. [task][tick(...)]( 174933 )
    Diese Methode implementiert alle Aktionen von sich bewegenden Zellen außer Essen:
    1. Wenn `food`$$\geq$$`reproductiponCost()` gilt, wird mit `getNew()` eine neue Zelle erstellt und mit `Cell.place()` platziert. `place()` bekommt dafür die Position der Elternzelle übergeben. 
    2. Wenn die neue Zelle erfolgreich auf dem Spielfeld platziert wurde, wird `food` auf `initialFood()` gesetzt, sonst geschieht nichts.
    3. `foodConsumption()` wird von `food` abgezogen (das simuliert die Basis-Food-Kosten einer `MovingCell` unabhängig von Vermehrung).
    4. Wenn `food` nicht negativ ist, wird `move()` aufgerufen.
  
11. [task][priority(): int]( 174897 )
    Gibt 1 zurück.

@startuml

interface Cell {
   174911 )>~+getSymbol(): CellSymbol 
 174916 )>~+priority(): int 
 174934 )>~+tick(Cell[] cells, Cell[] newCells,int width,int height,int x,int y) 
}
abstract class MovingCell {
   174495 )>food: long 
 174926 )>~+canEat(Cell other): boolean 
 174922 )>~+foodConsumption(): int 
 174917 )>~+consumedFood(): int 
 174905 )>~+reproductionCost(): int 
 174915 )>~+initialFood(): int 
 174913 )>~+getNew(): Cell 
 174936 )>+move(Cell[] cells, Cell[] newCells, int width, int height, int x, int y) 
 174932 )>+eat(Cell[] cells, Cell[] newCells, int width, int height, int x, int y) 
 174933 )>+tick(Cell[] cells, Cell[] newCells,int width,int height,int x,int y) 
 174897 )>+priority(): int 
}

Cell <|-down- MovingCell #testsColor( 174496 )
hide empty fields
hide empty methods

@enduml

### 6. [task][Hamster, Pingu & Wolf]( 174538 , 174541 , 174510 , 174551 , 174591 , 174560 , 174896 , 174910 , 174923 , 174931 , 174895 , 174902 , 174894 , 174921 , 174899 , 174906 , 174907 , 174924 , 174898 , 174918 , 174903 , 174900 , 174909 , 174908 , 174901 , 174914 , 174928 , 174539 , 174516 , 174547 )
Diese Klassen sind sich sehr ähnlich, daher werden sie zusammen erklärt. Hier werden nun die abstrakten Methoden aus Unterpunkten 2. bis 7. von `MovingCell` für die drei Unterklassen individuell implementiert.

1. [task][getSymbol(): CellSymbol]( 174896 , 174910 , 174923 )
    Hier wird die entsprechende Konstante aus `CellSymbol` zurückgegeben. Für `Hamster` wäre das beispielsweise `CellSymbol.HAMSTER`. 

2. [task][canEat(Cell other): boolean]( 174931 , 174895 , 174902 )
    Gibt zurück, ob diese Zelle gegessen werden kann. `Hamster` und `Pingu` essen `Plant` und `Wolf` isst `Hamster`.

3. [task][foodConsumption(): int]( 174894 , 174921 , 174899 )
    Gibt die entsprechende Variable aus `SimConfig` aus.

4. [task][consumedFood(): int]( 174906 , 174907 , 174924 )
    Gibt die entsprechende Variable aus `SimConfig` aus.

5. [task][reproductionCost(): int]( 174898 , 174918 , 174903 )
    Gibt die entsprechende Variable aus `SimConfig` aus.

6. [task][initialFood(): int]( 174900 , 174909 , 174908 )
    Gibt die entsprechende Variable aus `SimConfig` aus.

7. [task][getNew(): Cell]( 174901 , 174914 , 174928 )
    Erstellt eine neue Instanz dieser Klasse und gibt sie zurück.

@startuml

interface Cell {
   174911 )>~+getSymbol(): CellSymbol 
 174916 )>~+priority(): int 
 174934 )>~+tick(Cell[] cells, Cell[] newCells,int width,int height,int x,int y) 
}

abstract class MovingCell {
   174495 )>food: long 
 174926 )>~+canEat(Cell other): boolean 
 174922 )>~+foodConsumption(): int 
 174917 )>~+consumedFood(): int 
 174905 )>~+reproductionCost(): int 
 174915 )>~+initialFood(): int 
 174913 )>~+getNew(): Cell 
 174936 )>+move(Cell[] cells, Cell[] newCells, int width, int height, int x, int y) 
 174932 )>+eat(Cell[] cells, Cell[] newCells, int width, int height, int x, int y) 
 174933 )>+tick(Cell[] cells, Cell[] newCells,int width,int height,int x,int y) 
 174897 )>+priority(): int 
}


class Hamster {
   174896 )>+getSymbol(): CellSymbol 
 174931 )>+canEat(Cell other): boolean 
 174894 )>+foodConsumption(): int 
 174906 )>+consumedFood(): int 
 174898 )>+reproductionCost(): int 
 174900 )>+initialFood(): int 
 174901 )>+getNew(): Cell 
}

class Pingu {
   174910 )>+getSymbol(): CellSymbol 
 174895 )>+canEat(Cell other): boolean 
 174921 )>+foodConsumption(): int 
 174907 )>+consumedFood(): int 
 174918 )>+reproductionCost(): int 
 174909 )>+initialFood(): int 
 174914 )>+getNew(): Cell 

}

class Wolf{
   174923 )>+getSymbol(): CellSymbol 
 174902 )>+canEat(Cell other): boolean 
 174899 )>+foodConsumption(): int 
 174924 )>+consumedFood(): int 
 174903 )>+reproductionCost(): int 
 174908 )>+initialFood(): int 
 174928 )>+getNew(): Cell 
}

Cell <|.down. MovingCell #testsColor( 174496 )
MovingCell <|-down- Hamster #testsColor( 174539 )
MovingCell <|-down- Pingu #testsColor( 174516 )
MovingCell <|-down- Wolf #testsColor( 174547 )
hide empty fields
hide empty methods

@enduml

### 7. [task][Simulation]( 174540 , 174595 , 174526 , 174919 )

1. [task][tick()]( 174919 )
    Diese Methode wird für jeden Schritt der Simulation einmal aufgerufen. 
    Dabei führt sie die folgenden Schritte aus:
    1. Erstelle eine Kopie (z.B. `copyOfCells`) von `cells`.
    2. Rufe auf jeder Instanz von `MovingCell` in `cells` `eat()` auf. Dabei ist die Kopie `copyOfCells` der Parameter `newCells`.
    3. Nun ist in `copyOfCells` das aktuelle Spielfeld enthalten, nachdem alle `Cell`s gegessen haben. Fülle also das ursprüngliche Array `this.cells` mit lauter `null`-Einträgen (ohne dessen Größe zu ändern).
    4. Führe auf jeder Cell aus dem in 1. erstellten neuen Array `tick` aus. Der Parameter `cells` ist dabei jetzt `copyOfCells` und der Parameter `newCells` das aus `this.cells`. Damit steht nun das Endergebnis von `tick()` wieder in `this.cells`.

@startuml

class Simulation {
   174526 )>cells: Cell[] 
 174919 )>+tick() 
}

hide empty fields
hide empty methods

@enduml"
299,Praktikum: Grundlagen der Programmierung WS23/24,12277,W08P01 - Generischer Stack,"# Der Stack

Schon in Woche 02 hast du einen Stack kennengelernt. Stacks eignen sich, um Objekte abzulegen, welche man in umgekehrter Reihenfolge wieder aufnehmen möchte. Das Prinzip nennt sich ""Last In First Out"" kurz LIFO. Der Stack unterstützt im Grunde zwei wichtige Operationen:

[task][Push]( 175258 )
  Mit dieser Operation werden Elemente in den Stack geschrieben. Wenn ein Element mit `push()` auf den Stack geschrieben wird, findet man dies an oberster Stelle des Stacks. (gleicher Test wie pop)
    
[task][Pop]( 175258 )
  Dies ist die Gegenoperation zu `push()`. Mit `pop()` wird das oberste Element vom Stack entfernt und zurück gegeben. Falls es keine Elemente mehr auf dem Stack gibt, soll `null` zurück gegeben werden. (gleicher Test wie push)
    
    
Wie ein Stack funktioniert, könnt ihr [hier](https://www.cs.usfca.edu/~galles/visualization/StackArray.html) ausprobieren.
    
# Generics

Pinguin Larry hat auch schon von Stacks gehört, jedoch reicht ihm ein Stack, wie ihn ein Prozessor hat, nicht aus. Da Larry verschiedenste Werte - von Zahlen über Strings bis hin zu Fischstatistiken - speichern möchte, braucht er eine allgemeinere Lösung. Larry möchte es sich offen halten, in Zukunft neue Datentypen zu verwenden. Wenn jetzt einfach für jeden Datentyp ein eigener Stack programmiert werden würde, wäre das mit unverhältnismäßig viel Aufwand verbunden. Deswegen bittet dich Larry, einen Stack mit Generics zu implementieren.

Du darfst zur Implementierung Listen benutzen, alles andere aus `java.util` ist verboten.

[task][Beipiel]( 175256 )

Im Folgenden ist beispielhaft die Priorisierung der Hausaufgaben eines Erstsemesters dargestellt:
```
Stack  stack = new Stack<>();

        stack.push(""PGDP W07P04"");
        System.out.println(""Pushed: "" + ""PGDP W07P04"");
        stack.push(""PGDP W07H01"");
        System.out.println(""Pushed: "" + ""PGDP W07H01"");
        stack.push(""PGDP W07H02"");
        System.out.println(""Pushed: "" + ""PGDP W07H02"");
        stack.push(""DS HA"");
        System.out.println(""Pushed: "" + ""DS HA"");

        System.out.println(""Popped: "" + stack.pop());
        System.out.println(""Popped: "" + stack.pop());

        stack.push(""ERA HA"");
        System.out.println(""Pushed: "" + ""ERA HA"");

        System.out.println(""Popped: "" + stack.pop());
        System.out.println(""Popped: "" + stack.pop());

        stack.push(""PGDP W07P01"");
        System.out.println(""Pushed: "" + ""PGDP W07P01"");
        stack.push(""PGDP W07P02"");
        System.out.println(""Pushed: "" + ""PGDP W07P02"");

        System.out.println(""Popped: "" + stack.pop());
        System.out.println(""Popped: "" + stack.pop());

        stack.push(""PGDP W07P03"");
        System.out.println(""Pushed: "" + ""PGDP W07P03"");

        System.out.println(""Popped: "" + stack.pop());
        System.out.println(""Popped: "" + stack.pop());
```
 
 So sollte das Ergebnis aussehen. (zum Ausklappen hier klicken) 
```
Pushed: PGDP W07P04
Pushed: PGDP W07H01
Pushed: PGDP W07H02
Pushed: DS HA
Popped: DS HA
Popped: PGDP W07H02
Pushed: ERA HA
Popped: ERA HA
Popped: PGDP W07H01
Pushed: PGDP W07P01
Pushed: PGDP W07P02
Popped: PGDP W07P02
Popped: PGDP W07P01
Pushed: PGDP W07P03
Popped: PGDP W07P03
Popped: PGDP W07P04
```
 

[task][Weitere Tests]( 175263 , 175262 , 175260 , 175261 )
Weitere Tests."
299,Praktikum: Grundlagen der Programmierung WS23/24,12278,W08P02 - Object Counting,"# Object Counting

In dieser Aufgabe geht es darum mit Hilfe der JavaDoc herauszufinden, welche Bibliotheksfunktionen rund um `Collection` und `HashMap` am besten geeignet sind, um die verschiedenen Teilaufgaben schnell zu lösen. Dafür erhälst du eine Klasse `CountingObjectsCollection`, die Objekte eines generischen Typs in einer `HashMap` speichert (""Keys""), zusammen mit der Anzahl, wie oft jedes Element in die Klasse eingefügt wurde (""Values"").

- [task][Warmup]()
Als erstes sollst du selbstständig die Java 17 Documentations-Website von `HashMap` im Internet finden. (Hierfür gibt es natürlich keinen Test, aber dafür - trotzdem **nicht schummeln!!!** - eine [Lösung](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/HashMap.html))

- [task][Konstruktor]( 175281 )
Die Klasse `CountingObjectsCollection` hat bereits einen parameterlosen Konstruktor, in dem `map` leer initialisiert wird. Ein zweiter Konstruktor mit Parameter ist bereits vorgegeben. Hier soll `map` mit allen key-value-pairs, die die `map` des übergebenen Objekts enthält, initialisiert werden. Dies sollte mit nur einer Zeile Code machbar sein.

- [task][insert]( 175278 )
Die Methode `insert` registriert das übergebene Objekt. Falls es noch nicht eingefügt wurde, soll es auf `1` gemappt werden, andernfalls soll der aktuell gemappte Wert um eins erhöht werden. Auch dies ist in nur einer Zeile machbar.

- [task][getObjectCount]( 175285 )
Die Methode `getObjectCount` gibt die Anzahl der `insert`s des übergebenen Objekts zurück (also den gemappten Wert). Falls das Objekt noch nicht eingefügt wurde, soll 0 zurückgegeben werden. Diese Aufgabe ist wieder in nur einer Zeile machbar.

- [task][getTotalObjectCount]( 175279 )
Die Methode `getTotalObjectCount` gibt die Gesamtzahl der eingefügten Objekte zurück. Diese Aufgabe kannst du (noch) nicht in einer Zeile lösen, du solltest aber eine `for-each`-Schleife verwenden.

- [task][getKeyList]( 175283 )
Die Methode `getKeyList` soll eine Liste mit allen in der Map enthaltenen Keys zurückgeben. Die zurückgegebene List soll modifizierbar sein und hat sonst keine weiteren Einschränkungen. Diese Teilaufgabe ist wieder in einer Zeile lösbar.

- [task][equals]( 175280 )
Das Template enthält bereits große Teile der `equals`-Methode. Es fehlt nur noch die Überprüfung, ob beide `map`s äquivalent sind. Dafür sollst du aber **nicht** die `equals`-Implementierung von `java.util.Map` verwenden. Zwei `HashMaps` sind äquivalent, wenn beide genau die selben key-value-Paare beinhalten (und keine anderen).

Hinweise:
- ""In einer Zeile machbar"" ist in java natürlich fast alles, wenn man gängige Formatierungsregeln missachtet. In dieser Aufgabe bezieht sich die Aussage aber auf bekannte Codestyle Formatierung.
- Die automatischen Tests testen nur grobe Funktionalität, aber nicht umfassend auf edge cases oder das Einhalten der Zeilen-""Beschränkungen""."
299,Praktikum: Grundlagen der Programmierung WS23/24,12279,W08P03 - Iteration,"# Iteration

Die Fakultät für Pingu Algorithms and Datastructures der PUM möchte ihre bestehende Listen und Baum Implementierung je um einen [Iterator](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Iterator.html) erweitern. 

[task][List Iterator]( 175299 , 175293 )
Zuerst wird dabei ein Iterator für die einfach verkettete Liste hinzugefügt. Der Iterator soll ein Element enthalten und dieses in `next()` mit dem nächsten ersetzen.
Bei `null` ist der Iterator am Ende angekommen. Wie im Javadoc beschrieben sollte `next()` auf einem leeren Iterator eine `NoSuchElementException` werfen, dies wurde aber noch nicht behandelt und wird vom Test nicht überprüft.

1. Implementiere `List.Iterator` mit einem public Konstructor der ein `List.Element` als Parameter erwartet. Die Klasse soll [java.util.Iterator](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Iterator.html) implementieren.
2. Implementiere [Iterable](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html) für `List`. Die hierfür benötigte Methode ist bereits mit einem Dummy-Wert vorgegeben.

[task][Tree Iterator]( 175295 , 175297 )
Nun soll noch ein Iterator für den Binärbaum implementiert werden. Der Iterator soll für jedes Element zuerst durch den linken Teilbaum (`left`) iterierieren, danach der Inhalt des entrechenden Knotens zurückgegeben und schließlich durch den rechten Teilbaum (`right`) iterieren.

3. Implemtiere `Tree.Iterator` mit einem public Konstruktor der ein `Tree.Element` als Parameter erwartet. Die Klasse soll `java.util.Iterator` implementieren. Wenn als Parameter `null` übergeben wird, ist der Iterator leer.
4. Implementiere `Iterable` für `Tree`. Auch hier ist die leere Methode bereits vorgegeben.

[task][2D List Iterarator]( 179043 )
Zuletzt soll ein Iterator für eine 2D-Liste geschrieben werden, also eine Liste, die wiederum Listen enthält. Der Iterator soll die inneren Listen in der Reihenfolge durchlaufen, wie sie in der äußeren Liste abgespeichert sind. Die inneren Listen sollen auch von vorne nach hinten durchlaufen werden. Du kannst und sollst dafür den Iterator für die normalen Listen wiederverwenden.

5. Implementiere nun einen Iterator für 2D-Listen, in der Klasse `List2D.List2DIterator`. Auch hier muss die Klasse `List2D` `Iterable` korrekt implementieren."
299,Praktikum: Grundlagen der Programmierung WS23/24,12324,W07H01 - Aufraeumaktion,"# Aufräumaktion bei der PUM

Die Forschuine der PUM aus der Fakultät für Eisforschung haben ganz oft verfrorene Flügel, und konnten in den letzten Jahren die Duplikaten in ihren Daten nicht immer löschen. Wir wollen ihnen nun dabei helfen.

Sie haben ihren Code im Package `pgdp.oopwarmup.foreigncode`. Diesen Code dürfen wir nicht ändern.

## Serialisierung
Da wir den Fremdcode nicht ändern können, müssen wir ihn anderweitig erweitern. Definiere dafür die Klassen `SerializablePerson` und `SerializableBook` im Package `pgdp.oopwarmup.ourcode`. Sie sollen jeweils `Person` und `Book` extenden, und das Interface `Serializable` implementieren.

**Hinweis:** Pass auf dass du überall mit `pgdp.oopwarmup.pingutils.Serializable` arbeitest, und nicht `java.io.Serializable`. Dafür die Imports in den Klassen beachten. 
**Hinweis:** Keyword `extends` vor `implements`.

1. [task][Implementiere Klassen]( 176350 , 176358 , 176366 , 176356 , 176363 )
Erstelle im Paket `pgdp.oopwarmup.ourcode` die Klassen `SerializableBook` und `SerializablePerson`. Sie sollen Konstruktoren mit identischen Signaturen wie ihre Elternklassen haben, und per `super` diese aufrufen.

2. [task][Implementiere Serialisierung]( 176369 )
Implementiere die Methode `public String serialize()` in den Klassen `SerializableBook` und `SerializablePerson`.
Dabei soll die Methode für `SerializableBook` "" SerializableBook,⎵ \ ,⎵ \ "" als `String` zurückgeben, und für `SerializablePerson` "" SerializablePerson,⎵ \ ,⎵ \ "".

```java
new SerializableBook(""My Title"", ""My Author Name"").serialize();
// Gibt ""SerializableBook, My Title, My Author Name"" zurück.
new SerializablePerson(""Name Surname"", 20).serialize();
// Gibt ""SerializablePerson, Name Surname, 20"" zurück.
```

Bevor du mit der nächsten Teilaufgabe weitermachst, stelle sicher dass die Serialisierung korrekt funktioniert. Als weitere Übung kannst du erst mal alles lokal überprüfen, bevor du deinen Code in Artemis abgibst.

## Duplikate aussortieren
Die Serialisierung stellt nun alle Objekte so dar, dass nur gleiche Objekte die gleiche Serialisierung haben. Also können wir jetzt duplikate aussortieren.

3. [task][Implementiere distinct]( 176368 )
Implementiere die Methode `public static Serializable[] distinct(Serializable[] data)` in der Klasse `DataNormalizer`, die die Duplikate enterfernt.
Du kannst dich dabei an der Lösung aus der Woche 3 mit den Arrays orientieren. Die Typen der verwendeten Methoden sollen nicht mehr `int` sein, sondern `Serializable`.
Außerdem sollst du nicht die Objektreferenzen vergleichen, sondern ihre Serialisierung mittels `equals`. Ansonsten ändert sich nichts an der Lösung.

## Alles zusammen
4. [task][Implementiere distinct]( 176368 )
Implementiere jetzt die Methode `public static void printDistinct(Serializable[] things)` in der Klasse `Main`. Sie bekommt ein Serializable Array und soll die serialisierte Objekte ohne Duplikate ausgeben mit `System.out.println`.

**Input**
```java
new Serializable[] {new SerializableBook(""My Title"", ""Author Name""), new SerializablePerson(""Name Surname"", 20), new SerializableBook(""My Title"", ""Author Name"")}
```
**Output**
```text
SerializableBook, My Title, Author Name
SerializablePerson, Name Surname, 20
```"
299,Praktikum: Grundlagen der Programmierung WS23/24,12353,W09P01 - Passwortpruefung,"# Passwortprüfung

In dieser Aufgabe wollen wir einige Exceptions implementieren,
die bei der Überprüfung der Gültigkeit eines Passworts verwendet werden können.
Dafür soll die folgende Klassenhierarchie umgesetzt werden, wobei [Exception](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html)
eine Klasse aus der Java-Standardbibliothek ist.

@startuml
class Exception{}
class IllegalCharException{
    -used: char
}
class NotEnoughException{
    -should: int
    -is: int
}
class NotEnoughLetterException{}
class NotEnoughUpperCaseException{}
class NotEnoughLowerCaseException{}
class NotLongEnoughException{}

IllegalCharException -up-|> Exception
NotEnoughException -up-|> Exception
NotEnoughLetterException -up-|> NotEnoughException
NotEnoughUpperCaseException -up-|> NotEnoughLetterException
NotEnoughLowerCaseException -up-|> NotEnoughLetterException
NotLongEnoughException -up-|> NotEnoughException
hide empty fields
hide empty methods
@enduml

Für ein Passwort können die folgenden Mindestanforderungen gestellt werden, die bei
Missachtung zu einer entsprechenden Exception führen:
- Das Passwort muss eine Mindestlänge haben, andernfalls wird eine `NotLongEnoughException` geworfen.
- Das Passwort muss eine Mindestanzahl an Großbuchstaben enthalten, andernfalls wird eine
`NotEnoughUpperCaseException` geworfen.
- Das Passwort muss eine Mindestanzahl an Kleinbuchstaben enthalten, andernfalls wird eine
`NotEnoughLowerCaseException` geworfen.
- Das Passwort darf bestimmte Sonderzeichen **nicht** enthalten, andernfalls wird eine
`IllegalCharException` geworfen.

Wir betrachten hier alle Zeichen zwischen `'a'` und `'z'` als Kleinbuchstaben, alle Zeichen zwischen `'A'`
und `'Z'` als Großbuchstaben, alle Zeichen zwischen `'0'` und `'9'` als Ziffern und alles andere als Sonderzeichen.

Für die konkrete Implementierung gelten folgende Anforderungen:
- Die Klasse `NotEnoughException` hat die beiden Parameter `is` und `should`.
Diese repräsentieren die Mindestanzahl Zeichen einer bestimmten Kategorie,
die ein Passwort enthalten muss und die echt kleinere Anzahl an Zeichen, die das Passwort,
das die Exception auslöst, hat. Die Variablen sollen im Konstruktor `public NotEnoughException(int should, int is)` gesetzt werden.
Sollte `is` nicht echt kleiner sein als `should`, soll eine [IllegalArgumentException](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/IllegalArgumentException.html)
geworfen werden.
- Jede Unterklasse von `NotEnoughException` soll im Konstruktor die gleichen Parameter entgegennehmen und dann
entsprechend die Attribute der Oberklasse setzen.
- Jede Klasse soll ihre `toString()` Methode überschreiben und dabei eine Fehlermeldung zurückgeben, die alle Informationen enthält (also insbesondere alle bekannten Attributwerte). Nutzen Sie bei der Klasse IllegalCharException die mitgelieferte Methode escapeSpecial.

Implementiere dann die Methode `checkFormat(String pwd)` in `Password`, die das übergebene Passwort nach den
im Konstruktor übergebenen Kriterien prüft und ggf. die entsprechende Exception wirft.

Zuletzt soll noch die `checkFormatWithLogging(String pwd)` Methode implementiert werden, die `checkFormat(pwd)` aufruft, evtl. geworfene hier implementierte Exceptions abfängt, den Rückgabewert von `toString()` auf die Konsole schreibt und wieder wirft.

Vermeide Codeduplikate so gut wie möglich durch Verwendung von `super`.
Alle vorgegebenen Membervariablen müssen als `final` deklariert werden."
299,Praktikum: Grundlagen der Programmierung WS23/24,12354,W09P02 - Funktionale Pingus,"# Funktionale Pingus

Die Pinguine haben in letzter Zeit öfters von funktionaler Programmierung gehört, und möchten das jetzt auch selbst ausprobieren. Besonders sind sie an sogenannten *higher order functions* interessiert. Das sind Funktionen, die andere Methoden als Parameter nehmen. Sie können vielseitig eingesetzt werden und sehr mächtig sein. Zu ihrer Freude finden sie in der Standardbibliothek das [`java.util.function` Package](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/package-summary.html), das Interfaces für verschiedene Arten von Funktionen bietet. 

Zuerst wollen sie eine `map` Funktion schreiben, die eine Instanz des [`Function `](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Function.html) Interfaces und eine `List ` als Parameter nimmt, und eine `List ` zurückgibt.
1. Implementiere die Methode `map` in `Functions`. Die mitgegebene Funktion soll auf jedem Element der gegebenen Liste aufgerufen werden und das Ergebnis in unveränderter Reihenfolge in eine neue Liste gepeichert werden.

Nun wollen die Pinguine ihre neue Methode natürlich auch testen. Dazu wollen sie eine Methode schreiben, die jedes Element in einer `List ` quadriert. 
Die Pinguine haben von einem besonderen Syntax zum einfacheren Implementierung solcher Interfaces mit nur einer Methode namens Lambda gehört. Nutze so ein Lambda in deiner Lösung.

2. Implementiere die statische Methode `square` in `Functions` und nutze dafür `map`.

Als nächstes wollen sie noch eine generische Methode schreiben, die jedes Element einer beliebigen `List ` in ihre String Repräsentation umwandelt.

3. Implementiere die statische Methode `toString` in `Functions` und nutze dafür `map`.

Den Pinguinen hat das bisher schon sehr gut gefallen, also wollen sie auch mal eines der anderen Interfaces dieses packages ausprobieren: [`Predicate`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Predicate.html). Dieses Interface stellt eine Funktion bereit, die einen generischen Typen als Parameter nimmt und ein `boolean` zurückgibt.

4. Implementiere `filter`.Dabei sollen in der Ergebnis Liste nur die Elemente sein, für die das Predicate true zurückgibt.

5. Implementiere `filterAny` mit `filter`. Es soll nur die Elemente behalten, bei denen eines der beiden `Predicate`s `true` zurükgibt. Nutze dafür die `default` Methoden des Predicate Interface.

6. Implementiere `multiple2or7`. Nur `Integer`s die durch `2` oder `7` teilbar sind, sollen in der Ergebnis Liste enthalten sein. Nutze dafür `filterAny`."
299,Praktikum: Grundlagen der Programmierung WS23/24,12384,W08H01 - Simple Generics,"# Simple Generics

Die Forschuine der PUM arbeiten aktuell an ihrer digitalen Datenverarbeitung. Dazu brauchen sie noch einige Utility Funktionen, die ihnen das Leben leichter machen sollen. Da sie sich mit Generics noch nicht so wohl fühlen wie du, unterstützt du sie bei der Entwicklung.

*Hinweis:* in der ganzen Aufgabe kannst du davon ausgehen, dass die getesteten Inputs niemals `null` sind. 
*Tipp:* Nutze dein Wissen über Collections aus der Vorlesung/Zentralübung. Auch ein Blick in die Java Docs kann sehr hilfreich sein. Was nicht verboten ist, ist erlaubt. 🐧

- [task][toString]( 179167 )
Um beim Debuggen eine einheitliche Repräsentation für Collections zu haben, benötigen die Pingine die Methode `toString(Collection)`. Der Methode wird eine `Collection` übergeben. Zurückgegeben werden soll ein `String` um diese Collection zu visualisieren. Dabei muss sich an folgedes Muster gehalten werden:
1. die `Collection` selbst wird durch zwei geschweifte Klammern dargestellt: "" { \ } "".
2. die Elemente der `Collection` sollen zwischen den geschweiften Klammern stehen und jeweils von folgendem String getrennt werden: "" ,⎵ "".
3. die Reihenfolge, in der die Elemente im String dargestellt werden sollen, soll der Reihenfolge entsprechen, die durch den `Iterator` der gegebenen `Collection` diktiert wird.
4. Hier ein Beispiel für die `List  l = Arrays.asList(1, 2, 3, 5, 4)`: "" {1,⎵2,⎵3,⎵5,⎵4} "" 

-  [task][toIntArray]( 179171 )
`Collection`s können sehr einfach zu Arrays gecastet werden. Wollen wir jedoch aus einer `Collection ` ein primitives `int[]` casten, ist das ohne Weiteres nicht direkt machbar. Implementiere die Methode `toIntArray(Collection )`, die das passende `int` Array zurückgeben soll. Das Array soll die passende Länge haben (nicht länger sein als die `Collection`). Die Reihenfolge der Elemente im Array soll der Reihenfolge entsprechen, die durch den `Iterator` der gegebenen `Collection` diktiert wird.

-  [task][specialSort]( 179194 )
Die Methode `specialSort` soll ein sortiertes Array der gegebenen `Collection` zurückgeben. Ein Array eines Generics zu erstellen, ist in Java nicht so einfach möglich (probiere es am besten einmal aus und überlege dir warum das nicht geht). Um dennoch solch ein Array erstellen zu können, findest du im Template direkt über der Methode dieser Teilaufgabe die bereits implementierte Methode `generateGenericArray(Class  clazz, int length)`. Benutze diese Methode um ein Array mit passender Länge zu erstellen. Die gegebene `Collection` soll anschließend in diesem Array gespeichert und vor der Rückgabe mit dem übergebenen `Comparator` sortiert werden.

-  [task][intersection]( 179193 )
Der Methode wird ein Array aus `Collections` übergeben. Zurückgegeben werden soll eine Collection, die alle Elemente enthält, die in jeder der gegebenen `Collection`s enthalten ist. Die gegebenen `Collection`s dürfen dabei nicht verändert werden. Für alle möglichen Eingaben soll eine echte/sinnvolle `Collection` (nicht `null`) zurückgeben werden. Was für eine konkrete Implementierung von `Collection` du hierbei für am sinnvollsten erachtest, sollst du dir selbst überlegen.

 
  Beispiel zu intersection 
```java
intersection({}) = {}
intersection({{1, 2, 3, 4, 5}, {1, 2, 3}, {1, 2, 4, 5}}) = {1, 2}
```
 

-  [task][getValues]( 179175 )
Leider arbeiten die Pinguine immer wieder mit modifizierten `Map`s, deren `values()`-Methode kaputt gehen kann. Die Methode `getValues(Map)` soll diese ersetzen. Sie soll ein `Set`, bestehend aus allen Values, die in der gegebenen `Map` gespeichert werden, zurückgeben. Da die `Map` modifiziert sein könnte, darfst du `Map.values()` dazu nicht benutzen. Alle anderen Methoden der `Map` dürfen verwendet werden.

Viel Erfolg!"
299,Praktikum: Grundlagen der Programmierung WS23/24,12385,W08H02 - Effiziente Aufgabenverwaltung,"# Effiziente Aufgabenverwaltung

Die PUM ist eine weltweit agierende Institution. Daher lässt es sich auch nicht vermeiden, dass einige Aufgaben mehrfach ausgeführt werden müssen. Aber auch Pinguine müssen Strom sparen. Deshalb haben sich die Forschuine dazu entschieden, ein System aufzubauen, mit dem sich mehrfache Berechnungen (und das mehrfache Abspeichern dieser) vermeiden lassen. Das System haben sie schon durchgeplant, jedoch haben sie wichtige Deadlines für eine anstehende Konferenz in Südgeorgien. Da Pinguine nicht fliegen können, müssen sie den ganzen Weg schwimmen, müssen also rechtzeitig aufbrechen und alles vorher fertig haben. Deswegen liegt es wieder an dir, die Implementierung zu übernehmen.

## Hinweise
- Bei dieser Aufgabe gibt es keine Public Behavior Tests. Lediglich die Anwesenheit von geforderten Attributen und Methoden, deren Rümpfe nicht vorgegeben sind, werden öffentlich getestet.
- Es gibt keine Einschränkungen bzgl. Bibliotheken, die verwendet werden dürfen. Ebenso dürfen private Hilfsmethoden, Attribute und Klassen verwendet werden.
- Beispiele zu erwarteten Verhaltensweisen findest du in den `main`-Methoden des Templates oder am Ende der Aufgabenstellung.

## Aufgabe

In dieser Aufgabe geht es darum, ein System für `Task`s aufzubauen, dass ähnlich wie Javas `String`-Pool funktioniert (siehe z.B. [hier](https://www.javatpoint.com/string-pool-in-java)). Dabei soll jeweils nur eine äquivalente `Task` gleichzeitig gespeichert werden. Um dies zu erreichen, werden `Task`s in einem `TaskPool` gespeichert und verwaltet und über eine `TaskFactory` initialisiert.

[task][TaskFunction]( 179249 )
Die Klasse `TaskFunction` dient als Wrapper für eine Java [Function](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Function.html), die mit einer eindeutigen `ID` identifiziert werden kann. Da du `FunctionalInterfaces` vielleicht noch nicht kennst, haben dir die Forschuine eine Auswahl an `Function`s in der utility Klasse `FunctionLib` mitgegeben, damit du mit diesen deine Implementierung testen kannst, ohne dir Gedanken über die Deklaration machen zu müssen. Evaluieren kannst du eine `Function` mit `function.apply(input)`. 
`TaskFunction` hat folgende Anforderungen:
- Attribute `int ID` und `Function  function`, die jeweils `private` und `final` sein sollen.
- Einen Konstruktor, der als Parameter eine `Function ` erwartet und das Attribut mit dem entsprechenden Wert initialisiert (du darfst davon ausgehen, dass nie `null` übergeben wird). Außerdem soll `ID` mit einer fortlaufenden ID initialisiert werden, beginnend bei `0`. Das heißt, dass bei jedem Programmstart die erste Instanz die ID 0 erhalten soll, die zweite ID 1, die dritte ID 2 und so weiter. (Dem Konstruktor kannst du zum Testen einfach einen konstanten Member aus `FunctionLib` mitgeben)
- Eine Methode `public R apply(T)`, die `function` auf den übergebenen Parameter anwendet und das Ergebnis zurück gibt.
- Überschriebene Methoden `hashCode` und `equals`, die jeweils nur von `ID` abhängig sein sollen. Die Anforderungen dieser Methoden kannst du in der [JavaDoc](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html) nachlesen. Zwei `TaskFunction`s sind genau dann gleich, wenn sie dieselbe `ID` haben. **Tipp:** du darfst `Objects.hash()` verwenden.

[task][Task]( 179243 )
Die Klasse `Task` dient zur Speicherung einer einzelnen Aufgabe bestehend aus Eingabe, Berechnungsfunktion und Ergebnis. Dabei ist wichtig, dass das Ergebnis nur bei Bedarf (""lazy"") berechnet wird und auch nur einmal (also genau dann, wenn zum ersten Mal auf den Wert zugegriffen wird, wir wollen ja Rechenpower sparen). Du darfst davon ausgehen, dass das Ergebnis nie `null` sein wird. Die Klasse hat folgende Anforderungen:
- Attribute `T input`, `R result` und `TaskFunction  taskFunction`, alle sollen `private` sein und Getter haben. Zusätzlich sollen `input` und `taskFunction` `final` sein.
- Einen `protected` Konstruktor, der initiale Werte für `input` und `taskFunction` (in dieser Reihenfolge) erwartet und die Attribute entsprechend initialisiert. Das `result` soll noch **nicht** berechnet werden.
- Methoden `hashCode` und `equals`, die jeweils genau von beiden finalen Attributen abhängig sind. Zwei `Task`s sind also genau dann gleich, wenn sowohl `input`, als auch die `taskFunction` gleich sind.

[task][TaskPool]()
Die Klasse `TaskPool` dient als Speicherort der `Task`s und sorgt dafür, dass jede Aufgabe nur einmal gespeichert werden kann. Es gibt **keinen** Public Test für diese Teilaufgabe!  
Die Klasse hat folgende Anforderungen:
- Einen parameterlosen `protected` Konstruktor.
- Eine Methode `Task  insert(Task )`, die die übergebene Aufgabe in den Pool aufnimmt, falls sie noch nicht vorhanden ist, und wieder zurückgibt. Falls schon eine äquivalente Aufgabe enthalten ist, so wird das äquivalente Objekt zurückgegeben. In diesem Fall passiert mit dem Parameter nichts weiter.
- Eine Methode `Task  getByValue(T, TaskFunction )`, die den Pool nach einer `Task` mit zu den Parametern äquivalenten `input` und `taskFunction` Attributen durchsucht und dieses zurückgibt. Sollte keine solche `Task` gefunden werden, so soll `null` zurückgegeben werden.
- **Hinweis:** In was für einer Datenstruktur du die `Task`s verwaltest, bleibt dir überlassen. (Tipp: eine [HashMap](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/HashMap.html) könnte hilfreich sein).

[task][TaskFactory]( 179251 )
Die Klasse `TaskFactory` dient dazu, neue `Task`s zu erstellen oder auf diese zuzugreifen, ohne dass dabei Duplikate entstehen. Dafür hat die Klasse folgende Anforderungen:
- Ein `private final` Attribut `TaskPool  pool`, in dem die `Task`s gespeichert werden können.
- Einen parameterlosen Konstruktor.
- Eine Methode `Task  create(T, TaskFunction )`, die eine `Task` mit den entsprechenden Attributwerten zurückgibt. Falls eine äquivalente `Task` bereits im Pool enthalten ist, so soll diese zurückgegeben werden. Andernfalls (und nur dann) wird erst eine neue erstellt, in den Pool aufgenommen und dann zurückgegeben.
- Eine Methode `Task  intern(Task )`, die die Pool-Repräsentation der übergebenen `Task` zurückgibt. Falls eine äquivalente `Task` bereits vorhanden ist, so wird diese zurückgegeben, andernfalls wird die übergebene `Task` in den Pool aufgenommen.


## Beispiele

In diesem Abschnitt findest du einige Beispiele zur Verwendung der einzelnen Klassen. Diese findest du auch in den main-Methoden des Templates.

 
 1. TaskFunction  
```java
public static void main(String[] args) {
		TaskFunction  f1 = new TaskFunction<>(FunctionLib.SQUARE);
		TaskFunction  f2 = new TaskFunction<>(FunctionLib.SUM_OF_HALFS);
		TaskFunction  f3 = new TaskFunction<>(FunctionLib.SQUARE);
		System.out.println(f1.equals(f2)); // false
		System.out.println(f1.equals(f3)); // false
		System.out.println(f1.equals(f1)); // true
		System.out.println(f1.apply(2));   // 4
}
```
f1 und f3 berechnen zwar dasselbe, jedoch haben sie verschiedene IDs und werden nicht als gleich angesehen.
 
 
 2. Task  
```java
public static void main(String[] args) {
		TaskFunction  f1 = new TaskFunction<>(FunctionLib.INC);
		TaskFunction  f2 = new TaskFunction<>(FunctionLib.INC);
		Task  t1 = new Task<>(1, f1);
		Task  t2 = new Task<>(1, f1);
		Task  t3 = new Task<>(1, f2);

		System.out.println(t1.equals(t2)); // true
		System.out.println(t1.equals(t3)); // false

		System.out.println(t1.getResult()); // 2
}
```
Auch hier gilt: t1 und t3 berechnen dasselbe, aber mit unterschiedlichen TaskFunctions. Daher sind sie nicht gleich. t1 und t2 hingegen sind gleich, da sie sowohl input, als auch die Funktion teilen. Hätte t2 eine andere Zahl als input, wäre das anders.
 
 
 3. TaskPool  
 ```java
public static void main(String[] args) {
		TaskFunction  f = new TaskFunction<>(FunctionLib.SQUARE);
		TaskPool  tp = new TaskPool<>();

		System.out.println(tp.getByValue(1, f)); // null

		Task  t1 = new Task<>(1, f);
		Task  t2 = new Task<>(1, f);
		System.out.println(t1 == tp.insert(t1)); // true
		System.out.println(t1 == tp.insert(t2)); // true
		System.out.println(t1 == tp.getByValue(1, f)); // true
}
```
t1 und t2 sind equivalen/gleich, daher wird beim 2. insert auch t2 nicht in den Pool aufgenommen, sondern t1 zurückgegeben.  
Die Kombination aus 1 und f würde eine Task äquivalent zu t1 ergeben, daher gibt getByValue auch t1 zurück.
 
 
 4. TaskFactory  
```java
public static void main(String[] args) {
		TaskFactory  tf = new TaskFactory<>();
		TaskFunction  f = new TaskFunction<>(FunctionLib.SQUARE);
		Task  t1 = tf.create(5, f);
		Task  t2 = new Task<>(5, f);
		System.out.println(t1 == tf.create(5, f)); // true
		System.out.println(t1 == tf.intern(t2)); //true
}
```
Das 2. create mit 5 und f würde eine zu t1 äquivalente Task erzeugen und gibt daher direkt t1 zurück. Auch t2 ist äquivalent zu t2, weshalb intern t1 zurück gibt. 
Anmerkung: normalerweise würde man t2 natürlich nicht so verwenden (sonst hätten wir uns die Implementierung dieser Aufgabe auch sparen können). Stattdessen würde man eher `Task  t2 = tf.intern(new Task<>(5,f));` verwenden oder direkt auf `create` zurückgreifen."
299,Praktikum: Grundlagen der Programmierung WS23/24,12386,W08H03 - Baumiteration,"# Baumiteration

Die Forschuine der PUM führen aktuell ein kleines Projekt an der Pinguin Schule durch. Für das Projekt muss als nächstes ein Iterator für eine vorgegebene Baum-Datenstruktur geschrieben werden. Leider ist das Forschungsbudget mal wieder ausgeschöpft, weshalb die Forschuine dich als günstige studentische Arbeitskraft mit der Implementierung der Lösung für die Aufgabe engagieren.


## Datenstruktur

Im Template erhältst du die Klassen `QuarternaryNode` und `QuarternarySearchTree`, die zusammen einen Suchbaum mit drei Elementen pro Knoten bilden. In einem Suchbaum gilt folgende Invariante: die Elemente des linken Teilbaums sind alle kleiner als das Element in der Wurzel und die Elemente im rechten Teilbaum größer. Gleich große Elemente befinden sich auch im rechten Teilbaum, falls es welche gibt (dies sollte für diese Aufgabe aber irrelevant sein). Die Besonderheit am gegebenen Suchbaum ist allerdings, dass pro Knoten nicht nur ein, sondern gleich drei Elemente enthalten sind. Dadurch hat jeder Knoten auch mehr als zwei Unterbäume, nämlich insgesamt vier. Für die vorherige Invariante bedeutet dies folgendes: Elemente Teilbaum 0 <= 0. Element <= Elemente Teilbaum 1 <= 1. Element <= Elemente Teilbaum 2 <= 2. Element <= Elemente 3. Teilbaum. Verständlicher wird das durch die unten abgebildeten Beispiele.

Das Template enthält bereits alle benötigten Methoden, um mit dem Baum arbeiten zu können (du wirst aber nicht alle zur Bearbeitung der Aufgabe benötigen, einige sind nur der Vollständigkeit halber enthalten):
- Konstruktor zum Erstellen eines leeren Baumes.
- Methode `insert` zum Einfügen eines neuen Elements.
- `size` für die Anzahl der gespeicherten Elemente und `height` für die Höhe des Baums.
- `contains` zur Überprüfung, ob ein Element enthalten ist.
- `toString` für eine geklammerte String-Repräsentation des Baums (funktioniert für alle Bäume).
- `toGraphvizString` für eine Graphviz Repräsentation des Baums, die z.B. über [diese Website](https://dreampuf.github.io/GraphvizOnline/) zu einer Grafik wie unten umgewandelt werden kann (funktioniert nur richtig für Bäume ohne Duplikate, die natürlich trotzdem vorkommen können).
- Alle Getter und Setter.
- `QuarternaryNode.nodeSize` gibt an, wie viele Elemente bereits im Knoten gespeichert werden.

## Aufgabe

Deine Aufgabe ist es nun, die Methode `iterator()` des Interface [Iterable](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html) in `QuarternarySearchTree` zu implementieren (die leere Methode ist bereits im Template vorgegeben). Iteratoren kennst du bereits aus W08P04. Der Iterator soll die im Baum enthaltenen Elemente in ihrer natürlichen Ordnung (""inorder"", siehe Beispiel für Binärbaum [hier](https://en.wikipedia.org/wiki/Tree_traversal#In-order,_LNR)) iterieren. Für die beiden Beispiele mit `Integer`n unten bedeutet dies in numerisch aufsteigender Reihenfolge.

Dabei gelten folgende Einschränkungen:
- Die vorgegebenen Methoden dürfen nicht verändert werden (außer zum selbstständigen Testen).
- Die Implementierung des Iterators muss iterativ umgesetzt werden. Rekursion darf in dieser Aufgabe **NICHT** genutzt werden.
- Private Hilfsmethoden, -Attribute und Klassen sind erlaubt. Wie immer gilt Vorsicht bei der Nutzung statischer Attribute, da diese zwischen Tests nicht zurückgesetzt werden.
- Du darfst davon ausgehen, dass der Baum während einer vollständigen Iteration mit dem Iterator nicht verändert wird.
- Der zurückgegebene `Iterator` muss explizit nur die Methoden `hasNext` und `next` unterstützen.
- Die Methode [next](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Iterator.html#next()) wirft unter bestimmten Umständen (wenn keine Elemente zum Iterieren mehr vorhanden sind) eine `NoSuchElementException`, wie du in der verlinkten JavaDoc nachlesen kannst. Da Exceptions aber erst nächste Woche drankommen, ist die entsprechende Codezeile bereits im Template als Kommentar enthalten und muss nur noch richtig in die Lösung eingebaut werden.
- Der Iterator muss für alle möglichen Bäume, die mit den gegebenen Methoden erstellt werden können, funktionieren.

## Beispiele

- [task][Kleines Beispiel]( 179296 )
Testet ein kleines Beispiel nur bestehend aus einer vollen Wurzel ([Graphviz Repräsentation](https://dreampuf.github.io/GraphvizOnline/#digraph%20G%20%7B%0D%0Asubgraph%20%22cluster_1_2_3_%22%20%7B%0D%0A%7Brank%3Dsame%20%221%22%20-%3E%20%222%22%20-%3E%20%223%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%7D)). Die Elemente sollten in numerisch aufsteigender Reihenfolge vom Iterator zurückgegeben werden (1, 2, 3).

![Kleines Beispiel](/api/core/files/markdown/Markdown_2022-11-07T15-56-48-951_1a65b1de.svg)

- [task][Größeres Beispiel]( 179300 )
Testet das Beispiel, das schon in der Template `main` enthalten ist und den folgenden Baum darstellt ([Graphviz Repräsentation](https://dreampuf.github.io/GraphvizOnline/#digraph%20G%20%7B%0D%0Asubgraph%20%22cluster_4_8_12_%22%20%7B%0D%0A%7Brank%3Dsame%20%224%22%20-%3E%20%228%22%20-%3E%20%2212%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0Asubgraph%20%22cluster_1_2_3_%22%20%7B%0D%0A%7Brank%3Dsame%20%221%22%20-%3E%20%222%22%20-%3E%20%223%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0A%224%22%20-%3E%20%222%22%0D%0A%0D%0Asubgraph%20%22cluster_5_6_7_%22%20%7B%0D%0A%7Brank%3Dsame%20%225%22%20-%3E%20%226%22%20-%3E%20%227%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0A%228%22%20-%3E%20%226%22%0D%0A%0D%0Asubgraph%20%22cluster_9_10_11_%22%20%7B%0D%0A%7Brank%3Dsame%20%229%22%20-%3E%20%2210%22%20-%3E%20%2211%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0A%2212%22%20-%3E%20%2210%22%0D%0A%0D%0Asubgraph%20%22cluster_13_14_15_%22%20%7B%0D%0A%7Brank%3Dsame%20%2213%22%20-%3E%20%2214%22%20-%3E%20%2215%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0A%2212%22%20-%3E%20%2214%22%0D%0A%7D)). Auch hier gilt die numerisch aufsteigende Reihenfolge (1, 2, 3, 4, 5 ..., 11, 12, 13, 14, 15)

![Größeres Beispiel](/api/core/files/markdown/Markdown_2022-11-07T15-55-05-406_b3ef7fdf.svg)"
299,Praktikum: Grundlagen der Programmierung WS23/24,12394,W08H04 - Knoten und Baeume,"# Bäume
In dieser Aufgabe lernst du den Liebling eines jeden Informatikers kennen: Bäume. Bäume sind hierarchische Datenstrukturen bestehend aus Knoten und Kanten. Da wir uns diese Woche mit Rekursion beschäftigen, bietet sich auch ein Blick auf die rekursive Definition an: *Ein Baum ist entweder leer oder besteht aus einer Wurzel mit null oder mehr Teilbäumen, von denen jeder auch ein Baum ist. Die Wurzel jedes Teilbaums ist durch eine Kante mit der Wurzel des übergeordneten Baums verbunden.* [Quelle]( https://de.wikipedia.org/wiki/Baum_%28Datenstruktur%29#Definitionen)

Knoten, die keine Nachfolger, auch Kinder genannt, haben, nennt man Blätter. Der einzige Knoten im Baum, der keinen Vorgänger bzw. Elternknoten hat, ist die Wurzel. Anders als bei echten Bäumen wachsen Bäume in der Informatik von oben nach unten. Ein weiterer wichtiger Begriff ist die Höhe des Baums. Die Höhe ist die Länge des längsten Pfades von der Wurzel zu einem Blatt, wobei je nach Definition die Anzahl der Knoten (wie in dieser Aufgabe) bzw. Kanten des Pfades verwendet wird. Im Gegensatz dazu bezeichnet die `size` des Baumes die Gesamtzahl der Knoten im ganzen Baum.

In dieser Aufgabe werden wir uns von einer Verallgemeinerung von Knoten schrittweise zu Binärbäumen vorarbeiten. Bei Binärbäumen hat jeder Knoten maximal zwei Nachfolger, weshalb man auch vom linken und rechten Kind eines Knoten spricht.

 


Es gibt verschiedene Möglichkeiten, die Knoten eines solchen Baumes in sinnvoller Weise zu besuchen. Das nennt man auch Traversierungsreihenfolge. Dabei unterscheidet man zwischen
-	In-Order: Zuerst wird der linke Teilbaum besucht, dann die Wurzel und zuletzt der rechte Teilbaum
-	Pre-Order: Zuerst wird die Wurzel besucht, dann der linke und zuletzt der rechte Teilbaum
-	Post-Order: Zuerst wird der linke Teilbaum, dann der rechte und zuletzt die Wurzel besucht
Um zwischen den Reihenfolgen zu unterscheiden, enthält das Template das Enum `Order`.

 


### Node
Der erste Schritt auf dem Weg zu deinem eigenen Baum ist die generische Klasse `Node`. Die Klasse ist bereits im Template enthalten und es müssen nur noch einige Methoden ergänzt werden.
- [task][getChild]( 179476 )
Die Methode soll das `i`-te Kind des Knoten zurückgeben oder `null` für ungültige Werte von `i`.
- [task][setChild]( 179480 )
Die Methode soll das `i`+te Kind auf die übergebenen `Node` setzen, falls der Wert von `i` gültig ist.
- [task][isLeaf]( 179486 )
Die Methode soll `true` zurückgeben, falls der Knoten ein Blatt ist.
- [task][height]( 179485 )
Die Methode soll die Höhe des Teilbaums zurückgeben, der an der aktuellen `Node` beginnt. Implementiere die Methode rekursiv!
- [task][size]( 179477 )
Die Methode soll die Anzahl der Knoten im aktuellen Teilbaum zurückgeben. Implementiere die Methode rekursiv!

### BinaryNode
Mit der Klasse `Node` können wir schon allgemeine Bäume darstellen. Da wir aber an Binärbäumen interessiert sind, spezialisieren wir die Knoten mit der Klasse `BinaryNode`.
- [task][BinaryNode Konstruktoren, getter und setter]( 179478 , 179475 )
`BinaryNode` soll zwei Konstruktoren enthalten:
    - Der erste Konstruktor soll nur ein `T` für den Wert des Knoten übernehmen. Gehe sicher, dass nach dem Aufruf genug Platz für genau zwei Kinder in `children` ist.
    - Der zweite Konstruktor soll zusätzlich `BinaryNodes` für das linke und rechte Kind übernehmen (in dieser Reihenfolge).
    - **Tipp:** Falls du die Schreibweise noch nicht kennst: Der Konstruktor von `Node` übernimmt eine variable Anzahl an `Node`-Parametern, die Komma-separiert übergeben werden können und automatisch in ein Array der entsprechenden Länge umgewandelt werden.
    - Außerdem sollen Getter und Setter für das linke und rechte Kind existieren (`get/setLeft`, `get/setRight`).
- [task][toList]( 179490 )
Die Methode soll eine Liste der Elemente des Baums (also der `value`-Werte, nicht der `Node`-Objekte!) zurückgeben, dessen Wurzel die aktuelle `BinaryNode` ist. Dabei soll die übergebene Traversierungsreihenfolge beachtet werden.
    - Ist der Baum leer, dann auch die Liste
    - Als Listenimplementierung soll `java.util.LinkedList` verwendet werden
    - Implementiere die Methode rekursiv!
- [task][toString]( 179492 )
Du sollst zwei `toString`-Methoden implementieren: die normale `Object.toString` ohne Parameter, welche eine String-Repräsentation in-order zurückgibt, und eine, die die Traversierungsreihenfolge wie die `toList`-Methode übernimmt und die String-Repräsentation entsprechend dieser Reihenfolge zurückgibt.
    - Ein Blatt soll folgenden String zurückgeben: "" [ \ ] ""
    - Für einen inneren Knoten (Knoten mit mindestens einem Kind) hängt die Ausgabe von der Traversierungsreihenfolge ab. Für in-order soll z.B. folgender String zurückgegeben werden: "" [ \ ,⎵ \ ,⎵ \ ] ""
    - Ein leerer Teilbaum wird durch "" - "" symbolisiert, ohne die Klammern.
    - Der Ausgabestring für eine `BinaryNode ` mit `value`=*3*, ohne linkes Kind und mit rechtem Kind mit `value`=*5*, welches ein Blatt ist, in post-order würde wie folgt aussehen: "" [-,⎵[5],⎵3] ""
    - Implementiere die Methode rekursiv!

### BSTNode
Jetzt kommen wir zu der `Node`-Klasse, die wir letztlich in dieser Aufgabe für den Baum nutzen wollen. Ziel ist nämlich ein binärer Suchbaum (BST), in dem folgende Invariante gilt: Für einen Knoten a mit linkem Kind b und rechtem Kind c gilt: b.value < a.value < c.value. Wir erlauben keine doppelten Werte. Diese Invariante erlaubt es uns, deutlich effizienter zu überprüfen, ob ein Element in der Datenstruktur vorhanden ist, als es z.B. für Listen der Fall ist.
- [task][BSTNode Konstruktoren]( 179482 )
`BSTNode` soll die gleichen Konstruktoren haben, wie `BinaryNode`. (Für die Kinder wird hier natürlich je eine `BSTNode` erwartet)
- [task][insert]( 179488 )
Die Methode soll den übergebenen Wert gemäß der oben beschriebenen Invariante in den Baum einfügen. Zum Überprüfen, ob ein Element größer oder kleiner ist als ein anderes, kannst du das [Comparable](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html)-Interface nutzen, welches vom generischen Typ `T` implementiert werden muss (siehe Klassen-Kopf).
    - Wie oben beschrieben sollen keine Duplikate eingefügt werden. In diesem Fall ändert sich der Baum nicht.
    - Implementiere die Methode rekursiv!
- [task][contains](test_BSTNode_contains()
Die Methode gibt `true` zurück, falls der übergebene Wert im Baum enthalten ist, sonst `false`.
    - Implementiere die Methode rekursiv!

### BST
Mit `BSTNode` hast du die interne Struktur des Baums bereits implementiert. Jetzt fehlt nur noch der Baum an sich. Benutze für die folgenden Aufgaben soviel Code aus den `Node`-Klassen, wie möglich.
- [task][BST Attribut und Konstruktor]( 179491 )
BST soll ein `private`-Attribut `root` vom Typ `BSTNode` enthalten, welches die Wurzel des Baumes darstellt. Der einzige, parameterlose Konstruktor soll dieses Attribut mit null initialisieren.
- [task][insert]( 179487 )
`insert` fügt den übergebenen Wert gemäß der oben beschriebenen Invariante in den Baum ein.
- [task][isEmpty]( 179479 )
Die Methode `isEmpty` gibt `true` zurück, wenn der Baum leer ist, sonst `false`.
- [task][size]( 179483 )
Soll die die Anzahl der Knoten im Baum zurückgeben.
- [task][contains]( 179474 , 179481 )
Gibt `true`, wenn der übergebene Wert im Baum vorhanden ist, sonst `false`.
- [task][toList]( 179489 )
Gibt eine Liste der im Baum enthaltenen Werte in-order zurück.
-	Auch hier soll wieder eine `LinkedList` verwendet werden.
-	für einen leeren Baum soll eine leere Liste zurückgegeben werden.
- [task][toString]( 179484 )
Gibt eine String-Repräsentation des Baumes zurück. Die Regeln sind dabei die selben wie für `BinaryNode.toString(Order.IN)`. Für einen leeren Baum soll "" [] "" zurückgegeben werden."
299,Praktikum: Grundlagen der Programmierung WS23/24,12482,W09H02 - Mathematik an der PUM Netwonverfahren,"# Mathematik an der PUM
Die Forschuine der PUM brauchen schon wieder deine Hilfe! Dieses mal sind es die Matheuine, die mithilfe von Functional Interfaces einige Berechnungen vereinfachen wollen. Sie haben außerdem vor kurzem rausgefunden, dass man Lambda-Expressions schreiben kann, die keine One-Liner sind. Sowie:
```java
Function , Double> average = lst -> {
    double sum = 0;
    for (int x: lst) {
        sum += x;
    }
    return sum / lst.size(); // Note that this does not handle null divisions!
}
```
Sie sind sehr begeistert, und wollen mit deiner Hilfe mehr damit machen!

## Polynome
Die Matheuine repräsentieren ihre Polynome als Arrays von `double`s, so dass jedes Element den Koeffizienten der Potenz des entprechenden Index repräsentiert. Z.B. würde das Array `{3, 2, 0, 4}` das Polynom $$p(x) = 4x^3 + 0x^2 + 2x + 3$$ repräsentieren.

Wir wollen nun diese Arrays in Functions umwandeln.

1. [task][Polynome]( 184617 )
Implementiere in der Klasse `Polynoms` die Methode `public static Function  polynom(double[] coefficients)`, die die passende Polynomfunktion für das gegebene Array zurückgibt.

 Beispiel 
```java
double y = Polynoms.polynom(new double[] {1,2,3}).apply(2);
// y is 17
```
 

Die Matheuine sind außerdem an den Ableitungen der Polynome interessiert. Bei Bedarf kannst du dich [hier](https://de.wikipedia.org/wiki/Differentialrechnung#Zusammenfassung) an die Ableitungsregeln erinnern.

2. [task][Polynomableitungen]( 184623 )
Implementiere in der Klasse `Polynoms` die Methode `public static Function  polynomDerivative(double[] coefficients)`, die die Ableitung der passenden Polynomfunktion für das Array zurückgibt.

 Beispiel 

```java
double y = Polynoms.polynomDerivative(new double[] {1,2,3}).apply(2);
// y is 14
```
 

## Ableitungen

Die Matheuine können ihre Begeisterung kaum zurückhalten. Jetzt wollen sie sogar allgemeine Ableitungsfunktionen approximieren. Diese Annäherung hängt von der Auswahl von $$\epsilon$$ ab und wird definiert als $$f'(x) = \frac{f(x+\epsilon)-f(x)}{\epsilon}$$.

**Hinweis:** Nutze die `main`-Methode und `Function.apply`, um deine Ergebnisse in den folgenden Aufgaben zu testen.

3. [task][Ableitungen]( 184625 )
Implementiere nun in der Klasse `PinguMath` die Methode `public static Function  derivativeFunction(Function  f, double epsilon)`, die die Ableitung der gegebenen Funktion mit $$\epsilon$$ approximiert.

## Newtonverfahren
Als letztes wollen die Matheuine Nullstellen von Funktionen mithilfe des [Newtonverfahrens](https://de.wikipedia.org/wiki/Newtonverfahren) berechnen. Dazu entwickeln wir nun die Klasse `NewtonApproximator`.

4. [task][Newtonapproximation - Konstruktoren]( 184632 )
Implementiere die beiden vorgegebenen Konstruktoren in der Klasse `NewtonApproximator`. Ist `fPrime` nicht gegeben, muss sie mithilfe von `PinguMath.derivativeFunction` berechnet werden. Wir verwenden dabei stets $$\epsilon=0.0000001$$.

5. [task][Newtonapproximation - Schritt]( 184627 )
Implementiere nun die Methode `nextStep`, die einen Approximationsschritt berechnet und das aktuelle Ergebniss in `x` speichert. Außerdem muss verwaltet werden, wie viele Iterationschritte bereits durchgeführt wurden.

6. [task][Newtonapproximation]( 184619 , 184629 )
Implementiere die Methode `public double approximateRoot(double epsilon, int maxIterations)`, die die gefundene Nullstelle `x` zurückgibt. Das Verfahren wird abgebrochen, wenn $$|f(x)| \leq \epsilon$$, oder wenn `maxIterations` erreicht wird.

Du kannst jetzt deinen Approximator testen! Wenn du ihn mit `new NewtonApproximator(Math::sin, 1);` definierst, solltest du die Nullstelle $$x=0$$ annähern, mit `new NewtonApproximator(Math::sin, 3);` die Nullstelle $$x=\pi$$."
299,Praktikum: Grundlagen der Programmierung WS23/24,12484,W09H01 - Wertetabellen,"In dieser Aufgabe erstellen wir Wertetabellen für verschiedene Funktionen. Dabei erfassen wir die x-Werte und die zugehörigen y-Werte.

Für die Funktion $$f(x)=x^2$$ sieht es etwa so aus:

```
| 1   | 1    |
| 1.5 | 2.25 |
| 2   | 4    |
| 2.5 | 5.75 |
| 3   | 3    |
```
Dazu wird zunächst durch Start- und Endwert sowie Schrittgröße ein Bereich für die x-Werte definiert:
```
0, 10, 1 -> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
5, 6, 0.3 -> 5.0, 5.3, 5.9
4, 2, -1 -> 4, 3
4, 2, 1 -> Nicht valide
```
Überlege dir nun welche Kombinationen valide sind. 

1. [task][isValidRange]( 184659 )
Implementiere die Methode `isValidRange` in der Klasse `Main`.

Wir möchten nun eine eigene `Exception` erstellen, die ausgelöst werden kann, wenn ungültige Bereiche definiert werden.

2. [task][InvalidRangeException]()
Erstelle die Klasse `InvalidRangeException`. Der Konstruktor nimmt drei `double`s als Parameter und die `protected` Felder `start`, `end` und `step` sollen initialisiert werden.

3. [task][toString]( 184661 , 184658 )
Implementiere die Methode `toString`in der Klasse `InvalidRangeException`. Sie gibt `Invalid⎵range⎵(start,⎵end,⎵step)` als String zurück.

 Beispiel 
```java
System.out.println(new InvalidRangeException(5, 4, 3));
```
printet `Invalid range (5.0, 4.0, 3.0)`.
 

4. [task][showTable]( 184670 , 184655 , 184657 , 184662 )
Implementiere die Methode `showTable` in der Klasse `Main`. Diese Methode erhält den Start- bzw. Endwert sowie die Schrittgröße als `double`-Werte und zusätzlich eine Funktion als Parameter. Die Methode soll für die gegebenen Intervalle überprüfen, ob sie gültig sind. Falls ja, soll die als Parameter übergebene Funktion auf die Werte in diesem Intervall angewendet werden. Überlege dir, wie du ungültige Bereiche behandeln kannst.

Dabei soll dein Output wie folgt aussehen: 
 Beispiel 
```java
showTable(1, 5, 1, x -> x * x);

1.0	1.0
2.0	4.0
3.0	9.0
4.0	16.0
```
Die Zahlen sind mit einem `""\t""` getrennt.
 

5. [task][showTableWithExceptionHandling]( 184652 , 184650 )
Des Weiteren ist noch die Methode `showTableWithExceptionHandling` zu implementieren. Diese Methode erhält ebenfalls den Start- bzw. Endwert sowie die Schrittgröße als `double`-Werte und zusätzlich eine Funktion als Parameter. Falls ein ungültiger Bereich als Parameter übergeben wird, soll auf der Konsole "" Error:⎵ "" und der ungültige Bereich `Invalid⎵range⎵(start,⎵end,⎵step)`  ausgegeben werden.

*Hinweis:* In dieser Methode sollst du einfach überprüfen, ob die Methode `showTable` die von dir definierte `InvalidRangeException` wirft.

*Hinweis:* Es werden keine Tests für Ausnahmen wie Division durch Null oder für nicht stetige Funktionen durchgeführt."
299,Praktikum: Grundlagen der Programmierung WS23/24,12532,W10P01 Files,"In dieser Aufgabe wollen wir Objekte in Dateien speichern und wieder laden.

Es geht natürlich um Objekte der Klasse `Penguin`, genauer handelt es sich dabei um Records. Gespeichert werden sie mithilfe der Klasse `PenguinRepository`, die das Interface `Repository ` implementiert.

1. [task][Speichern]( 185625 )
Implementiere die Methode `save(Penguin p, String filename)` in der Klasse `PenguinRepository`. Sie soll den Namen, Alter und Gewicht vom Penguin jeweils in einer Zeile speichern.  
 **Beispiel** 
```java
Penguin p = new Penguin(""Tux"", 10, 20.0);
PenguinRepository pr = new PenguinRepository();
pr.save(p, ""tux.txt"");
```

tux.txt
```
Tux
10
20.0
```
 

2. [task][Laden]( 185611 )
Implementiere die Methode `load(String filename)` in der Klasse `PenguinRepository`. Sie soll aus einer mit `save` erzeugten Datei einen `Penguin` laden."
299,Praktikum: Grundlagen der Programmierung WS23/24,12533,W10P02 Streams,"# 1. Äquivalente For-Schleife

1. [task][Äquivalente For-Schleife]( 185651 )
Implementiere die Methode `streamToFor`. Diese soll mit einer for-Schleife dieselbe Funktionalität wie das folgende Snippet haben:

```java
Stream.of(3, 1, -4)
      .map(x -> x * x)
      .forEach(System.out::println);
```

 

---

 

*Tipp: Gelegentlich bietet sich ein Blick in die JavaDocs zu Streams an, um praktische Funktionen zu finden.*

_ Hinweis 1 : Die folgenden Teilaufgaben können in den meisten Fällen in Form eines Einzeilers (nach gängigen Code-Formatierungsregeln) gelöst werden._ 
_ Hinweis 2 : Alle folgenden Aufgaben sind ohne die Nutzung klassischer Kontrollstrukturen (`if/else`, `for`, `while/do-while`, etc.) lösbar und sollen auch ohne solche gelöst werden. Die Tests prüfen allerdings nicht, ob ihr euch daran haltet._ 
 

# 2. Erstellung von Streams

Als kulturinteressierte Jungpinguine wollt ihr in der vorlesungsfreien Zeit _die_ angesagteste Theateraufführung des Jahres live sehen: _Harald Pingu und der eisige Wind_. Da der Studienort der PUM jedoch die teuerste Stadt Deutschlands ist und die PUM zum Wintersemester die Studiengebühren auch für antarktische Erdenbewohner stark erhöht hat, müsst ihr euch für die teuren Theaterkarten zuvor in der lokalen Fischfiletfabrik etwas Geld dazuverdienen.

Als Praktikantuin seid ihr an der Warenannahme dafür verantwortlich, die gefangenen Fische der verschiedenen Lieferanten anzunehmen und in die hochmoderne Maschine zu legen, welche durch fortschrittliches _Image Recognition_ die Spezies und mittels einer Waage das Gewicht des Fisches bestimmt (`void analyze(Stream )`). Vor wenigen Wochen wurde das Fließband der Maschine dabei auf den Rund-um-die-Uhr-Betrieb umgestellt, weshalb das Fließband für die Fischannahme nun praktische `Stream`s zur Verarbeitung erwartet.

Eure Aufgabe ist es nun, aus den unterschiedlichen Anlieferungen der Kooperationspartner der Fischfiletfabrik `Stream`s zu erstellen, damit diese einheitlich von der Maschine verarbeitet werden können.
Schreibt euren Code dafür in `StreamCreation`.

1. [task][Handfang]( 185647 )
Implementiere die Methode `Stream  caughtWithHand(Fish, Fish, Fish)`, welche die Lieferungen der lokalen Fischfänger vor Ort entgegennimmt. Diese besuchen euch immer dann, wenn sie exakt drei Fische gefangen haben und diese abgeben möchten.

2. [task][Anglerverein]( 185645 )
Implementiere als nächstes die Methode `Stream  caughtWithFishingRod(Fish[])`, welche die Abgaben des Anglervereins verarbeitet. Durch seine vielen fleißigen Vereinsmitglieder kann der Vorstand immer ein ganzes Array an Fischen abliefern.

3. [task][Hochseefischer]( 185646 )
Da die Fänge einiger Hobby-Fischer nicht ausreichen um die hohe Nachfrage nach Fischfilet zu decken, hat die Firma nun auch Verträge mit Hochseefischereien abgeschlossen.
Implementiere die Methode `Stream  caughtWithFishNet(Collection )`, welche Collections an Fischen zu einem Stream umwandelt.

4. [task][Fischfarm]( 185649 , 185652 )
Um Lieferschwierigkeiten für die Zukunft definitiv ausschließen zu können hat der Firmenchef eine eigene Fischfarm erbauen lassen, welche direkt mit der Maschine verbunden ist. Implementiere zuletzt `Stream  caughtInFishFarm(Supplier )`, welche konstant Fisch produziert und die endlose Menge an Fischen ebenso in einen Stream verwandelt.


 

---

 


# 3. Bearbeitung von Streams

Als nächstes wollen wir uns ansehen, welche Operationen auf Streams ausgeführt werden können. Nutze dafür die Klasse `StreamModification`.

1. [task][Begrenzte Fischannahme]( 185655 )
Nachdem der Fabrikchef all die verschiedenen Händler mit dem Fischfang beauftragt hatte, flachte das Geschäft unerwarteterweise wieder ab. Nun muss er die Menge an angenommenem Fisch beschränken, damit dieser nicht in seinem Lager schlecht wird. Implementiere dafür `Stream  limitIncomingFish(Stream , int)`. Der zurückgegebene Stream soll dabei maximal so viele Fische enthalten, wie der zweite Parameter spezifiziert, allerdings auch nur aus solchen Fischen bestehen, die mindestens 0.8 kg wiegen. Da der Firmenchef keinerlei Risiken eingehen will, soll die Maschine die Fischentnahme aus der Lieferung beenden, sobald ein Fisch das Mindestgewicht nicht erfüllt - _""Alle weiteren Fische sind vermutlich ebenfalls klein""_, denkt der Chef.

2. [task][Bestimmte Spezies]( 185650 )
Manche Großkunden der Gastronomie möchten nur bestimmte Fischspezies erhalten. Die Maschine soll also nun in `Stream  filterSpecies(Stream , Fish.FishSpecies)` nur solche Fische behalten, die von der entsprechenden Spezies sind. Der Rest wird aussortiert.

3. [task][Lieferung inspizieren]( 185654 )
Mit `Stream  printAllFish(Stream )` möchte der Chef in die ankommenden Lieferungen je einen Blick werfen, um deren Qualität zunächst grob begutachten zu können.
 **Wichtig**: Die Lieferung soll danach weiter verarbeitbar sein und nicht durch die Kontrolle des Chefs zerstört werden! Zudem soll der Stream _lazy_ evaluiert werden, d.h. die `print`s erst ausgeführt werden, wenn der Stream weiter verarbeitet wird.

4. [task][Enthaltene Spezies]( 185659 , 185660 )
Ab und an prüft die Fischfiletfabrik vereinzelte Lieferungen auf ihre Speziesvielfalt (`void printAvailableSpecies(Stream )`). Dabei soll aus der Lieferung jede enthaltene Fischspezies ausgegeben werden - jedoch jede nur einmal (wenn sie mindestens einmal vorkommt).

5. [task][Babyfische]( 185656 )
In der Fischfarm kommen regelmäßig neue Fische auf die Welt - da jedoch nur die Fische mit der besten Form den höchsten Gewinn erzielen, soll die Maschine nun auch den gebärenden Fischen dabei helfen, ihre Babies möglichst unbeschadet auf die Welt zu bringen. `Stream  getBabyFish(Stream )` soll aus einem Stream an Fischen ebendiese zusammen mit ihren Kindern in einen neuen Stream verbinden. Die Babyfische schwimmen aus dem bereits implementierten Teil `Fish[] birthHelper(Fish mother)` der Maschine in Form eines Arrays heraus, wenn diesem ein Fisch übergeben wird. Beachte, dass auch die Elternfische im resultierenden Stream enthalten sein sollen!
 _ Hinweis : Um zwei Streams in einen zu verbinden kannst du die Methode `Stream .concat(Stream , Stream )` verwenden._

6. [task][Gewichtsortierung]( 185653 )
`Stream  sortByWeight(Stream )` soll den übergebenen Stream aufsteigend nach dem Gewicht der enthaltenen Fische sortieren und zurückgeben. Wenn zwei Fische dasselbe Gewicht haben, soll ihre Reihenfolge im ursprünglichen Stream beibehalten werden.


 

---

 


# 4. Aggregation und Endverarbeitung von Streams

*Aggregationsfunktionen sind solche, die mehrere Elemente auf eines abbilden (z.B. indem die Anzahl an Elementen gezählt, das Maximum bestimmt oder Werte summiert werden). Sie werden häufig zum Abschluss der Stream-Verarbeitung eingesetzt.*

Implementiere die folgenden Aufgaben in der Klasse `StreamTermination`.

1. [task][Fische verkaufen I]( 185668 , 185665 )
Der Firmenchef ist sehr stolz auf euch, dass die Warenannahme und -verarbeitung inzwischen reibungslos funktioniert. Nun möchte er auch das Verpacken und Verkaufen der Fischfilets an die Wünsche seiner Kunden anpassen - bei diesen sind Listen aktuell *die* Trendverpackung. Implementiere die Methode `List  sellFish(Stream )`, welche die Elemente eines gegebenen Fisch-Streams als Liste zurückgibt.

2. [task][Fische verkaufen II]( 185662 , 185658 )
Trotz der großen Beliebtheit der Listen-Verpackungen gefällt diese nicht allen Kunden. Herr und Frau Kaiser(pinguin) bestehen darauf, ihren Fisch in Form eines Arrays zu erhalten, weil *""Das haben wir schon immer so gegessen!""*. Da die beiden fast täglich mehrere Kilo Fisch kaufen, kann die Fischfiletfabrik es sich nicht leisten, die beiden als Stammkunden zu verlieren. Implementiere nun also auch noch `Fish[] sellFishArray(Stream )`, welche einen Stream als Array zurückgibt.

3. [task][Küchenvorbereitung]( 185666 )
Knuth Koch ist in der gesamten Antarktis für seine exzellenten Fischfilets mit Spekulatiuskruste bekannt und arbeitet - wie könnte es anders sein - in der kleinen Suppenküche gleich neben der Fischfiletfabrik. Um die Vielzahl an täglichen Kunden mit seinen Gerichten zufriedenstellen zu können, muss er gleich morgens mit der Vorbereitung der Kochtöpfe beginnen. Dafür ist es wichtig, die Anzahl verschiedener Fisch-Spezies zu kennen, um entsprechend viele Brühen aufzusetzen. Implementiere die Methode `long numberOfDifferentSpecies(Stream )`, welche die Anzahl verschiedener Fischarten im Lager zählt und zurückgibt.

4. [task][Allergikuin]( 185664 )
Sofia Schnief ist eine liebenswürdige Pingudame, leider jedoch auch auf sehr viele Lebensmittel allergisch - so auch auf sämtliche Fischarten außer Forellen (Trouts). Daher inspiziert sie ihr Mittagessen (einen `Stream `) in `void consumeTrouts(Stream )` darauf, dass nur `TROUT`s enthalten sind (die anderen Fische nimmt sie nicht mit) und verzehrt die Forellen anschließend, wobei sie deren köstlichen Geschmack stets mit den Worten: `""Sofia fand TROUT mit Gewicht  kg sehr lecker!""` lobt.

5. [task][Schwersten Fisch finden]( 185633 , 185667 )
Für das Schaufenster möchte Knuth Koch jeden Tag den dicksten Fang aus der gekauften Lieferung vollautomatisiert zur Schau stellen. Bestimme mit `Optional  heaviestFish(Stream )` den schwersten Fisch im Stream.
 **Achtung**: Sollte Knuth einmal keine Fische ankaufen (z.B. an einem Feiertag), so soll die Maschine dies durch die Rückgabe eines `Optional .empty()` bemerken, um nichts auf den Teller zu legen. Wenn du in dieser Teilaufgabe die richtige Stream-Funktion verwendest, geschieht das automatisch.

6. [task][Bodybuilduin]( 185661 )
Markus Muskel ist ein Bodybuilduin, der aufgrund seines strikten Ernährungsplans jeden Tag mindestens einen Thunfische (Tuna) essen muss. Um richtig Muskeln aufbauen zu können, muss zudem mindestens einer der Thunfische im Stream mindestens 2.0kg wiegen. Hilf ihm, seinen Einkauf darauf zu prüfen, ob ein solcher Thunfisch mindestens einmal enthalten ist. Nutze dafür `boolean hasHeavyTuna(Stream )`.

7. [task][Gesamtgewicht]( 185663 )
Da Markus Muskel als guttrainierter Pinguin durch sein hohes Muskelgewicht bereits einige Kilo auf die Waage bringt, möchte er vermeiden, dass sein beschauliches Iglu, das auf einer Eisscholle gebaut ist, durch das zusätzliche Gewicht seiner Fischeinkäufe einbricht. Implementiere `double totalFishWeight(Stream )`, womit Markus das Gesamtgewicht der Fische in seinem Iglu berechnen kann.


 

---

 

# 5. Parallelisierung von Streams

Streams können auch parallel verarbeitet werden, was bei großen Datenmengen für kürzere Laufzeiten sorgen kann (mehr dazu in den nächsten beiden Wochen). Sieh dir nun die Klasse `StreamParallelizationExample` an.

_Bei den folgenden 3 Aufgaben müsst ihr keinen Code schreiben, sondern sollt stattdessen lokal mit den vorgegebenen Streams experimentieren und Unterschiede ermitteln. Es gibt auch keine Tests, da der Code bereits vorgegeben ist._

0. [task][Komplexe Berechnungen]()
Sieh dir in `StreamParallelizationExample` die Methode `int complexCalculation(int)` an. Diese wartet bei einem Aufruf zunächst 300ms und gibt anschließend das Doppelte der übergebenen Zahl zurück.

1. [task][Sequentielle Stream-Bearbeitung]()
Schau dir zunächst die Implementierung der Methode `streamExecutionSequential(Integer[])` an. Kommentiere in der `main`-Methode nun alle Methodenaufrufe außer `streamExecutionSequential(numbers);` aus und führe den Code aus. Was beobachtest du?
 
 **Lösung** 
Die Ausführung dauert, verglichen mit den vorigen Teilaufgaben, erwartbar relativ lang. $$10$$ Elemente in `numbers` $$\times$$ $$300ms = 3000ms$$, d.h. etwas mehr als 3 Sekunden.
 

2. [task][Parallele Stream-Bearbeitung I]()
Schau dir nun die Implementierung der Methode `streamExecutionParallel(Integer[])` an. Kommentiere anschließend in der `main`-Methode alle Methodenaufrufe außer `streamExecutionParallel(numbers);` aus und führe den Code mehrmals aus. Was beobachtest du jetzt? Woran kann das liegen?
 
 **Lösung** 
Die Ausführung geht nun deutlich schneller (circa 700ms - je nach Computer, definitiv aber unter 3 Sekunden). Allerdings sind die ausgegebenen Elemente nun nicht mehr in der gleichen Reihenfolge, wie sie in `numbers` in `main` vorgegeben werden. Die Reihenfolge unterscheidet sich zudem zwischen den Ausführungen.
 Das liegt daran, dass Java die einzelnen Elemente des Streams dank `.parallel()` nun parallel, also gleichzeitig verarbeiten kann. Je nachdem, wie die Elemente aufgeteilt werden und wie schnell die verschiedenen Prozesse sind, kann dabei die Ausgabereihenfolge variieren.
 

3. [task][Parallele Stream-Bearbeitung II]()
Schau dir zuletzt die Implementierung der Methode `streamExecutionParallelKeepOrder(Integer[])` an. Kommentiere anschließend in der `main`-Methode alle Methodenaufrufe außer `streamExecutionParallelKeepOrder(numbers);` aus und führe den Code mehrmals aus. Was beobachtest du? Woran kann das liegen?
 
 **Lösung** 
Die Ausführungsdauer ist ähnlich schnell wie bei `streamExecutionParallel(Integer[])`, jedoch bleibt die Reihenfolge bei jeder Ausführung gleich. Dafür sorgt `.forEachOrdered()`, was im Gegensatz zu `.forEach()` die ursprüngliche Reihenfolge der Elemente im Stream behält und nach der parallelen Ausführung von `complexCalculation()` wartet, bis dieselbe Reihenfolge wiederhergestellt werden kann.
 

Öffne nun die Klasse `StreamParallelization`.

4. [task][Parallele Berechnungen]( 185670 )
Der mathematikinteressierte Sohn des Firmenchefs hat eine geniale Formel entwickelt, mit welcher er glaubt, die Haltbarkeit der Fische besser vorhersagen zu können. Er bittet dich, die rechenintensiven Operationen effizient in der Maschine zu implementieren. `double calculationOfWeights(Stream  fishStream, int limit)` soll aus dem gegebenen, unendlichen Stream die ersten `limit` Fische entnehmen und deren Gewichte nach folgender hoch wissenschaftlicher Formel verrechnen: $$\sum{(3 * (weight^4 + 1.5)^{0.7})}$$
 Beachte, dass der Test zu dieser Aufgabe Limits bis zu $$5~000~000$$ überprüft.

 

---

 

Geschafft! Der Firmenchef ist mit deiner Arbeit vollstens zufrieden und zahlt dir deinen Lohn aus, mit welchem du dir gleich zwei Logenplätze für _Harald Pingu und der eisige Wind_ leisten kannst. Jetzt musst du nur noch überlegen, welcher deiner Freunde dich in die Aufführung begleiten darf..."
299,Praktikum: Grundlagen der Programmierung WS23/24,12534,W10H03 - Bahn Analyse mit Streams,"# W10H03 Bahn-Analyse mit Streams

Im Folgenden wollen wir die Deutsche Bahn und den ÖPNV mit der Hilfe von Streams analysieren.

## Streams

Diese Aufgabe dient dazu Javas Streams kennenzulernen, daher sind alle konventionellen Kontrollstrukturen verboten, dazu gehören: `for (;;)`-, `for (:)`- und (`do`-)`while` Schleifen, die Methode `.forEach()` auf `Stream` und `List` sowie Rekursion. `if`-Statements / `if`-`else`-Statements (und der Ternary Operator) sind im Gegensatz zur ersten Hausaufgabe explizit erlaubt. Diese Einschränkungen werden in einem public Test automatisch überprüft. Sollte es Probleme damit geben, würden wir uns auf Zulip über Feedback freuen.

Wenn Ihr bei einer Teilaufgabe nicht weiter kommt, hilft oft ein Blick in die [Stream API](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html). Beachtet auch, dass es neben generischen Streams auch spezielle Implementationen, u. a. `IntStream`, `LongStream` und `DoubleStream` gibt, welche besondere Funktionen bereitstellen.

*Hinweise/Tipps:*
- Nochmals: `if`-Statements / `if`-`else`-Statements sind in dieser Aufgabe explizit erlaubt und sind bei mindestens einer Teilaufgabe sehr nützlich.
- **Für Teilaufgaben 2, 4 und 6:** Die Verspätung eines Zuges an einer Station in Minuten kann mithilfe der bereits von uns implementierten Methode `TrainStop.getDelay()` ermittelt werden. Diese gibt die Differenz (in Minuten, wie gesagt) zwischen tatsächlicher und geplanter Ankunftszeit zurück, wenn diese positiv ist, 0, wenn nicht. Die unerwünschten negativen Verspätungen werden durch `getDelay()` also bereits automatisch auf 0 gesetzt.
- **Für Teilaufgaben 3, 4 und 6:** Die Methode `Stream.flatMap()` (genauso wie die von ihr abgeleiteten Methoden `flatMapToInt()`, ...) ist eine Variante von `Stream.map()`. Sie nimmt eine Funktion entgegen, die aus einem Stream-Element einen Stream macht. Würde man `map()` mit so einer Funktion aufrufen, würde man einen Stream von Streams erhalten. `flatMap()` nimmt nun noch diesen Stream von Streams und kombiniert die inneren Streams zu einem großen Gesamt-Stream. Diese Methode mag in einigen Situationen nützlich sein. 
[`Stream.flatMap()`-JavaDoc](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#flatMap(java.util.function.Function)) 
[`Stream.flatMap()` Erklärung](https://www.baeldung.com/java-difference-map-and-flatmap)
- **Für Teilaufgaben 5 und 6:** Die Methode `Stream.collect()` in Kombination mit den Kollektoren `Collectors.groupingBy()` und `Collectors.toMap()` sind hier hilfreich. Ersterem wird eine Funktion übergeben, die ein Stream-Element auf einen Key abbildet, zurückgegeben wird dann eine Map vom jeweiligen Key auf eine Liste aller Stream-Elemente, die auf diesen Key abbilden. Letzterem werden zwei Funktionen übergeben, eine, die aus dem gegebenen Stream-Element einen Key baut und eine zweite, die aus einem gegebenen Stream-Element einen Value baut. Die Map mit einem Key-Value-Paar pro Stream-Element, wobei der Key durch Anwenden ersterer, der Value durch Anwenden zweiterer Funktion aus dem Stream-Element erzeugt wird, wird dann zurückgegeben.
Nutze nun erst `groupingBy()` um die `TrainConnection`s (Aufg. 5) bzw. die `TrainStop`s (Aufg. 6) geeignet in eine Map von Typ der Verbindung bzw. Stunde auf die Liste aller Verbindungen mit diesem Typ bzw. Halte in dieser Stunde zu überführen. Danach mache aus der erhaltenen Map mit `Map.entrySet().stream()` wieder einen Stream und Nutze nun `Stream.collect(Collectors.toMap(..))` geeignet, um das Endergebnis zu erzeugen. 
[`Collectors.groupingBy()`-JavaDoc](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#groupingBy(java.util.function.Function)) 
[`Collectors.groupingBy()` Erklärung](https://www.baeldung.com/java-groupingby-collector) 
[`Collectors.toMap()`-JavaDoc](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#toMap(java.util.function.Function,java.util.function.Function)) 
[`Collectors.toMap()` Erklärung](https://www.baeldung.com/java-collectors-tomap)

[task][Keine verbotenen Konstrukte verwendet]( 185721 ) 

## Die Daten

Die Datengrundlage für unsere Analyse kommt von [expert.bahn](https://bahn.expert), einer öffentlichen [API](https://de.wikipedia.org/wiki/Programmierschnittstelle) für verschiedene Daten rund um Bus und Bahn. Die API nutzt `JSON` als Datenformat, die Umwandlung in die entsprechenden Objekte `TrainConnection`, `TrainStop` und `Station` (diese Klassen bitte nicht modifizieren) ist bereits in der Klasse `DataAccess` implementiert. Hier gibt es einmal die Möglichkeit Verbindungen aus einer Datei zu laden oder von der API abzurufen. Wir würden Euch bitte beim Testen mit gespeicherten Daten zu arbeiten und die API so wenig wie möglich zu nutzen, eine Anfrage findet ihr in der Datei `connections_test/sample.json`.

## Die Analyse

Da wir die Daten nun laden können, wollen wir im Folgenden schauen, welche Schlüsse sich ziehen lassen. Schaut Euch die Klassen `TrainConnection`, `TrainStop` und `Station` an und stellt sicher, dass ihr alle Attribute und Funktionen, welche nicht fürs Parsing zuständig sind, versteht. Beachtet beim bearbeiten bitte Folgendes:
- *Negative Verspätung*: Es gibt keine negativen Verspätungen! Sollte ein Zug zu früh sein, darf das in der Statistik nicht andere Verspätungen ausgleichen.
- *CANCELLED Stops*: Außer in der ersten und dritten Aufgabe muss keine Rücksicht darauf genommen werden ob ein Stop gestrichen wurde. `CANCELLED` Stops sollen daher wie alle anderen behandelt
werden.
- *Leere Stops*: Die Liste mit Stops einer TrainConnection wird immer mindestens ein Element enthalten.

###1. Clean Dataset

In der Methode `cleanDataset` wollen wir sicherstellen, dass wir eine saubere Datengrundlage haben. Dafür wollen wir den übergebenen Stream:

1. Von Duplikaten befreien, da die API teilweise leider doppelte Verbindungen übergibt. (Da `TrainConnection`, `TrainStop` und `Station` als `Record`s implementiert sind haben sie eine “richtige” `.equals()` Methode, welche nicht auf Referenz-Gleichheit, sondern auf Inhalt prüft, dementsprechend gilt zwei Verbindungen `v1` und `v2` als Duplikate voneinander, wenn `v1.equals(v2)` gilt - in dem Fall soll nur eine von beiden behalten werden).
2. Sortieren nach geplanter Abfahrtzeit am Abfahrtsbahnhof (der nullte Index in der Stops-Liste).
3. Aus den Stops der Verbindungen sollen diejenigen aussortiert werden, welche nicht angefahren werden, und daher das `Kind` Attribut `CANCELLED` haben. (Die Methode `TrainConnection.withUpdatedStops()` könnte hilfreich sein).

[task][Public Tests]( 185739 )
[task][Hidden Tests]( 185715 , 185689 , 185704 , 185691 , 185683 )
[task][Punkte]( 185717 )
 
###2. Schlimmste Verspätung

In der Methode `worstDelayedTrain` soll aus allen Verbindungen diejenige gefunden werden, welche die schlimmste Verspätung an einem Halt im Laufe der Fahrt hatte. Wenn keine Verbindungen übergeben wurden, soll `null` zurückgegeben werden. Sollte es keine Verspätung geben, kann eine beliebige Verbindung zurückgegeben werden. Sollten mehrere Verbindungen die gleiche maximale Verspätung an einer ihrer Stops gehabt haben, kann eine beliebige aus diesen zurückgegeben werden.

[task][Public Tests]( 185724 )
[task][Hidden Tests]( 185713 , 185681 , 185710 , 185705 , 185709 )
[task][Punkte]( 185716 )
 
###3. Wie viel Prozent sind ..

In der Methode `percentOfKindStops` soll berechnet werden, wie viel Prozent `[0, 100]` der Stops im Betrachtungszeitraum `CANCELLED`, `ADDITIONAL` bzw. `REGULAR` sind. Welches Attribut wir betrachten, wird der Methode als Argument `kind` übergeben.

[task][Public Tests]( 185734 )
[task][Hidden Tests]( 185679 , 185720 , 185688 , 185699 , 185707 )
[task][Punkte]( 185714 )
 
###4. Durchschnittliche Verspätung an …

Die Methode `averageDelayAt` soll die durchschnittliche Verspätung an einer speziellen, übergebenen Station in Minuten berechnen. Beachtet wieder, dass `Station` als `Record` bereits eine `equals` Methode hat, welche benutzt werden kann. 

[task][Public Tests]( 185722 )
[task][Hidden Tests]( 185690 , 185697 , 185703 , 185695 , 185706 )
[task][Punkte]( 185712 )
 
###5. Anteilige Verspätung pro Verkehrsmittel

Die Methode `delayComparedToTotalTravelTimeByTransport` soll eine Map zurückgeben, in welcher jedes im Datensatz vorkommende Verkehrsmittel (`type` Attribut in `TrainConnection`) auf seine anteilige Verspätung abbildet. Anteilig meint hierbei, wie viele Prozent der gesamten gefahrenen Zeit (für eine einzelne Verbindung ist das immer die Zeit zwischen dem ersten und letzten Stop) des Verkehrsmittels auf Verspätungen zurückzuführen sind. Wenn alle ICEs im Betrachtungszeitraum zusammen 24 Stunden fahren, aber nur 16 geplant waren, dann sprechen wir von einer anteiligen Verspätung von 33,3333...%, da ein Drittel der gefahrenen Zeit einer Verspätung zuzuordnen ist (vergleiche $$(24-16) / 24 = 0.3333...$$). (Beachtet hierbei auch die Methoden `totalTimeTraveledScheduled` und `totalTimeTraveledActual`).

[task][Public Tests]( 185728 )
[task][Hidden Tests]( 185686 , 185682 , 185701 , 185684 , 185708 )
[task][Punkte]( 185719 )
 
###6. Durchschnittliche Verspätung pro Stunde

Die Methode `averageDelayByHour` soll eine Map berechnen, wobei jede Stunde in der im Betrachtungszeitraum eine Station angefahren wurde, auf die durchschnittliche Verspätung in Minuten in dieser Stunde verweist. In einer Stunde sollen dabei jeweils die `TrainStop`s betrachtet werden, die tatsächlich in dieser Stunde die jeweilige Station angefahren haben (`TrainStop.actual()`, nicht `TrainStop.scheduled()`). (`LocalDateTime.getHour()` findet die Stunde einer `LocalDateTime` heraus).

[task][Public Tests]( 185696 )
[task][Hidden Tests]( 185692 , 185702 , 185687 , 185694 , 185700 )
[task][Punkte]( 185698 )
 
### FAQ
**Was sind `Record`s**: Das ist eine neue Art Klassen zu erstellen, welche besondere Eigenschaften haben: Alle Attribute sind `private final` und haben einen Getter `attributeName()`. `equals()`, `toString()` und `hashCode()` sind bereits implementiert. Mehr könnt Ihr hier nachlesen: [Records](https://www.baeldung.com/java-record-keyword)"
299,Praktikum: Grundlagen der Programmierung WS23/24,12535,W10H02 - Pinguin Ausflug,"# WH10H02 - Pinguin Ausflug

Es wird endlich wieder Sommer in der Antarktis und die Pinguine der Familie Fluss können ihren ersten Ausflug nach dem langen Winter kaum noch erwarten. Damit auch alles glattgeht und der Ausflug zu einem vollen Erfolg wird, brauchen sie aber Deine Hilfe! Sie würden ihren Ausflug nämlich gerne analysieren, bevor sie aufbrechen. Da sie gelesen haben, dass sich Streams dafür sehr gut eignen, würden sie diese These gerne von Dir testen lassen.

## Streams

Diese Aufgabe dient dazu Javas Streams kennenzulernen, daher sind alle konventionellen Kontrollstrukturen verboten, dazu gehören: `for (;;)`-, `for (:)`- und (`do`-)`while` Schleifen, `if-else`-Statements, der Ternary Operator, die Methode `.forEach()` auf `Stream` und `List` sowie Rekursion. Diese Einschränkungen werden in einem public Test automatisch überprüft. Sollte es Probleme damit geben, würden wir uns auf Zulip über Feedback freuen.

*Hinweise/Tipps:*
- Wenn Ihr bei einer Teilaufgabe nicht weiter kommt, hilft oft ein Blick in die [Stream API](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html). Alle Aufgaben lassen sich in wenigen Zeilen Code (bzw. mit wenigen Methodenaufrufen auf einem Stream) lösen. Oft reduziert sich die Schwierigkeit nur darauf, die richtige Stream-Methode zu finden. Beachtet auch, dass es neben generischen Streams auch spezielle Implementationen, u. a. [IntStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/IntStream.html), [LongStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/LongStream.html) und [DoubleStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/DoubleStream.html) gibt, welche besondere Funktionen (wie z.B. `sum()` oder `average()`) bereitstellen.


[task][Keine verbotenen Konstrukte verwendet]( 185795 ) 


## Gegebene Klassen

Euch sind bereits die Klassen `WayPoint` und `OneWay` gegeben. Diese enthalten einige Methoden für geometrische Berechnungen, Umwandlung von Strings zu Objekten und Ausgabe. Schaut euch die Klassen gut an und verwendet die gegebenen Methoden nach Möglichkeit. 
## Aufgabe

Vervollständige nun die Methoden in der Klasse `PinguTrip` wie im Folgenden beschrieben!


###1. Route einlesen

Die Pinguine haben sich schon den ganzen Winter lang Gedanken gemacht, wo sie denn bei ihrem ersten Ausflug überall hin möchten. Da sie aber erst im Oktober angefangen haben zu programmieren, stehen ihre ganzen Notizen noch in einer .txt Datei und sie hätten gerne eine Methode `readWayPoints`, welche ihre Wegpunkte einliest und in `WayPoint` Objekte umwandelt, damit sie die Notizen besser analysieren können.

Die Methode soll den Pfad zu den Notizen als String bekommen und einen Stream, welcher die `WayPoint` Objekte beinhaltet, zurückgeben. Jede Zeile in der Notiz ist dabei genau in einem von drei Formaten:
1. Eine Koordinate `x;y`. Diese soll in einen `WayPoint` umgewandelt werden. x und y stehen hierbei für beliebige doubles als String.
2. Ein Kommentar `// …`. Startend mit zwei Schrägstrichen und gefolgt von einer beliebigen Zeichenfolge. Kommentare sollen ignoriert werden.
3. Ein Schlussstrich `---`. Als die Pinguine gemerkt haben, dass ihre Route schon viel zu lang ist haben sie einen Schlussstrich gezogen. Alles, was danach kommt, soll nicht mehr behandelt werden.

Alle anderen Fälle, wie etwa eine Zeile die nicht in einem der drei Formate ist, werden nicht getestet und müssen nicht behandelt werden.

Sollte beim Einlesen ein Fehler auftreten, soll ein leerer Stream zurückgegeben werden.

 
 Beispiel 
Eine Datei mit folgendem Inhalt:
```text
4.0;11.5
// comment
19.1;3.2
---
9.11;1.1
```

soll umgewandelt werden in:

```java
Stream.of(new WayPoint(4.0, 11.5), new WayPoint(19.1, 3.2));
```
 
    
[task][Public Tests]( 185777 , 185766 )
[task][Hidden Tests]( 185769 , 185767 )
 
###2. Wegpunkte zu Wegen wandeln

Da nur die Wegpunkte zu haben manchmal sehr umständlich sein kann, wollen die Pinguine ihre Wegpunkte nun in Wege - repäsentiert duch `OneWay` Objekte - umwandeln. Dafür sollen in der Methode `transformToWays` die Elemente einer Liste von Wegpunkten verbunden werden und zwar so, dass immer der i-te mit dem i+1-ten Wegpunkt zu einem Weg wird. Die Methode wird nur mit Streams, welche mindestens zwei Wegpunkte enthalten, getestet. Leere Streams oder Streams mit nur einem Element müssen nicht behandelt werden.

*Tipp:* Der Weg wird hier aus einem Grund als eine Liste und nicht wie in den anderen Methoden als ein Stream übergeben. Mit `waysPoints.stream()` zu beginnen, ist also vermutlich nicht der richtige Weg. Überlege dir stattdessen, mit was für einem Stream du deine Berechnungen beginnen willst. Die Methode `IntStream.range()` könnte hilfreich sein.
 
 Beispiel 

```java
List.of(new WayPoint(4.0, 11.5), new WayPoint(19.1, 3.2), new WayPoint(2.1, 7.4));
```
    
Soll umgewandelt werden in:
    
```java
Stream.of(new OneWay(new WayPoint(4.0, 11.5), new WayPoint(19.1, 3.2)), new OneWay(new WayPoint(19.1, 3.2), new WayPoint(2.1, 7.4)))
```
    
 

[task][Public Tests (= Punkte)]( 185774 )
[task][Hidden Tests]( 185781 )
 
###3. Länge des Weges

Die Pinguine wollen wissen, wie lang ihr Weg überhaupt ist. Dafür soll die Länge der gesamte Strecke in der Methode `pathLength` berechnet werden. 

 
 Beispiel 
```java
Stream.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0)));
```
Sollte dementsprechend `1.0` zurück geben.
 

[task][Public Tests]( 185771 )
[task][Hidden Tests]( 185779 )
 
###4. Kinderausflug

In der großen Pinguin-Familie sind auch Küken, welche nicht so weite Strecken laufen können. Daher sollen in der Methode `kidFriendlyTrip` ein Ausflug erstellt werden, der auch für die kleinen Pinguine geeignet ist. Dafür sollen vom Start aus die Wege genommen werden, welche nicht länger als die durchschnittliche Weglänge in der gesamten Route sind. Sobald der erste Weg länger ist, soll der Kinderausflug beendet werden und keine weiteren Wege mehr enthalten (exklusive dem Weg, welcher länger als der Durchschnitt war).

*Hinweis:* Dass hier wieder Listen statt Streams übergeben und zurückgegeben werden, hat ebenfalls seine Gründe. Hier musst du dir darüber allerdings nicht allzu viele Gedanken machen. `oneWays.stream()` zu verwenden ist hier eine gute Idee.

 
 Beispiel 
```java
List.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0)),
          new OneWay(new WayPoint(1.0, 0.0), new WayPoint(3.0, 0.0)),
          new OneWay(new WayPoint(3.0, 0.0), new WayPoint(4.0, 0.0)));
```
soll zu folgender Liste umgewandelt werden, da die durchschnittliche Länge $$(1 + 2 + 1) / 3 = 1.33..$$ ist, und der zweite Weg mit $$2 > 1.33$$ länger als der Durschnitt ist und somit ab diesem Punkt keine weiteren Wege mehr mit aufgenommen werden.
```java
List.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0))
```
 

[task][Public Tests]( 185775 )
[task][Hidden Tests]( 185776 )
 
###5. Maximale Entfernung nach Hause

Damit sie ihren Ausflug auch gut spontan abbrechen können, wollen die Pinguine in der Methode `furthestAwayFromHome` gerne berechnet haben bei welchem Wegpunkt sie sich am weitesten von Zuhause entfernen. Wenn es keinen Wegpunkt gibt, soll der Wegpunkt ihres Zuhauses zurückgegeben werden. Sollten mehrere Wegpunkte gleich weit entfernt sein, kann von diesen ein Beliebiger zurückgegeben werden.
 
 Beispiel 
```java
Stream  path = Stream.of(new WayPoint(1.0, 0.0), new WayPoint(2.0, 0.0));
WayPoint home = new WayPoint(0.0, 0.0)
```
soll folgenden Wegpunkt wieder geben:
```java
new WayPoint(2.0, 0.0)
```
 

[task][Public Tests]( 185826 )
[task][Hidden Tests]( 185768 )
 
###6. Freunde besuchen

Die Pinguine haben im Winter viele ihrer Freunde nicht gesehen und würden diese gerne besuchen. Dies ist aber nur sinnvoll, wenn ihre Freunde auf dem Weg ihrer Route leben. Gegeben ist eine Route und der Wegpunkt eines Freundes, die Methode `onTheWay` soll berechnen, ob ihr Freund auf dem geplanten Weg liegt.
 
 Beispiel 
```java
Stream.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0));
WayPoint visit = new WayPoint(0.5, 0.0);
```
Soll `true` wieder geben.
 

[task][Public Tests]( 185778 )
[task][Hidden Tests]( 185772 )
 
###7. Schöne Richtungsangaben

Nachdem ihr Ausflug nun hinreichend analysiert wurde, wollen sich die Pinguine auf den Weg machen. Da der Mobilfunk-Ausbau in der Antarktis aber leider genau so schleppend voran geht wie in Deutschland, wollen sie sich ihre Wegbeschreibung ausdrucken. Dafür muss sie aber erstmal in der Methode `prettyDirections` in ein hübsches und lesbares Format umgewandelt werden. Jeder Weg soll in eine Zeile in folgendem Format gewandelt werden: \ ⎵Schritte⎵Richtung⎵ \ ⎵Grad. , (die Methode `prettyPrint` übernimmt diese Umwandlung bereits für euch).

 
 Beispiel 
```java
Stream.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0)),
          new OneWay(new WayPoint(1.0, 0.0), new WayPoint(3.0, 0.0)),
          new OneWay(new WayPoint(3.0, 0.0), new WayPoint(4.0, 1.0)));
```
Soll folgenden String zurück geben.
```text
1 Schritte Richtung 0 Grad.
3 Schritte Richtung 0 Grad.
2 Schritte Richtung 45 Grad.
```
 

[task][Public Tests]( 185825 )
[task][Hidden Tests]( 185773 )
 
## FAQ
**Null Elemente**: Ihr könnt davon ausgehen, dass alle Attribute von WayPoint und OneWay sowie die Parameter der Methoden immer ungleich `null` sind."
299,Praktikum: Grundlagen der Programmierung WS23/24,12536,W10H04 - Videoverarbeitung,"# Videobearbeitung

Da die PUM ihre Erfolge kund tun möchte (und hin und wieder auch mal etwas Freizeit sein muss) gibt es viele verschiedene Veranstaltungen. 
Um diese nach außen zu tragen ist Mediuin Janez ein gern gesehener Gast bei solchen Veranstaltungen. 
Er hält sie auf Foto und Video fest. 
Aufgrund des hohen Arbeitsaufwands der Nachbearbeitung, braucht Janez eure Hilfe. 
Er bittet euch ein Programm zu entwickeln, welches Filter automatisch anwendet und die Videos passend zuschneidet.

#  Hinweise 

* Die Klassen `FrameProvider`, `FrameConsumer` und `Frame` wurden bereits implementiert. Nähere Informationen findet ihr am Ende der Aufgabenstellung und in den Kommentaren.
* Die Klasse `BufferedImage` hält die Bilddaten eines Frames. Hier werden nur die Methoden `getRGB(x, y)` und `setRGB(x, y, rgb)` verwendet. 
    * Der Ursprung eines Bildes ist oben links. 
    * Nähere Informationen findet ihr auch im [Javadoc](https://docs.oracle.com/en/java/javase/17/docs/api/java.desktop/java/awt/image/BufferedImage.html)
    * Ihr könnt die Klasse `Color` verwenden um euch die manuelle Manipualtion der RGB Farbwerte abzunehmen. ([Javadoc](https://docs.oracle.com/en/java/javase/17/docs/api/java.desktop/java/awt/Color.html))
* Der `FrameProvider` wird in den Tests immer einen `Frame` mit initialisierten Pixeldaten von konsistenter Größe zurückgeben. Das Verhalten beim Verarbeiten von echten Videodaten kann abweichen.
    * Falls keine Frames mehr verfügbar sind, gibt der `FrameProvider` `null` zurück.
    * Andere Limitierungen bezüglich Größe, und Mindestabmessungen gibt es nicht und müssen der Aufgabenstellung entsprechend abgefangen werden.
* Der `FrameConsumer` nimmt solange Frames entgegen, bis er geschlossen wird. Anschließend wird das Video als Datei ausgeschrieben und es können keine neuen Frames hinzugefügt werden.
 
* Wenn eure Aufgaeb lokal zu lange buildet könnt ihr diese [build.gradle](https://bitbucket.ase.in.tum.de/projects/PGDP2324W09H04/repos/pgdp2324w09h04-exercise/browse/build.gradle) verwenden.
* Es gab eine Änderung in der Aufgabenstellung. Bei `crop` wurde aus ""linker Seite"" ""die Seite näher zum Ursprung"".


# Aufgabe

Implementiere die noch nicht implementierten Methoden/Konstruktoren etc. in den Dateien `VideoContainer.java` und `Operations.java`.


## Video Container

Die Klasse `VideoContainer` dient dazu Videodaten zu halten und Operationen auf diesen auszuführen. 

### Frame Stream

Da das Speichern aller Frames eines 30 Sekunden FullHD Videos den Arbeitsspeicher jeden gewöhnlichen PCs sprengen würde, müssen wir Frames einzeln verarbeiten.
Ein ideales Werkzeug hierfür sind Java Streams. 
Java Streams werden 'Lazy' ausgewertet. Das bedeutet, dass man Operationen auf dem gesamten Stream ausführen kann, die einzelnen Elemente aber nacheinander ausgewertet werden.
Der beste Weg um das in dieser Situation zu erreichen, ist einen eigenen Iterator zu erstellen und diesen mit `StreamSupport.stream(Spliterators.spliteratorUnknownSize( , Spliterator.ORDERED), false);` in einen Stream umuwandeln.
Hierbei ist ` ` eine Instanz eures Iterators. 
Der Iterator kann hier allein unter Verwendung des im Konstruktor von `VideoContainer` übergebenen `FrameProvider` implementiert werden.
Exceptions dürfen beliebig behandelt werden, solange sie nicht weitergeworfen werden und der Iterator anschließend keine weiteren Frames zurückgibt.
Falls vom Iterator Frames verlangt werden und vorher eine Exception aufgetreten ist oder der `FrameProvider` `null` zurückgegeben hat, soll eine `NoSuchElementException` geworfen werden.

### Konstruktor

Der Konstruktor des `VideoContainers` soll die privaten Attribute instanziieren.
Falls der `FrameProvider` auf eine Datei zeigt, welche nicht existiert, soll eine `FileNotFoundException` geworfen werden.
Für Fehler im übergebenen Video soll eine eigene `IllegalVideoFormatException` implementiert werden. 
Diese wird geworfen, sobald eine der Dimensionen des `FrameProviders` `0` ist. 
Alle Exceptions, welche im Konstruktor auftreten, sollen an die aufrufende Methode weitergegeben und nicht gesondert behandelt werden.

### Funktionen und Limits

Um Operationen auf dem `frameStream` auszuführen gibt es die Funktionen `limit()` und `applyFunc()`.
Beide sollen das Attribut nach Nutzung so setzen, dass anschließend weitere Stream-Operationen darauf ausgeführt werden können.

`applyFunc(f)` nimmt eine Funktion entgegen, welche einen `Frame` auf einen unter Umständen anderen `Frame` abbildet und führt diese auf dem `frameStream` aus. Der `frameStream` sollte nach Ausführen dieser Methode also ein neuer Stream sein, der als Elemente die aus der übergebenen `function` berechneten `Frame`s enthält.

`limit(n)` soll den `frameStream` auf die ersten `n` Frames begrenzen.

### Write

Die `write()` Funktion nimmt zu guter Letzt einen `FrameConsumer` entgegen.
Diesem werden alle Frames des Streams *lazy* übergeben (was der `frameStream` bereits sicherstellen sollte, wenn der Iterator korrekt geschrieben wurde). 
Exceptions hierbei dürfen beliebig behandelt werden.
Anschließend wird versucht, den `FrameConsumer` zu schließen.
Falls beim Schließen Exceptions auftreten, sollen diese an die aufrufende Methode weitergegeben werden.

[task][Public Test]( 185846 )

## Operations

1. [task][grayscale]( 185843 )

Die Funktion `grayscale` nimmt einen Frame entgegen und gibt einen Frame mit gleicher Framenummer zurück. Die Bilddaten jedoch werden in ein Graustufenbild umgewandelt.
Der Farbwert eines jeden Pixels ergibt sich aus Folgender Formel: $$0.299 * R + 0.587 * G + 0.114 * B$$
Dieser Wert wird in alle Farbkanäle des Pixels geschrieben. 
Der Alphakanal bleibt unverändert.

2. [task][crop]( 185841 )

Die Funktion `crop` nimmt eine Breite und eine Höhe entgegen und gibt eine `Function ` zurück, die die Größe eines Frames auf die übergebenen Werte für Breite und Höhe anpasst. 
Falls eine der Dimensionen größer als die des ursprünglichen `Frame`s ist, wird schwarz (RGB: 0, 0, 0) als Farbe für alle undefinierten Pixel genutzt. 

Der Bildausschnitt ist immer zentriert. 
Das bedeutet, dass falls die neue Dimension größer ist als die alte, auf beiden Seiten ein gleichgroßer schwarzer Rand ist. 
Ebenso gilt, dass auf beiden Seiten gleich viel abgeschnitten wird, wenn die neue Dimension kleiner ist als die alte.
Falls die Differenz zwischen den Größen ungerade ist, wird auf der Seite näher zum Ursprung abgerundet (also ein Pixel weniger weggeschnitten/hinzugefügt als auf der rechten).

3. [task][encode]( 185847 )

Die `encode` Methode ermöglicht es, Textdaten in einem Video einzubetten. 
Um dies zu ermöglichen wird die unterste Reihe an Pixeln durch die Binärrepräsentation des Textes ersetzt. Dabei werden pro `char` des übergebenen `String`s nur die letzten 8 bit betrachtet (in der Annahme, dass wir es hier nur mit lateinischen Buchstaben zu tun haben, die nur die letzten 8 bit verwenden). Nun soll jedes dieser Bits in eine Farbe für ein Pixel der untersten Bildreihe übersetzt werden: `1` soll zu einem weißen Pixel werden, `0` zu einem schwarzen Pixel.
Falls die Binärrepräsentation länger ist, als die Breite eines Frames, wird der Text über mehrere Frames hinweg gestreckt. Sieht dir also die `frameNumber` des hiesigen `Frame`s an, um zu wissen, welchen Ausschnitt des Textes du in diesem Frame kodieren sollst. Wenn wir z.B. Bilder mit 1024 Pixel Breite betrachten, passen auf jeden Frame `1024 / 8 = 128` Zeichen. Wenn wird z.B. einen Text der Länge 300 übergeben bekommen, sollen Zeichen `0` bis `127` dieses Textes in Frame `0`, Zeichen `128` bis `255` in Frame `1` und die restlichen Zeichen `256` bis `299` in Frame `2` gespeichert werden. Dementsprechend muss die von `encode` zurückgegebene Funktion nachsehen, ob das übergebene Frame die Nummer `0`, `1` oder `2` oder eine andere Nummer hat, um zu wissen, ob welche Zeichen es in das Bild kodieren soll.

In jedes Frame soll nur eine ganzzahlige Anzahl an `char`s geschrieben werden, evtl. bleiben also die letzten Paar Pixel frei, wenn die Bildbreite nicht durch 8 teilbar ist. In dem Fall musst du besonders darauf achten, dass immer die richtigen, zu dem aktuellen Frame passenden `char`s aus dem String in das `Frame` geschrieben werden. Wenn wir beispielsweise `Frame`s mit Breite `20` betrachten und einen String mit Länge `7`, sollten in Frame `0` die Zeichen `0` und `1` besagten Strings, in Frame `1` die Zeichen `2` und `3`, in Frame `2` die Zeichen `4` und `5` und letztlich noch in Frame `3` das Zeichen `6` geschrieben werden.
Alle Pixel, welche nicht zum Speichern von Daten verwendet werden, behalten ihren originalen Wert.

4. [task][decode]( 185848 )

Die Methode `decode` gibt für jeden Frame den durch `encode` eingebetteten String zurück. 
Es wird nicht geprüft, ob der String den in der vorherigen Aufgabe gestellten Bedingungen entspricht, da durch das Encoden von Videos Farbinformationen verfälscht werden können. 
Stattdessen setzen wir eine Schwelle, ab welcher ein Pixel als `1` zählt.
Ist die Summe der Werte der einzelnen Farbkanäle größer `384 = 3 * 128`, zählt ein Pixel als `1`, sonst `0`. 
Zudem wird versucht alle entsprechenden Pixel eines Frames zu decoden (außer den letzten Paar Pixeln eines Frames, die überstehen, falls die Breite nicht durch 8 teilbar ist).
Ihr braucht also nicht versuchen, das Ende des eingebetteten Strings zu erkennen. Es wird einfach stur unabhängig von Breite und Frame-Nummer die gesamte untere Zeile dekodiert.

 
 Beispiel für de/encode 
```text
String: Hallo
Binär: 01001000 01100001 01101100 01101100 01101111 
Bildbreite: 42 Pixel
Pixelfolge in der untersten Pixelreihe:
bwbbwbbbbwwbbbbwbwwbwwbbbwwbwwbbbwwbwwwwxx
# b=Schwarzer Pixel, w=Weißer Pixel, x=Original Farbe
```
 

Es sind eine [Beispieldatei](https://bitbucket.ase.in.tum.de/projects/PGDP2223W09H03/repos/pgdp2223w09h03-exercise/browse/noot.mp4) und Main der Aufgabenstellung beigefügt.

## Dokumentation

###Frame
 

Klasse um Frames eines Videos zu speichern.

#### Attribute

`frameNumber`:
index des Frames im VideoStream

`pixels`
`BufferedImage` mit Bilddaten

#### Konstruktoren

`Frame(int width, int height, int frameNumber)`:
Erstellt einen neuen `Frame` mit einem neuen `BufferedImage` mit den angegebenen Dimensionen. Setzt zudem die `frameNumber`

`Frame(BufferedImage pixels, int frameNumber)`:
Erstellt einen neuen `Frame` mit den übergebenen `pixels` und `frameNumber`


#### Methoden

Getter und setter für die Attribute
 


###FrameProvider
 
#### Attribute

Attribute zum Interagieren mit FFmpeg.

#### Konstruktoren

`FrameProvider()`:
Default Konstruktor zum testen.

`FrameProvider(String filename)`:
Nimmt Dateinamen entgegen und beginnt Frames einzulesen.


#### Methoden

`fileExists()`:
gibt `boolean` zurück ob die Datei zum einlesen tatsächlic existiert.

`nextFrame()`:
gibt den nächsten Frame im Video zurück. Sonst `null`. 

`close()`:
schließt den Leseprozess.

Sonst getter für: höhe, breite, framerate, bitrate

 


###FrameConsumer
 
#### Attribute

Attribute zum Interagieren mit FFmpeg.

#### Konstruktoren

`FrameConsumer()`:
Default Konstruktor zum testen.

`FrameConsumer(FrameProvider, String filename)`:
Nimmt Dateinamen und FrameProvider entgegen. 
Die Ausgabedatei wird mit den gleiche Parametern geschrieben wie die Datei aus welcher der FrameProvider gelesen hat.

`FrameConsumer(FrameProvider, String filename, int widt, int height)`:
Nimmt Dateinamen und FrameProvider entgegen. 
Die Ausgabedatei wird mit den gleiche Parametern geschrieben wie die Datei aus welcher der FrameProvider gelesen hat.
Die Höhe und breite werden jedoch mit den übergebenen Parametern ersetzt.

#### Methoden

`consume()`:
nimmt Frame entgegen und fügt sei dem Ausgabevideo hinzu

`close()`:
schließt den Schreibeprozess.

 


# FAQ
### Q: Wofür ist das FAQ?
A: Um häufig gestellte Fragen zu sammeln. Wer trotzdem noch fragt macht Pinguine traurig."
299,Praktikum: Grundlagen der Programmierung WS23/24,12538,W10H01 Warmup,"# Warmup: Binge-Streaming

 Hinweis : Die folgenden Aufgaben können und sollen ohne die Nutzung von Kontrollstrukturen (`if-else`, `for`, `while/do-while`, etc.) gelöst werden. Bei Nutzung von Schleifen schlagen alle Tests fehl.

*weitergeführte Lore aus `W10P02`*

Der Firmenchef erfreut sich sehr daran, euch beim Lösen seiner Aufgaben zuzuschauen. Daher bietet er euch für das doppelte Gehalt nun noch einige schwerere Aufgaben an, mit denen ihr euer Können unter Beweis stellen könnt. Löse die folgenden Aufgaben in der Klasse `BingeStreaming`.

1. [task][Kochzutaten]( 185919 )
Die Jungpinguine Max und Ali möchten während der Winterzeit regelmäßig Knuths *Lachs mit Spekulatiuskruste*-Rezept nachbacken. Dafür benötigen sie nur Lachse (Salmon) und Barsche (Bass) - letztere schmecken ihrer Oma besser. Um direkt bei der Ankunft neuer Fischlieferungen (welche in Form einer `List ` bei der Fischfiletfabrik gekauft werden) auch die durschnittlich benötigte Menge Mehl und Dill pro Fisch vollautomatisch von ihrem Thermomix3000 berechnen zu können, bitten sie dich, in `int avgWeightSalmonAndBass(List )` zunächst alle Fische, die keine Lachse oder Barsche sind, auszusortieren und anschließend den Durchschnitt der Gewichte aller verbleibenden Fische zu bilden. Sollte dem Thermomix dabei einmal kein Fisch übergeben werden, dessen Gewicht für die Durchschnittsberechnung verwendet werden kann (beispielsweise, weil Max und Ali statt Knuths Rezept auch gelegentlich Schokokuchen backen), so soll der Thermomix stattdessen $$0$$ zurückgeben.

2. [task][Großkundenrabatt]( 185922 )
Die Fischfiletfabrik macht ihren Großkunden Rabatte nach folgendem Muster: Zusammen mit einer Preistabelle (`Map `), die für jeden Kunden individuell ist, wird der Preis pro Gewicht eines jeden Fischs bestimmt. Zudem ist jeder 10. Fisch kostenlos, d.h. es wird für den 10., 20., 30., usw. Fisch kein Preis berechnet. 
`double price(List , Map )` soll die summierten Kosten für die abzurechnende Fischliste zurückgeben.

Bei den folgenden beiden Aufgaben übt ihr euren Umgang mit Streams und Datenstrukturen. Denkt an die Ausführungsreihenfolge der Objekte eines Streams!
 _ Hinweis : Es kann hilfreich sein, Teilaufgaben 3 und 4 nicht als Einzeiler zu lösen und zwecks Lesbarkeit auf mehrere Zeilen/Statements aufzuteilen. Kontrollstrukturen sind weiterhin nicht notwendig._

3. [task][Gewichte, nach Spezies sortiert]( 185918 )
`Map > weightPerSpecies(List )` soll eine `Map` zurückgeben, für welche pro Fischart eine Liste aller Gewichte der Fische dieser Spezies aus der Fischliste existiert.

4. [task][Gewichteverteilung]( 185921 )
Zuletzt soll in `Map  avgWeightPerSpecies(List )` pro Fischart das Durchschnittsgewicht aller Fische dieser Art aus der Fischliste berechnet werden."
299,Praktikum: Grundlagen der Programmierung WS23/24,12541,W11P01 - Chat,"# Chat

In dieser Aufgabe sollst du ein einfaches Chatprogramm mittels Sockets implementieren. Ergänze die Klasse `Chat` an den Stellen, die mit TODOs gekennzeichnet sind.

Die Kommunikation hat folgenden Ablauf:
1. Das Programm fragt den Nutzer nach einer Eingabe (bereits im Template). Diese Abfrage wird so lange wiederholt, bis eine Verbindung zustandekommt oder der Nutzer "" exit "" eingibt.
    1. Gibt der Nutzer etwas ein, was keinen "" : "" enthält, wird die Eingabe als Port interpretiert und das Programm versucht, auf diesem Port einen `ServerSocket` zu starten und auf Verbindungen zu warten. Der Server erwartet genau eine Verbindung.
    2. Gibt der Nutzer etwas mit `:` ein, wird die Eingabe als ""\ : \ "" interpretiert und das Programm versucht, sich mit dem gegebenen Host am gegebenen Port zu verbinden.
2. Beide Teilnehmer tauschen Nachrichten aus. **Der Server beginnt mit dem Senden.** Das Programm wartet also abwechselnd auf Nachrichten vom Nutzer und vom Socket.
3. Einer der Teilnehmer gibt "" exit "" ein. Beide Programme beenden sich dadurch.

Behandle alle Exceptions geeignet. Gib möglichst genaue Meldungen aus und entscheide, ob du die Programmausführung trotz des Fehlers fortsetzen kannst oder nicht. Stelle sicher, dass beim Beenden des Programms alle Sockets, Writer und Reader ordnungsgemäß geschlossen wurden. Nutze dazu entweder `finally`-Blöcke oder [try-with-resource-statements](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).

Teste dein Programm, indem du entweder mit dir selbst oder einem Kommilitonen chattest! Beachte, dass du nur Portnummern >1024 verwenden kannst. Beachte außerdem, dass du dein Programm häufig erst durch die Firewall freigeben musst. Falls deine Firewall auf Windows dich nicht automatisch beim Start des Programms fragt, ob es freigegeben werden soll, kannst du alternativ auch den Port deiner Wahl freigeben. [Hier](https://www.netzwelt.de/anleitung/181406-windows-10-firewall-so-oeffnet-ports.html) ist beschrieben, wie. Beachte, dass solche Portfreigaben am besten nach Abschluss der Nutzung wieder gelöscht werden sollten, andernfalls kann es zu unerwünschten Effekten kommen, solltest du je ein Programm starten, dass zufälligerweise den gleichen Port nutzt (das ist dann nämlich plötzlich unerwarteterweise vom Netzwerk aus zugreifbar).
- Um mit sich selbst zu chatten, starte erst ein Programm als Server und verbinde dich dann mit einem zweiten Programm damit. Dein lokaler Host heißt `localhost`. (z.B. `localhost:5000` wenn der Server auf dem Port `5000` läuft.
- Um mit deinen Kommilitonen zu chatten ist es nötig, dass sich beide Rechner im gleichen Netz befinden. Statt das gleiche WLAN zu verwenden, kannst du dies erreichen, indem du das VPN des lrz verwendest. Dieses wird typischerweise im Vorkurs installiert, falls du es noch nicht hast ist die Installation [hier](https://doku.lrz.de/display/PUBLIC/VPN) beschrieben. Sobald beide Chatpartner mit dem VPN verbunden sind, muss einer von beiden die eigene IP-Adresse herausfinden (z.B. durch den Befehl `ipconfig` (oder `ifconfig`, je nach Betriebssystem) im Terminal) und den Server auf einem beliebigen Port starten. Der/Die andere kann sich dann mit dieser IP als Host verbinden."
299,Praktikum: Grundlagen der Programmierung WS23/24,12542,W11P02 - Parallele Summierung,"# Parallele Summierung

In dieser Aufgabe sollst du ein gegebenes Integer-Array summieren. Easy, das ist ja Stoff von Woche 03! Nicht so schnell. Diesmal wird der entsprechenden Methode noch ein zweiter Parameter `threadCount` übergeben. Die Summierung soll dann in genau so viele Threads parallel ausgeführt werden, um die vorhandene Rechenpower besser auszunutzen.

## Aufgaben

###1. Die Klasse `ParallelSummer`
Vervollständige zuerst die Klasse `ParallelSummer`. Diese soll einen Thread repräsentieren, der das als Attribut gespeicherte `array` von Index `lowerBound` (inklusive) zu Index `upperBound` (exklusive) summiert und das Ergebnis in sein Attribut `result` speichert, sobald er ausgeführt wird (keine Prüfung, ob die Bounds auch innerhalb der Array-Grenzen liegen, nötig!).

###2. Die Methode `sumParallel`
Vervollständige nun im Template noch die Methode `sumParallel`. Diese soll die Summation des übergebenen Arrays auf `threadCount` Threads (genauer: `ParallelSummer`s) verteilen, die alle einen (etwa) gleichgroßen Teil des Arrays summieren sollen. Danach soll die Methode die einzelnen Zwischenergebnisse alle zu einem Endergebnis aufsummieren und dieses zurückgeben.

###3. Den Code Ausführen
Teste nun mithilfe des Codes in der im Template vorgegebenen `main()`-Methode deine Implementierung. Die `main()`-Methode summiert mittels `sumParallel` ein Array mit einer Milliarde einträgen und misst die dabei verstrichene Zeit (mithilfe der Methode [`System.currentTimeMillis()`](https://currentmillis.com/tutorials/system-currentTimeMillis.html)). Verändere nun die Anzahl an verwendeten Threads und beobachte, wie sich die Rechenzeit dabei verändert. Versuche dabei herauszufinden

1. ob du ""korrekt"" parallelisierst, also ob mit mehreren Threads die Berechnung tatsächlich schneller ist, als mit nur einem (wenn du z.B. die Threads nacheinander laufen lässt, also wartest, bis ein Thread zu Ende gelaufen ist, ehe du den nächsten startest, wird es logischerweise keinerlei Zeitersparnis geben) und
2. mit wie vielen Threads die Berechnung am schnellsten ist. 

Stelle den `threadCount` auch auf `10_000` und beobachte nun die benötigte Rechenzeit. Wie erklärst du dir das?

[task][Test, ob Summierung korrekt funktioniert]( 185977 )
Dieser Test prüft nur, ob die Summe korrekt berechnet wird und zwar unabhängig vom `threadCount`. Ob auch ""sinnvoll"" parallelisiert wurde (als z.B. nicht einfach alle Threads hintereinander ausgeführt werden, ohne dass je Berechnungen parallel stattfinden) musst du selbst überprüfen, indem du die Zeit misst, die deine Implementierung mit einem vs. mit mehreren Threads für die Berechnung der Summe benötigt."
299,Praktikum: Grundlagen der Programmierung WS23/24,12580,W11H01 Parallele Baumsumme,"> Bei dieser Aufgabe sind die Fehlermeldungen etwas detaillierter und es gibt mehr Hinweise als sonst. Das soll dir den Einstieg erleichtern.
Versuche aber die Aufgabe möglichst ohne die Hinweise zu bearbeiten. Durch Ausprobieren lernst du viel besser! 
Erst wenn du dir sicher bist, dass du nicht mehr vorankommst, sollst du die Hilfestellungen nutzen.

> Bitte gib uns danach Feedback, ob dieses Format für dich hilfreich ist!

 

> Auch neu: Wilkommen im Battle: Studenten vs Tutoren - Glückwunsch, 2 haben es geschafft!

> Hier ein Counter, wie viele Studenten schneller waren als der schnellste Tutor (beim ersten Versuch der Bearbeitung)

> 4

> Momentane Bestzeit Tutoren: 27 min

> Momentane Bestzeit Studenten: 20 min

> Wichtig: diese Zeiten sind nicht unsere Erwartungen an euch in der ÜPA

In dieser Aufgabe wollen wir die Summe über einen Baum berechnen. 
Zur Vereinfachung lassen wir die Wrapper-Klasse weg und arbeiten 
direkt mit den Knoten, wie sie in der `Node` Klasse definiert sind. In 
der Klasse `Main` ist Code gegeben, mit dem du testen kannst. Diesen musst
du natürlich für unterschiedliche Fälle anpassen z.B. um mit einer
anderen Anzahl an Threads zu arbeiten.

Zuerst berechnen wir die Summe ohne Threads. Diesmal verwenden
wir für die Kinderknoten `Optional` Typen, damit sie keinen `null`-Wert
haben müssen. Ansonsten ändert sich nichts.

Danach werden wir in 'SumThread' die Berechnung parallelisieren. Das Ergebnis
wird im Feld `sum` gespeichert. Wenn wir den Thread erstellen, beginnen wir ohne ein Teilergebnis. Deswegen ist auch dieses Feld vom Typ `Optional`.

Dabei werden wir die Gesamtanzahl begrenzen. Deswegen wird jeder `SumThread` mit 
    `remainingThreads` initialisiert. Dieser beschreibt die Anzahl der Threads in dieser 
Teilberechnung, inklusive des Threads, der aktuell gestartet wird.
## Aufsummieren ohne Parallelisierung

1. [task][Implementiere sum]( 186686 )
Implementiere die Methode `public int sum()` in der Klasse `Node`.


 
 Hinweise: Falsches Ergebnis 
    Stelle sicher, dass du den eigenen Wert von einem Knoten zu der Summe hinzufügst.
 
 
 Hinweise: NoSuchElementException 
    Die Kinderknoten sind vom Typ `Optional`. Diese können auch `empty` sein. Überprüfe, ob ein Wert vorhanden ist.
 

## Parallelisierung

2. [task][Implementiere den Konstruktor]( 186679 )
Implementiere den Konstruktor `public SumThread(Node node, int remainingThreads)` in der Klasse `SumThread`. Initialisiere die Attribute `sum`, `node` und `remainingThreads` mit sinnvollen Werten. Mit den Threads soll in diesem Schritt noch nichts passieren. 


3. [task][Implementiere leftThreadCount()]( 186689 )
Implementiere die Methode `protected int leftThreadCount()` in der Klasse `SumThread`. Sie soll die Anzahl der verbleibenden Threads für den **linken** Teilbaum berechnen. Die Threads werden noch nicht gestartet. Falls es einen rechten und linken Teilbaum gibt, soll die Anzahl an Threads möglichst gleichmäßig auf beide Teilbäume aufgeteilt werden. Wenn beide Teilbäume existieren und die Threads nicht gleichmäßig aufgeteilt werden können, soll die rechte Seite einen Thread mehr zugeteilt bekommen als die linke Seite. Wenn ein Teilbaum leer ist, werden für diesen keine Threads reserviert. 


 
 Hinweise: Falsches Ergebnis 
   Denke an den aufrufenden Thread im aktuellen Schritt. Diesen kannst du nicht in die Aufteilung miteinrechnen.
 


4. [task][Implementiere startChildThreads()]( 186681 )
Implementiere die Methode `protected void startChildThreads()` in der Klasse `SumThread`. Berechne dafür zuerst die Anzahl der Threads für den rechten Teilbaum und erzeuge neue `SumThread`s für die Teilbäume. Achte auf die Mitgabe des richtigen `Node`s und der richtigen Anzahl an Threads für den jeweiligen Teilbaum. Rufe auf den neu erzeugten `SumThread`s die Methode `start()` auf. Die Methode soll auch funktionieren, wenn einer der zwei Teilbäume leer ist. 


 
 Hinweis 
  Könnte dein rechter Teilbaum leer sein? 
 


5. [task][Implementiere run()]( 186684 )
Implementiere die Methode `public void run()` in der Klasse `SumThread`. Falls es keinen Thread für den Teilbaum gibt, der Teilbaum aber existiert, soll die Summe von diesem Teilbaum ohne Threads berechnet werden. Ansonsten erhälst du den Wert aus dem zugehörigen Thread. Speichere dein Endergebnis wieder in dem Attribut `sum` des aktuellen Nodes. 

 
 Hinweise zur Implementierung 
 
  Vergess nicht, die Threads erst zu starten! 
  Um ohne Threads zu summieren, steht `Node.sum` bereits zur Verfügug.  
  Denk daran, dass du warten musst, bis die Kinderthreads fertig sind.  
  Beachte, dass `SumThread.sum` vom Typ `Optional ` ist.  
 
 



## Freies Spiel
Glückwunsch, dass du es so weit geschafft hast. Der Rest dieser Aufgabe ist zum freien
Experimentieren da, und es gibt keine automatisierte Tests dazu. 

Jetzt kannst du dir wieder die `Main`-Klasse 
anschauen und die Laufzeiten vergleichen. Experimentiere mit unterschiedlichen Baumgrößen.
Ab wann lohnt sich der Verwaltungsaufwand für die Parallelisierung? 

Um dir einen besseren Überblick zu schaffen, kannst du die `Main`-Klasse mit einer Methode ergänzen,
die als Parameter die Anzahl der Threads und die Baumgröße entgegennimmt und die Bearbeitungsdauer 
zurückgibt. 

Überlege dir als letztes, ob die gegebene Anzahl an Threads immer erzeugt wird. Kannst du einen Baum konstruieren, in dem 
es möglichst ineffizient läuft? Wie vergleichen sich die Zeiten jetzt?"
299,Praktikum: Grundlagen der Programmierung WS23/24,12581,W11H02 - Parallel PinguMath,"# Parallel PinguMath

Seit du unseren Partnern der PUM dabei geholfen und mit deinem Binomial Heap die Administration wieder auf Vordermann gebracht hast, haben sie endlich wieder Zeit für Forschung. Die forschenden Pinguine haben beim Mittagessen in der Mensa mitbekommen, dass du schon Erfahrungen mit Pageranking für die PPL gesammelt hast. Sie erklären dir, dass man mit einem alternativen Ansatz das Pageranking berechnen kann, genauer gesagt, mit einer quadratischen Matrix ([Google Matrix](https://en.wikipedia.org/wiki/Google_matrix)). Weil du dich aktuell in deinem Studium mit Multithreading auseinandersetzt, fragst du dich, wie du Threads dazu nutzen könntest, um Standard-Operationen effizienter zu berechnen. Um dich erstmal auf das Multithreading zu fokussieren, beschränkst du dich ausschließlich auf quadratische Matrizen, bei denen die Dimension eine 2er-Potenz ist.

**Hinweis 1:** Sowohl bei der Addition als auch bei der Multiplikation soll das Ergebnis in einer neuen `SquareMatrix` zurückgegeben werden. Die beiden Matrizen die addiert bzw. multipliziert werden, dürfen nicht verändert werden. 
**Hinweis 2:** Die beiden Methoden `resetThreadCount` und `getThreadCount` von `AddComputeThread` und `MulComputeThread` dürfen von deiner Implementierung nicht aufgerufen werden. Generell gilt: Wird der `computeThreadCounter` in irgend einer Form manipuliert (abgesehen vom vorgegebenen Inkrement im jeweiligen Konstruktor), wird die Abgabe ohne Ausnahmen mit 0P bewertet. 
**Tipp:** In der Klasse `Playground` findest du eine Methode zum Plotten der Rechenzeit. Es lohnt sich durchaus, ein wenig mit der Größe der Matrizen oder dem Threshold `minDim` zu spielen, um ein Gefühl zu entwickeln, wie viel schneller eine parallele Implementierung sein kann, aber auch wie viel Overhead das Erstellen neuer Threads verursachen kann. Punkte gibt es dafür aber natürlich keine.
**Tipp:** Solltest du bereits vor deinem Tutorium mit der Aufgabe beginnen wollen, war unsere Ehren-Pinguin-Tutorin Lara so lieb und hat euch ein kleines Erklärvideo zu dieser Aufgabe erstellt. Sollten dennoch Fragen zur Mathematik offen geblieben sein antworten wir euch wie immer in Zulip! [Hier geht's zum Video von Lara](https://www.youtube.com/watch?v=FW-qbvLgLNA)

## SquareMatrix
Die Klasse `SquareMatrix` stellt dir alle Funktionen zur Verfügung, die du für diese Aufgabe benötigst. Einige davon kannst du auch hervorragend zum Testen deiner Implementierung nutzen. Hier eine Kurzbeschreibung der Methoden, genaueres findest du in den Kommentaren der Implementierung. **WICHTIG:** Die Klasse zu Verändern ist ausdrücklich verboten.
-	`SquareMatrix(int n)` erstellt eine Matrix von Dimension n x n und füllt diese mit  0 -en
-	`SquareMatrix(SquareMatrix M11, SquareMatrix M12, SquareMatrix M21, SquareMatrix M22)` erstellt eine Matrix aus den vier übergebenen Blockmatrizen. Beispiel: $$ newSquareMatrix = \begin{pmatrix}M\_{11}  & M\_{12} \\\ M\_{21} & M\_{22} \end{pmatrix} $$
-	`SquareMatrix(BigInteger[][] values)` erstellt eine Matrix und füllt diese mit den übergebenen Werten. Beispiel: $$ newSquareMatrix \begin{bmatrix}\begin{bmatrix} v\_1 & v\_2 \end{bmatrix} \\\ \begin{bmatrix} v\_3 & v\_4 \end{bmatrix} \end{bmatrix} = \begin{pmatrix} v\_1 & v\_2 \\\  v\_3 & v\_4 \end{pmatrix} $$
-	`getDimension()` gibt die Dimension der Matrix zurück
-	`get(int i, int j)` gibt den Wert der Position (i, j) zurück. Beispiel: $$ M = \begin{pmatrix} a\_{1\:1} & \dots & a\_{1\:dim} \\\ \vdots & a\_{i\:j} & \vdots \\\  a\_{dim\:1} & \dots & a\_{dim\:dim} \end{pmatrix} $$
-	`set(int i, int j, BigInteger newValue)` setzt den neuen Wert der Position (i, j)
-	`getQuadrant(int i, int j)` gibt die Blockmatrix der Position (i, j) zurück
-	`setQuadrant(int i, int j, quadrant)` ersetzt die Blockmatrix an Position (i, j)
-	`negate()` negiert jeden Eintrag der Matrix
-	`transpose()` transponiert die Matrix
-	`equals()` vergleicht zwei Matrizen
-	`toString()` gibt eine Stringrepräsentation der Matrix zurück
-	`generateRandomMatrix(int n)` erstellt eine Matrix von Dimension n und füllt diese mit Zufallszahlen
-	`generateRandomMatrix(int n, Random rnd)` erstellt eine Matrix von Dimension n und füllt diese mit Zufallszahlen, die vom übergebenen Random generiert werden

##SquareMatrixAdd & AddComputeThread
1. [task][addSequential]( 186740 , 186735 , 186732 )
Eine sehr schwierige Aufgabe: In der Klasse `SquareMatrixAdd` ist die Methode `addSequential` vorgegeben. In dieser Teilaufgabe musst du nichts programmieren. Du siehst hier nur ob du ausversehen die vorgegebene Implementierung ""kaputt"" gemacht hast.

2. [task][addParallel]( 186738 , 186736 , 186737 , 186742 , 186728 )
In der Klasse `SquareMatrixAdd` soll die Methode `addParallel(SquareMatrix A, SquareMatrix B, int minDim)` implementiert werden. Diese soll die Addition von zwei Matrizen realisieren. Sollten die zwei Matrizen nicht addiert werden können, muss eine `IllegalArgumentException` mit einer entsprechenden Nachricht("" A⎵can⎵not⎵be⎵null "", "" B⎵can⎵not⎵be⎵null "" oder "" A⎵and⎵B⎵have⎵different⎵dimensions "") geworfen werden. Das Argument `minDim` ist nach unten durch die Konstante `MIN_DIM` beschränkt, d.h. ist `minDim` kleiner als die untere Schranke, soll statt dessen der Wert von `MIN_DIM` genutzt werden. **WICHTIG:** der Wert von `MIN_DIM` darf von euch nicht verändert werden. 
Die Idee der Implementierung ist es, rekursiv Threads zu erzeugen, die jeweils die Addition einer der vier Blockmatrizen (Quadranten) übernimmt. Dies geschieht solange, bis die Dimension der Matrizen kleiner gleich unserem Threshold `minDim` bzw. `MIN_DIM` ist. Sobald die Dimension unseren Threshold erreicht hat, wird der vorgegebene sequentielle Ansazt zur Berechnung der Addition verwendet (siehe `SquareMatrixAdd.addSequential`). 
Die zu erzeugenden Threads (`AddComputeThread`) musst du natürlich noch vervollständigen. Der Konstruktor von `AddComputeThread` erwartet als Argumente eine `threadID`. Diese gibt den Index im `results` Array an, an dem nach der Berechnung des Threads das Ergebnis erwartet wird. Die Argumente `A` und `B` sind die beiden zu addierenden Matrizen und `minDim` der zuvor behandelte Threshold. Wird der Thread gestartet, soll dieser wenn nötig/erlaubt neue `AddComputeThreads` für jeden der vier Quadranten von `A`/`B` erstellen, um die Addition der Quadranten in den neuen Threads zu berechnen. (**Tipp:** `SquareMatrix.getQuadrant` gibt dir die entsprechenden Blockmatrizen zurück.) Final müssen diese Teilergebnisse noch zu einer Ergebnis-Matrix kombiniert werden, dazu bietet dir `SquareMatrix` einen passenden Konstruktor bereit. 
Hier ein kleines Beispiel zur Addition mit Blockmatrizen: 
$$ \text{Seien } A\_{ij}, B\_{ij}, C\_{ij} \in \mathbb{Z}^{2^n\times 2^n}, i,j \in \\{1, 2 \\}, n \in \mathbb{N}^{+} , A + B = C .\text{ Seien des weiteren A, B und C wie folgt in Blockmatrizen unterteilt: } A = \begin{pmatrix} A\_{11} & A\_{12} \\\ A\_{21} & A\_{22} \end{pmatrix}, B = \begin{pmatrix} B\_{11} & B\_{12} \\\ B\_{21} & B\_{22} \end{pmatrix} \text{ und } C = \begin{pmatrix} C\_{11} & C\_{12} \\\ C\_{21} & C\_{22} \end{pmatrix}.  \text{ Es gilt dann: } A + B = \begin{pmatrix} A\_{11} & A\_{12} \\\ A\_{21} & A\_{22} \end{pmatrix} + \begin{pmatrix} B\_{11} & B\_{12} \\\ B\_{21} & B\_{22} \end{pmatrix} = \begin{pmatrix} A\_{11} + B\_{11} & A\_{12} + B\_{12} \\\ A\_{21} + B\_{21} & A\_{22} + B\_{22} \end{pmatrix} = \begin{pmatrix} C\_{11} & C\_{12} \\\ C\_{21} & C\_{22} \end{pmatrix} = C. \text{ Also gilt: } C\_{ij} = A\_{ij} + B\_{ij} $$

3. [task][mulSequential]( 186743 , 186727 , 186734 )
In der Klasse `SquareMatrixMul` soll die Methode `mulSequential(SquareMatrix A, SquareMatrix B)` implementiert werden. Diese soll die Multiplikation von zwei Matrizen realisieren. Sollten die zwei Matrizen nicht multipliziert werden können, muss eine `IllegalArgumentException` mit einer entsprechenden Nachricht("" A⎵can⎵not⎵be⎵null "", "" B⎵can⎵not⎵be⎵null "" oder "" A⎵and⎵B⎵have⎵different⎵dimensions "") geworfen werden. 
Für die sequentielle Implementierung, reich der naive Ansatz, den du bereits aus der Vorlesung oder Schule kennst: 
$$ \text{Seien } A, B, C \in \mathbb{Z}^{2^n\times 2^n}, n \in \mathbb{N}\_0 \text{ mit } A = (a\_{ij}), B = (b\_{jk}), C = (c\_{ik}) \text{ Matrizen, dann kann das Produkt } A\cdot B = C \text{ mit folgender Formel berechnet werden: } c\_{ik} = \sum\_{j=1}^{2^n} a\_{ij} \cdot b\_{jk} $$

4. [task][mulParallel]( 186741 , 186739 , 186710 , 186713 , 186724 )
In der Klasse `SquareMatrixMul` soll die Methode `mulParallel(SquareMatrix A, SquareMatrix B, int minDim)` implementiert werden. Diese soll die Multiplikation von zwei Matrizen realisieren. Sollten die zwei Matrizen nicht multipliziert werden können, muss eine `IllegalArgumentException` mit einer entsprechenden Nachricht("" A⎵can⎵not⎵be⎵null "", "" B⎵can⎵not⎵be⎵null "" oder "" A⎵and⎵B⎵have⎵different⎵dimensions "") geworfen werden. Das Argument `minDim` ist nach unten durch die Konstante `MIN_DIM` beschränkt, d.h. ist `minDim` kleiner als die untere Schranke, soll statt dessen der Wert von `MIN_DIM` genutzt werden. **WICHTIG:** der Wert von `MIN_DIM` darf von euch nicht verändert werden. 
Die Idee der Implementierung ist es rekursiv Threads zu erzeugen, die jeweils die Multiplikation von Blockmatrizen (Quadranten) übernimmt. Dies geschieht solange, bis die Dimension der Matrizen kleiner gleich unserem Threshold `minDim` bzw. `MIN_DIM` ist. Sobald die Dimension unseren Threshold erreicht hat, wird der sequentielle Ansatz zur Berechnung der Multiplikation verwendet (siehe `SquareMatrixMul.mulSequential`). 
Die zu erzeugenden Threads (`MulComputeThread`) musst du natürlich noch vervollständigen. Der Konstruktor von `MulComputeThread` erwartet als Argumente eine `threadID`. Diese gibt den Index im `results` Array an, an dem nach der Berechnung des Threads das Ergebnis erwartet wird. Die Argumente `A` und `B` sind die beiden zu multiplizierenden Matrizen und `minDim` der zuvor behandelte Threshold. Im Gegensatz zur Blockmatrix Addition gestaltet sich die Multiplikation etwas komplexer, aber keine Sorge wir gehen das Verfahren Schritt für Schritt durch. Es ist nicht notwendig, dass du verstehst, wieso es funktioniert. 
$$ \text{Seien } A\_{ij}, B\_{ij}, C\_{ij} \in \mathbb{Z}^{2^n\times 2^n}, i,j \in \\{1, 2 \\}, n \in \mathbb{N}^+ \text{ Blockmatrizen von } A = \begin{pmatrix} A\_{11} & A\_{12} \\\ A\_{21} & A_{22} \end{pmatrix}, B = \begin{pmatrix} B\_{11} & B\_{12} \\\ B\_{21} & B\_{22} \end{pmatrix} \text{ und } C = \begin{pmatrix} C\_{11} & C\_{12} \\\ C\_{21} & C\_{22} \end{pmatrix}. \text{ Wir möchten das Produkt } C = A \cdot B \text{ berechnen. Dazu bestimmen wir zunächst die Zwischenergebnisse: } \\\ R\_1 = A\_{11} \cdot B\_{11}, \\\ R\_2 = A\_{12} \cdot B\_{21}, \\\ R\_3 = A\_{11} \cdot B\_{12}, \\\ R\_4 = A\_{12} \cdot B\_{22}, \\\ R\_5 = A\_{21} \cdot B\_{11}, \\\ R\_6 = A\_{22} \cdot B\_{21}, \\\ R\_7 = A\_{21} \cdot B\_{12}, \\\ R\_8 = A\_{22} \cdot B\_{22} \\\ \text{Für die Blockmatrizen von C gilt dann: } \\\ C\_{11} = R\_1 + R\_2, \\\ C\_{12} = R\_3 + R\_4, \\\ C\_{21} = R\_5 + R\_6, \\\ C\_{22} = R\_7 + R\_8 \\\ \text{Die vollständige Berechnung sieht also wie folgt aus: } \\\ C = A \cdot B = \begin{pmatrix} A\_{11} & A\_{12} \\\ A\_{21} & A\_{22} \end{pmatrix} \cdot \begin{pmatrix} B\_{11} & B\_{12} \\\ B\_{21} & B\_{22} \end{pmatrix} = \begin{pmatrix} A\_{11} B\_{11} + A\_{12} B\_{21} & A\_{11} B\_{12} + A\_{12} B\_{22} \\\ A\_{21} B\_{11} + A\_{22} B\_{21} & A\_{21} B\_{12} +  A\_{22} B\_{22}\end{pmatrix} = \begin{pmatrix} C\_{11} & C\_{12} \\\ C\_{21} & C\_{22} \end{pmatrix} = C $$ 
Wie du siehst, benötigst du erneut die Matrixaddition. Dazu musst du erneut deine Implementierung von `addParallel` verwenden. Der Aufruf soll mit dem selben Wert von `minDim` erfolgen.

[Lösungsvorschlag](https://bitbucket.ase.in.tum.de/projects/PGDP2324W11H02/repos/pgdp2324w11h02-solution/browse) 
[Tests](https://bitbucket.ase.in.tum.de/projects/PGDP2324W11H02/repos/pgdp2324w11h02-tests/browse)"
299,Praktikum: Grundlagen der Programmierung WS23/24,12585,W11H03 - PinguChat,"# PinguChat

Einige Pinguine haben sich entschieden, etwas Zeit bei uns an der Universität zu verbringen. 
Um mit ihren Freunden und Kollegen an der PUM weiter Kontakt halten zu können, möchten sie ein Chatprogramm entwickeln.  
Der Ping-uin Jeff und der PinGUIn GUIseppe haben bereits den Server und die Benutzeroberfläche entwickelt. 
Da sie aber jetzt mit dem Umzug beschäftigt sind, brauchen sie deine Hilfe, um das Backend zu vervollständingen


##  Hinweise 

* Eure Nachrichten sind unverschlüsselt gespeichert, passt also auf was ihr schreibt.
* Wenn Netzwerkoperationen Exceptions werfen, darf euer Programm abstürzen.
* Eine Version des Servers zur lokalen benutzung findet ihr [hier](https://bitbucket.ase.in.tum.de/projects/PGDP2223W11H03/repos/pgdp2223w11h03-server)
* Der Server ist erreichbar unter `pgdp.pl.cit.tum.de`
    * Der Server ist nur aus dem Uninetz erreichbar.
    * Man muss also mit eduroam oder eine Netzwerkdose im Universitätsnetz verbunden sein.
    * Alternativ kann man sich über [EduVPN](https://doku.lrz.de/vpn-eduvpn-installation-und-konfiguration-11491448.html) mit dem Uninetz verbinden.
* Alle zu bearbeitenden Methoden sind mit TODO gekennzeichnet.
* Nützliche Links:
    * [Netcat](https://wiki.ubuntuusers.de/netcat/) ist ein Linux Werkzeug zum Testen von Socket-Verbindungen.
    * [BurpSuite](https://portswigger.net/burp/communitydownload) ist ein Werkzeug zum Untersuchen von Verbindungen mit Websiten.
    * https://de.wikipedia.org/wiki/Byte-Reihenfolge
* Die spitzen Klammern in den Beschreibungen der Bodies der Server-Antworten und das, was dazwischen steht, werden dann selbstverständlich durch den jeweils von Server berechneten String ersetzt.
* Damit ihr nicht ungewollt mit Nachrichten überflutet werdet, muss man sich erst auf Öffentlich setzen um mit anderen zu schreiben. 
Das geht, indem ihr euch [hier](http://carol.sse.cit.tum.de/docs) anmeldet und an der Schnittstelle `/api/user/me/setpublic` über `Try Out` den `boolean` auf `true` setzt und anschließend `Execute` auswählt. 
Nun könnt ihr mit allen anderen öffentlichen Nutzern chatten.
* Das aktuelle Template findet ihr [hier](https://bitbucket.ase.in.tum.de/scm/PGDP2324W11H03/pgdp2324w11h03-exercise.git)

## API über HTTP:

[HTTP](https://de.wikipedia.org/wiki/Hypertext_Transfer_Protocol) ist ein häufig genutztes Protokoll zur Datenübertragung in einem Rechnernetz - also eine Reihe von Konventionen, wie Anfragen und Antworten der Kommunikation auszusehen haben u.Ä.
Für diese Aufgabe müsst ihr HTTP nicht verstehen. Das Anfragen Erstellen und Empfangen ist bereits für euch übernommen worden. Hier werden die Java-eigenen Klassen/Interfaces [HttpRequest](https://docs.oracle.com/en/java/javase/17/docs/api/java.net.http/java/net/http/HttpRequest.html) - modelliert eine Anfrage an den Server - und [HttpResponse](https://docs.oracle.com/en/java/javase/17/docs/api/java.net.http/java/net/http/HttpResponse.html) - modelliert die Antwort des Servers - verwendet.
Ihr müsst dann lediglich mittels der beiden Methoden `HttpResponse.statusCode()` und `HttpResponse.body()` den Status und Inhalt der Antwort wie jeweils unten beschrieben weiterverarbeiten.
Den Inhalt bekommt ihr als `String` im JSON-Format. Wenn ihr wollt, dürft ihr zu dessen Verarbeitung auch Libraries wie `org.json.*` importieren und verwenden. `JSONArray` und `JSONObject` aus dieser Library sind für euch bereits in `DataHandler` importiert worden. Ihr dürft die `String`s aber auch gerne per Hand bearbeiten. Das ist halt im Zweifelsfall etwas zeitaufwändiger und fehleranfälliger.

Ihr findet eine ausführlich Dokumentation der API mit Möglichkeiten zum Ausprobieren [hier](http://carol.sse.cit.tum.de/docs) (wenn der Link nicht funktioniert, siehe oben). 
Hier findet ihr auch nochmal alle Informationen, wie die Header und Körper von Anfragen auszusehen haben. Das Wichtigste ist aber in den Beschreibungen der einzelnen Methoden unten für euch aufgelistet. 
Hier könnt ihr auch Anfragen ausprobieren und die Antworten sehen.

### register

Die `register` Methode soll eine Anfrage auslösen, welche einen Nutzer für euch in der Datenbank des Servers anlegt. 
Falls ihr euer Passwort vergessen habt, kann diese Funktion auch genutzt werden, um euch ein neues Passwort zu erstellen. 
Das Passwort schickt der Server dann an eure TUM Email Adresse. 
Hierzu müsst ihr eine Anfrage an den `/api/users/register` Endpunkt stellen und den `register` übergebenen Nutzernamen und die TUM-Kennung mitschicken.

Das Schicken der Anfrage und Holen der Antwort ist bereits für euch implementiert worden. Die Antwort des Servers kommt in einer von zwei Formen:

 
 
Wenn die Anfrage erfolgreich war:
 
 Status-Code:  200 
 Body: 
```
{
  ""username"": "" "",
  ""id"":  
}
```
 
 
 
Wenn die Anfrage *nicht* erfolgreich war:
 
 Status-Code:  422 
 Body: 
```
{
  ""detail"": [
    {
      ""loc"": [
        "" "",
         
      ],
      ""msg"": "" "",
      ""type"": "" ""
    }
  ]
}
```
 

Alles, was ihr tun müsst, ist, genau dann `true` zurückzugeben, wenn die Anfrage erfolgreich war, sonst `false`.



### requestToken

Um sich in Anfragen an die API authentifizieren zu können, braucht man einen Token. 
Diesen erhält man, wenn man seinen Nutzernamen und Passwort an den `/token` Endpunkt der API übergibt. 
Der Token, welchen man zurück erhält, ist jedoch nur für begrenzte Zeit gültig.
Die `requestToken` Methode übernimmt das Anfragen dieses Tokens.

Das Schicken der Anfrage und Holen der Antwort ist bereits für euch implementiert worden. Die Antwort des Servers kommt in einer von zwei Formen:

 
 
Wenn die Anfrage erfolgreich war:
 
 Status-Code:  200 
 Body: 
```
{
  ""access_token"": "" "",
  ""token_type"": "" ""
}
```
 
 
 
Wenn die Anfrage *nicht* erfolgreich war:
 
 Status-Code:  422 
 Body: 
```
{
  ""detail"": [
    {
      ""loc"": [
        "" "",
         
      ],
      ""msg"": "" "",
      ""type"": "" ""
    }
  ]
}
```
 

Wenn die Anfrage erfolgreich war, sollt ihr nun den Token aus der Antwort auslesen und zurückgeben. Die Art des Tokens ist dabei irrelevant. Wenn die Anfrage erfolglos blieb, soll `null` zurückgegeben werden.



### login

In der `login` Methode sollt ihr zuerst einen Token mit dem übergebenen Nutzernamen und Passwort anfragen.
Falls diese Anfrage erfolgreich ist, werden im `DataHandler` die entsprechenden Klassenattribute gesetzt und die Nutzer ID vom `/api/user/me/` Endpunkt erfragt. 

Das Schicken der Anfrage und Holen der Antwort ist bereits für euch implementiert worden. Die Antwort des Servers kommt in einer von zwei Formen:

 
 
Wenn die Anfrage erfolgreich war:
 
 Status-Code:  200 
 Body: 
```
{
  ""username"": "" "",
  ""id"":  
}
```
 
 
 
Wenn die Anfrage *nicht* erfolgreich war:
 
 Status-Code:  422 
 Body: 
```
{
  ""detail"": [
    {
      ""loc"": [
        "" "",
         
      ],
      ""msg"": "" "",
      ""type"": "" ""
    }
  ]
}
```
 

Wenn hier nun die Anfrage erfolgreich war, soll die ID in das entsprechende Attribut des `DataHandler`s geschrieben werden.
Insgesamt soll die Methode genau dann `true` zurückgeben, wenn der gesamte Login erfolgreich war.



### getContacts

Um die verfügbaren Kontakte zu erhalten, gibt es den Endpunkt `/api/users`. 
Dieser gibt alle auf öffentlich gestellten Nutzer zurück. 
Nutzt diesen Endpunkt, um eine `Map` mit den Nutzer IDs als Schlüssel und Nutzerobjekten zurückzugeben.

Das Schicken der Anfrage und Holen der Antwort ist bereits für euch implementiert worden. Die Antwort des Servers kommt in einer von zwei Formen:

 
 
Wenn die Anfrage erfolgreich war:
 
 Status-Code:  200 
 Body: 
```
[
  {
    ""username"": "" "",
    ""id"":  
  },
  {
    ""username"": "" "",
    ""id"":  
  },
  ...
  {
    ""username"": "" "",
    ""id"":  
  }
]
```
 
 
 
Wenn die Anfrage *nicht* erfolgreich war:
 
 Status-Code:  422 
 Body: 
```
{
  ""detail"": [
    {
      ""loc"": [
        "" "",
         
      ],
      ""msg"": "" "",
      ""type"": "" ""
    }
  ]
}
```
 

Aus dieser Antwort sollt ihr nun, wenn die Anfrage erfolgreich war, die entsprechende `Map` bauen.



### getMessages

Die vergangenen Nachrichten einer Unterhaltung kann man mit dem Endpunkt `/api/messages/with/` laden. 
Dieser Endpunkt unterstützt auch das Unterteilen der Antwort. So kann man zum Besipiel nur 50 Nachrichten auf einmal laden. 
Ihr sollt hier die Nachrichten mit dem Nutzer mit der ID `id` als Liste zurückgeben beschränkt auf die in `count` übergebene Anzahl und die Seite `page`.

Das Schicken der Anfrage und Holen der Antwort ist bereits für euch implementiert worden. Die Antwort des Servers kommt in einer von zwei Formen:

 
 
Wenn die Anfrage erfolgreich war:
 
 Status-Code:  200 
 Body: 
```
[
  {
    ""from_id"":  ,
    ""to_id"":  ,
    ""text"": "" "",
    ""id"":  ,
    ""time"": "" ""
  },
  {
    ""from_id"":  ,
    ""to_id"":  ,
    ""text"": "" "",
    ""id"":  ,
    ""time"": "" ""
  },
  ...
  {
    ""from_id"":  ,
    ""to_id"":  ,
    ""text"": "" "",
    ""id"":  ,
    ""time"": "" ""
  }
]
```
 
 
 
Wenn die Anfrage *nicht* erfolgreich war:
 
 Status-Code:  422 
 Body: 
```
{
  ""detail"": [
    {
      ""loc"": [
        "" "",
         
      ],
      ""msg"": "" "",
      ""type"": "" ""
    }
  ]
}
```
 

Aus dieser Antwort sollt ihr nun, wenn die Anfrage erfolgreich war, die entsprechende `List` bauen.

Um das Datum in das geforderte `LocalDateTime`-Objekt umzuwandeln, sollt ihr die Methode `LocalDateTime.parse()` verwenden.







## Socket

Um einen schnellen Austausch von Nachrichten zu ermöglichen, unterstützt unser Server auch eine direkte Socket Verbindung auf Port 80. 
Zum Lesen und Schreiben von und zu dem Socket benutzen wir hier nicht wie in der Zentralübung `BufferedReader` und `PrintWriter`, sondern die beiden Klassen `DataInputStream` und `DataOutputStream` (siehe die Attribute `in` und `out` der Klasse `DataHandler`). `DataInputStream.read(byte[])` und `DataOutputStream.write(byte[])` übernehmen dabei jeweils ein `byte`-Array als Parameter. Erstere füllt das übergebene Array mit den vom Server erhaltenen Bytes, letztere schickt die im übergebenen Array enthaltenen Bytes an den Server.
Im Gegensatz zur Zentralübung, in der wir Text verschickt haben, wollen wir also jetzt die genauen Bytes der Nachricht kontrollieren können. Dabei kodieren wir Nachrichten nach unserem Haus-eigenen Protokoll: dem PCP (Pingu Chat Protocol).

Die genaue Spezifikation findet ihr hier (Zahlen wie 0x2a sind genau ein Byte große = zwei Ziffern lange [Hexadezimalzahlen](https://de.wikipedia.org/wiki/Hexadezimalsystem). Der Präfix ""0x"" zeigt dabei an, dass es sich hier um eine Hexadezimalzahl handelt, die restlichen Ziffern sind die Zahl selbst. [Umrechnung](https://bin-dez-hex-umrechner.de)):
 
 
Protokoll
 
```text

Legende:
    S->C: Server schickt Nachricht an Client
    C->S: Client schickt Nachricht an Server

Nachrichtenaufbau:

Das erste Byte der Nachricht ist jeweils entweder 0x00, was für eine ""Handshake-Nachricht"" steht, oder 0x01, was für eine Text-Nachricht steht.
Handshake-Nachrichten sind zum kontrollieren der Verbindung, Text-Nachrichten schicken eine Message an einen Chat-Partner.

Handshake-Nachricht (0x00):
    
    Das zweite Byte ist eine Zahl zwischen 0x00 und 0x05 oder 0xf0, 0xf1 oder 0xff.
    Diese 9 Zahlen haben folgende Bedeutungen:
    
    0x00: Server Hello
        Die erste Nachricht, die man vom Server erhält, wenn man sich mit ihm verbindet.
        Erhält man diese Nachricht nicht zurück, weiß man,
        dass mit der Verbindung etwas schiefgelaufen ist.
        Als drittes und letztes Byte wird in diesem Fall die Versionsnummer des Servers geschickt.
        
        Beispiel-Nachricht (S->C): 0x00 0x00 0x2a
            Der Server begrüßt den Client mit seiner Versionsnummer 0x2a (= 42).
            
    0x01: Client Hello
        Diese Nachricht wird vom Server erwartet,
        sobald dieser sein Server-Hello an einen Client geschickt hat.
        Es wird kein weiteres Byte verschickt.
        
        Beispiel-Nachricht (C->S): 0x00 0x01
            Der Client begrüßt den Server bzw. bestätigt ihm den Erhalt von dessen Begrüßung.
            
    0x02: Client Identification
        Diese Nachricht sendet der Client an den Server, um sich bei ihm mit seiner ID anzumelden.
        Das dritte Byte dieser Nachricht soll eine Zahl k zwischen 1 und 8 sein,
        die die Anzahl an darauf noch folgenden Bytes ist.
        Darauf folgen dann k Bytes, die die gesamte ID des Clients enthalten.
        (Die ID wird dabei in Big-Endian-Kodierung versandt, also der uns aus Java bekannten.)
        
        Beispiel-Nachricht (C->S): 0x00 0x02 0x02 0x13 0x37
            Der Client identifiziert sich beim Server mit seiner ID 0x1337 (= 4919).
            Diese braucht 2 Bytes Platz, was im dritten Byte der Nachricht zu sehen ist.
            Man hätte die ID aber auch beispielsweise mit der Nachricht
            0x00 0x02 0x04 0x00 0x00 0x13 0x37 versenden können.
            
    0x03: Client Authentication
        Diese Nachricht sendet der Client an den Server, um sich mit dem zuvor erhaltenen Token
        zu authentifizieren. Das dritte und vierte Byte dieser Nachricht gibt die Länge k des
        Tokens an (also eine Zahl zwischen 0 und 65535), darauf folgen dann k Bytes mit dem Token.
        (Auch hier wird Big-Endian für die Kodierung verwendet.)
        
        Beispiel-Nachricht (C->S): 0x00 0x03 0x00 0x01 0x45
            Der Client authentifiziert sich beim Server mit einem Token von Länge 1B
            (siehe drittes und viertes Byte der Nachricht), nämlich dem Token 0x45.
            
    0x04: Partner Switch
        Der Client teilt dem Server mit, dass er gerne mit einem neuen Partner
        (i.d.R. anderer Client) Nachrichten austauschen würde.
        Das dritte Byte dieser Nachricht gibt die Länge 1 <= k <= 8 der ID des neuen Partners an,
        darauf folgen k Bytes ID.
        
        Beispiel-Nachricht (C->S): 0x00 0x04 0x01 0x01
            Der Client bittet den Server, ihn mit dem Client mit ID 0x01 zu verbinden.
            
    0x05: Server Acknowledge
        Diese Nachricht wird vom Server an den Client verschickt,
        wenn der Partnerwechsel stattfinden kann. Es werden hiernach keine weiteren Bytes verschickt.
        
        Beispiel-Nachricht (S->C): 0x00 0x05
            Der Server teilt dem Client mit, dass dieser nun mit seinem neuen Partner verbunden ist.
            
    0xf0: Invalid Message (S->C)
    0xf1: Authentication Failure (S->C)
    0xff: Session End (S->C)
        Auf diese letzten drei folgen keine weiteren Bytes.            
            
            
            
Text-Nachrichten (0x01):
    Nachricht an/vom Chatpartner.
    Das zweite und dritte Byte geben die Länge k der Nachricht (in Big-Endian) an,
    darauf folgen k Bytes mit der Nachricht in Byte-Form.
    
    Beispiel-Nachricht (C->S): 0x01 0x00 0x05 0x48 0x61 0x6c 0x6c 0x6f
        Der Client schickt die Nachricht ""Hallo"" (in UTF-8 Kodierung) an den Server,
        der diese dann an den aktuellen Gesprächspartner weiterleiten sollte.
        Die UTF-8 Kodierung von ""Hallo"" ist 0x05 = 5 Bytes lang und lautet 0x48 0x61 0x6c 0x6c 0x6f.
        
        
        
Handshake Struktur:
    Nach der ersten Verbindung mit dem Server (= dem Erstellen des Socket-Objektes auf Client-Seite)
    werden folgende Nachrichten in der angegebenen Reihenfolge ausgetauscht:

    Server Hello
    Client Hello
    Client Identification
    Client Authentication



Anschließend können Nachrichten wie Folgt verschickt werden:
(*: 0 oder mehr; +: 1 oder mehr; a|b: a oder b):
*{
    Partner Switch
    Server Acknowledgement
    *{
        S->C:Message|
        C->S:Message
    }
}
```

Hier eine Beispielverbindung

```text
Server Hello:
S->C: 0x00 0x00 0x2a

Client Hello:
C->S: 0x00 0x01

Client Identification:
C->S: 0x00 0x02 0x02 0x13 0x37

Client Authentification:
C->S: 0x00 0x03 0x00 0x01 0x2a

Switch Partner:
C->S: 0x00 0x04 0x01 0x01

Server Acknwoledgement:
S->C: 0x00 0x05

Nachricht von Nutzer 1 an Nutzer 0x1337:
S->C: 0x01 0x00 0x05 0x48 0x61 0x6c 0x6c 0x6f

Antwort von 0x1337 an 1:
C->S: 0x01 0x00 0x0b 0x48 0x61 0x6c 0x6c 0x6f 0x20 0x50 0x69 0x6e 0x67 0x75

Server schließt aufgrund von TimeOut
S->C: 0x00 0xff
```

 

### connect

Um den initialen Handshake mit dem Server durchzuführen, wird die `connect` Methode benutzt. 
Dazu muss zuerst ein Socket mit dem Server aufgemacht werden. 
Anschließend soll der volle Handshake wie im Protokoll beschrieben durchgeführt werden. 
Falls der Server an der entsprechenden Stelle des Handshakes nicht antwortet oder als Version nicht `0x2a` zurückgibt, soll eine `ConnectionException` geworfen werden. 
Das ist die einzige Exception, welche an die aufrufende Methode weitergegeben werden muss. Mit anderen Exceptions könnt ihr verfahren, wie ihr wollt.
Wenn der Handshake erfolgreich war, sollen die `socket`, `in` und `out` Attribute gesetzt werden.
Es soll `connected` auf `true` gesetzt werden und nun kann zum Bearbeiten der einkommenden Nachrichten die `startInputHandler` Methode aufgerufen werden.
(Diese letzten beiden Punkte sind im Template bereits für euch gemacht worden.)



### switchConnection

Mit Hilfe der `switchConnection` Methode wird ausgewählt, mit welchem Nutzer gerade gechattet werden soll. 
Falls noch keine Verbindung zum Server aufgebaut wurde, soll das zuerst geschehen. (Dies ist bereits im Template vorhanden.)
Anschließend wird gemäß des Protokols eine `Switch Partner` Anfrage gestellt. 
Da die Antworten des Servers in der `handleInput` Methode ankommen, müssen diese mit der `getResponse` Methode abgefragt werden. Der Call `getResponse(n)` gibt euch die `n` nächsten vom Server geschickten Bytes zurück.
Sollte der Server nicht mit einem `Server Acknowledge` antworten, soll eine `ConnectionException` geworfen werden. 
Im Gegensatz zu allen anderen Exceptions muss eine `ConnectionException` an die Aufrufende Funktion weitergegeben werden. Mit anderen Exceptions könnt ihr verfahren, wie ihr wollt.



### sendMessage

Die Methode `sendMessage` wandelt die übergebene Nachricht in eine Byte Sequenz um und versendet sie entsprechend des Protokolls.
(Diese Methode versendet die Message nur und überlässt dem Server den Rest. Ihr müsst hier keine Antworten empfangen oder irgendetwas dergleichen.)



# FAQ
### Q: Wofür ist das FAQ?
A: Um häufig gestellte Fragen zu sammeln. Wer trotzdem noch fragt macht Pinguine traurig."
299,Praktikum: Grundlagen der Programmierung WS23/24,12601,W11H02 - Parallel PinguMath NEW,"# Parallel PinguMath

Seit du unseren Partnern der PUM dabei geholfen und mit deinem Binomial Heap die Administration wieder auf Vordermann gebracht hast, haben sie endlich wieder Zeit für Forschung. Die forschenden Pinguine haben beim Mittagessen in der Mensa mitbekommen, dass du schon Erfahrungen mit Pageranking für die PPL gesammelt hast. Sie erklären dir, dass man mit einem alternativen Ansatz das Pageranking berechnen kann, genauer gesagt, mit einer quadratischen Matrix ([Google Matrix](https://en.wikipedia.org/wiki/Google_matrix)). Weil du dich aktuell in deinem Studium mit Multithreading auseinandersetzt, fragst du dich, wie du Threads dazu nutzen könntest, um Standard-Operationen effizienter zu berechnen. Um dich erstmal auf das Multithreading zu fokussieren, beschränkst du dich ausschließlich auf quadratische Matrizen, bei denen die Dimension eine 2er-Potenz ist.

**Hinweis 1:** Sowohl bei der Addition als auch bei der Multiplikation soll das Ergebnis in einer neuen `SquareMatrix` zurückgegeben werden. Die beiden Matrizen die addiert bzw. multipliziert werden, dürfen nicht verändert werden. 
**Hinweis 2:** Die beiden Methoden `resetThreadCount` und `getThreadCount` von `AddComputeThread` und `MulComputeThread` dürfen von deiner Implementierung nicht aufgerufen werden. Generell gilt: Wird der `computeThreadCounter` in irgend einer Form manipuliert (abgesehen vom vorgegebenen Inkrement im jeweiligen Konstruktor), wird die Abgabe ohne Ausnahmen mit 0P bewertet. 
**Tipp:** In der Klasse `Playground` findest du eine Methode zum Plotten der Rechenzeit. Es lohnt sich durchaus, ein wenig mit der Größe der Matrizen oder dem Threshold `minDim` zu spielen, um ein Gefühl zu entwickeln, wie viel schneller eine parallele Implementierung sein kann, aber auch wie viel Overhead das Erstellen neuer Threads verursachen kann. Punkte gibt es dafür aber natürlich keine.
**Tipp:** Solltest du bereits vor deinem Tutorium mit der Aufgabe beginnen wollen, war unsere Ehren-Pinguin-Tutorin Lara so lieb und hat euch ein kleines Erklärvideo zu dieser Aufgabe erstellt. Sollten dennoch Fragen zur Mathematik offen geblieben sein antworten wir euch wie immer in Zulip! [Hier geht's zum Video von Lara](https://www.youtube.com/watch?v=FW-qbvLgLNA)

## SquareMatrix
Die Klasse `SquareMatrix` stellt dir alle Funktionen zur Verfügung, die du für diese Aufgabe benötigst. Einige davon kannst du auch hervorragend zum Testen deiner Implementierung nutzen. Hier eine Kurzbeschreibung der Methoden, genaueres findest du in den Kommentaren der Implementierung. **WICHTIG:** Die Klasse zu Verändern ist ausdrücklich verboten.
-	`SquareMatrix(int n)` erstellt eine Matrix von Dimension n x n und füllt diese mit  0 -en
-	`SquareMatrix(SquareMatrix M11, SquareMatrix M12, SquareMatrix M21, SquareMatrix M22)` erstellt eine Matrix aus den vier übergebenen Blockmatrizen. Beispiel: $$ newSquareMatrix = \begin{pmatrix}M\_{11}  & M\_{12} \\\ M\_{21} & M\_{22} \end{pmatrix} $$
-	`SquareMatrix(BigInteger[][] values)` erstellt eine Matrix und füllt diese mit den übergebenen Werten. Beispiel: $$ newSquareMatrix \begin{bmatrix}\begin{bmatrix} v\_1 & v\_2 \end{bmatrix} \\\ \begin{bmatrix} v\_3 & v\_4 \end{bmatrix} \end{bmatrix} = \begin{pmatrix} v\_1 & v\_2 \\\  v\_3 & v\_4 \end{pmatrix} $$
-	`getDimension()` gibt die Dimension der Matrix zurück
-	`get(int i, int j)` gibt den Wert der Position (i, j) zurück. Beispiel: $$ M = \begin{pmatrix} a\_{1\:1} & \dots & a\_{1\:dim} \\\ \vdots & a\_{i\:j} & \vdots \\\  a\_{dim\:1} & \dots & a\_{dim\:dim} \end{pmatrix} $$
-	`set(int i, int j, BigInteger newValue)` setzt den neuen Wert der Position (i, j)
-	`getQuadrant(int i, int j)` gibt die Blockmatrix der Position (i, j) zurück
-	`setQuadrant(int i, int j, quadrant)` ersetzt die Blockmatrix an Position (i, j)
-	`negate()` negiert jeden Eintrag der Matrix
-	`transpose()` transponiert die Matrix
-	`equals()` vergleicht zwei Matrizen
-	`toString()` gibt eine Stringrepräsentation der Matrix zurück
-	`generateRandomMatrix(int n)` erstellt eine Matrix von Dimension n und füllt diese mit Zufallszahlen
-	`generateRandomMatrix(int n, Random rnd)` erstellt eine Matrix von Dimension n und füllt diese mit Zufallszahlen, die vom übergebenen Random generiert werden

##SquareMatrixAdd & AddComputeThread
1. [task][addSequential]( 187183 , 187199 , 187198 )
Eine sehr schwierige Aufgabe: In der Klasse `SquareMatrixAdd` ist die Methode `addSequential` vorgegeben. In dieser Teilaufgabe musst du nichts programmieren. Du siehst hier nur ob du ausversehen die vorgegebene Implementierung ""kaputt"" gemacht hast.

2. [task][addParallel]( 187208 , 187209 , 187185 , 187207 , 187181 )
In der Klasse `SquareMatrixAdd` soll die Methode `addParallel(SquareMatrix A, SquareMatrix B, int minDim)` implementiert werden. Diese soll die Addition von zwei Matrizen realisieren. Sollten die zwei Matrizen nicht addiert werden können, muss eine `IllegalArgumentException` mit einer entsprechenden Nachricht("" A⎵can⎵not⎵be⎵null "", "" B⎵can⎵not⎵be⎵null "" oder "" A⎵and⎵B⎵have⎵different⎵dimensions "") geworfen werden. Das Argument `minDim` ist nach unten durch die Konstante `MIN_DIM` beschränkt, d.h. ist `minDim` kleiner als die untere Schranke, soll statt dessen der Wert von `MIN_DIM` genutzt werden. **WICHTIG:** der Wert von `MIN_DIM` darf von euch nicht verändert werden. 
Die Idee der Implementierung ist es, rekursiv Threads zu erzeugen, die jeweils die Addition einer der vier Blockmatrizen (Quadranten) übernimmt. Dies geschieht solange, bis die Dimension der Matrizen kleiner gleich unserem Threshold `minDim` bzw. `MIN_DIM` ist. Sobald die Dimension unseren Threshold erreicht hat, wird der vorgegebene sequentielle Ansazt zur Berechnung der Addition verwendet (siehe `SquareMatrixAdd.addSequential`). 
Die zu erzeugenden Threads (`AddComputeThread`) musst du natürlich noch vervollständigen. Der Konstruktor von `AddComputeThread` erwartet als Argumente eine `threadID`. Diese gibt den Index im `results` Array an, an dem nach der Berechnung des Threads das Ergebnis erwartet wird. Die Argumente `A` und `B` sind die beiden zu addierenden Matrizen und `minDim` der zuvor behandelte Threshold. Wird der Thread gestartet, soll dieser wenn nötig/erlaubt neue `AddComputeThreads` für jeden der vier Quadranten von `A`/`B` erstellen, um die Addition der Quadranten in den neuen Threads zu berechnen. (**Tipp:** `SquareMatrix.getQuadrant` gibt dir die entsprechenden Blockmatrizen zurück.) Final müssen diese Teilergebnisse noch zu einer Ergebnis-Matrix kombiniert werden, dazu bietet dir `SquareMatrix` einen passenden Konstruktor bereit. 
Hier ein kleines Beispiel zur Addition mit Blockmatrizen: 
$$ \text{Seien } A\_{ij}, B\_{ij}, C\_{ij} \in \mathbb{Z}^{2^n\times 2^n}, i,j \in \\{1, 2 \\}, n \in \mathbb{N}^{+} , A + B = C .\text{ Seien des weiteren A, B und C wie folgt in Blockmatrizen unterteilt: } A = \begin{pmatrix} A\_{11} & A\_{12} \\\ A\_{21} & A\_{22} \end{pmatrix}, B = \begin{pmatrix} B\_{11} & B\_{12} \\\ B\_{21} & B\_{22} \end{pmatrix} \text{ und } C = \begin{pmatrix} C\_{11} & C\_{12} \\\ C\_{21} & C\_{22} \end{pmatrix}.  \text{ Es gilt dann: } A + B = \begin{pmatrix} A\_{11} & A\_{12} \\\ A\_{21} & A\_{22} \end{pmatrix} + \begin{pmatrix} B\_{11} & B\_{12} \\\ B\_{21} & B\_{22} \end{pmatrix} = \begin{pmatrix} A\_{11} + B\_{11} & A\_{12} + B\_{12} \\\ A\_{21} + B\_{21} & A\_{22} + B\_{22} \end{pmatrix} = \begin{pmatrix} C\_{11} & C\_{12} \\\ C\_{21} & C\_{22} \end{pmatrix} = C. \text{ Also gilt: } C\_{ij} = A\_{ij} + B\_{ij} $$

3. [task][mulSequential]( 187205 , 187191 , 187204 )
In der Klasse `SquareMatrixMul` soll die Methode `mulSequential(SquareMatrix A, SquareMatrix B)` implementiert werden. Diese soll die Multiplikation von zwei Matrizen realisieren. Sollten die zwei Matrizen nicht multipliziert werden können, muss eine `IllegalArgumentException` mit einer entsprechenden Nachricht("" A⎵can⎵not⎵be⎵null "", "" B⎵can⎵not⎵be⎵null "" oder "" A⎵and⎵B⎵have⎵different⎵dimensions "") geworfen werden. 
Für die sequentielle Implementierung, reich der naive Ansatz, den du bereits aus der Vorlesung oder Schule kennst: 
$$ \text{Seien } A, B, C \in \mathbb{Z}^{2^n\times 2^n}, n \in \mathbb{N}\_0 \text{ mit } A = (a\_{ij}), B = (b\_{jk}), C = (c\_{ik}) \text{ Matrizen, dann kann das Produkt } A\cdot B = C \text{ mit folgender Formel berechnet werden: } c\_{ik} = \sum\_{j=1}^{2^n} a\_{ij} \cdot b\_{jk} $$

4. [task][mulParallel]( 187195 , 187206 , 187200 , 187193 , 187192 )
In der Klasse `SquareMatrixMul` soll die Methode `mulParallel(SquareMatrix A, SquareMatrix B, int minDim)` implementiert werden. Diese soll die Multiplikation von zwei Matrizen realisieren. Sollten die zwei Matrizen nicht multipliziert werden können, muss eine `IllegalArgumentException` mit einer entsprechenden Nachricht("" A⎵can⎵not⎵be⎵null "", "" B⎵can⎵not⎵be⎵null "" oder "" A⎵and⎵B⎵have⎵different⎵dimensions "") geworfen werden. Das Argument `minDim` ist nach unten durch die Konstante `MIN_DIM` beschränkt, d.h. ist `minDim` kleiner als die untere Schranke, soll statt dessen der Wert von `MIN_DIM` genutzt werden. **WICHTIG:** der Wert von `MIN_DIM` darf von euch nicht verändert werden. 
Die Idee der Implementierung ist es rekursiv Threads zu erzeugen, die jeweils die Multiplikation von Blockmatrizen (Quadranten) übernimmt. Dies geschieht solange, bis die Dimension der Matrizen kleiner gleich unserem Threshold `minDim` bzw. `MIN_DIM` ist. Sobald die Dimension unseren Threshold erreicht hat, wird der sequentielle Ansatz zur Berechnung der Multiplikation verwendet (siehe `SquareMatrixMul.mulSequential`). 
Die zu erzeugenden Threads (`MulComputeThread`) musst du natürlich noch vervollständigen. Der Konstruktor von `MulComputeThread` erwartet als Argumente eine `threadID`. Diese gibt den Index im `results` Array an, an dem nach der Berechnung des Threads das Ergebnis erwartet wird. Die Argumente `A` und `B` sind die beiden zu multiplizierenden Matrizen und `minDim` der zuvor behandelte Threshold. Im Gegensatz zur Blockmatrix Addition gestaltet sich die Multiplikation etwas komplexer, aber keine Sorge wir gehen das Verfahren Schritt für Schritt durch. Es ist nicht notwendig, dass du verstehst, wieso es funktioniert. 
$$ \text{Seien } A\_{ij}, B\_{ij}, C\_{ij} \in \mathbb{Z}^{2^n\times 2^n}, i,j \in \\{1, 2 \\}, n \in \mathbb{N}^+ \text{ Blockmatrizen von } A = \begin{pmatrix} A\_{11} & A\_{12} \\\ A\_{21} & A_{22} \end{pmatrix}, B = \begin{pmatrix} B\_{11} & B\_{12} \\\ B\_{21} & B\_{22} \end{pmatrix} \text{ und } C = \begin{pmatrix} C\_{11} & C\_{12} \\\ C\_{21} & C\_{22} \end{pmatrix}. \text{ Wir möchten das Produkt } C = A \cdot B \text{ berechnen. Dazu bestimmen wir zunächst die Zwischenergebnisse: } \\\ R\_1 = A\_{11} \cdot B\_{11}, \\\ R\_2 = A\_{12} \cdot B\_{21}, \\\ R\_3 = A\_{11} \cdot B\_{12}, \\\ R\_4 = A\_{12} \cdot B\_{22}, \\\ R\_5 = A\_{21} \cdot B\_{11}, \\\ R\_6 = A\_{22} \cdot B\_{21}, \\\ R\_7 = A\_{21} \cdot B\_{12}, \\\ R\_8 = A\_{22} \cdot B\_{22} \\\ \text{Für die Blockmatrizen von C gilt dann: } \\\ C\_{11} = R\_1 + R\_2, \\\ C\_{12} = R\_3 + R\_4, \\\ C\_{21} = R\_5 + R\_6, \\\ C\_{22} = R\_7 + R\_8 \\\ \text{Die vollständige Berechnung sieht also wie folgt aus: } \\\ C = A \cdot B = \begin{pmatrix} A\_{11} & A\_{12} \\\ A\_{21} & A\_{22} \end{pmatrix} \cdot \begin{pmatrix} B\_{11} & B\_{12} \\\ B\_{21} & B\_{22} \end{pmatrix} = \begin{pmatrix} A\_{11} B\_{11} + A\_{12} B\_{21} & A\_{11} B\_{12} + A\_{12} B\_{22} \\\ A\_{21} B\_{11} + A\_{22} B\_{21} & A\_{21} B\_{12} +  A\_{22} B\_{22}\end{pmatrix} = \begin{pmatrix} C\_{11} & C\_{12} \\\ C\_{21} & C\_{22} \end{pmatrix} = C $$ 
Wie du siehst, benötigst du erneut die Matrixaddition. Dazu musst du erneut deine Implementierung von `addParallel` verwenden. Der Aufruf soll mit dem selben Wert von `minDim` erfolgen."
299,Praktikum: Grundlagen der Programmierung WS23/24,12611,W12Q01 - Nebenläufigkeit,
299,Praktikum: Grundlagen der Programmierung WS23/24,12612,W12P01 - Geschaeftspartner,"# Geschäftspartner

Das Geschäft mit Essen für Pinguine brummt. Die beiden `BusinessPenguins` Peter und Paul haben schon bemerkt, dass sie alleine keine Chance haben werden, sich in diesem stark umkämpften Markt zu behaupten. Daher haben sie beschlossen, im Fischhandel zusammenzuarbeiten, indem jeder die Hälfte seines Einkommens durch Fischverkäufe dem anderen gibt. Da die beiden aber keine Ahnung von Informatik haben brauchen sie deine Hilfe bei der Umsetzung.

## Aufgaben

Das Template dieser Aufgabe enthält drei Packages

- `pgdp.threads.start`,
- `pgdp.threads.race` und
- `pgdp.threads.dead`.

Das zweite Package enthält dabei die Lösung der ersten Aufgabe und das dritte die der zweiten. Sieh dir die unteren beiden Packages also jeweils erst dann an, wenn du in der Aufgabe weit genug bist.


### Aufgabe 1: Parallelly Purchasing Penguins

**Package:** `pgdp.threads.start`

Ergänze die Methode `sellFish` in `BusinessPenguin`, die jeweils dem Pinguin selbst und seinem Partner den halben Preis auf seine `balance` gutschreibt (`+=`). Du kannst davon ausgehen, dass der Preis gerade ist.

Jeder der beiden Pinguine hat nun einen Stammkunden, der bei ihm einkauft. Beide Kunden kaufen parallel ein. Ergänze die Klasse `Customer` so, dass jede `Customer`-Instanz nebenläufig arbeitet. Die Kunden kaufen jeweils 5000 Fische für je 2PD (Pingu-Dollar) ein. Füge `Customer` eine entsprechende `run`-Methode hinzu.

Vervollständige zuletzt die `main`-Methode in `Main`, sodass sie den Pinguinen jeweils einen Stammkunden zuordnet, diese einkaufen lässt und, sobald beide Kunden fertig sind, ausgibt, wie viel Geld die beiden Pinguine jeweils besitzen.

Führe das Programm mehrmals aus und überlege, wie es zu diesem Ergebnis kommen konnte.

Der (noch problematische) Lösungsvorschlag zu diesem Teil ist im Package `pgdp.threads.race` zu finden.

[task][Tests]( 187426 , 187416 )
*Hinweis:* Die Tests testen nur, ob die `sellFish`- und die `run`-Methode in einem nicht-parallelen Setting korrekt funktionieren. Daher passen sie im Falle von Aufgaben 2 und 3 auch direkt und stellen nur einen Indikator dafür, dass du nichts an der Funktionalität beim Synchronisieren/Probleme Beheben kaputt gemacht hast. Diskutiere, warum Testen auf Synchronisation nie perfekt möglich sein wird.

### Aufgabe 2: Racing to the Banks

**Package:** `pgdp.threads.race`

Überlege, wie du die in Aufgabe 1 entstandenen Probleme lösen kannst. Passe dazu die Beispiellösung von Aufgabe 1 im Package `pgdp.threads.race` entsprechend an.

*Hinweis:* Nutze das Schlüsselwort `synchronized`.

Je nachdem, wie genau du die Aufgabe gelöst hast, kann nun entweder alles so funktionieren, wie gewünscht, oder es ist ein neues Problem aufgetreten.

[task][Tests]( 187431 , 187414 )
*Hinweis:* Die Tests testen nur, ob die `sellFish`- und die `run`-Methode in einem nicht-parallelen Setting korrekt funktionieren. Daher passen sie im Falle von Aufgaben 2 und 3 auch direkt und stellen nur einen Indikator dafür, dass du nichts an der Funktionalität beim Synchronisieren/Probleme Beheben kaputt gemacht hast. Diskutiere, warum Testen auf Synchronisation nie perfekt möglich sein wird.

### Aufgabe 3: Waiting for the Other's Play

**Package:** `pgdp.threads.dead`

In `pgdp.threads.dead` findest du eine Implementierung, die versucht, das Problem aus Aufgabe 1 durch Synchronisation zu lösen. Betrachte den Code und bestimme erstmal nach Augenmaß, ob du denkst, dass die Implementierung korrekt ist.

Führe anschließend das Programm mehrfach aus, um deine These zu prüfen. Falls das Programm fehlerhaft ist, korrigiere es. Der Lösungsvorschlag zu diesem Teil ist in der Musterlösung dann im dortigen Package `pgdp.threads.dead` zu finden.

[task][Tests]( 187412 , 187415 )
*Hinweis:* Die Tests testen nur, ob die `sellFish`- und die `run`-Methode in einem nicht-parallelen Setting korrekt funktionieren. Daher passen sie im Falle von Aufgaben 2 und 3 auch direkt und stellen nur einen Indikator dafür, dass du nichts an der Funktionalität beim Synchronisieren/Probleme Beheben kaputt gemacht hast. Diskutiere, warum Testen auf Synchronisation nie perfekt möglich sein wird.



## Freiwillige Übung

**Freiwillig**: Zur weiteren Übung zum Thema Race-Conditions und Deadlocks gibt es z.B. folgendes [Spiel](https://deadlockempire.github.io/), in dem es deine Aufgabe ist, derartige Schwächen in Programmen zu finden und auszunutzen. Beachte, dass dort nicht Java verwendet wird und sich die Syntax daher ein bisschen unterscheidet."
299,Praktikum: Grundlagen der Programmierung WS23/24,12613,W12P02 - Klausurkorrektur,"# Klausurkorrektur

Um eine möglichst gerechte und schnelle Korrektur der anstehenden Klausur zu gewährleisten, werden wir dies hier simulieren. Dafür wurden bereits die Klassen `Exam` und `CorrectionScheme` sowie diverse Hilfsmethoden fertig implementiert.

Der Ablauf der Korrektur ist wie folgt:

@startuml

hide circle
hide members

package InitialerBuffer < > {
}
class ""Korrektur Aufg. 1"" as k1
package Buffer1 < > {
}
class ""Korrektur Aufg. 2"" as k2
package Buffer2 < > {
}
class ""  ...  "" as k3
package Buffer7 < > {
}
class ""Korrektur Aufg. 8"" as k8
package FinalerBuffer < > {
}
class ""Zusammenrechnen und Eintragen"" as k9

InitialerBuffer --> k1
k1 --> Buffer1
Buffer1 --> k2
k2 --> Buffer2
Buffer2 --> k3
k3 --> Buffer7
Buffer7 --> k8
k8 --> InitialerBuffer : Zweitkorrektur
k8 --> FinalerBuffer : Korrektur abgeschlossen
FinalerBuffer --> k9

@enduml

Insgesamt sollen 1900 Klausuren korrigiert werden. Dabei haben der initiale und finale Buffer Größe 1900 und alle dazwischenliegenden je Größe 50. Jedem der 32 Tutoren wird nun eine Aufgabe zugewiesen. Danach beginnen sie nebenläufig, Klausuren aus dem Buffer vor der jeweiligen Korrektur zu entnehmen, die jeweilige Aufgabe zu bewerten und die Klausur danach im dahinterliegenden Buffer abzulegen. Dazu gibt es bereits die Methode `correctExam` im Template, die die Punkte entsprechend einträgt und zurückgibt, ob die Klausur vollständig korrigiert wurde. Eine fertig korrigierte Klausur wird dann in den finalen Buffer abgelegt. Das Zusammenrechnen und Eintragen wird vom main-Thread übernommen.

Erledige nun folgende Teilaufgaben:
- Beginne damit, die Klasse `Buffer` zu vervollständigen, sodass diese Thread-safe arbeiten. Die Größe des Buffers wird im Konstruktor übergeben.
Dabei soll der `Buffer` wie eine Queue funktionieren, also die erste Klausur, die von einem Tutor des vorigen Teams in den Buffer gelegt wurde, soll auch die erste sein, die der Tutor aus hiesigem Team dann entnimmt und weiterkorrigiert. Essentiell ist `Buffer` nichts anderes, als ein Ring-Buffer (siehe [W06H03](https://artemis.cit.tum.de/courses/299/exercises/12224) ) mit Synchronisation (du kannst ihn auch anders implementieren, aber ein RingBuffer bietet sich an).
Nutze zur Synchronisation die Klasse [Semaphore](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Semaphore.html).  
*Falls du unsicher bist, wie du dies lösen kannst, schaue nochmal in die Vorlesungsfolien.*
- Ergänze anschließend die Klasse `Tutor`. Tutoren nehmen eine Klausur aus ihrem `in`-Buffer, führen ihre wie oben beschriebene Aufgabe aus und legen sie dann in ihren `out`- oder den `finished`-Buffer. Sollte `in` leer oder `out`/`finished` voll sein, wartet der Tutor, bis der Engpass behoben ist. Die Methode `correctExam()` in `Tutor` gibt dabei genau dann `true` zurück, wenn die übergebene `Exam` mit diesem Aufruf fertig korrigiert wird, d.h. wenn dies eine Zweitkorrektur der Aufgabe 8 ist. In dem Fall sollte die Klausur dann natürlich nicht auf den `out`-Stapel, sondern den `finished`-Stapel gelegt werden.
- Vervollständige die `main`-Methode in `ExamCorrection`. Die Methode erstellt bereits alle Buffer und die zugehörigen Tasks. Deine Aufgabe ist nun, 32 Tutor-Threads mit den gegebenen Tasks zu starten (je 4 pro Aufgabe) und anschließend mit dem main-Thread Klausuren aus dem finalen Buffer zu entnehmen und zu bearbeiten (dazu gibt es die Hilfsmethode `finalizeExam`). Sobald alle Klausuren abgeschlossen wurden, sollen alle Threads beendet werden und `""Korrektur der EIDI Klausur beendet :)""` ausgegeben werden.

[task][Tests]( 187445 , 187447 , 187442 , 187443 , 187444 )
Tests: Die Tests testen wieder nur die Funktionalität des Buffers. Ob deine Vervollständigungen der Klassen `ExamCorrection` und `Tutor` korrekt funktionieren, musst du durch Ausführen der `main`-Methode in `ExamCorrection` selbst testen."
299,Praktikum: Grundlagen der Programmierung WS23/24,12614,W12P03 - Synchrone Listen,"# Synchrone Listen

Wie Du der [Dokumentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/LinkedList.html)
entnehmen kannst, sind `LinkedList`s in Java nicht synchron. In dieser Aufgabe sollst Du daher eine Klasse
`SynchronizedList` erstellen, die es mehreren Threads ermöglicht, zugleich auf die Liste zuzugreifen.

Führe die im Template mitgelieferte main-Methode zunächst mehrfach ohne Synchronisation aus.
Diskutiere das Ergebnis.

Synchronisiere nun alle Zugriffe mittels `synchronized`. Führe erneut die main-Methode aus.
Diskutiere, warum das Programm deutlich langsamer geworden ist.

Synchronisiere zuletzt mit einem Read-Write-Lock. Implementiere dazu die Klasse `RW` mit den
Methoden `startRead()`, `stopRead()`, `startWrite()` und `stopWrite()` analog zur Vorlesung.
Das Lock soll sicherstellen, dass mehrere lesende Prozesse gleichzeitig zugreifen können,
aber nur ein schreibender Zugriff zugleich erlaubt ist. Sorge dafür, dass Deine Implementierung frei
von Race-Conditions oder Deadlocks ist. Führe abschließend die main-Methode erneut aus und
überlege, warum das Programm schneller geworden ist.

[task][Test]( 187468 )
Test der Implementierung."
299,Praktikum: Grundlagen der Programmierung WS23/24,12623,W12H01 - Work Life Balance of Threaduins,"# Work Life Balance of Threaduins

Wie auch an der TUM ist die PUM eine hoch diversifizierte Hochschule. Von überengagierten Pinguinen bishin zu Schlafmützen findet man alles. Du als ausgewogenes Individuum hast dich mit vielen Pinguinen angefreundet. Weil du so ein guter Freund bist, sorgst du dich um ihre Gesundheit und ihren Erfolg. Zeit deine Pingu-Freunde zu unterstützen!

## Aufgabe

*Hinweis 1:* Alle `String`s, die in dieser Aufgabe benötigt werden, sind in der `Threaduins` Klasse als `final String` deklariert. Benutze am Besten diese `String`s, damit du dir keine Sorgen um Typos machen musst. (z.B. `Threaduins.STOP_MSG`)  
*Hinweis 2:* Du kannst bei allen Methoden davon ausgehen, dass dir keine `null`-Values übergeben werden. Du erhältst also nur echte `Thread`s oder `PrintStream`s, die voll funktional sind. In anderen Worten: Mach dir keine Gedanken über Edge Cases. 🐧  
*Hinweis 3:* Zum Testen eignet sich das vorgegebene `ConsoleSignal` nicht. Daher enthält das Template die Methode `setSignal`, mit der du eigene Implementierungen verwenden kannst. Achte darauf, dass die Methode wirklich nur zum Testen verwendet wird.  

1. [task][Workaholic Penguin]( 187553 )
Ein Workaholic Pinguin ist ein `Thread`, der ständig arbeitet, außer er wird dazu gezwungen aufzuhören. Implementiere die Methode `getWorkaholic(PrintStream)`, die einen Workaholic Pinguin zurückgeben soll. Dieser soll, solange er arbeitet, ständig die Nachricht `WORKAHOLIC_WORKING_MSG` an den spezifizierten `PrintStream` senden (Jede Nachricht soll dabei in einer neuen Zeile stehen, benutze also am besten `PrintStream.println(String)`). Wird der Pinguin bei seiner Arbeit gestört, soll er einmalig die Nachricht `WORKAHOLIC_STOP_MSG` an den `PrintStream` senden und anschließend seine Arbeit niederlegen.
2. [task][Save a Workaholic]( 187555 )
Implementiere die Methode `stopWorkaholic(Thread)`. Die Methode soll den gegebenen Workaholic Pinguin zunächst starten. In der Konsole soll nun die Nachricht `STOP_MSG` ausgegeben und auf das `Signal` zum stoppen des `Thread`s gewartet werden. Das `Signal signal` ist bereits als `static` Variable gesetzt. Ein `Signal` implementiert die Methode `await()` die den aktuellen `Thread` auf ein Signal warten lässt. Erhältst du das Signal, wird das Programm wie gewohnt nach dem Aufruf von `await` weiter ausgeführt. Sobald du das Signal erhalten hast, soll die Arbeit des Pinguins unterbrochen werden. Achte darauf, dass er seine Arbeit beendet, bevor du die Nachricht `STOPPED_MSG` in der Konsole ausgibst.
*Tipp:* Wenn du deine Implementierung ausprobieren möchtest, wirf einen Blick in die `main` Methode, dort findest du schon den entsprechenden Code. Das Signal ist in diesem Fall eine beliebige Eingabe in der Konsole.
3. [task][Procrastinating Penguin]( 187546 )
Ein prokrastinierender Pinguin ist ein `Thread` und prokrastiniert auf höchstem Niveau! Implementiere die Methode `getLuckyProcrastinator(PrintStream)`, die einen prokrastinierenden Pinguin zurückgibt. Dieser sendet an den spezifizierten `PrintStream` die Nachricht `PROCRASTINATOR_PROCRASTINATING_MSG`, sobald er mit dem Prokrastinieren beginnt. Ab dann wartet er unbegrenzt, bis ein lieber Freund ihn an die Deadline der PGdP Hausaufgaben erinnert (i.e. bis ein anderer Thread ihn benachrichtigt). Obwohl er es eigentlich besser wissen sollte, ist er natürlich über die Deadline überrascht und sendet, nachdem sein Warten durch die Benachrichtigung beendet wurde, die Nachricht `LUCKY_PROCRASTINATOR_WORKING_MSG` an den `PrintStream`. (`PrintStream.println(String)`)
4. [task][Friend of a Procrastinator]( 187558 )
Implementiere die Methode `stopProcrastinator(Thread)`. Die Methode soll den gegebenen prokrastinierenden Pinguin zunächst starten. In der Konsole soll nun die Nachricht `STOP_MSG` ausgegeben und auf das `Signal` zum Erinnern des `Thread`s gewartet werden (`await`). Sobald du das Signal erhalten hast, musst du den Pinguin an die annähernde PGdP Deadline erinnern (i.e. benachrichtigen). Achte darauf, dass er seine Nachricht an den `PrintStream` senden konnte, bevor du die finale Ausgabe `STOPPED_MSG` in der Konsole tätigst. (*Wichtig:* der Pinguin soll erinnert werden, aber nicht dazu gezwungen werden.)


## Tests

Hier werden dir die Ergebnisse der automatischen Tests direkt angezeigt:
[task][Tests]( 187557 , 187556 , 187551 , 187563 , 187559 , 187552 , 187538 , 187561 , 187548 , 187550 , 187560 , 187554 , 187534 , 187562 ) Testet deine Abgabe nach der Deadline.

Viel Erfolg!"
299,Praktikum: Grundlagen der Programmierung WS23/24,12624,W12H02 - PUM Server Synchronisierung,"# PUM Server Synchronisierung

In [Woche 06](https://artemis.ase.in.tum.de/courses/299/exercises/12224) hast du den Softwareuinen der PUM bereits geholfen, einen `RingBuffer` und einen `MultiStack` zu implementieren. In der Zwischenzeit haben sie ein wenig weiter an den Klassen gearbeitet, doch jetzt brauchen sie wieder die Hilfe ihres exzellenten Freundes: Deine! Da der Hochleistungsrechner natürlich stark parallelisiert arbeitet, müssen die Datenstrukturen auch für diesen Einsatz geeignet sein.

## MultiStack

Der `MultiStack` wurde um zwei neue Methoden erweitert. `size` gibt die Anzahl der aktuell im MultiStack enthaltenen Elemente zurück und `search(int)` die 1-indizierte Distanz des übergebenen `int`s zum zuletzt eingefügten Element (vgl. [JavaDoc Stack.search](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Stack.html#search(java.lang.Object)\). Deine Aufgabe ist es jetzt, die Methoden des `MultiStack` so zu synchronisieren, dass mehrere lesende Threads gleichzeitig auf den MultiStack zugreifen können, während aber nur ein schreibender Thread diesen zu einem bestimmten Zeitpunkt verändern darf. Während eines schreibenden Zugriffs sind auch keine lesenden erlaubt. Dabei gilt es Folgendes zu beachten:
- Die Signaturen der vorgegebenen Methoden müssen gleich bleiben.
- Die Konstruktorsignatur von `MultiStack` muss gleich bleiben (die von `Stack` darf allerdings verändert werden).
- Vorhandene Attribute müssen gleich bleiben.
- Hilfsmethoden und -Attribute sind erlaubt.
- Die bisherige Funktionalität der Methoden muss natürlich weiterhin bestehen.
- Klassen aus `java.util.concurrent.locks` und `Semaphore` dürfen verwendet werden.

- [task][MultiStack Public Tests]( 187564 )
Hier siehst du, ob deine Änderungen die ursprüngliche Funktionalität der Methoden beeinflusst. 

## RingBuffer

Der `RingBuffer` soll in einen ""BlockingRingBuffer"" umgewandelt werden (die Klasse soll aber nicht umbenannt werden!). Das heißt, dass `put(val)` das übergebene `val` immer in den Buffer einfügt. Falls der Buffer voll ist, soll der einfügende Thread warten, bis wieder Kapazität vorhanden ist. Deshalb wurde der Rückgabetyp auch auf `void` geändert (es wird ja immer eingefügt). Ebenso soll `get` immer ein Element zurückgeben. Falls der Buffer leer ist, wartet der Thread, bis wieder ein Element vorhanden ist. Sollte ein wartender Thread interrupted werden, soll in beiden Methoden eine `InterruptedException` geworfen werden. Während eines `toString`-Aufrufs darf nichts am Buffer geändert werden. Für diese Teilaufgabe gilt Folgendes:
- Die Signaturen der vorgegebenen Methoden und des Konstruktors müssen gleich bleiben. `put` und `get` wurden bereits um ein `throws InterruptedException` erweitert.
- Die Attribute außer `mem` dürfen beliebig geändert werden und neue dürfen hinzugefügt werden. Einzig `mem` darf nicht geändert werden. Hilfsmethoden sind erlaubt.
- Die bisherige Funktionalität der Methoden muss natürlich weiterhin bestehen.
- Klassen aus `java.util.concurrent.locks` und `Semaphore` dürfen verwendet werden.

- [task][RingBuffer Public Tests]( 187567 )
Hier siehst du, ob deine Änderungen die ursprüngliche Funktionalität der Methoden beeinflusst. (Dies kannst du auch mit den [Test von W06H03](https://bitbucket.ase.in.tum.de/projects/PGDP2324W06H03/repos/pgdp2324w06h03-tests/browse) selber überprüfen, du musst die Tests teilweise allerdings anpassen.)

##Ausführliche Tests
- [task][MultiStack Tests]( 187579 , 187585 , 187589 , 187584 )
- [task][RingBuffer Tests]( 187572 , 187571 , 187568 , 187582 )"
299,Praktikum: Grundlagen der Programmierung WS23/24,12625,W12H03 - PSA Shuttle Computer,"# PSA Shuttle Computer

Die PSA (Pingu Space Agency) arbeitet derzeit an einem neuen Spaceshuttle. Für dieses wird auch ein neuer, leistungsstarker Bordcomputer entwickelt. Doch wie es in der Forschung immer so ist, sind die finanziellen Mittel für das Projekt eng bemessen. Deshalb bittet dich die Führungsabteilung der PSA, den Code für den Computer beizusteuern. Dabei ist Redundanz bei den Berechnungen extrem wichtig, da durch die Strahlung im All unerwartete Bitflips auftreten können, die die Ergebnisse beeinflussen (siehe hierzu [dieses](https://youtu.be/AaZ_RSt0KP8) sehr empfehlenswerte Video (kein Muss für diese Aufgabe!)) und somit zu großen Problemen für die Mission führen können.

## Struktur und allgemeine Funktionsweise
Im folgenden Bild kannst du den Aufbau des `ShuttleComputer`s sehen. Dieser besteht aus folgenden `ShuttleComputerComponent`s: Einem `TaskDistributer`, der mit Hilfe eines `TaskGenerator` eine vorher festgelegte Anzahl an `ShuttleTask`s generiert. Vier `ShuttleProcessor`en (es sind auch mehr/weniger möglich), die die Ergebnisse der `ShuttleTask`s berechnen. Einem `TaskChecker`, der überprüft, ob sich die `ShuttleProcessor`en für eine `ShuttleTask` auf ein Ergebnis ""einigen"" konnten (mehr dazu in der Aufgabenstellung weiter unten). Und ein `ShuttleOutput`, der die Ergebnisse der abgeschlossenen `ShuttleTasks` ausgibt. Die im Bild enthaltenen Pfeile geben an, welche Komponenten wie `ShuttleTask`s austauschen.

![ShuttleComputer Aufbau](/api/core/files/markdown/Markdown_2022-11-21T14-24-17-192_5058a7d8.svg)

Der Shuttle Computer produziert also Aufgaben, die dann parallel gelöst werden. Anschließend werden die Ergebnisse überprüft und ggf. eine erneute Lösung in die Wege geleitet. Korrekt gelöste und überprüfte Aufgaben werden schließlich auf der Konsole ausgegeben.

## Template
Im Template findest du bereits eine vollständige Implementierung von `ShuttleTask`, das Interface `TaskGenerator`, sowie zwei Implementierungen davon: `ErrorlessTaskGenerator`, dessen `ShuttleTask`s immer das richtige Ergebnis berechnen; und `ErrorProneTaskGenerator`, dessen `ShuttleTasks` mit einer übergebenen Wahrscheinlichkeit ein falsches Ergebnis zurückgeben (um die Bitflips zu simulieren). Solltest du eine eigene lustige oder interessante Idee für einen `TaskGenerator` haben, darfst du diesen gerne auch schon vor der Deadline der Aufgabe öffentlich teilen, solange (wie immer) nichts von der Implementierung der eigentlichen Aufgabe verraten wird.  
Weiterhin enthält das Template bereits Implemenierungen der übrigen bisher beschriebenen Klassen, die du beliebig erweitern darfst (die Konstruktor und Methoden-Signaturen, die bereits vorgegeben sind, müssen aber gleich bleiben!). Deine Aufgabe ist es, die Methoden `shutDown` und `run` in diesen Klassen zu implementieren. Weitere Informationen findest du im Punkt ""Aufgaben"".
In der Klasse `ShuttleComputer` findest du außerdem eine `main`-Methode, mit der du deine Implementierung ausprobieren kannst.

## Allgemeine Hinweise
- Am besten liest du dir die ganze Aufgabenstellung einmal durch, bevor du mit der Implementierung der einzelnen Teilaufgaben beginnst
- "" ⎵ "" dient wie immer nur der besseren Lesbarkeit und soll in der tatsächlichen Ausgabe durch ein Leerzeichen ersetzt werden.
- `shutDown` muss für jede Objekt-Instanz nur einmal funktionieren
- `run` muss für jede Objekt-Instanz nur einmal funktionieren
- Die Klassen (außer `ShuttleComputer` !!) werden unabhängig voneinander getestet
- Deine Implementierung darf bei der Interaktion mit Objekten aus dem Package `pgdp.shuttle.tasks` nur die vorgegebenen Methoden verwenden und diese dürfen nicht verändert werden.
- Sollte ein Test fehlschlagen und ""This could be an Artemis issue."" beinhalten, ist es **möglich**, dass das Problem an Artemis und nicht an deiner Implementierung liegt. In solch einem Fall solltest du 1.) deinen Code nochmal genau überprüfen, ob du nicht doch einen Fehler findest, und 2.) etwas abwarten und nochmal pushen (möglicherweise löst sich dadurch der Fehler von selbst)
- Falls ein Thread gerade nichts zu tun hat, soll er warten. Ebenso soll ein Thread informiert werden, falls er wieder etwas zu tun bekommt. (Stichwort `wait` und `notify`)
- Falls andere Exceptions auftreten als `InterruptedExceptions` wird kein spezielles Verhalten erwartet.
- Du musst dir keine Gedanken machen, ob im Konstruktor initialisierte Variablen `null` sein könnten.

## Aufgaben
Wie bereits oben beschrieben musst du die Methoden `shutDown` und `run` implementieren. Allgemein gilt für die Methoden: 
- `shutDown`: beendet den Thread. Das Beenden soll ""auf natürliche Weise"", d.h. ohne Exceptions, etc., sondern durch verlassen der `run`-Methode erreicht werden. Dies muss nur einmal pro Objekt-Instanz funktionieren.
- `run`: übernimmt die im folgenden definierten Aufgaben je Klasse. Muss nur einmal pro Objekt-Instanz funktionieren. Wenn nicht anders definiert, wartet diese Methode auch immer, wenn sie gerade nichts zu tun hat.

[task][TaskDistributer]( 187611 , 187594 )
Diese Klasse übernimmt im Konstruktor die Anzahl der zu generierenden Aufgaben (`tasksToGenerate`), eine Liste von `ShuttleProcessor`en (`processors`) und einen TaskGenerator (`generator`). In der `run`-Methode sollen solange `ShuttleTasks` mit dem Generator erstellt und an alle Prozessoren mit normaler Priorität verteilt werden (jeder Prozessor erhält jede Task, zum Verteilen existiert die Methode `addTask`), bis entweder `tasksToGenerate` Aufgaben erstellt und verteilt wurden, oder der `TaskDistributer` mittels `shutDown` beendet wird. In letzterem Fall soll aber immer eine schon generierte Task auf alle Prozessoren fertig verteilt werden. Weiterhin sollen folgende Ausgaben auf der Konsole getätig werden:
- Direkt beim Starten: "" TaskDistributer⎵starting⎵to⎵generate⎵tasks. ""
- Bei normalem Beenden (sobald die maximale Anzahl and Tasks generiert wurde oder `shutDown` aufgerufen wurde): "" TaskDistributer⎵finished⎵generating⎵ \ / \ ⎵tasks.⎵Shutting⎵down. ""
- Beim Auftreten einer `InterruptedException` statt der Nachricht zum normalen Beenden: "" TaskDistributer⎵was⎵interrupted⎵after⎵ \ ⎵tasks! ""

[task][ShuttleProcessor]( 187618 )
Diese Klasse verwaltet `ShuttleTask`s in zwei Warteschlagen, einer mit normaler (`taskQueue`) und einer mit hoher Priorität (`priorityTaskQueue`). In der `run` Methode sollen `ShuttleTask`s evaluiert (`evaluate()`) und an den TaskChecker weitergegeben werden (`checker.addTask()`). Dabei sollen `ShuttleTask`s aus der priorisierten Warteschlange bevorzugt werden. Ein `ShuttleProcessor` soll nur durch einen Aufruf von `shutDown` oder eine `InterruptedException` beendet werden. Sollte bei einem Aufruf von `shutDown` bereits eine `ShuttleTask` evaluiert worden sein, soll diese noch and den `TaskChecker` weitergegeben werden. Außerdem sollen noch folgende Ausgaben auf der Konsole getätigt werden:
- Bei normalem Beenden (durch `shutDown`): "" ShuttleProcessor⎵shutting⎵down. ""
- Beim Auftreten einer `InterruptedException` statt der Nachricht zum normalen Beenden: "" ShuttleProcessor⎵was⎵interrupted.⎵Shutting⎵down. ""

[task][TaskChecker]( 187597 )
Diese Klasse überprüft in der `run`-Methode, ob sich die verschiedenen `ShuttleProcessor`en auf ein Ergebnis für die `ShuttleTask` ""einigen"" konnten. Voraussetzung dafür ist, dass mindestens vier Prozessoren die Task evaluiert haben. Falls dies nicht der Fall ist, kann die `ShuttleTask` erstmal ignoriert werden, bis sie wieder in der `taskQueue` landet. Die `ShuttleProcessor`en ""einigen"" sich auf ein Ergebnis, wenn mindestens dreimal dasselbe Ergebnis berechnet wurde. In diesem Fall wird `result` der `ShuttleTask` auf den ensprechenden Wert gesetzt und die Task an den `ShuttleOutput` weitergegeben (Hinweis: jede `ShuttleTask` soll nur genau einmal an den `ShuttleOutput` weitergegeben werden). Andernfalls wird die `ShuttleTask` zurückgesetzt und wieder auf die Prozessoren verteilt, um neu berechnet zu werden. Die Neuberechnung hat dabei hohe Priorität. `ShuttleTask` bietet bereits alle nötigen Methoden, um dieses Verhalten umzusetzen. Ein `TaskChecker` soll nur durch einen Aufruf von `shutDown` oder eine `InterruptedException` beendet werden. Angefangene Überprüfungen werden vor dem Beenden mit `shutDown` noch zu Ende geführt. Außerdem sollen noch folgende Ausgaben auf der Konsole getätigt werden:
- Bei normalem Beenden (durch `shutDown`): "" TaskChecker⎵shutting⎵down. ""
- Beim Auftreten einer `InterruptedException` statt der Nachricht zum normalen Beenden: "" TaskChecker⎵was⎵interrupted.⎵Shutting⎵down. ""

[task][ShuttleOutput]( 187591 )
Diese Klasse ist letztlich dafür verantwortlich die Ergebnisse fertiger `ShuttleTask`s auf der Konsole auszugeben. Dies soll natürlich in der `run`-Methode geschehen. Außerdem soll auch `ShuttleOutput` nur durch einen Aufruf von `shutDown` oder eine `InterruptedException` beendet werden. Angefangene Ergebnis-Ausgaben werden vor dem Beenden mit `shutDown` noch vollendet. Diese Klasse tätigt folgende Konsolenausgaben:
- Beim Output eines Ergebnisses: "" Result:⎵ \ ""
- Bei normalem Beenden (durch `shutDown`): "" ShuttleOutput⎵shutting⎵down. ""
- Beim Auftreten einer `InterruptedException` statt der Nachricht zum normalen Beenden: "" ShuttleOutput⎵was⎵interrupted.⎵Shutting⎵down. ""

[task][ShuttleComputer]( 187616 )
Schließlich fehlt noch die Klasse `ShuttleComputer`. Diese soll in der `run`-Methode einen `TaskDistributer`, vier `ShuttleProcessor`, einen `TaskChecker` und einen `ShouttleOutput` initialisieren (`tasksToGenerate` und der benötigte `TaskGenerator` werden im Konstruktor initialisiert). Diese Komponenten sollen dann parallel ausgeführt werden. Nach `sleeptime` Millisekunden soll der `TaskDistributer` wieder heruntergefahren werden (falls er nicht schon fertig und damit heruntergefahren ist; trotzdem soll immer die volle  `sleeptime` gewartet werden) und anschließend auch alle anderen `ShuttleComputerComponent`en. Nachdem alle Threads beendet sind, soll sich auch der `ShuttleComputer` beenden. Während der Ausführung tätigt `ShuttleComputer` folgende Ausgaben auf der Konsole:
- Zu Beginn: "" ShuttleComputer⎵booting⎵up. ""
- Bei normalem Beenden ganz zum Schluss: "" ShuttleComputer⎵shutting⎵down. ""
- Falls eine `InterruptedException` auftritt, während auf den `TaskDistributer` gewartet wird, anstatt der normalen Schluss-Nachricht: "" ShuttleComputer⎵crashed⎵(interrupted⎵while⎵waiting⎵for⎵TaskDistributer)! ""
- Falls eine `InterruptedException` auftritt, während auf das Beenden der übrigen `ShuttleComputerComponent`en gewartet wird, anstatt der normalen Schluss-Nachricht: "" ShuttleComputer⎵crashed⎵(interrupted⎵while⎵waiting⎵for⎵ShuttleComputerComponent)! ""

## Ausführliche Tests
- [task][TaskDistributer]( 187593 )
- [task][ShuttleProcessor]( 187592 )
- [task][TaskChecker]( 187595 )
- [task][ShuttleOutput]( 187596 )
- [task][ShuttleComputer]( 187613 )

## FAQ
- **Frage:** Der ""shutDown""-Test zu Klasse XY failt mit einem Timeout. Woran könnte das liegen? 
Wahrscheinlich beachtest du noch nicht alle Hinweise. Lies dir am besten nochmal den Abschnitt ""Allgemeine Hinweise"" durch."
299,Praktikum: Grundlagen der Programmierung WS23/24,12709,Trees and Forests Redo,"# Trees and Forests

_TIPP_: Die Bäume enthalten eine Methode `toGraphviz()`, die einen String zurückgibt, den du mit einem Graphviz-Viewer dazu nutzen kannst den Baum zu rendern. Wir empfehlen hierfür folgende Website: [Graphviz Online](https://dreampuf.github.io/GraphvizOnline)

_ACHTUNG!:_
1. Verändere nicht die Signaturen der Methoden!
2. Füge den Klassen *keine* neuen Attribute hinzu!
3. Wenn du Hilfsmethoden implementierst, müssen diese `private` sein!
4. Du kannst davon ausgehen, dass in einem Baum *keine* doppelten Werte gespeichert werden.
5. Du kannst davon ausgehen, dass das Attribut `value` eines `Nodes` nie `null` ist.

## Tree
Ein `Tree ` ist eine mögliche Implementierung eines Baums. Da es sich um einen allgemeinen Baum handelt, kann jeder Knoten beliebig viele Kinder haben.

1. [task][Tree .Node .size()]()
Implementiere die Methode `size()` der inneren Klasse `Tree .Node `, die die Größe des Baums zurück gibt, der den aktuellen Knoten als Wurzel hat. *Hint*: Die Größe entspricht der Summe der Größen der Kindbäume plus `1` für den aktuellen Knoten (Wurzel).

2. [task][Tree .size()]()
Implementiere die Methode `size()` der Klasse `Tree `, die die Größe des Baums zurück gibt. *Hint*: In dieser Teilaufgabe kannst du Punkte bekommen, ohne die vorherige implementiert zu haben.

3. [task][Tree .Node .height()]()
Implementiere die Methode `height()` der inneren Klasse `Tree .Node `, die die Höhe des Baums zurück gibt, der den aktuell Knoten als Wurzel hat. *Hint*: Die Höhe entspricht der maximalen Höhe aller Kindbäume plus `1` für den aktuellen Knoten (Wurzel).

4. [task][Tree .height()]()
Implementiere die Methode `height()` der Klasse `Tree `, die die Höhe des Baums zurück gibt. *Hint*: In dieser Teilaufgabe kannst du Punkte bekommen, ohne die vorherige implementiert zu haben.

## BinaryTree
Ein `BinaryTree ` ist ein `Tree `, bei dem ein Knoten nie mehr als `2` Kinder enthält.

## BSTree
Ein `BSTree ` ist ein `BinaryTree `, der zusätzlich die Eigenschaft besitzt, dass alle `values` der linken Kinder eines Knoten *kleiner* und alle `values` der rechten Kinder eines Knoten *größer* als das `value` des Knoten selbst sind.


## MinMaxBSTree
Ein `MinMaxBSTree ` ist ein `BSTree `, der zusätzlich den kleinsten `min` und größten `max` Wert, der in einem Baum enthalten ist, mit speichert.

5. [task][MinMaxBSTree .MinMaxBSTNode .insert(B value)]()
Implementiere die Methode `insert(B value)` der inneren Klasse `MinMaxBSTree .MinMaxBSTNode `, die den Wert wie bei einem `BSTNode ` einfügt und zusätzlich die Referenzen `min` und `max` updatet. *Hint*: `BSTNode ` enthält bereits eine Implementierung für `insert`.

6. [task][MinMaxBSTree .insert(T value)]()
Implementiere die Methode `insert(T value)` der Klasse `MinMaxBSTree `, die den Wert in den Baum einfügt. *Hint*: In dieser Teilaufgabe kannst du Punkte bekommen, ohne die vorherige implementiert zu haben.

7. [task][MinMaxBSTree .MinMaxBSTNode .canContain(B value)]()
Implementiere die Methode `canContain(B value)` der inneren Klasse `MinMaxBSTree .MinMaxBSTNode `, die zurück gibt, ob der Knoten selbst oder eines der Kinder potentiell den übergebenen Wert enthalten könnte. *Hint*: Dies ist der Fall, wenn `min <= value` und `value <= max` gilt.

8. [task][MinMaxBSTree .MinMaxBSTNode .contains(B value)]()
Implementiere die Methode `contains(B value)` der inneren Klasse `MinMaxBSTree .MinMaxBSTNode `, die zurück gibt, ob der Knoten selbst oder eines der Kinder den übergebenen Wert enthält. Dabei soll *immer* zuerst gecheckt werden, ob der Wert überhaupt enthalten sein kann. Nutze dazu die Methode `canContain(B value)` *Hint*: `BSTree .BSTNode ` Enthält bereits eine Implementierung für `contains`.

## Forest
Ein `Forest ` ist eine Sammlung von Bäumen `Tree `. Zu einem Wald kann ein neuer Baum hinzugefügt werden und es kann abgefragt werden, ob der Wald einen Wert enthält. Bäume, die zu einem Wald gehören, werden in einem `Set > trees` gespeichert.

9. [task][Forest . addTree(Tree  tree)]()
Implementiere die Methode `addTree(Tree  tree)` der Klasse `Forest `, die den übergebenen Baum zu dem Wald hinzufügt.

10. [task][Forest .contains(T value)]()
Implementiere die Methode `contains(T tree)` der Klasse `Forest `, die zurückgibt ob der Wald den übergebenen Wert enthält."
299,Praktikum: Grundlagen der Programmierung WS23/24,12710,Job Manager Redo,"# Jobmanager
Die Klasse `Job` modelliert eine Rechenaufgabe, die von einem Computer ausgeführt wird. Jeder `Job` hat eine `id`. Wie lange ein `Job` zum Ausführen braucht wird in `durationInMinutes` beschrieben. Diese Klasse ist vollständig und soll nicht geändert werden.

Die Klasse `JobManager` verwaltet `Job`s mit unterschiedlichen Prioritäten wie folgt:
* Die Jobs werden in `private Map > priorityGroups` gespeichert. Also gibt es für *jede Prioritätsstufe eine Liste von Jobs*.
* Wenn es für eine Prioritätsstufe `n` keinen `Job` gibt, gibt es in `priorityGroups` keinen Eintrag für `n`, nicht einmal eine leere Liste.
* Prioritätsstufen können beliebige nicht negative ganze Zahlen sein. Eine größere Zahl stellt die höhere Priorität dar.

Beide Klassen verfügen über eine `toString` Methode, die zum Testen verwendet werden kann.

1. [task][Jobmanager]()
Implementiere einen Konstruktor für `JobManager` der keinen Parameter annimmt und `priorityGroups` mit einer leeren Map initialisiert.

2. [task][Jobverwaltung]()
Implementiere die Methode `public void addJob(Job job, int priority)`. Wenn es noch keinen Job mit `priority` gibt, muss erst eine Liste als Eintrag initialisiert werden, die den Job beinhaltet. Sonst wird der Job ans Ende der bestehenden Liste von Jobs dieser `priority` hinzugefügt.

 
 **Beispiel** 
Alle Codebespiele können von der `main` methode der Klasse `Main` ausgeführt werden.
```java
JobManager jobManager = new JobManager();
jobManager.addJob(new Job(1, 10), 2);
jobManager.addJob(new Job(2, 20), 2);
jobManager.addJob(new Job(3, 30), 1);
jobManager.addJob(new Job(4, 30), 450);
jobManager.addJob(new Job(5, 30), 254);
System.out.println(jobManager);
```
Gibt (bis auf Reihenfolge der Map-Elemente) das folgende aus:
```
{1=[Job 3 (30 minutes)], 2=[Job 1 (10 minutes), Job 2 (20 minutes)], 450=[Job 4 (30 minutes)], 254=[Job 5 (30 minutes)]}
```
 

## JobIterator

Im Konstruktor wird zunächst ein Hilfsarray mit den vorhandenen Prioritätsstufen initialisiert. Dazu wird die Methode getSortedPriorities() aufgerufen, die bei der nächsten Teilaufgabe implementiert werden muss:

3. [task][Sortierte Prioritäten]()
Implementiere die Methode `protected int[] getSortedPriorities()` in der Klasse `JobIterator`, die ein aufsteigend sortiertes Array von Prioritätsstufen zurückgibt.  
**Hinweis:** Die Methode `.keySet()` von `Map` gibt ein `Set` zurück, das selbst ein `Iterable` ist. Außerdem hat `Map` eine `.size()` Methode.  
**Hinweis:** Das Array darf mit `Arrays.sort` sortiert werden.


 
 **Beispiel** 
```java
JobManager jobManager = new JobManager();
jobManager.addJob(new Job(1, 10), 2);
jobManager.addJob(new Job(2, 20), 2);
jobManager.addJob(new Job(3, 30), 1);
jobManager.addJob(new Job(4, 30), 450);
jobManager.addJob(new Job(5, 30), 254);
JobIterator jobIterator = new JobIterator(jobManager.getPriorityGroups());
System.out.println(Arrays.toString(jobIterator.getSortedPriorities()));
```
Gibt das folgende aus:
```
[1, 2, 254, 450]
```
 
 

Nun wollen wir in der Klasse `JobIterator` einen Iterator bauen, um damit in der richtigen Reihenfolge über Jobs iterieren zu können:  
Unter `Job`s mit unterschiedlichen Prioritätsstufen, kommt der Job mit der höheren Prioritätsstufe zuerst vor.  
Unter `Job`s mit gleicher Priorität kommt der Job zuerst vor, der als erstes hinzugefügt wurde.


4. [task][Iterator]()
Ersetze nun die Beispielimplementierung in den Methoden `hasNext` und `next` in der Klasse `JobIterator`. Über Jobs soll dann auf der oben beschriebenen Art iteriert werden. Die Methode `next` wird nie aufgerufen, wenn `hasNext` `false` zurückgibt.

 
 **Beispiel** 
```java
JobManager jobManager = new JobManager();
jobManager.addJob(new Job(1, 10), 2);
jobManager.addJob(new Job(2, 20), 2);
jobManager.addJob(new Job(3, 30), 1);
jobManager.addJob(new Job(4, 30), 450);
jobManager.addJob(new Job(5, 30), 254);
JobIterator jobIterator = new JobIterator(jobManager.getPriorityGroups());
while (jobIterator.hasNext()) {
    System.out.println(jobIterator.next().getId());
}
```
Gibt das folgende aus:
```
4
5
1
2
3
```
 
**Hinweis:** Versuche erst zu verstehen, was im Konstruktor gemacht wird.

 

5. [task][Iterable]()
Ergänze jetzt die Klasse `JobManager` so, dass sie das Interface `Iterable ` mit dem Iterator `JobIterator` implementiert.

# Zeitaufwand

Berechne nun die Summe der Dauer von den (in der oben beschriebenen Reihenfolge) ersten `numberOfJobs` Jobs. Wenn insgesamt weniger als `numberOfJobs` Jobs vorhanden sind, soll einfach die gesamte Dauer von allen Jobs berechnet werden.

6. [task][Summe]()
Implementiere in der Klasse `Main` die Methode `public static int durationOfFirstJobs(Iterable  jobManager, int numberOfJobs)`.  
 
 **Beispiel** 
```java
JobManager jobManager = new JobManager();
jobManager.addJob(new Job(1, 10), 2);
jobManager.addJob(new Job(2, 20), 2);
jobManager.addJob(new Job(3, 30), 1);
jobManager.addJob(new Job(4, 30), 450);
jobManager.addJob(new Job(5, 30), 254);
System.out.println(durationOfFirstJobs((Iterable ) jobManager, 3));
```
Gibt das folgende aus:
```
70
```"
299,Praktikum: Grundlagen der Programmierung WS23/24,12711,Universe Redo,"# Universe

##Allgemeine Hinweise
In dieser Aufgabe musst du einige Klassen und Interfaces implementieren. Alle notwendigen Dateien existieren bereits, es müssen also keine neuen Dateien erstellt werden.

Du kannst das Enum `ConsoleOutputs` für Ausgabetexte nutzen, damit du dich nicht aus versehen vertippst. Hier findest du alle Strings die für diese Aufgabe notwendig sind. Für Typos in den Konsolenausgaben wird es Punktabzug geben!
Wie schon in den P- und H-Aufgaben werden die Strings in der Angabenstellung mit `⎵` statt Leerzeichen dargestellt. Die Implementierung soll die `⎵` durch Leerzeichen ersetzen!

Genauso muss darauf geachtet werden, dass die geforderten Signaturen und Parameterreihenfolgen stimmen. Auf Fehler hierbei wird es ebenso Punktabzug geben!

*Tipp*: Du kannst die main-Methode in der Klasse `Main` zum Testen benutzen.

## Klassen
Wir betrachten in dieser Aufgabe ein Universum, das von Tieren bevölkert wird, und wollen diese Tiere genauer klassifizieren. 
- `Animal` ist die Oberklasse von allen Tieren und beinhaltet unter anderem den Namen des Tieres und dessen Geschlecht (`sex`) für die Fortpflanzung. Der Einfachheit halber werden in diesem Modell nur zwei Geschlechter betrachtet.
- `Bird` ist eine weitere Oberklasse für verschiedene Vögel. Sie speichert zudem noch die Melodie ab, die von diesem Vogel gesungen werden kann.
- `Oviparous` und `Viviparous` geben an, wie die Nachkommen der Tiere auf die Welt kommen. `Oviparous` gibt dabei an, dass die Tiere Eier legen, und `Viviparous` gibt an, dass die Nachkommen der Tiere lebend geboren werden.
- Die weiteren Klassen sollen in den folgenden Aufgaben implementiert werden.

1. [task][Universe]()
Implementiere die Klasse `Universe`. Es soll immer nur ein Objekt von dieser Klasse existieren können!
Erstelle dafür die Methode `public static Universe getUniverse()`. Sie soll einmalig ein neues Objekt erstellen und dann bei jedem Aufruf die Referenz auf dieses Objekt zurück geben.
Es darf in anderen Klassen nicht möglich sein anderweitig ein Objekt dieser Klasse zu erstellen.
Zudem musst du implementieren, dass die `inhibitors` dieses Universums in einem `HashSet` gespeichert werden.

2. [task][Viviparous]()
Implementiere das Interface `Viviparous`, das alle Tiere mit Lebendgeburten darstellt. Es stellt die default-Methode `void giveBirth()` bereit, die in der Konsole folgende _Zeile_ ausgibt: ""\ ⎵gave⎵birth! "". _Achtung_: \  muss natürlich noch passend ersetzt werden.

3. [task][Mammal]()
Implementiere die abstrakte Klasse `Mammal`, welche von `Animal` erben soll.
Da fast alle Nachkommen von Säugetieren lebend geboren werden, soll die Klasse zudem das Interface `Viviparous` implementieren.
Sie speichert zusätzlich die Anzahl der Zitzen (`numberOfTeats`) ab. Es werden dabei nie höhere Werte als 100 erwartet, wähle den Datentyp dementsprechend sinnvoll aus (das bedeutet möglichst klein). Achte darauf, dass alle Klassen, die `Mammal` erweitern auf das Attribut `numberOfTeats` zugreifen können sollen, ohne auf Getter und Setter zugreifen zu müssen.
Der Konstruktor soll als Parameter die Attribute von `Animal` annehmen und zusätzlich noch `numberOfTeats` als _letzten_ Parameter entgegen nehmen. Alle Attribute sollen mit diesen Parametern dann initialisiert werden.
Zudem soll die Methode `public void suckle()` implementiert werden, die in der Konsole folgende _Zeile_ ausgibt: ""\ ⎵is⎵suckling! "". _Achtung_: \  muss natürlich noch passend ersetzt werden.

4. [task][Platypus]()
Implementiere die Klasse `Platypus`. Schnabeltiere sind Säugetiere, legen aber Eier. Erstelle dafür passend die Vererbungshierarchie in dieser Klasse.
Sie besitzen keine Zitzen, die anderen Attribute müssen als Parameter im Konstruktor übergeben werden und mit ihnen dann initialisiert werden.
Achte darauf, dass Schnabeltiere keine Lebendbegurten machen können und die entsprechende Methode dafür dementsprechend in dieser Klasse nichts macht oder ausgibt.
Zuletzt sollen sich Schnabeltiere fortpflanzen können. Dies soll nur möglich sein, wenn beide Tiere ein Schnabeltier sind und ein verschiedenes Geschlecht haben. Das Weibchen soll dann ein Ei legen.

5. [task][Parrot]()
Implementiere die Klasse `Parrot`. Papageien sind natürlich Vögel. Erstelle dafür passend die Vererbungshierarchie in dieser Klasse.
Im Konstruktor müssen an `Bird` alle Parameter in derselben Reihenfolge übergeben und dann passend initialisiert werden.
Zuletzt sollen sich auch Papageien fortpflanzen können. Dies soll wieder nur möglich sein, wenn beide Tiere ein Papagei sind und ein verschiedenes Geschlecht haben. Das Weibchen soll dann wieder ein Ei legen."
299,Praktikum: Grundlagen der Programmierung WS23/24,12890,Streams Redo,"# WICHTIG
 !!!  Bei dieser Aufgabe dürfen **KEINE SCHLEIFEN** verwendet werden. Jegliche Nutzung bei den Abgaben (inklusive Vorkommen im Testcode) führt dazu, dass die gesamte Aufgabe mit 0 Punkten bewertet wird.

# Streams
* Alle Klassen, deren Objekte in den Teilaufgaben bearbeitet werden, sind in `pgdp.streams.models` definiert. In diesem Package dürfen **keine Änderungen** vorgenommen werden.
* In allen Teilaufgaben kann angenommen werden, dass die Parameter nie `null` sein werden. Das gilt auch für einzelne Elemente von Arrays, die in den Parametern vorkommen.
* Zwei Objekte sind gleich, wenn ihre `equals`-Methode `true` zurückgibt.
* Ein `Teacher` kommt nie in seinem eigenen `students`-Array oder dem eines anderen `Teacher`s vor. Wenn ein `teachers`-Array als Parameter übergeben wird, enthält dieses jeden `Teacher` höchstens einmal.

1. [task][Durchschnittsalter]()
Implementiere die Methode `averageAge(Person[] people)`, die das durchschnittliche Alter aller Personen in `people` zurückgibt. Du kannst davon ausgehen, dass `people` mindestens ein Element enthält.  
**Hinweis:** Rückgabewert der Methode ist `double`, nicht `OptionalDouble`!

2. [task][Hausaufgaben]()
Implementiere die Methode `createHomeworks(Teacher teacher, int numberOfHomeworks)`, die einen Stream von `numberOfHomeworks`-vielen Hausaufgaben erstellt. Eine Hausaufgabe wird vom `teacher` mittels `teacher.createHomework()` erstellt.

3. [task][Schwere Hausaufgaben 1]()
Implementiere die Methode `mostDifficultHomework(Stream  homeworkStream)`, welche die schwierigste Hausaufgabe aus dem Stream `homeworkStream` zurückgibt. Falls `homeworkStream` leer ist, soll `Optional.empty()` zurückgegeben werden. Eine Hausaufgabe gilt als schwieriger als eine andere, wenn ihre `getDifficulty`-Methode einen höheren Wert zurückgibt.

4. [task][Schwere Hausaufgaben 2]()
Implementiere die Methode `mostDifficultHomework(Teacher teacher, int numberOfHomeworks)`, die zunächst `numberOfHomeworks`-viele Hausaufgaben mithilfe des `teacher`s erstellt und von diesen die schwierigste Hausaufgabe wie in den Teilaufgaben 2 und 3 zurückgibt. 

5. [task][Machbare Hausaufgaben]()
Implementiere die Methode `doableHomework(Teacher teacher, int numberOfHomeworks, int thresholdDifficulty)`, die einen Stream von Hausaufgaben wie in Teilaufgabe 2 erstellt, aber nur die Hausaufgaben zurückgibt, deren Schwierigkeit strikt kleiner als `thresholdDifficulty` ist.

6. [task][Lösungen, bis es zu schwer wird]()
Implementiere die Methode `doHomeworkUntilTooDifficult(Stream  homework, int thresholdDifficulty)`. Sie soll alle Hausaufgaben aus `homework` bearbeiten, bis eine Hausaufgabe erreicht wird, die zu schwer (Schwierigkeit größer oder gleich `thresholdDifficulty`) ist. Die Hausaufgaben sollen dann in einen Stream von `Solution`s umgewandelt werden.
Das Fach einer Lösung ist natürlich das gleiche wie das Fach der Aufgabe. Für eine Hausaufgabe mit Schwierigkeit 0 werden 10 Minuten benötigt und die Dauer einer Hausaufgabe steigt pro Schwierigkeitsstufe um 10 Minuten.

7. [task][Zeitaufwand]()
Implementiere die Methode `timeTakenForSubject(Stream  solutions, Subject subject)`. Sie soll die Zeit berechnen, die für alle Lösungen in `solutions` aus dem Fach `subject` benötigt wird.

8. [task][Schüler]()
Implementiere die Methode `allStudents(Teacher[] teachers)`. Sie soll einen Stream bestehend aus allen Schülern von jedem Lehrer in `teachers` zurückgeben. Die Schüler sollen dabei im Stream nur einmal vorkommen.

9. [task][Anzahl der Schüler]()
Implementiere die Methode `numberOfStudents(Teacher[] teachers)`. Sie soll die Anzahl der Schüler aller Lehrer in `teachers` wie in Teilaufabe 8 zurückgeben.

10. [task][Lister aller Personen]()
Implementiere als letztes die Methode `allPeopleAlphabeticallyList(Teacher[] teachers)`. Sie soll eine Liste bestehend aus allen Lehrern aus `teachers` und ihren Schülern zurückgeben.
Wie in Teilaufgabe 8 sollen die Personen im Stream nur einmal vorkommen. Ferner sollen die Personen in der Liste alphabetisch nach ihrem Namen sortiert sein."
299,Praktikum: Grundlagen der Programmierung WS23/24,12891,Threads Redo,"# Jobs

In dieser Aufgabe ist ein `Job` ein `Thread`. `Jobs` können voneinander abhängig sein. Ein `Job` kann seinen `Task` erst ausführen, wenn alle seine Vorgänger (`dependencies`) abgeschlossen sind. Ein `Job` speichert zusätzlich alle `Jobs` ab, die auf diesen `Job` warten müssen (`successors`). Ein `JobMaster` dient dazu eine Vielzahl an `Jobs` zu generieren, starten und stoppen.
Sowohl `Job` als auch `JobMaster` enthalten bereits viele Konstuktoren um dir das Testen zu vereinfachen. Die zugehörigen Kommentare beschreiben die Instanzen, die du damit erstellen kannst.

*Tipp:* Die folgenden Teilaufgaben können unabhängig voneinander gelöst werden. Achte darauf, die Methoden zu nutzen, wenn die Angabe dies vorschreibt und deren Signatur nicht zu verändern.

## Job

1. [task][notifySuccessors]()
Implementiere die Methode `Job.notifySuccessors()`. Diese soll bei allen folgenden `Jobs` (`successors`) den aktuellen `Job` aus den Vorgängern entfernen (`Job.removeDependency(Job)`) und diese benachrichtigen bzw. wecken.
2. [task][completeTask]()
Implementiere die Methode `Job.completeTask()`. Diese soll zunächst im `PrintStream` des aktuellen `Jobs` *eine Zeile* ausgeben, die signalisiert, dass damit begonnen wird zu arbeiten. Der ausgegebene `String` besteht aus dem Namen des `Threads` (`Thread.getName()`) konkateniert mit dem `String` `Job.START_WORKING`, z.B. "" MyThreadName⎵started⎵working. "".
Anschließend soll der `Task` ausgeführt werden, dies geschieht mit der Methode `Task.execute()`.
Sobald der `Task` fertig ist, muss im `PrintStream` des `Jobs` *eine Zeile* ausgegeben werden, die signalisiert, dass die Bearbeitung beendet wurde. Der ausgegebene `String` besteht aus dem Namen des `Threads` (`Thread.getName()`) konkateniert mit dem `String` `Job.IS_DONE`, z.B. "" MyThreadName⎵is⎵done! "".
Zuletzt müssen noch die Nachfolger entsprechend benachrichtigt werden, dies geschieht mit der Methode `Job.notifySuccessors()`
3. [task][waitForDependency]()
Implementiere die Methode `Job.waitForDependency()`. Die Methode setzt den Thread sofort in einen wartenden Zustand (`Thread.wait()`), bis dieser via `Thread.notify()` benachrichtigt wird. Sobald dies geschieht, wird im `PrintStream` des aktuellen `Jobs` *eine Zeile* ausgegeben, die signalisiert, dass der `Job` geweckt wurde. Der ausgegebene `String` besteht aus dem Namen des `Threads` (`Thread.getName()`) konkateniert mit dem `String` `Job.IS_AWAKE`. Hat der `Job` keine weiteren Vorgänger (`dependencies`) auf die er warten muss, so gibt die Methode `true` zurück, andernfalls `false`.
4. [task][run]()
Implementiere die Methode `Job.run()`. Diese soll, solange der Thread nicht interrupted wurde, auf das Fertigwerden der Vorherigen `Jobs` warten. Dazu soll die Methode `waitForDependency()` genutzt werden. Zur Erinnerung: diese gibt `true` zurück wenn keine Vorgänger existieren. Sobald dies der Fall ist, kann der eigentliche `Task` ausgeführt und die Nachfolger informiert werden, indem die Methode `Job.completeTask()` aufgerufen wird. Denk daran, dass die Methode `Job.completeTask()` bereits die Nachfolger informiert. Ist der `Task` abgeschlossen, kann das wiederholte Warten und damit der `Job` selbst beendet werden.

## JobMaster

1. [task][start]()
Implementiere die Methode `JobMaster.start()`. Diese startet alle `Jobs`.
2. [task][stop]()
Implementiere die Methode `JobMaster.stop()`. Diese soll alle `Jobs` sachgerecht terminieren, auch wenn diese noch warten. Das bedeutet wartende `Jobs` sollen unterbrochen werden, auch wenn diese noch nicht ihre Aufgabe erfüllt haben."
299,Praktikum: Grundlagen der Programmierung WS23/24,12892,Debug Redo,"#Debug 
In dieser Aufgabe geht es darum, die bereits implementierten Methoden an deren Beschreibungen anzupassen. Meistens sind minimale Änderungen hinreichend. Du musst also die Methoden nicht von vorne implementieren.

1. [task][payWith]()
Die Methode `BankAccount.payWith(Customer customer, double amount, Account... accounts)` soll alle Konten nach dem übergebenen Kunden durchsuchen und den Betrag `amount` abziehen, wenn es ein Konto gibt, was dem Kunden gehört und mindestens so viel Geld wie `amount` hat. Gesucht wird vom kleinsten zum größten Index. Achte dabei darauf, dass die Konten nicht notwendigerweise dem Kunden selbst gehören und der gesammte Betrag von genau einem Konto abgebucht werden soll. Mit Konten anderer Kunden kann nicht bezahlt werden.

2. [task][mergeAccounts]()
Die Methode `BankAccount.mergeAccounts(Account... accounts)` soll die beiden Konten mit dem kleinsten und dem größten Geldbetrag finden. Insofern möglich, sind diese unterschiedlich. Zurückgegeben werden soll der gesammte Geldbetrag, der sich auf den beiden Konten bzw. dem Konto befindet. Du kannst davon ausgehen, dass keiner der `accounts` `null` ist.

3. [task][addInterest]()
Die Methode `BankAccount.addInterest(Account account)` soll den Nettobetrag berechnen, nachdem der Zinssatz auf den aktuellen Betrag des Kontos berechnet wurde. Beispiel: Bei einem Zinssatz von 5% und einem Kontostand von 10.000 Euro beträgt der Nettobetrag nach dem Erhalt der Zinsen 10.500 Euro. Der Zinssatz ist durch den Parameter `rate` gegeben. Du kannst davon ausgehen, dass der `account` nicht `null` ist, einen nicht negativen Geldbetrag enthält und der Zinssatz ebenfalls nicht negativ ist.

4. [task][authenticateAccess]()
Die Methode `BankAccount.authenticateAccess(Account account)` soll wiederholt eine Nutzereingabe im Terminal lesen und verifizieren, bis das eingegebene Passwort korrekt ist. Das Passwort ist korrekt, sobald `Account.validatePassword(int password)` `true` zurück gibt. Du darfst davon ausgehen, dass nur Ganzzahlen eingegeben werden, d.h. du musst dir keine Gedanken über Exceptions machen, die durch das Einlesen selbst geworfen werden könnten. Zusätzlich kannst du davon ausgehen, dass der `account` nicht `null` ist.

5. [task][sortCustomers]()
Die Methode `CustomerService.sortCustomers(List  customerSet, Comparator  ...comparator)` soll die übergebene Liste aus Kunden als sortierte Liste zurückgeben. Die Reihenfolge der Comparators bestimmt die Priorität der Attribute, nach denen die Kunden sortiert werden sollen.
Beispiel: Für `sortCustomers(customers, BY_LAST_NAME, BY_FIRST_NAME, BY_AGE)` werden die Kunden erst nach ihren Nachnamen sortiert, gefolgt von Vorname und Alter. Du kannst davon ausgehen, dass keine der Eingaben `null` ist (inklusive der Elemente der Liste).

6. [task][analyzeCustomers]()
Die Methode `CustomerService.analyzeCustomers(Set  customers)` bekommt ein Set von Kunden und soll analysieren und auf der Konsole ausgeben, ob im gegebenen Set mindestens ein Kunde minderjährig (jünger als 18) ist, keine Minderjährigen vorhanden sind oder alle minderjährig sind. Du kannst davon ausgehen, dass keine der Eingaben `null` ist (inklusive der Elemente des Sets).

7. [task][filterCustomerList]()
Die Methode `CustomerService.filterCustomerList(CustomerList customerList, Predicate  predicate)` filtert die gegebene Liste von Kunden und löscht alle Elemente, die das Prädikat `predicate` nicht erfüllen. Du kannst davon ausgehen, dass keine der Eingaben `null` ist (inklusive der Elemente der CustomerList)."
299,Praktikum: Grundlagen der Programmierung WS23/24,12902,Kreise Redo,"# Kreise

1. [task][In oder auf dem Kreis]( 191718 , 191710 , 191698 , 191703 , 191708 , 191722 , 191700 )
Implementiere die Methode `isOnOrInsideCircle(int r, int x, int y)` in der Klasse `Kreise`. Sie soll zurückgeben, ob sich der Punkt $$(x, y)$$ auf dem Koordinatensystem
**innerhalb oder auf dem Kreis** mit Mittelpunkt $$(0, 0)$$ und Radius $$r$$ befindet.  
**Hinweis:** Der Abstand von einem beliebigen Punkt $$(x, y)$$ zum Ursprung ( $$(0,0)$$ ) ist gleich $$ \sqrt{(x^2+y^2)} $$. Der Kreis selbst besteht aus Punkten mit Abstand `r` zum Ursprung.

# Im roten Bereich
Betrachte den Kreis mit Mittelpunkt $$(0, 0)$$ und Radius $$200$$, sowie das Quadrat 1, mit Ecken $$(0,0), (0,100), (100, 0), (100, 100)$$ 
und das Quadrat 2 mit Ecken $$(-100, -100), (0, -100), (-100, 0), (0, 0)$$. Der Bereich zwischen dem Kreis und den Quadraten ist in der folgenden Abbildung rot markiert.

Die Ränder der Quadrate und des Kreises gehören dabei zu dem roten Bereich.

![red_area.svg](/api/core/files/markdown/Markdown_2023-10-25T10-38-31-333_94abd42b.svg)


2. [task][Im roten Bereich]( 191721 , 191709 , 191693 , 191711 , 191714 , 191707 , 191723 , 191715 , 191713 , 191699 , 191696 , 191705 , 191694 , 191712 , 191702 , 191720 , 191701 )
Implementiere die Methode `isInRedArea(int x, int y)`, die zurückgibt, ob der Punkt $$(x, y)$$ sich auf dem oben beschriebenen roten Bereich befindet.


# PI Approximation
Für eine gegebene positive ganze Zahl $$n$$, betrachten wir jetzt die Punkte $$(x,y)$$ mit $$ x,y \in \mathbb{Z}, -n \le x \le n, -n \le y \le n$$. Für $$n=5$$ sind sie auf der folgenden Abbildung dargestellt.
Die roten Punkte befinden sich im oder auf dem Kreis.

![circle.svg](/api/core/files/markdown/Markdown_2023-10-25T10-39-49-003_8653c5e2.svg)


3. [task][PI Approximation - Teil 1]( 191704 , 191697 , 191724 , 191717 , 191706 )
Implementiere die Methode `countPointsInCircle(int n)`, die die Anzahl solcher Punkte zurückgibt, die sich in oder auf dem Kreis mit dem Radius $$n$$ befinden. 


4. [task][PI Approximation - Teil 2]( 191691 , 191690 , 191692 , 191689 , 191725 )
Sie $$n$$ gegeben. $$Dots$$ sei die Anzahl aller Punkte $$(x,y)$$ aus Teilaufgabe 3. $$Red$$ sei die Anzahl der Punkte in oder auf dem Kreis. Dann ergibt $$\frac{Red}{Dots}*4$$ eine Approximation von $$\pi$$, die mit steigendem $$n$$ immer exakter wird.
Implementiere die Methode `approximatePi(int n)`, die für $$n$$ diese Approximation berechnet."
299,Praktikum: Grundlagen der Programmierung WS23/24,12903,Penguin Numbers Redo,"# Penguin Numbers

## Definition

Penguin Numbers sind eine Folge von Zahlen, die wie folgt definiert werden kann:  
- $$ p\_0 = 0 $$
- $$ p\_1 = p\_2 = 1 $$
- für positive $$n$$ ($$n > 0$$) ist $$ p\_n $$ definiert als $$ p\_n = p\_{n-1} + p\_{n-2} + p\_{n-3} $$. Die Penguin Number $$ p\_n $$ berechnet sich also aus der Summe der drei vorherigen Penguin Numbers.
- für negative $$n$$ ($$n < 0$$) ist $$ p\_n $$ mit $$n = -n'$$ definiert als $$ p\_n = p\_{-n'} = (-1)^{n'+1} \cdot p\_{n'} $$. Der Betrag der Penguin Numbers $$p\_n$$ und $$p\_{-n}$$ ist also gleich, einzig und allein das Vorzeichen kann sich unterscheiden.
- die $$n$$-te Penguin Number ($$ p\_n$$) nennen wir auch die Penguin Number mit *Index* $$n$$

**Beispiel:** In dieser Tabelle findest du einige Beispiele:

 
 
 n 
 -7 
 -6 
 -5 
 -4 
 -3 
 -2 
 -1 
 0 
 1 
 2 
 3 
 4 
 5 
 6 
 7 
 
 
  $$ p_n $$ 
 24 
 -13 
 7 
 -4 
 2 
 -1 
 1 
 0 
 1 
 1 
 2 
 4 
 7 
 13 
 24 
 
 

**Achtung:** Da wir Rekursion noch nicht in PGdP behandelt haben, soll die Aufgabe ohne rekursive Aufrufe implementiert werden. Solltest du dennoch Rekursion benutzen, behalten wir uns Punktabzug vor.

## Aufgabe

1. [task][penguNumPositive]( 191865 , 191786 , 191921 , 191766 , 191850 , 191774 , 191801 , 191737 )
Implementiere die Methode `penguNumPositive(int)`. Die Methode bekommt einen *nicht negativen* Integer `n` als Eingabe und soll die `n`-te Penguin Number als `long` zurückgeben. Deine Implementierung muss für alle Eingaben die *nicht negativ* (d.h. größer oder gleich `0`) das richtige Ergebnis zurückgeben, solange dieses in einem `long` gespeichert werden kann.

2. [task][penguNumNegative]( 191882 , 191829 , 191883 , 191807 , 191860 , 191815 , 191902 , 191839 , 191910 , 191833 , 191870 , 191847 , 191869 , 191799 , 191879 , 191835 , 191812 , 191733 )
Implementiere die Methode `penguNumNegative(int)`. Die Methode bekommt einen *negativen* Integer `n` als Eingabe und soll die `n`-te Penguin Number als `long` zurückgeben. Deine Implementierung muss für alle Eingaben die *negativ* (d.h. kleiner als `0`) das richtige Ergebnis zurückgeben, solange dieses in einem `long` gespeichert werden kann.

3. [task][penguNum]( 191843 , 191863 , 191853 , 191845 , 191861 , 191855 , 191857 , 191851 , 191787 )
Implementiere die Methode `penguNum(int)`. Die Methode bekommt einen Integer `n` als Eingabe und soll die `n`-te Penguin Number als `long` zurückgeben. Deine Implementierung muss für alle Eingaben das richtige Ergebnis zurückgeben, solange dieses in einem `long` gespeichert werden kann.  
**Achtung:** Für diese Teilaufgabe kannst du nur Punkte erhalten, wenn du `penguNumPositive` und `penguNumNegative` implementiert hast. Die Implementierungen müssen dafür nicht zu 100% richtig sein, eine teilweise korrekte Implementierung reicht aus.

4. [task][penguNumIndex]( 191935 , 191876 , 191936 , 191884 , 191896 , 191917 , 191906 , 191901 , 191742 , 191764 )
Implementiere die Methode `penguNumIndex(long)`. Die Methode bekommt eine Penguin Number `n` als Eingabe und soll den Index der Penguin Number als `int` zurückgeben. Deine Implementierung muss für alle validen Eingaben (d.h. du kannst davon ausgehen, dass die Eingabe tatsächlich eine Penguin Number ist) das richtige Ergebnis zurückgeben. Ist der Index nicht eindeutig, soll bevorzugt der *positive* Index ausgegeben werden. Sind beide möglichen Indexe positiv, soll der *kleinste* Index zurückgegeben werden.  

5. [task][isPenguNumPositive]( 191889 , 191735 , 191823 , 191888 , 191803 , 191772 , 191729 , 191837 , 191734 , 191809 , 191784 , 191796 , 191732 , 191748 )
Implementiere die Methode `isPenguNumPositive(long)`. Die Methode bekommt einen *nicht negativen* Long `n` als Eingabe und soll `true` zurück geben wenn die Eingabe eine Penguin Number ist, ansonsten `false`. Deine Implementierung muss für alle Eingaben die *nicht negativ* (d.h. größer oder gleich `0`) das richtige Ergebnis zurückgeben.  
**Achtung:** In dieser Teilaufgabe ist es nicht erlaubt eine der bereits implementierten Methoden wieder zu verwenden. Insbesondere bezieht sich dies auf `penguNum()`, `penguNumPositive()` und `penguNumNegative()`.

6. [task][isPenguNum]( 191760 , 191730 , 191805 , 191825 , 191827 , 191819 , 191821 , 191811 , 191849 , 191817 , 191831 , 191813 , 191841 , 191749 , 191897 )
Implementiere die Methode `isPenguNum(long)`. Die Methode bekommt einen Long `n` als Eingabe und soll `true` zurück geben wenn die Eingabe eine Penguin Number ist, ansonsten `false`. Deine Implementierung muss für alle Eingaben das richtige Ergebnis zurückgeben.
**Hinweis:** In dieser Teilaufgabe ist es erlaubt und sogar ratsam eine (oder mehrere) der bereits implementierten Methoden wiederzuverwenden."
299,Praktikum: Grundlagen der Programmierung WS23/24,12904,Arrays und Pinguine Redo,"# Arrays und Pinguine

### Größtes gemeinsames Element
Gegeben seien zwei Arrays von nicht-negativen Integern. Schreibe eine Funktion, die die größte Zahl zurückgibt, die in beiden Arrays vorkommt. Wenn es kein solches Element gibt, muss die Funktion `-1` zurückgeben.
1. [task][Großtes gemeinsames Element]()
Implementiere die Methode `greatestCommonElement(int[], int[])` in der Klasse `ArraysUndPinguine`.
 


### Aufsteigende Teilfolge
Wenn wir alle Elemente aus dem Array entfernen, die nicht strikt größer sind als **alle** vorherigen Elemente, bekommen wir eine aufsteigende Teilfolge.  

2. [task][Aufsteigende Teilfolge]()
Implementiere die Methode `toAscending(int[])` in der Klasse `ArraysUndPinguine`, die mit dem oben beschriebenen Verfahren aus der gegebenen Array eine aufsteigende Array macht und diese zurückgibt.  
**Beispiel:** Aus dem Array `{1, 5, 3, 4, 6, 6}` werden die Elemente `3`, `4`, und eine `6` entfernt. (`3` und `4` sind nicht größer als `5`, die zweite `6` ist nicht größer als die erste `6`.) Das Ergebnis wäre dann `{1, 5, 6}`.
 **Hinweis:** Möglicherweise hat das Array, das zurückgegeben wird, eine andere Länge als die Eingabe.
 



### Pingulympics
Bei den Pingulympics werden die Spieler in Teams verteilt basierend auf ihren Namen. Dabei besteht jedes Team aus Pinguinen, deren Namen mit dem gleichen Buchstaben anfangen. 
 `Alex`, `Alice`, `Bob`, `Bertha` und `Cathy` würden z.B. in drei Teams verteilt werden: Alex & Alice, Bob & Bertha und Cathy allein. Wir wollen jetzt rausfinden, wie viele Teams es auf den Pingulympics gibt. Dabei bestehen Namen ausschließlich aus ASCII Buchstaben, und alle Namen bestehen aus mindestens einem Buchstaben. Außerdem ist der erste Buchstabe immer groß.
 
3. [task][Teamverteilung]()
Implementiere die Methode `numberOfTeams(char[][])` in der Klasse `ArraysUndPinguine`, die die Anzahl der Teams nach der Verteilung zurückgibt. Das Eingabeparameter ist eine Array von Namen, die als `char[]` dargestellt werden. 
**Beispiel:** `numberOfTeams( new char[][] { {'A', 'l', 'e', 'x'}, {'B', 'e', 'r', 't', 'h', 'a'}, {'B', 'o', 'b'}, {'A', 'l', 'i', 'c', 'e'}, {'C', 'a','t','h','y'} } )` soll `3` zurückgeben.
 


### Pinguball
Beim Hauptspiel der Pingulympics hat jedes Team genau `4` Würfe auf ein rechteckiges Ziel. Das Ziel ist in Felder mit unterschiedlichen Punktzahlen unterteilt. Danach wird wie folgt berechnet, wie viele Punkte ein Team bekommen hat:
- Jedes getroffene Feld bringt die entsprechende Menge an Punkte, allerdings nur **einmal** unabhängig davon wie oft das Feld getroffen wurde. 
- Ein Team bekommt `10` Bonuspunkte wenn alle Würfe das Ziel treffen, unabhängig davon welches Feld getroffen wurde.
- Für jede Zeile oder Spalte, auf der alle Felder getroffen wurden, bekommt ein Team `5` Bonuspunkte.

4. [task][Pinguball]()
Implementiere die Methode `pinguballPoints(int[][] fieldPoints, int[][] hits)` in der Klasse `ArraysUndPinguine`, die die erreichte Punktzahl zurückgibt. Dabei beschreibt `fieldPoints` wie viele Punkte die jeweiligen Felder bringen. `hits` hat dieselben Dimensionen und beschreibt wie viele Würfe die einzelnen Felder getroffen haben.  
Die Punktzahl passt immer in ein `int`. 

**Beispiel:**  
`pinguballPoints(new int[][] {{1, 2, 3}, {4, 5, 6}, new int[][] {{1, 0, 2}, {0, 1, 0}}` gibt `19` zurück.
 
     fieldPoints hits Punkte 
 
 
 1 2 3 
 4 5 6 
 
 
 
 
 1 0 2 
 0 1 0 
 
 
 
Das Team bekommt `19` Punkte. (Getroffenne Felder: `1 + 3 + 5`, `+10` Bonuspunkte, weil alle vier getroffen haben)
 
 
 
 1 2 
 4 5 
 
 
 
 1 1 
 0 1 
 
 
Das Team bekommt `18` Punkte. (Getroffene Felder `1 + 2 + 5`, `5` Bonuspunkte für die erste Zeile. `5` Bonuspunkte für die zweite Spalte.)"
299,Praktikum: Grundlagen der Programmierung WS23/24,13082,Pingu Reise Redo,"# Pingureise

Wie Pinguine reisen, wird in der Klasse `Travel` modelliert. Dabei hat jede Reise einen Startpunkt (`startDestination`)
vom Typ `Destination`. Die Klasse `Destination` modelliert die Reiseziele. Das Feld `trainConnectionsTo` beinhaltet die `Destination`s,
die von der `Destination` aus erreichbar sind.

Die `startDestination` wird bei allen Tests ungleich `null` sein. 

## Reiseplanung
In der Klasse `TravelIterator` wird implementiert, in welcher Reihenfolge die Pinguine die `Destination`s besuchen.
Es wird mit der startDestination gestartet, und die nächste Destination ist immer diejenige aus trainConnectionsTo mit dem kleinsten Index, die noch nicht besucht wurde.
Gibt es keine unbesuchte `Destination` mehr (oder allgemein keine), ist die Reise beendet.

1. [task][Iteratoren]()
In der Klasse `TravelIterator` ist eine Beispielimplementierung gegeben. Ersetze diese Implementierung durch eine neue,
so dass die `Destinations` in der oben beschriebenen Reihenfolge zurückgegeben werden. 
Du musst die Funktionen `hasNext()`, `next()` und möglicherweise den Konstruktor anpassen.   
**Hinweise:**  
 
  Eine Implementierung, die immer die erste passende `Destination` aus `trainConnectionsTo` zurückgibt, bringt auch einen Teil der Punkte 
  Überlege was für ein Attribut du dem Iterator hinzufügen kannst, um dir zu merken, welche `Destination`s
schon besucht wurden. 
  Die weiteren Teilaufgaben können auch mit dem vorgegebenem Iterator implementiert werden, sie werden 
unabhängig bewertet. 
  Es werden nicht immer alle `Destination`s besucht. Es kann sein, dass die Reise schon vorher beendet ist. 
 
 
 Beispiel (inkludiert in main) 
```java
Destination start = new Destination(""South pole"", 10);
Destination d1 = new Destination(""Iceberg"", 5);
Destination d2 = new Destination(""Madagascar"", 15);
Destination d3 = new Destination(""Atlantis"", 7);

start.addTrainConnection(d1);
start.addTrainConnection(d2);

d1.addTrainConnection(d3);
d1.addTrainConnection(d2);

d3.addTrainConnection(d2);

Travel travel = new Travel(start);
```
Reihenfolge: start, d1, d3, d2 (South pole, Iceberg, Atlantis, Madagascar)
 

2. [task][Iterable]()
Passe die Klasse `Travel` so an, dass sie das Interface `Iterable ` korrekt implementiert. 
Dabei soll ein `Iterator` zurückgegeben werden, der die oben beschriebene Reihenfolge einhält. 

## Die Reise beginnt
In der Klasse `Main` wird das folgende so implementiert, dass Travel als Iterable verwendet wird.

3. [task][Fotos]()
Implementiere die Methode `public static averageNumberOfPhotos(Travel travel)`, die den durchschnittlichen Wert der
Fotos per `Destination` zurückgibt. Dabei wird bei jeder `Destination` genau ein Foto per 
Sehenswürdigkeit (`numberOfSightseeingSpots`) gemacht. Die gesamte Anzahl der Fotos wird immer in ein `int` passen und es gibt immer mindest ein Reiseziel.
 
 Beispiel 
Mit `Travel travel` aus Teilaufgabe 1 gibt `averageNumberOfPhotos(travel)` 9.25 zurück. (Wenn du Teilaufgabe 1 nicht implementierst, sondern die vorgegebene Beispielimplementierung verwendest, soll `averageNumberOfPhotos(travel)` 10.0 zurückgeben)
 

4. [task][Reiseziele]()
Implementiere die Methode `public static List  listOfDestinations(Travel travel)`, die eine Liste 
(`java.util.List`), der `Destination`s zurückgibt, die in der Reise besucht werden, und zwar in der korrekten Reihenfolge. 
 
 Beispiel 
Mit `Travel travel` aus Teilaufgabe 1 gibt `listOfDestinations(travel)` die Liste von Destinationen zurück:
`[South pole:10, Iceberg:5, Atlantis:7, Madagascar:15]`."
404,Praktikum: Grundlagen der Programmierung WS24/25,14671,Hello Pengu,"# Hallo Pinguine!

Die Pinguine sind zu ihrer ersten Stunde `Praktikum: Grundlagen der Pinguine` ... äh `Praktikum: Grundlagen der Programmierung` zusammengekommen. Da sie aber sehr schüchtern sind, musst du sie zuerst begrüßen.

### Teil 1: Einrichten der IDE

Installiere dafür zuerst Java und Eclipse oder IntelliJ (bzw. eine andere IDE). Eine Anleitung hierfür gibt es auf Artemis und wird in der Tutorübung besprochen. Stelle sicher, dass alles korrekt installiert ist und die geforderten Einstellungen bezüglich des Encodings gesetzt wurden. Frage bei allen Problemen einen Tutor bzw. sieh im Zulip-Stream [\#PGdP-Technik](https://zulip.in.tum.de/#narrow/stream/1243-PGdP-Technik) nach und frage gegebenenfalls dort nach.

### Teil 2: Hallo sagen

Nun geht es darum die ersten Wörter auszugeben:

1. [task][""Hallo Pinguine!"" auf der Konsole ausgeben]( 222663 )
  Um etwas auszugeben, nutze die Funktion `System.out.println()`. Zwischen den Klammern kannst du in Anführungszeichen eine Zeichenkette angeben, die ausgegeben werden soll. Beim Aufruf eures Programmes wird dann der Code innerhalb der main-Methode ausgeführt. Probiere nun direkt einmal "" Hallo⎵Pinguine! "" mithilfe der Klasse `HelloPenguins` auszugeben.
**Tipp:** Kopiere die auszugebende Nachricht einfach direkt immer aus der Aufgabenstellung. Ersetze dabei das Zeichen ⎵ aber jeweils durch ein Leerzeichen. Fehlerhafte Ausgaben können nämlich zu unnötigem Punktabzug führen!

### Teil 3: Neue Quelldatei ###

Um einen zweiten Satz auszugeben, soll zunächst eine neue Quelldatei erstellt werden:

2. [task][Erstellen einer weiteren Klasse]( 222661 )
   Erstelle eine neue Quelldatei `PracticalCourse.java` im gleichen Verzeichnis wie `HelloPenguins.java`. Kopiere den Code aus `HelloPenguins.java` und passe den Klassennamen an, sodass er zum neuen Dateinamen passt.
3. [task][Weitere Ausgabe]( 222662 )
   Gebe nun mithilfe der neu erstellten Klasse `PracticalCourse` statt "" Hallo⎵Pinguine! "" den neuen Text "" Ich⎵freue⎵mich⎵übermäßig⎵auf⎵PGdP! "" auf der Konsole aus."
404,Praktikum: Grundlagen der Programmierung WS24/25,14718,W02P01 - Verhaltensforschung,"# Die Pinguin-Chefs betreiben Verhaltensforschung

In dieser Aufgabe wollen wir das Erstellen eines UML Diagramms üben. Natürlich kannst du die Aufgabe auch auf Papier lösen. 
**TIPP:** Den Online Editor hier auf Artemis kannst du auch Unabhängig von Aufgaben für eigene Projekte oder Hausaufgaben verwenden. Verwende dazu folgenden Link: [Apollon](https://apollon.ase.in.tum.de/)

## Gegeben sind uns folgende Informationen:

Unsere Pinguin-Chefs untersuchen aktuell das Verhalten in einem Hunderudel. Für eine Simulation sollen wir zwei Klassen modellieren: `Dog` und `Toy`. Diese repräsentieren Hunde und deren Spielzeug. Natürlich haben Hunde einige interessante Eigenschaften die unsere Vorgesetzten interessieren. Wichtig ist vor allem das Gewicht (`weight`) in Kilogramm inklusive Dezimalstellen und Alter (`age`) als Ganzzahl. Zusätzlich sind auch Geschlecht (`gender`), Rasse (`race`) und Fellfarbe (`color`) relevant. Weil sich unsere Pinguin-Vorgesetzten schon so lange mit dem Rudel beschäftigen, haben die Hunde bereits eigene Namen (`name`) erhalten. Alle Werte abgesehen von Gewicht und Alter werden als Text gespeichert.

Zu jedem Spielzeug müssen zwei notwendige Informationen vermerkt werden. Einerseits erhält jedes Spielzeug eine detailierte Beschreibung (`description`) des Objekts in Form eines Aufsatzes mit mindestens 1000 Zeichen und andererseits der Farbe (`color`) des Spielzeugs.

Wenn das Hunderudel spielt, haben die Pinguine beobachtet, dass Hunde versuchen Spielzeug aufzuheben (`tryToPickUpToy`). Wenn sie dies tun entscheiden sie sich natürlich für ein ganz bestimmtes Spielzeug!
Hat der Hund viel Zeit damit verbracht zu spielen, kann er sein Spielzeug auch wieder Ablegen (`putDownToy`). In seltenen Fällen kann es vorkommen, dass Hunde kein Spielzeug finden das herum liegt. Logischerweise versuchen sie dann einem ihrer Freunde ein Spielzeug zu klauen (`stealToyFromDog`). Wichtig ist zu wissen, dass ein Hund niemals mit zwei Spielzeugen gleichzeitig Spielen kann.
Als extra Wunsch haben die Pinguin-Chefs uns den Auftrag für ein Easter-Egg gegeben: Die `Dog`-Klasse soll dazu eine Methode anbieten, die aus den gespeicherten Daten für einen Hund ein individuelles Text-Bild erstellt welches in Textform zurück gegeben werden soll (`toString`).

Zuletzt bleibt noch ein  wichtiger Hinweis : Um den heutigen Datenschutzrechtlinien gerecht zu werden und weil die Pinguin-Chefs Angst davor haben, dass Eindringlinge die Daten verfälschen könnten, wollen die Pinguin-Chefs alle Daten so sicher wie möglich halten.


## Nun endlich dein Auftrag
Lies dir den Text sorgfältig durch und fertige das entsprechende UML Diagramm an. Beachte auch, dass zwischen `Dog` und `Toy` eine relevante Beziehung besteht.

Viel Erfolg!"
404,Praktikum: Grundlagen der Programmierung WS24/25,14719,W02P02 - Fahrzeuge,"Falls du Eclipse benutzt und die Aufgabe lokal nicht ausführen kannst, lohnt es sich mal [hier](https://zulip.in.tum.de/#narrow/stream/1243-PGdP-Technik/topic/Eclipse.20Fehler/near/1663669) vorbeizuschauen!

# Fahrzeuge

Ziel dieser Aufgabe ist, das folgende UML-Diagramm in Code umzusetzen: 

@startuml

hide circle

class Engine {
	- model: String
	- capacity: double
	- fuelConsumption: double
	+ burnFuel(amount: double): double
}

class FuelTank {
	- fillLevel: double
	+ getFillLevel(): double
	+ fillUp(amount: double): double
	+ letFuelOut(amount: double): double
}

class Vehicle	{
	- seats: int
	- vehicleNumber: int
	- licensePlate: String
	- currentPosition: double
	+ getCurrentPosition(): double
	+ fillUpTank(amount: double): double
	+ drive(fuelToUse: double): void
}

Engine ""1"" --o ""1"" Vehicle : -engine
FuelTank ""1"" -right-o ""1"" Vehicle: -fuelTank

@enduml

Wie im richtigen Leben macht es auch hier Sinn, die Einzelteile vor dem Endprodukt zu implementieren. 
Implementiere also erst die Klassen `Engine` und `FuelTank` bevor du mit `Vehicle` weitermachst.

**Hinweis 1:** Erstelle alle Klassen im Package `pgdp.vehicle`!

**Hinweis 2:** Tests, die die Funktionalität der Methoden überprüfen, werden erst ausgeführt, wenn alle Attribute, Konstruktoren und Methoden in allen Klassen vorhanden sind.

**Hinweis 3:** Auch wenn die `toString`-Methode nicht explizit im UML-Diagramm auftaucht, so wird sie in der Aufgabe trotzdem von den Structural Tests erwartet.

## Struktur

- [task][Engine]( 223979 , 223988 )
Implementiere zuerst die im Diagramm gegebenen Attribute der Klasse `Engine`. Außerdem soll die Klasse einen Konstruktor enthalten, der die Attribute in der angegebenen Reihenfolge als Parameter erwartet.
- [task][burnFuel]( 223981 , 224001 )
Implementiere jetzt die Methode `burnFuel` in der Klasse `Engine`. Die Methode soll die Hälfte des Produkts des Attributs `fuelConsumption` und des übergebenen Parameters `amount` berechnen und zurückgeben.
- [task][FuelTank]( 223980 , 223998 )
Implementiere als nächstes die Klasse `FuelTank` mit dem gegebenen Attribut. Zudem soll er einen Konstruktor ohne Parameter besitzen.
- [task][getFillLevel]( 223986 , 223984 )
Implementiere jetzt die Methode `getFillLevel`. Diese soll den Wert des privaten Attributs `fillLevel` zurückgeben.
	- Methoden wie diese, die den lesenden Zugriff auf private Attribute erlauben, nennt man *Getter*.
- [task][fillUp/letFuelOut]( 223986 , 224004 )
Vervollständige jetzt die Klasse `FuelTank` mit den angegebenen Methoden. `fillUp` (bzw. `letFuelOut`) soll `fillLevel` um den übergebenen Wert erhöhen (bzw. verringern) und den *neuen* Füllstand zurückgeben.
Dass der Füllstand durch letztere Methode auch negativ werden könnte, darfst du diese Woche noch ignorieren.

Nun, da die Einzelteile bereit sind, kann das Fahrzeug fertiggestellt werden.
- [task][Vehicle]( 223992 )
Implementiere die Attribute der Klasse `Vehicle`. Denke dabei auch an die Attribute, die durch die Beziehung der verschiedenen Klassen symbolisiert werden!
- [task][Vehicle Konstruktor]( 224002 )
Implementiere jetzt einen Konstruktor für die Klasse `Vehicle`. 
	- Für die Attribute `seats`, `vehicleNumber` und `licensePlate` soll der Konstruktor initiale Werte als Parameter übernehmen (in dieser Reihenfolge).
	- Das Attribut `currentPosition` soll mit *0.0* initialisiert werden.
	- Die Attribute `fuelTank` und `engine` sollen durch Konstrutoraufrufe der entsprechenden Klassen initialisiert werden. Die vom Konstruktor der Klasse `Engine` benötigten Parameter soll der Konstruktor von `Vehicle` als Parameter abfragen.
	- Die gesamte Parameterliste des Konstruktors von `Vehicle` lautet also: (int, int, String, String, double, double)
- [task][getCurrentPosition]( 223987 , 223995 )
Implementiere nun die Getter-Methode `getCurrentPosition` in der Klasse `Vehicle`. Wie `getFillLevel` der Klasse `FuelTank` soll diese den Wert des entsprechenden Attributs (hier `currentPosition`) zurückgeben.
- [task][fillUpTank]( 223987 , 224005 )
Mit der Methode `fillUpTank` soll das Fahrzug um den übergebenen Wert *aufgetankt* werden. Ändere dazu den Wert von `fillLevel` der Klasse `FuelTank` mit einem geeigneten Methodenaufruf auf `fuelTank`.
- [task][drive]( 223987 , 223993 )
Mit `drive` bringen wir alles zusammen. `fuelToUse` gibt an, wie viel Treibstoff verbraucht werden soll. 
	- Die Methode soll den Tank um den entsprechenden Wert leeren.
	- Außerdem soll die zurückgelegte Distanz (berechenbar über die Methode `burnFuel` der Klasse `Engine`) berechnet und `currentPosition` entsprechend angepasst werden.

Schließlich wollen wir uns noch die Werte des Fahrzeugs ausgeben lassen:
- [task][toString]( 223981 , 223986 , 223987 , 224003 , 223999 , 223989 )
Füge in jeder der drei Klassen eine Methode `toString` hinzu, die keine Parameter erwartet und einen String zurückgibt. Dieser soll folgende Form haben:
    - `FuelTank`: "" Der⎵Füllstand⎵beträgt⎵ \ ⎵Einheiten. ""
    - `Engine`: "" Motor⎵des⎵Models⎵ \ ⎵hat⎵eine⎵Kapazität⎵von⎵ \ ⎵und⎵verbraucht⎵ \ ⎵Einheiten. ""
    - `Vehicle`: "" Fahrzeug⎵# \ ⎵mit⎵Kennzeichen⎵ \ ⎵hat⎵ \ ⎵Sitzplätze.\nTank:⎵ \ \nMotor:⎵ \ ""
    - **Hinweis 1:** die `toString`-Methode wirst du noch oft implementieren müssen, da sie zu den Standardmethoden jeder Klasse gehört und immer eine String-Repräsentation dieser zurückliefert. 
    - **Hinweis 2:** "" \n "" ist der sogenannte Newline-Character und erzeugt einen Zeilenumbruch im String.
    - **Hinweis 3:** Wir werden häufig Strings erzeugen, die Variablen- bzw. Attributwerte beinhalten. Um diese zu repräsentieren nutzen wir *reguläre Ausdrücke* (z.B.  ). Genaueres über reguläre Ausdrücke wirst du noch in der Vorlesung lernen. Vorerst reicht es aus zu verstehen, dass bei "" Der⎵Füllstand⎵beträgt⎵ \ ⎵Einheiten. "" der String nicht den Substring "" \ "" enthalten soll, sondern an dieser Stelle der Wert der Variable `fillLevel` eingefügt werden muss.
	- **Hinweis 4:** Ersetze das Zeichen ⎵ in deinem Code durch ein Leerzeichen.

Du kannst deine Implementierung z.B. so testen: Füge in der Klasse `Vehicle` die folgende `main`-Methode ein
```java
public static void main(String[] args){
    Vehicle v = new Vehicle(2, 9001, ""P1NGU"", ""Pingu V8 Turbo"", 100.0, 42);
    System.out.println(v.toString());
}
```
Die Ausgabe sollte dann so aussehen:
```
Fahrzeug #9001 mit Kennzeichen P1NGU hat 2 Sitzplätze.
Tank: Der Füllstand beträgt 0.0 Einheiten.
Motor: Motor des Models Pingu V8 Turbo hat eine Kapazität von 100.0 und verbraucht 42.0 Einheiten.
```"
404,Praktikum: Grundlagen der Programmierung WS24/25,14720,W02P03 - Roboter I,"# Die Pinguine bauen einen Fischroboter

In dieser Aufgabe wollen wir das Erstellen eines UML Diagramms und das Umsetzen in Code üben. Natürlich kannst du diesen Teil der Aufgabe auch auf Papier lösen. 
**TIPP:** Den Online Editor hier auf Artemis kannst du auch unabhängig von Aufgaben für eigene Projekte oder Hausaufgaben verwenden. Verwende dazu folgenden Link: [Apollon](https://apollon.ase.in.tum.de/)

## Gegeben sind uns folgende Informationen:

Das Ziel ist es einen Roboter zu bauen, welcher den Pinguinen beim Fischen hilft. Um den Roboter zu konstruieren, benötigen die Pinguine zudem noch Räder, eine Angelrute und ein Fischlager.

Die Räder haben eine Geschwindigkeit und eine Richtung, welche die Ausrichtung des Roboters in Grad angibt. Die Räder benötigen zudem noch eine Möglichkeit gesteuert zu werden. Hierzu benötigen die Räder eine Methode zum fahren und eine zum steuern. Die Methode zum Fahren soll als Parameter einen Integer für die Distanz, die Methode zum steuern soll einen Integer für die Richtung übergeben bekommen.

Die Angelrute soll ein Attribut für unterschiedliche Köder besitzen, damit die Pinguine auch verschiedene Fische fangen können. Zu dem soll der Roboter die Angel auswerfen oder einholen können.

Nach dem erfolgreichen Fischen muss der Roboter die Fische in einem Fischlager lagern, damit sie anschließend zu den Pinguinen gebracht werden können. Hierzu muss die aktuell enthaltene Anzahl an Fischen gespeichert werden. Die Angelrute soll zudem auf das Fischlager zugreifen können. Hierzu wird eine Methode zum Hinzufügen von Fischen benötigt. Damit die Pinguine auch etwas von ihren Fischen haben, müssen diese wieder entnommen werden. Hierzu soll das Fischlager eine Methode bereitstellen, welche die Anzahl an enthaltenen Fischen zurück gibt und das Lager leert.

All diese Funktionalität soll nun im Roboter zusammen kommen. Hier soll zunächst einmal der Name des Roboters gespeichert werden. Zudem soll der Roboter Methoden bereitstellen, welche es ihm erlauben zu fischen und sich zu bewegen. Letztere soll eine Distanz und eine Richtung als Integer übergeben bekommen."
404,Praktikum: Grundlagen der Programmierung WS24/25,14721,W02P04 - Roboter II,"Falls du Eclipse benutzt und die Aufgabe lokal nicht ausführen kannst, lohnt es sich mal [hier](https://zulip.in.tum.de/#narrow/stream/1243-PGdP-Technik/topic/Eclipse.20Fehler/near/1663669) vorbeizuschauen!

# Roboter bauen

Nach langem Planen und Entwickeln haben die Pinguine endlich einen Plan, nach dem sie den Roboter bauen können. Das UML-Diagramm, welches ihr in der letzten Aufgabe entwickelt habt, wird nun umgesetzt. Hierzu haben die Pinguine ihre Anforderungen noch einmal genauer formuliert:

## Der Roboter

Der Roboter soll die Klassen `Wheels`, `FishStorage` und `FishingRod` besitzen.  
Die `Wheels` Klasse ist für die Bewegung des Roboters verantwortlich. Sie soll das Attribut `speed` haben, mit einer Methode `steer` den Roboter drehen und mit einer Methode `drive` den Roboter bewegen können. Beide Methoden sollen jeweils ein Integer entgegen nehmen.  
Die `FishStorage` Klasse ist dafür verantwortlich, die gefangen Fische zu lagern. Hierzu benötigt man ein Attribut `numberOfFish` welches die Anzahl an gelagerten Fischen speichert. Zudem benötigt man eine `storeFish` Methode um Fische einzulagern, und eine Methode `emptyFish` um alle gelagerten Fische wieder zu entnehmen. Letztere soll zudem die Anzahl der entnommen Fische zurückgeben.  
Um die Fische überhaupt zu fangen, benötigen die Pinguine eine `fishingRod`. Diese muss in der Lage sein, ausgeworfen zu werden(`reelOut`) und wieder eigeholt zu werden(`reelIn`). Außerdem sollen verschieden Köder benutzt werden. Hierfür ist ein Attribut `bait` notwendig.
Um diese ganze Funktionalität zusammenzuführen, gibt es die `Robot`-Klasse. Diese kontrolliert sowohl Räder, als auch eine Angel und ein Fischlager. Um den Roboter zu bewegen, soll eine `move`-Methode implementiert werden, welche Richtung und Distanz entgegennimmt. Zu guter letzt soll dem Roboter sein eigentlicher Zweck, das Fischen, implementiert werden. Hierzu wird eine `fish`-Methode benötigt.



@startuml

hide circle

class Robot {
  - name: String
  + move(direction: int, distance: int): void
  + fish(): void
  
}

class Wheels {
  - speed: int
  + drive(distance: int): void
  + steer(direction: int): void
}

class FishStorage {
  - numberOfFish: int
  + storeFish(): void
  + emptyFish(): int
}

class FishingRod {
  - bait: String
  + reelOut(): void
  + reelIn(): void
}

Wheels -up-o Robot: wheels
FishStorage -up-o Robot: fishStorage
FishingRod -up-o Robot: fishingRod

@enduml


## Umsetzung

Nun geht es ans Eingemachte. Die Pinguine müssen den Roboter zusammen bauen.

### Teil 1: Struktur

Setze das UML-Diagram um.

1. [task][Struktur]( 224041 , 224042 , 224051 , 224049 , 224040 , 224045 , 224039 , 224043 )
     Zuerst gilt es die grundlegende Struktur entsprechend dem UML-Diagram zu erstellen. Es wird erwartet, dass es für alle privaten Parameter *Getter* und *Setter* gibt.

### Teil 2: Basisfunktionalität

Hier geben wir den Einzelteilen ihre Funktionalität.

**Hinweis:** Ersetze bei allen Konsolen-Outputs das Zeichen ⎵ in deinem Code durch ein Leerzeichen.

#### Räder:

1. [task][Konstruktor]( 224017 )
Der Konstruktor der `Wheels`-Klasse soll ein `int` entgegennehmen und es im Attribut `speed` speichern.
2. [task][Steuern]( 224019 )
Die `steer`-Methode soll eine Richtung als `int` entgegennehmen. Anschließend soll sie "" Der⎵Pinguroboter⎵richtet⎵sich⎵auf⎵ \ ⎵Grad⎵aus. "" auf der Konsole ausgeben.
3. [task][Fahren]( 224015 )
Die `drive`-Methode funktioniert ähnlich wie die `steer` Methode. Sie nimmt eine Distanz als `int` entgegen und gibt anschließend "" Der⎵Pinguroboter⎵fährt⎵ \ ⎵m. "" auf der Konsole aus.

#### Fishlager:

1. [task][Konstruktor]( 224018 )
Der Konstruktor der `FishStorage`-Klasse muss nur das `numberOfFish` Attribut auf  0  initialisieren.
2. [task][Fische lagern]( 224020 )
Die `storeFish`-Methode behandelt das Einlagern der Fische. Damit die Pinguine beim zählen nicht durcheinaner kommen, kann pro Aufruf nur ein Fisch eingelagert werden. Beim Einlagern eines Fisches soll das `numberOfFish`-Attribut inkrementiert werden, und "" Es⎵wurde⎵ein⎵Fisch⎵eingelagert. "" ausgegeben werden.
3. [task][Fische entnehmen]( 224022 )
Die mühevoll gelagerten Fische müssen irgendwann ja auch wieder ausgelagert und verspeist werden. Hierzu gibt es die `emptyFish`-Methode. Diese Methode entleert das Fischlager. Es soll die Anzahl an entleerten Fischen zurückgegeben werden. Außerdem soll das `numberOfFish`-Attribut aktualisiert werden und "" Das⎵Fischlager⎵wird⎵geleert. "" ausgegeben werden.

#### Angel:

1. [task][Konstruktor]( 224025 )
Der Konstruktor der `FishingRod`-Klasse soll einen Köder als `String` entgegen nehmen, und im `bait` Attribut speichern.
2. [task][Auswerfen]( 224014 )
Bei der `reelOut`-Methode soll die Angel ausgeworfen werden. Es werden zwei Zeilen auf der Konsole ausgegeben: Erst "" Der⎵Pinguroboter⎵wirft⎵die⎵Angel⎵aus. "" und anschließend "" Es⎵wird⎵folgender⎵Köder⎵benutzt:⎵ \ "".
3. [task][Einholen]( 224024 )
Beim `reelIn` passiert genau das Gegenteil, die Angel wird wieder eingeholt. Da werden die folgenden Zeilen ausgegeben: Erstens "" Der⎵Pinguroboter⎵holt⎵die⎵Angel⎵wieder⎵ein. "" und anschließend "" Es⎵wurde⎵ein⎵Fisch⎵gefangen. "".

### Teil 3: Die Hochzeit

Nachdem alle Einzelteile fertig sind, kann die Funktionalität nun ""verheiratet"" werden. Die Tests in diesem Abschnitt basieren darauf, dass alle andere Funktionalität implementiert ist und funktioniert.

1. [task][Konstruktor]( 224023 )
Der Konstruktor der `Robot`-Klasse nimmt drei Variablen entgegen: Den Namen als `String`, die GeschwindigKeit als `int` und den Köder als `String`. Damit sollen das `name`-Attribut gesetzt, und die Räder, Angel und das Fischlager initialisiert werden. Am Ende soll dann "" Der⎵Pinguinroboter⎵mit⎵dem⎵Namen⎵ \ ⎵wurde⎵initialisiert. "" ausgegeben werden.
2. [task][Bewegen]( 224016 )
Damit der Roboter sich bewegen kann, soll er die Räder verwenden. Der `move`-Methode werden eine Richtung und eine Distanz übergeben. Hierfür soll der Roboter zuerst in die richtige Richtung ausgerichtet werden und anschließend die entsprechende Distanz fahren.
3. [task][Fischen]( 224021 )
Das Fischen gestaltet sich auch relativ einfach. Die Angel wird ausgeworfen und wieder eingeholt. Der gefangene Fisch muss dann nur noch im Fischlager gelagert werden."
404,Praktikum: Grundlagen der Programmierung WS24/25,14722,W02H01 - Rechtecke,"Falls du Eclipse benutzt und die Aufgabe lokal nicht ausführen kannst, lohnt es sich mal [hier](https://zulip.in.tum.de/#narrow/stream/1243-PGdP-Technik/topic/Eclipse.20Fehler/near/1663669) vorbeizuschauen!

# Rechtecke
In dieser Aufgabe werden wir eine Datenstruktur für Rechtecke implementieren. Folge dazu den Anweisungen Schritt für Schritt.

## **WICHTIG:** 
Bevor nicht alle Attribute, Konstruktoren und Methodensignaturen korrekt implementiert sind (also bevor Namen, Access Modifiers, Parameters, Return Types, etc. stimmen), wird kein Behavioral Test ausgeführt. Hinweise zu Fehlern in der Struktur liefern die Structural Tests (beispielsweise gibt ""`testAttributes[Vector2D]`"" Hinweise auf Fehler in den Attributen der Klasse `Vector2D`). Um alle Structural Tests zu bestehen müssen die Methoden noch keine Funktionalität haben. Es reicht aus, dass sie existieren. Falls du trotzdem schon vorher testen möchtest, nutze die `main`-Methode in den beiden Klassen, um deine Implementierung anhand von (eigenen) Beispielen zu testen.

## Vektoren
Als aller Erstes möchten wir die Klasse `Vector2D` entwickeln. Diese soll uns das Arbeiten mit Vektoren vereinfachen. Die Verwendung einer solchen Klasse ist in vielerlei Hinsicht sinnvoll. Zum Beispiel wird dadurch ein Programm strukturiert und leichter nachvollziehbar. Auch die (komplexe) Implementierung von häufig genutzen Operationen kann elegant in den Methoden der Klasse versteckt werden, sodass andere Entwickler nicht jedes mal einen eigenen Algorithmus entwickeln müssen.
- [task][Objektattribute]( 224056 )
Erstelle zuerst die beiden privaten Attribute `x` und `y`, diese verwenden wir um die x- bzw. y-Koordinaten des Vektors zu speichern. Da wir uns nicht auf ganzzahlige Koordinaten beschränken möchten, sollen beide Attribute vom Typ `double` sein.
- [task][Konstruktor]( 224061 , 224096 ) 
Um eine Instanz eines Vektors erstellen zu können muss ein entsprechender Konstruktor implementiert werden. Der Konstruktor erwartet die Attribute des Objekts (in der entsprechenden Reihenfolge: x, y) als Parameter.
- [task][Getter & Setter]( 224066 , 224094 ) 
Erstelle nun für jedes der Attribute die passenden *Getter* und *Setter*.
- [task][add]( 224066 , 224093 )
Desweiteren soll die Klasse die Vektoraddition unterstützen. Implementiere diese Funktionalität als Methode `add`, welche einen `Vector2D` als Parameter erwartet. Die Objektattribute des Vektors, bei dem die Methode aufgerufen wurde, werden entsprechend modifiziert. Es darf kein neuer `Vector2D` erstellt werden.
- [task][toString]( 224066 , 224097 ) 
Zuletzt möchten wir dazu in der Lage sein, eine String-Repräsentation eines Vektors erstellen zu können. Dies wird in der Methode `toString` umgesetzt. Der String soll dabei wie folgt formatiert sein: "" [ \ ,⎵ \ ] "". Der Vektor mit x-Koordinate:  4.0  und y-Koordinate:  5.0  würde also folgenden String zurückgeben: "" [4.0,⎵5.0] "". Ersetze das Zeichen ⎵ in deinem Code durch ein Leerzeichen. Um zu testen ob deine Formatierung den Anforderungen entspricht kannst du die `main`-Methode in der Klasse `Vector2D` ausführen.

## Rechtecke
Endlich kommen wir zum eigentlichen Ziel der Aufgabe: die Implementierung der `Rectangle`-Klasse. Natürlich haben wir `Vector2D` nicht umsonst entwickelt. Diese werden wir dazu benutzen um die Eckpunkte des Rechtecks zu speichern.
- [task][Objektattribute]( 224062 ) 
Im allgemeinen sind Rechtecke durch drei fixe Punkte eindeutig beschrieben. Unsere Implementierung wird sich jedoch auf Rechtecke beschränken, deren Kanten ausschließlich horizontal und vertikal verlaufen. Daher benötigen wir nur noch zwei Punkte `topLeft` und `bottomRight`. Für diese privaten Attribute nutzen wir selbstverständlich unsere eigene Datenstruktur `Vector2D`.
- [task][Konstruktor]( 224060 , 224091 ) 
Auch für `Rectangle` erstellen wir einen Konstruktor. Dieser erwartet zwei `Vector2D` als Parameter: als erstes den oberen linken und als zweites den unteren rechten Punkt. Du musst dir also keine Gedanken über degenerierte Fälle oder fehlerhafte Eigaben machen. Die Benutzer (und Testfälle) werden die Datenstruktur immer sachgemäß verwenden und die vordefinierte Reihenfolge einhalten. D.h. sie werden als zweites Argument immer einen Punkt übergeben, welcher tatsächlich rechts und unterhalb des ersten Argumentes liegt.
- [task][toString]( 224065 , 224089 )
Zur Visualisierung wird auch `Rectangle` eine `toString`-Methode implementieren. Der String soll dabei wie folgt formatiert sein: "" Rectangle⎵spanned⎵by⎵points⎵ \ ⎵and⎵ \ . "".Ein Rechteck mit den Vektoren "" [0.0,⎵1.0] "" und "" [2.0,⎵0.0] "" würde also folgenden String zurück geben: "" Rectangle⎵spanned⎵by⎵points⎵[0.0,⎵1.0] and [2.0,⎵0.0]. "". Achte dabei auch hier auf die Leerzeichen. Um zu Testen ob deine Formatierung den Anforderungen entspricht kannst du die `main`-Methode in der Klasse `Rectangle` ausführen.

Jetzt können wir uns endlich den interessanteren Methoden widmen, die `Rectangle` bereitstellen soll.
- [task][calculateArea]( 224065 , 224090 )
Zuerst wollen wir eine Methode (`calculateArea`) zur Bestimmung des Flächeninhaltes erstellen. Die Methode gibt den berechneten Flächeninhalt als `double` zurück. Dabei helfen dir folgende Tipps:
1. Unsere Rechtecke haben ausschließlich horizontale bzw. vertikale Kanten (Breite und Höhe des Rechtecks)
2. Die Wahl der Vektoren die das Rechteck repräsentieren (oben-links $$ \vec{tl} $$, unten-rechts $$ \vec{br} $$) erlaubt es uns die Breite ($$ \Delta x $$)/Höhe ($$ \Delta y $$) des Rechtecks durch die Differenz der x-/y-Werte zu ermitteln: $$\Delta x = \vec{br}\_x - \vec{tl}\_x $$ und $$ \Delta y = \vec{tl}\_y - \vec{br}\_y $$
3. Der Flächeninhalt lässt sich dann schnell aus dem Produkt der Breite und Höhe berechnen: $$A = \Delta x \cdot \Delta y $$.
- [task][shiftBy]( 224065 , 224095 )
Zu guter Letzt wollen wir auch noch dazu in der Lage sein, Rechtecke im Koordinatensystem zu verschieben. Dazu implementieren wir die Methode `shiftBy`, die das Rechteck um einen übergebenen `Vector2D` verschiebt.  
Betrachte dazu folgendes Beispiel:

 

Hier hast du zu Beginn das Rechteck von den Punkten "" [1.0, 2.0] "" und "" [3.0, 1.0] "" gespannt (makiert mit dem Index `old`). Dieses soll um den Vektor `shift` ("" [2.5, 1.5] "") im Koordinatensystem verschoben werden. Wie du siehst handelt es sich dabei um simple Vektoraddition. **Hinweis:** Diese hast du bereits zuvor implementiert.
Durch die Verschiebung ergibt sich die neue Position des Rechtecks (markiert mit dem Index `new`).
**WICHTIG:** Erstelle keine neuen Vektoren bzw. kein neues Rechteck. Es ist wichtig, dass lediglich die bereits vorhandenen Daten **modifiziert** werden."
404,Praktikum: Grundlagen der Programmierung WS24/25,14723,W02H02 - Saleuine,"Falls du Eclipse benutzt und die Aufgabe lokal nicht ausführen kannst, lohnt es sich mal [hier](https://zulip.in.tum.de/#narrow/stream/1243-PGdP-Technik/topic/Eclipse.20Fehler/near/1663669) vorbeizuschauen!

# Saleuine

Die Saleuine Claudia und Karl-Heinz sind stolze Besitzer eines Fischmarkts. Dort verkauft das Unternehmerehepaar die Lieblingsspeisen der Kaufuine: Krustentiere (*crustaceans*), Sardellen (*anchovies*) und Sardinen (*sardines*).
Vor kurzem haben die beiden eine tolle Erfindung gemacht, den Fischomat9000. Dieser erlaubt es ihnen, unbegrenzte Mengen der angebotenen Waren zu produzieren. Leider war die Konstruktion dieses Wunderwerks sehr teuer, weshalb Claudia und Karl-Heinz sehr hohe Preise für die Meerestiere verlangen müssen. Ihr Businessplan sieht allerdings vor, dass sie die Preise nach jedem Geschäftstag halbieren können.
Claudia und Karl-Heinz möchten jetzt, dass du ihnen hilfst, einen Überblick über die täglich verkauften Mengen, sowie über die Tages- und Gesamteinnahmen zu behalten. Außerdem wollen sie einige essentielle Kundeninformationen erhalten. Hilfsbereit, wie die beiden sind, haben sie sich bereits folgende Programmstruktur für dich überlegt: 

@startuml

hide circle

class Order {
	- amountCrustaceans: int
	- amountAnchovies: int
	- amountSardines: int
	+ getAmountCrustaceans(): int
	+ getAmountAnchovies(): int
	+ getAmountSardines(): int
	+ addOrder(order: Order): void
	+ toString(): String
}

class Kaufuin {
	- name: String
	- age: int
	- money: double
	+ getOrder(): Order
	+ giveNewOrder(newOrder: Order): void
	+ addToOrder(additionalOrder: Order): void
	+ giveInformation(): String
	+ pay(amount: double): void
}

Kaufuin ""1“ o--left- ""1“ Order : -order

@enduml

@startuml

hide circle

class Market {
	- daysInBusiness: int
	- soldCrustaceansDay: int
	- soldAnchoviesDay: int
	- soldSardinesDay: int
	- moneyMadeDay: double
	- moneyMadeTotal: double
	- priceCrustaceans: double
	- priceAnchovies: double
	- priceSardines: double
	+ serveCustomer(customer: Kaufuin): void
	+ endDay(): void
}

@enduml

Die Klasse `Order` symbolisiert hier einen Einkaufszettel eines `Kaufuins`. `Market` ist der Einkaufsladen unserer Unternehmer, in dem die Kaufuine einkaufen gehen.

Zusätzlich zu dieser Programmstruktur sagen Claudia und Karl-Heinz dir auch, wie du bei der Implementierung vorgehen sollst.

## **WICHTIG:** 
Bevor nicht alle Attribute, Konstruktoren und Methodensignaturen korrekt implementiert sind (also bevor Namen, Access Modifiers, Parameters, Return Types, etc. stimmen), wird kein Behavioral Test ausgeführt. Hinweise zu Fehlern in der Struktur liefern die Structural Tests (beispielsweise gibt ""`testAttributes[Order]`"" Hinweise auf Fehler in den Attributen der Klasse `Order`). Um alle Structural Tests zu bestehen müssen die Methoden noch keine Funktionalität haben. Es reicht aus, dass sie existieren. Falls du trotzdem schon vorher testen möchtest, nutze die `main`-Methode in der Klasse `Market`, um deine Implementierung anhand von (eigenen) Beispielen zu testen.

## Struktur
- [task][UML]( 224112 , 224110 , 224111 , 224113 , 224102 , 224100 , 224120 )
Starte zuerst mit der Implementierung der gegebenen Programmstruktur (siehe UML-Diagramm). Für die Getter-Methoden der Klasse `Order` kannst du dich an Aufgabe `W02P02` orientieren.
    - **Hinweis:** double sollte man eigentlich nicht als Datentyp für Geld nutzen. Da wir aber noch am Anfang stehen und das bei Pinguindollar nicht so wichtig ist, sehen wir hier mal darüber hinweg. Falls du Interesse an Gründen und Alternativen hast, kannst du [hier](https://dzone.com/articles/never-use-float-and-double-for-monetary-calculatio) weiterlesen.

Auf dieser Basis sollst du nun aufbauen und die Klassen Schritt für Schritt um neue Methoden erweitern. Alles Folgende soll außerdem `public` sein.
- [task][Konstruktor Order]( 224116 , 224126 )
Die Klasse `Order` soll einen Konstruktor enthalten, der drei Parameter erwartet. Diese sollen (in dieser Reihenfolge) die Einkaufsmengen für Krustentiere (`amountCrustaceans`), Sardellen (`amountAnchovies`) und Sardinen (`amountSardines`) enthalten.
- [task][Konstruktoren Kaufuin]( 224114 , 224134 , 224122 )
Die Klasse `Kaufuin` soll zwei Konstruktoren enthalten
	- beide sollen zuerst Werte für die Attribute `name`, `age` und `money` erwarten.
	- einer soll zusätzlich als letzten Parameter ein Objekt von Typ `Order` erwarten (für Kaufuine, die von ihrer Partner*in zum Einkaufen geschickt werden).
	- der andere soll die Einkaufsmengen der drei Produkte erwarten, in derselben Reihenfolge wie der Konstruktor der Klasse `Order` und nach den oben genannten Parametern (für Kaufuine, die ihren Einkaufszettel selber schreiben wollen).
- [task][Konstruktor Market]( 224115 , 224119 )
Der Konstruktor der Klasse `Market` soll initiale Werte für die Preise von Krustentieren, Sardellen und Sardinen übernehmen (in dieser Reihenfolge!). Außerdem soll der Markt mit Tag *1* starten (`daysInBusiness`). Die übrigen Attribute sollen mit *0* initialisiert werden.

## Funktionalität

Da nun die Grundstruktur steht, kannst du mit der Implementierung der eigentlichen Funktionen beginnen:

### Order
- [task][toString]( 224125 )
Die Methode `toString` soll den Inhalt des Einkaufszettels wie folgt zurückgeben: “\ ⎵Krustentiere,⎵ \ ⎵Sardellen⎵und⎵ \ ⎵Sardinen “
	- amountXXX soll dabei dem Wert des jeweiligen Attributs entsprechen, wie es in *Aufgabe W02P02 - Fahrzeug* beschrieben ist.
	- Ersetze das Zeichen ⎵ in deinem Code durch ein Leerzeichen.
	- Achte darauf, dass der String genau mit der Vorgabe übereinstimmt!
- [task][addOrder]( 224132 )
Die Methode `addOrder` ist für vergessliche Kaufuine, die bei der Erstellung ihres Einkaufzettels ein paar Sachen vergessen haben. Die Methode soll ein weiters `Order`-Objekt als Parameter übernehmen und die Mengen des übergebenen Objekts zu den jeweiligen Mengen des aktuellen Objekts dazu addieren.

### Kaufuin
- [task][Order-Methoden]( 224128 , 224124 , 224135 )
Kaufuine müssen mit ihrem Einkaufszettel einige Dinge erledigen. Dafür sollst du in der Klasse `Kaufuin` folgende Methoden implementieren:
	- `getOrder`, die keine Parameter hat und das aktuelle `Order`-Objekt zurückgibt.
	- `giveNewOrder`, die ein Objekt von Typ `Order` erwartet und das `order` Attribut mit dem übergebenen Wert überschreibt. So kann derselbe Kaufuin mehrmals einkaufen gehen, ohne immer die gleichen Mengen zu kaufen.
	- `addToOrder`, die ein Objekt von Typ `Order` erwartet und dessen Mengen zur aktuellen `order` addiert. Auch hier wieder für vergessliche Kaufuine.
- [task][giveInformation]( 224127 )
Wie oben beschrieben wollen Claudia und Karl-Heinz Kundeninformationen sammeln. Implementiere dazu eine Methode `giveInformation` in der Klasse `Kaufuin`. Diese erwartet keine Parameter und soll Informationen in folgender Form zurückgeben: “\ ( \ )⎵hätte⎵gerne⎵ \ ⎵Krustentiere,⎵ \ ⎵Sardellen⎵und⎵ \ ⎵Sardinen. “
	- Achte wieder darauf, dass die Ausgabe genau mit der Vorgabe übereinstimmt!
	- Achte auch hier auf die Leerzeichen!
- [task][pay]( 224121 )
Jetzt fehlt in der Klasse `Kaufuin` nur noch die – für Claudia und Karl-Heinz wichtigste – Methode: `pay`. Diese übernimmt den zu zahlenden Wert als double, subtrahiert ihn vom Geld des Kaufuins (`money`) und gibt folgenden String auf der Konsole aus: “\ ⎵zahlt⎵ \ ⎵und⎵hat⎵noch⎵ \ PD⎵übrig. “
	- name und money sollen den Werten der Attribute **NACH** dem Bezahlvorgang entsprechen (PD ist nur die Abkürzung für die gängige Währung: Pinguindollar).
	- amount soll dem übergebenen Wert entsprechen.
	- Achte wieder darauf, dass die Ausgabe genau mit der Vorgabe übereinstimmt!
	- **Hinweis:** zur Ausgabe auf der Konsole kannst du die Methode `write` der Klasse `PinguLib` verwenden.

### Market
Jetzt hast du es schon fast geschafft! Es fehlen nur noch 2 Methoden in `Market`, mit denen Claudia und Karl-Heinz alles im Blick behalten können.
- [task][serveCustomer]( 224118 )
Schreibe eine Methode `serveCustomer` in der Klasse `Market`, die einen übergebenen `Kaufuin` bedient. Dazu soll folgendes passieren:
	- Zuerst wird die Bestellung aufgenommen. Dazu soll folgendes auf der Konsole ausgegeben werden: “ Neue⎵Bestellung⎵wird⎵angenommen:⎵ \ ( \ )⎵hätte⎵gerne⎵ \ ⎵Krustentiere,⎵ \ ⎵Sardellen⎵und⎵ \ ⎵Sardinen. “.
	- Anschließend sollen die bestellten Mengen in die Tagesstatistik übernommen (`soldXXXDay`) und die Gesamtkosten (costXXX = amountXXX * priceXXX) berechnet werden. Letztere sollen wie folgt auf der Konsole ausgegeben werden: “ Die⎵Bestellung⎵kostet⎵ \ PD. “ (wobei cost durch die entsprechenden Kosten ersetzt werden soll).
	- Schließlich muss der Kaufuin noch bezahlen.
	- Der Übersichtlichkeit halber soll nach jedem bedienten Kunden eine leere Zeile ausgegeben werden.
	- Vergiss nicht, die täglichen Gesamteinnahmen zu aktualisieren!
	- **Hinweis:** zur Ausgabe auf der Konsole kannst du die Methode `write` der Klasse `PinguLib` verwenden.
- [task][endDay]( 224123 )
Als letztes fehlt noch die Methode `endDay` der Klasse `Market`. Diese soll den aktuellen Tag beenden und die Tagesstatistik ausgeben.
    - Zuerst sollen die Informationen wie folgt auf der Konsole ausgegeben werden: “ Der⎵Laden⎵der⎵Saleuine⎵Claudia⎵und⎵Karl-Heinz⎵hat⎵am⎵ \ .⎵Tag⎵ \ PD⎵eingenommen. “ *(neue Zeile)* “ Dafür⎵wurden⎵ \ ⎵Krustentiere,⎵ \ ⎵Sardellen⎵und⎵ \ ⎵Sardinen⎵verkauft. “ *(neue Zeile)* “ Insgesamt⎵hat⎵der⎵Laden⎵ \ PD⎵eingenommen. “
    - Auch hier soll wieder eine nachfolgende leere Zeile die Übersichtlichkeit gewährleisten.
    - Anschließend soll die Tagesstatistik auf 0 zurückgesetzt werden und der aktuelle Tag um 1 erhöht werden.
    - Abschließend sollen die Preise der Produkte jeweils halbiert werden.
    - Vergiss nicht, die Gesamteinnahmen an geeigneter Stelle zu aktualisieren!
	- **Hinweis:** zur Ausgabe auf der Konsole kannst du die Methode `write` der Klasse `PinguLib` verwenden.

## Beispiele

Geschafft! Hier siehst du noch, ob die Beispiel von unten funktionieren:
- [task][Beispiel]( 224117 )
- [task][Großes Beispiel]( 224130 )
Für das große Beispiel wird der Output nicht angezeigt. Vergiss also nicht, **ALLE** implementierten Methoden auch selbst zu testen!

Das Template enthält bereits die leeren Klassen `Order` und `Kaufuin`, sowie die Klasse `Market` mit folgender `main`-Methode:
```java
public static void main(String[] args) {
	Market market = new Market(1.99, 9.99, 100);

	Order jessiesOrder = new Order(5, 6, 7);
	Kaufuin jessie = new Kaufuin(""Jessie"", 19, 1337, jessiesOrder);

	market.serveCustomer(jessie);
	market.endDay();
}
```

Das große Beispiel kannst du selber in deine `main`-Methode kopieren:
```java
public static void main(String[] args) {
	Market market = new Market(1.99, 9.99, 100);

	Order jessiesOrder = new Order(5, 6, 7);

	Kaufuin jessie = new Kaufuin(""Jessie"", 19, 1337, jessiesOrder);
	Kaufuin alex = new Kaufuin(""Alex"", 23, 9001, new Order(0, 0, 10));

	market.serveCustomer(jessie);
	market.endDay();

	jessie.giveNewOrder(new Order(1, 2, 3));
	jessie.addToOrder(new Order(1, 1, 1));
	market.serveCustomer(jessie);
	market.serveCustomer(alex);
	market.endDay();
}
```

 
 Eine Ausführung der main-Methode sollte für das erste Beispiel zu dieser Ausgabe führen (zum Ausklappen hier klicken) 
 
Neue Bestellung wird angenommen: Jessie(19) hätte gerne 5 Krustentiere, 6 Sardellen und 7 Sardinen.
Die Bestellung kostet 769.89PD.
Jessie zahlt 769.89 und hat noch 567.11PD übrig.

Der Laden der Saleuine Claudia und Karl-Heinz hat am 1. Tag 769.89PD eingenommen.
Dafür wurden 5 Krustentiere, 6 Sardellen und 7 Sardinen verkauft.
Insgesamt hat der Laden 769.89PD eingenommen.

 
 
Du kannst den Inhalt der `main`-Methode nach Belieben verändern, um deine eigene Implementierung Schritt für Schritt zu testen."
404,Praktikum: Grundlagen der Programmierung WS24/25,14724,W02H03 - Das Zepter der Unterwerfung,"Falls du Eclipse benutzt und die Aufgabe lokal nicht ausführen kannst, lohnt es sich mal [hier](https://zulip.in.tum.de/#narrow/stream/1243-PGdP-Technik/topic/Eclipse.20Fehler/near/1663669) vorbeizuschauen!

# Das Zepter der Unterwerfung

Die Entdeckuine Antonia, Christian und Jonas langweilen sich in der Antarktis. Wohin das Auge sieht gibt es nur Eis und Schnee. Eines Tages fällt Antonia eine alte Geschichte ihres Großvaters ein, die von einem sagenumwobenen Zepter der Unterwerfung erzählt. Der Legende zufolge erhält derjenige die Macht, die Menschheit zu unterwerfen, der das Zepter besitzt. Antonia erzählt ihren beiden Freunden von der Geschichte und zusammen beschließen sie nach diesem Zepter zu suchen. Um sich darauf vorzubereiten, brauchen sie einen Rucksack mit Werkzeugen und Proviant. Am liebsten essen sie natürlich Fisch. Hilfst du ihnen, sich auf die Expedition vorzubereiten?

Bevor wir anfangen gibt es hier ein paar Hinweise:
- Die Aufgabe ist wieder zweigeteilt in Struktur und Funktionalität. Bevor die Tests für die Funktionalität ausgeführt werden können, muss erst die Struktur komplett stimmen.
- Im UML-Diagramm sind ein Attribut und eine Methode unterstrichen. Das bedeutet, dass diese beiden *static* sind.
- Deine IDE kann dir sehr vieles automatisch generieren, v.a. Konstruktoren, Getter und Setter. Informiere dich, welche Tastenkombination das für dich erledigt!
- Um Text auf der Konsole auszugeben, kannst du wie zuvor die `PinguLib` verwenden.
- In der Aufgabe wird in jedem String das Zeichen ⎵ verwendet, um Leerzeichen zu kennzeichnen. Ersetze sie dann später im Code durch ein richtiges Leerzeichen.

## [task][Struktur]( 224170 , 224149 , 224187 , 224156 , 224188 , 224173 , 224151 , 224181 , 224189 , 224176 )
Zunächst fangen wir mit der Struktur an, indem wir das folgende UML-Diagramm implementieren. In deinem Repo findest du bereits die notwendigen Klassen. Mit Ausnahme der Klasse `Scepter` bekommt jedes Attribut in jeder Klasse einen *Getter*. Zudem bekommt jede Klasse eine `toString`-Methode, ausgenommen `Backpack`. Infos zu den Konstruktoren findest du unterhalb des Diagramms.

@startuml

hide circle

class Backpack {
	+ putScepterIntoBackpack(scepter: Scepter): void
	+ steal(stealer: Entdeckuin): Scepter
}

class Entdeckuin {
    - name: String
	- age: int
	+ addProvisions(fish: Fish): void
	+ fish(type: String): Fish
	+ eat(): void
	+ usePickaxe(): void
	+ findScepter(): void
    + steal(other: Entdeckuin): void
}

class Scepter {
    {static}- instance: Scepter
    {static}+ findScepter(newOwner: Entdeckuin): Scepter
    + steal(newOwner: Entdeckuin): Scepter
}

class Fish {
    - type: String
    - preparation: String
    - amount: int
    + prepare(preparation: String): void
    + add(fish: Fish): int
    + eat(): int
}

class Tool {
    - type: String
    - durability: double
    + use(): double
}

Entdeckuin ""1"" o--right- ""1"" Backpack : - backpack
Backpack ""1"" o--- ""2"" Tool : - pickaxe, fishingRod
Backpack ""1"" o--- ""1"" Scepter : - scepter
Backpack ""1"" o--- ""1"" Fish : - provisions
Scepter ""1"" o--- ""1"" Entdeckuin : - owner

@enduml

### Konstruktoren
- [task][Fish]( 224168 , 224190 , 224183 )
Ein `Fish` hat einen `type` (beispielsweise "" salmon "" oder "" anchovies ""),eine `preparation` (bspw. "" fresh "" oder "" dried "") und eine Anzahl, wie viele Fische es sind.
Die Klasse bekommt 2 Konstruktoren:
    - Der erste bekommt einen Parameter `type` vom Typ `String` und soll das zugehörige Attribut initialisieren. Zudem soll `preparation` mit "" fresh "" und `amount` mit `1` initialisiert werden.
    - Der zweite soll die beiden Parameter `type` und ` preparation` vom Typ `String` in dieser Reihenfolge bekommen und die beiden zugehörigen Attribute Initialisieren. Zudem soll auch hier `amount` mit `1` initialisiert werden.
- [task][Tool]( 224159 , 224160 )
Die Klasse `Tool` hat einen `type` (bspw "" pickaxe "") und eine `durability`. 
Der Konstruktor bekommt `type` als `String` und soll das zugehörige Attribut, sowie `durability` mit `100.0` initialisieren.
- [task][Scepter]( 224184 , 224186 )
Der Konstruktor für `Scepter` wird etwas anders als gewohnt. Da das Zepter einzigartig ist, soll nur eine einzige Instanz dieser Klasse existieren können und andere Klassen sollen keine Möglichkeit haben, ein weiteres Objekt zu erzeugen. Dies können wir erreichen, indem wir den *default*-Konstruktor mit dem Modifier *private* hinzufügen. Somit existiert kein für andere Klassen aufrufbarer Konstruktor. Damit diese Instanz aber existiert, musst du sie bei der Deklaration von `instance` bereits initialisieren. Diese darf von nun an nie wieder neu initialisiert werden. Wir kümmern uns später darum, wie wir die Klasse sinnvoll verwenden können. Zudem besitzt das Zepter eine Referenz auf den `owner`, welche zu Beginn `null` sein soll.
- [task][Backpack]( 224158 , 224164 )
Unseren `Backpack` benutzen wir, um eine `pickaxe`, eine `fishingRod` und `provisions` in Form von `Fish` zu lagern und transportieren. Falls wir das Zepter gefunden haben, kommt das ebenfalls in den Rucksack.
Ein neuer `Backpack` bekommt 2 `String`s namens `fishType` und `fishPreparation`. Beide werden in dieser Reihenfolge dazu benutzt, um `provisions` passend zu initialisieren. Zudem soll `pickaxe` mit "" pickaxe "" und `fishingRod` mit "" fishing⎵rod "" initialisiert werden. Da wir das Zepter noch nicht gefunden haben, bleibt es erstmal `null`.
- [task][Entdeckuin]( 224191 , 224180 )
Die Klasse `Entdeckuin` hat die Attribute `name`, `age` und einen `backpack`.
Der Konstruktor bekommt 4 Parameter: einen `String name`, einen `int age` und 2 weitere `String`s `favoriteFishType` und `favoritePreparation`. Die ersten beiden Parameter initialisieren die beiden zugehörigen Attribute während mit den restlichen beiden `backpack` passend initialisiert wird.

### [task][Getter]( 224157 , 224152 , 224177 , 224155 )
Hier kannst du sehen, ob deine Getter richtig funktionieren.

## Funktionalität

### [task][toString]( 224182 , 224185 , 224175 , 224154 )

Als nächstes implementieren wir die ganzen `toString`-Methoden. Sie sollen für jede Klasse die folgenden `String`s zurückgeben:
- `Fish`: ""\ ⎵ \ ""
- `Tool`: ""\ ⎵with⎵ \ ⎵points⎵of⎵durability ""
- `Scepter`: "" The⎵scepter⎵of⎵submission⎵belongs⎵to⎵ \ ⎵now. ""
- `Entdeckuin`: "" Entdeckuin⎵ \ ( \ ) ""

Nachdem wir das jetzt aus dem Weg haben, können wir uns um die eigentlichen Methoden kümmern. Starten wir mit der Klasse `Fish`:

### Fish

- [task][prepare]( 224153 )
Diese Methode bekommt einen `String` übergeben und soll sein eigenes Attribut damit überschreiben.
- [task][add]( 224174 )
Diese Methode bekommt einen anderen `Fish` übergeben und soll die Menge des anderen Fisches auf die eigene addieren. Anschließend soll die neue Gesamtmenge zurückgegeben werden.
- [task][eat]( 224178 )
Diese Methode soll einen Fisch von der Gesamtmenge abziehen und den neuen Wert zurückgeben.

### Tool

- [task][use]( 224166 )
Diese Methode soll die `durability` dekrementieren und den neuen Wert zurückgeben.

### Scepter

So, kommen wir nun zu unserer besonderen Klasse. Zum einen wollen wir das Zepter zum ersten Mal finden können, zum anderen wollen wir das Zepter auch stehlen können. Im Prinzip sind beide Methoden genau gleich außer dem kleinen Unterschied, dass eine der beiden *static* ist. Diese erlaubt uns an die Instanz zu kommen, ohne dass wir die Instanz kennen.
- [task][findScepter und steal]( 224163 , 224162 )
Beide Methoden sollen zuerst den `owner` der `instance` auf den übergebenen Wert setzen, dann den Text der `toString`-Methode auf der Konsole ausgeben und zum Schluss die `instance` zurückgeben.

### Backpack

- [task][putScepterIntoBackpack]( 224161 )
Diese Methode soll `scepter` mit dem übergebenen Parameter überschreiben.
- [task][steal]( 224169 )
Diese Methode soll auf `scepter` die `steal`-Methode mit dem übergebenen Parameter aufrufen, die eigene `scepter`-Referenz auf `null` setzen und die `Scepter`-Instanz zurückgeben. Du kannst davon ausgehen, dass der Rucksack das Zepter auch wirklich enthält.

### Entdeckuin
Zum Schluss müssen wir nur noch 6 Methoden von `Entdeckuin` implementieren. Bis auf die letzten beiden Methoden kannst du hier schon Punkte bekommen, auch wenn deine anderen Klassen noch nicht richtig funktionieren:

- [task][addProvisions]( 224165 )
Mit dieser Methode können unsere Entdeckuine neuen Fisch in ihren Rucksack packen. Sie soll zuerst den übergebenen Fisch genauso zubereiten, wie der restliche Fisch im Rucksack (Stichwort: `preparation`). Danach wird der Fisch zu unseren `provisions` hinzugefügt. Zum Schluss soll noch folgendes auf der Konsole ausgegeben werden: ""\ ⎵ \ ⎵some⎵ \ ⎵and⎵added⎵it⎵to⎵their⎵provisions. ""
- [task][fish]( 224172 )
Mit dieser Methode können unsere Entdeckuine fischen. Zuerst soll die Angel aus dem Rucksack *benutzt* werden. Danach soll folgendes auf der Konsole ausgeben: ""\ ⎵used⎵the⎵ \ ⎵to⎵catch⎵some⎵ \ .⎵It⎵has⎵ \ ⎵durability⎵left. "" Zum Schluss soll ein neuer frischer Fisch mit dem übergebenen `type` zurückgegeben werden.
- [task][eat]( 224167 )
Mit dieser Methode können wir den Fisch aus unserem Rucksack *essen*. Anschließend soll folgendes auf der Konsole ausgegeben werden: ""\ ⎵ate⎵some⎵ \ .⎵There⎵is⎵ \ ⎵ \ ⎵left. ""
- [task][usePickaxe]( 224179 )
Mit dieser Methode können wir uns den Weg freischlagen. Dabei soll die `pickaxe` zunächst *benutzt* werden und anschließend soll folgender String ausgegeben werden: ""\ ⎵used⎵the⎵ \ ⎵to⎵crush⎵some⎵ice.⎵It⎵has⎵ \ ⎵durability⎵left. ""
- [task][findScepter]( 224150 )
Mit dieser Methode können wir das Zepter finden. Dazu nutzen wir einfach die *static* Methode, an die wir uns selber übergeben (Stichwort: `this`), und packen das Zepter in unseren Rucksack.
- [task][steal]( 224171 )
Mit dieser Methode können wir von dem übergebenen Entdeckuin das Zepter klauen. Dazu greifen wir einfach in seinen Rucksack und stehlen das Zepter, welches sich da drin befindet (auch hier übergeben wir uns wieder selber beim Methodenaufruf). Anschließend packen wir auch hier das Zepter in unseren Rucksack. Du kannst davon ausgehen, dass der andere Entdeckuin das Zepter auch wirklich besitzt, wenn die Methode aufgerufen wird.

## Beispiel

Geschafft! Hier findest du noch ein kleines Beispiel, welches du bereits in deiner `main`-Methode findest. Probiere ruhig selber eigene Beispiele aus und erschaffe deine eigene Geschichte der 3 Entdeckuine!

```java
public static void main(String[] args) {
	Entdeckuin antonia = new Entdeckuin(""Antonia"", 5, ""salmon"", ""salted"");

	antonia.addProvisions(new Fish(""salmon"", ""salted""));
    antonia.usePickaxe();
	antonia.findScepter();
	antonia.eat();
}
```

 
 Wenn du alles korrekt implementiert hast, sollte das Beispiel wie folgt aussehen (zum Ausklappen hier klicken) 
 
Entdeckuin Antonia(5) salted some salmon and added it to their provisions.
Entdeckuin Antonia(5) used the pickaxe with 100.0 points of durability to crush some ice. It has 99.0 durability left.
The scepter of submission belongs to Entdeckuin Antonia(5) now.
Entdeckuin Antonia(5) ate some salted salmon. There is 1 salted salmon left."
404,Praktikum: Grundlagen der Programmierung WS24/25,14851,W03P01 - Punktdarstellung,"# Punktdarstellung

*Ziel dieser Aufgabe ist es, die Vorteile von Kapselung zu zeigen.*

Du entwickelst mit an einer Bibliothek für 2-dimensionale Geometrie. Diese enthält eine Klasse `Point`, die 2-dimensionale Punkte repräsentiert.
Die Implementierung basiert auf der kartesischen Darstellung eines Punktes als x und y Koordinate. Ein Nutzer (`PointUser`), also ein anderer Programmierer, der deine Implementierung eines Punktes für sein eigenes Projekt nutzen möchte,
greift auf die Klasse `Point` zu. Du hast keinen Einfluss auf seinen Code und sein Projekt, außer dass du ihn auf neuere Versionen deiner Punkt-Bibliothek hinweisen kannst.

Aus bestimmten Gründen (z.B. da dadurch einige häufig verwendete Rechenoperationen kosteneffizienter werden) wird in deinem Team entschieden, dass es sinnvoller ist, die Punkte von nun an intern nicht mehr mittels kartesischer, sondern mittels
Polarkoordinaten darzustellen, also als das Paar aus dem ""Radius"" des Punktes, d.h. der Länge der Strecke vom Ursprung zu dem Punkt und dem Winkel, den diese Strecke mit der x-Achse aufspannt. Deine Aufgabe wird es nun sein, die Klasse `Punkt` für diese Neuerung umzubauen.
Du sollst dabei zwei Szenarien durchspielen. Eines, in dem die bereits bestehende Klasse `Point` nicht korrekt gekapselt ist (alle Attribute sind *public*) und eines, in dem die Klasse korrekt gekapselt ist (alle Attribute sind *private* und Zugriffe darauf erfolgen nur indirekt durch Methoden).

Lade nun das Code-Template für diese Aufgabe herunter. Im Folgenden wird es genauer erläutert und erklärt, was genau du jeweils tun sollst.

### Kartesische und Polare Koordinaten
 Für die Bearbeitung der Aufgabe ist es nicht notwendig, den folgenden Abschnitt zu verstehen. Er dient nur einem besseren Verständnis der verschieden Koordinatensysteme 
 
Das kartesische Koordinatensystem drückt einen (2-dimensionalen) Punkt als x- und y-Koordinate aus.

Der Abstand des Punktes $$(x, y)$$ vom Ursprung berechnet sich als $$\sqrt{x^2 + y^2}$$. 
Der Abstand zweier Punkte $$(x\_{1}, y\_1)$$ und $$(x\_2, y\_2)$$ als $$\sqrt{(x\_1 - x\_2)^2 + (y\_1 - y\_2)^2}$$.

Das polare Koordinatensystem hingegen stellt einen Punkt dar als den Radius $$r$$ des Punktes (der Länge der Stecke vom Ursprung zum Punkt) und dem Winkel $$\phi$$, den diese Linie mit der x-Achse einschließt.

Der Abstand des Punktes $$(r, \phi)$$ vom Ursprung ist dann einfach nur $$r$$. 
Der Abstand zweier Punkte $$(r\_1, \phi\_1)$$ und $$(r\_2, \phi\_2)$$ ist gegeben durch den Ausdruck $$\sqrt{r\_1^2 + r\_2^2 - 2 * r\_1 * r\_2 * cos(\phi\_1 - \phi\_2)}$$.  


### Packagestruktur in der Angabe

Wenn man ein Projekt mit vielen Dateien hat bzw. diese sich (wie in dieser Aufgabe) natürlich in Gruppen aufteilen, macht es Sinn, sie in sogenannte *Packages* aufzuteilen. *Packages* sind nichts anderes als Ordner. In dieser Aufgabe werden die Packages verwendet, um unterschiedliche Versionen derselben Bibliothek bzw. unterschiedliche Teilaufgaben bzw. eine Bibliothek und deren Nutzer zu repräsentieren. (Was nicht ihrem Zweck in einem gewöhnlichen Projekt entspricht! Allerdings bietet sich das hier an, um die gesamte Aufgabe in einem Projekt lösen zu können.)

In der Angabe wirst du folgende Package-Struktur vorfinden:

![](https://syncandshare.lrz.de/dl/fi9YTuhLqKTnEJcjTqUB2yTf/Ordnerbaum_Points.png&inline)

 1.  Die beiden Packages *not\_encapsulated* und *encapsulated* auf der höheren Ebene repräsentieren die beiden Szenarien. Du sollst die Aufgabe einmal für eine nicht korrekt gekapselte Version der Bibliothek durchführen: Den Code hierzu findest du/sollst du      ergänzen im Package *not\_encapsulated*. Danach sollst du die gleiche Aufgabe zum Vergleich noch einmal mit einer korrekt gekapselten Version der Bibliothek lösen: Den Code hierzu findest du/sollst du ergänzen im Package *encapsulated*.
 2.  In jedem dieser beiden Packages befindet sich dann jeweils das Package *cartesian* und das Package *polar*, in denen je eine Klasse `Point` zu finden ist. *cartesian* repräsentiert die alte, bereits releaste Version deiner Geometrie-Bibliothek.
     Sie ist bereits vollständig implementiert und die Klasse `Point` in ihr enthält alle Funktionalitäten, die der 2D-Punkt bereitstellen soll.
     Die Klasse `Point` im Package *polar* ist die neue Version des 2D-Punktes. Sie soll von dir jeweils implementiert werden.
 3.  Außerdem befindet sich sowohl im Package *not\_encapsulated* als auch im Package *encapsulated* ein Package *point_user*. Dieses repräsentiert jedes Mal den Nutzer der Bibliothek. In diesem Package **soll nichts geändert werden**
     (außer einem [Import-Statement](https://docs.oracle.com/javase/tutorial/java/package/usepkgs.html), um das Updaten zur neueren Version der Geometrie-Bibliothek zu simulieren - später genauer).
 4.  Zu guter Letzt gibt es noch außerhalb der Packages *not\_encapsulated* und *encapsulated* die Klasse *MathHelpers*. Diese soll dir die mathematisch und programmiertechnisch anspruchsvolleren Teile abnehmen.
     Anstatt z.B. die Umwandlung von einem kartesischen Koordinatenpaar $$(x, y)$$ in das zugehörige polare Paar $$(r, \phi)$$ selbst zu implementieren, musst du nur `MathHelpers.xyToRadius(x, y)` und `MathHelpers.xyToAngle(x, y)` aufrufen.

### Die Klasse Point

Du findest im Code-Template vier (teils unfertige) Implementierungen der Klasse `Point` und zwar je eine in den Packages

 -  *not\_encapsulated.cartesian*,
 -  *not\_encapsulated.polar*,
 -  *encapsulated.cartesian* und schließlich
 -  *encapsulated.polar*.

Die vier Klassen stellen (mehr oder minder) die gleichen Funktionalitäten zur Verfügung:

 -  Repräsentation eines 2D-Punktes
 -  Berechnen des Abstands zum Ursprung
 -  Berechnen des Abstands zu einem anderen Punkt (-Objekt derselben Klasse)

#### Nicht Gekapselte Variante

Die ""alte Version"" des nicht gekapselten Punktes in *not\_encapsulated.cartesian* ist durch folgendes UML-Klassendiagramm beschrieben:

@startuml

hide circle

class not_encapsulated.cartesian.Point {
    + x: double
    + y: double
    + distanceToOrigin(): double
    + distanceTo(other: Point): double
}

@enduml

Du willst nun diese Implementierung zu einer Darstellung als Polarkoordinaten umbauen. Die umgebaute Variante muss auch nicht gekapselt sein, d.h. die Mindestanforderungen an sie sind beschrieben durch das UML-Klassendiagramm

@startuml

hide circle

class not_encapsulated.polar.Point {
    + angle: double
    + radius: double
    + getX(): double
    + getY(): double
    + distanceToOrigin(): double
    + distanceTo(other: Point): double
}

@enduml

Implementiere also die neue Variante des nicht gekapselten Punktes nach diesem Diagramm. Du darfst nach Belieben noch Attribute und Methoden hinzufügen, die Attribute *angle* und *radius*
müssen aber zu jedem Zeitpunkt des Lebenszyklus eines Punkt-Objektes korrekt gesetzt sein. Du darfst sie nicht einfach ignorieren und wieder allein mit x- und y-Koordinaten arbeiten.
 
Allerdings darf der Code des Nutzers der nicht gekapselten Point-Klasse in `not_encapsulated.point_user.PointUser` durch deine neue Implementierung nicht auf einmal Fehler generieren
und muss nach wie vor funktionieren. Du hast keinen Einfluss auf seinen Code und kannst von ihm nicht verlangen, bei jedem Update deiner Bibliothek seinen ganzen Code umzubauen.
Ändere in `not_encapsulated.point_user.PointUser` also lediglich das Import-Statement `import pgdp.not_encapsulated.cartesian.Point` zu `import pgdp.not_encapsulated.polar.Point`,
nachdem du mit der Implementierung deiner neuen `Point`-Klasse fertig bist, um das Update des Nutzers zur neueren Version zu simulieren und nichts weiter.

#### Korrekt Gekapselte Variante

Die ""alte Version"" des korrekt gekapselten Punktes in *encapsulated.cartesian* ist durch folgendes UML-Klassendiagramm beschrieben:

@startuml

hide circle

class encapsulated.cartesian.Point {
    - x: double
    - y: double
    + getX(): double
    + getY(): double
    + setX(x: double): void
    + setY(y: double): void
    + distanceToOrigin(): double
    + distanceTo(other: Point): double
}

@enduml

Du willst nun diese Implementierung zu einer Darstellung als Polarkoordinaten umbauen. Die umgebaute Variante muss ebenfalls gekapselt sein, d.h. die Mindestanforderungen an sie sind beschrieben durch das UML-Klassendiagramm

@startuml

hide circle

class encapsulated.polar.Point {
    - angle: double
    - radius: double
    + getX(): double
    + getY(): double
    + setX(x: double): void
    + setY(y: double): void
    + getAngle(): double
    + getRadius(): double
    + distanceToOrigin(): double
    + distanceTo(other: Point): double
}

@enduml

Implementiere also die neue Variante des gekapselten Punktes nach diesem Diagramm. Du darfst nach Belieben noch Attribute und Methoden hinzufügen, die Attribute *angle* und *radius*
müssen aber zu jedem Zeitpunkt des Lebenszyklus eines Punkt-Objektes korrekt gesetzt sein. Du darfst sie nicht einfach ignorieren und wieder allein mit x- und y-Koordinaten arbeiten.
 
Allerdings darf der Code des Nutzers der gekapselten Point-Klasse in `encapsulated.point_user.PointUser` durch deine neue Implementierung nicht auf einmal Fehler generieren
und muss nach wie vor funktionieren. Du hast keinen Einfluss auf seinen Code und kannst von ihm nicht verlangen, bei jedem Update deiner Bibliothek seinen ganzen Code umzubauen.
Ändere in `encapsulated.point_user.PointUser` also lediglich das Import-Statement `import pgdp.encapsulated.cartesian.Point` zu `import pgdp.encapsulated.polar.Point`,
nachdem du mit der Implementierung deiner neuen `Point`-Klasse fertig bist, um das Update des Nutzers zur neueren Version zu simulieren und nichts weiter.

*Hinweis:*
Der Konstruktor aller Punkte muss die beiden *double*-Argumente auch in der neueren Variante als x- und y-Koordinate interpretieren und Winkel und Radius entsprechend setzen.
Sonst wäre er nicht konsistent mit der alten Variante und der Nutzer würde sich auf ein Verhalten (nämlich der Interpretation der Konstruktorargumente als x- und y-Koordinate)
verlassen, das nicht mehr aufgewiesen wird.

*Hinweis:*
Wann immer du ein Paar von x- und y-Koordinaten in einen Winkel und/oder einen Radius übersetzen musst, verwende die in `MathHelpers` bereitgestellten statischen Methoden.
Ähnlich, wenn du Winkel und Radius in x- und y-Koordinaten umwandeln musst.

*Hinweis:*
Wann immer du nur eine x- oder nur eine y-Koordinate in Winkel und Radius übertragen musst, überlege dir zuerst, wie du die jeweils andere Koordinate bekommst.
Ähnlich, wenn du nur einen Winkel oder nur einen Radius in x- und y-Koordinaten umwandeln musst."
404,Praktikum: Grundlagen der Programmierung WS24/25,14852,W03P02 - Call by Value,"# Call by Value

*In dieser Aufgabe wird gezeigt, wie bei einem Methodenaufruf die Parameter übergeben werden.*

Im Template findest du drei .java-Dateien. Die Hauptklasse in jeder dieser Dateien enthält jeweils eine statische Methode `foo`,
welche wiederum intern eine oder mehrere andere Methoden aufruft. Analysiere für jede der drei Teilaufgaben jeweils, was der vorliegende Code tut.
Erst ohne ihn auszuführen, danach mit. Versuche ihn gegebenenfalls (in den Teilaufgaben 2 und 3) zu fixen,
sodass er das ""erwartete"" Verhalten an den Tag legt.

*In dieser Aufgabe müssen keine Implementierungen gepusht werden und es gibt auch keine Tests*"
404,Praktikum: Grundlagen der Programmierung WS24/25,14853,W03P03 - Basistypen und Operatoren,"In dieser Aufgabe sollst du die Basistypen und Operatoren von Java besser kennenlernen.
Dazu wirst du dir einige Code-Schnipsel, welche die entsprechenden Basistypen und Operatoren verwenden, ansehen und versuchen zu verstehen,
was sie tun bzw. warum sie das Verhalten aufweisen, das sie aufweisen.

# Basistypen

Wiederhole mit deinem Tutor die acht Basistypen der Java-Sprache, indem du für jeden von ihnen (soweit diese Größe jeweils Sinn macht)
- den Speicherverbrauch in bit
- den minimalen Wert, den eine Variable dieses Typen annehmen kann und
- den maximalen Wert, den eine Variable dieses Typen annehmen kann

auflistest und zu jedem davon mindestens zwei Beispiele für Literale von diesem Typ angibst.
Mit einem Literal ist hier ein Wert im Programmcode gemeint. So ist beispielsweise in der Anweisung `int x = 4;` die *4* ein Literal vom
Typ `int`.

## Konversionen zwischen den Basistypen

Ruf dir ins Gedächtnis, welcher Basistyp jeweils in welchen anderen implizit umgewandelt (*""gecastet""*) werden kann, wie ein expliziter Cast
aussieht und was man bei Letzterem bzgl. des Wertes, der in der zu castenden Variable steht, beachten muss.
Löse anschließend folgende Aufgaben:
1. Welche der Kombinationen aus den Code-Schnipseln
    - `int n =`
    - `float f =`
    - `double d =`
    - `long l =`
    
    und
    - `4.0;`
    - `-7L;`
    - `8;`
    - `3.0f;`
    
    zusammensetzbaren Anweisungen kompilieren?
2. Und welche der Kombinationen aus den Code-Schnipseln
    - `char c =`
    - `short s =`
    
    und
    - `-5;`
    - `40000;`
    
    zusammensetzbaren Anweisungen kompilieren? Warum?
    
3. Erstelle ein neues Java-Projekt. In IntelliJ macht man das unter *File/New/Project* bzw. *Datei/Neu/Projekt*,
   in Eclipse unter *File/New/Java Project* bzw. *Datei/Neu/Java Projekt*. Nenne das Projekt *experimenting-with-types-and-operators* (oder wie auch immer du es nennen willst).
   Solltest du damit Schwierigkeiten haben, findest du [hier](https://hack-deck.de/projekt-erstellen) ein Tutorial, wie man in IntelliJ ein Projekt erstellt
   und [hier](https://mein-javablog.de/java-projekt-eclipse-anlegen/) eines, wie man in Eclipse ein Projekt erstellt.
   Lege eine neue Klasse `TypeAndOperatorExperiments` im Source-Ordner (*src*) an und fülle sie mit einer leeren main()-Methode:
    ```java
    public class TypeAndOperatorExperiments {
        public static void main(String[] args) {
            // Method calls go here ...
        }
    }
    ```
   Für jedes, der folgenden Code-Schnipsel, das du selbst ausprobieren sollst, lege eine neue `public static`-Methode in `TypeAndOperatorExperiments` an,
   die keine Parameter entgegennimmt und keinen Wert zurückgibt. Nenne diese Methode jeweils, wie du willst. Um das Code-Schnipsel laufen zu lassen,
   rufe sie einfach in der main()-Methode auf.
   
   Probiere nun also folgenden Code in einer eigenen statischen Methode aus:
    ```java
    float f0 = 1_000_000_000_000L;
    float f1 = 1_000_000_000_001L;
    float f2 = 1_000_000_000_010L;
    float f3 = 1_000_000_000_100L;
    // ...
    
    System.out.println(f1 - f0);
    System.out.println(f2 - f0);
    System.out.println(f3 - f0);
    // ...
    ```
   Was wird jeweils ausgegeben? Kannst du dir dieses Verhalten erklären?
4. Probiere auch folgenden Code aus:
    ```java
    short s = (short) 246;
    byte b = (byte) 246;
    int n = (int)(char) -1;
    
    System.out.println(""s = "" + s);
    System.out.println(""b = "" + b);
    System.out.println(""n = "" + n);
    ```
   Was wird hier ausgegeben? Wie lassen sich die Werte der Variablen *s*, *b* und *n* erklären?
   
# Operatoren

Nun werden wir nach und nach die meisten Operatoren der Java-Sprache wiederholen bzw. kennenlernen.

*Hinweis (var):* Seit der Java-Version 10 ist es möglich, anstelle der Angabe des Typen einer Variable das Schlüsselwort *var* zu verwenden,
insofern er (für den Compiler ersichtlich) aus dem Kontext hervorgeht.
Der Typ der Variablen wird dann vom Compiler automatisch ermittelt. D.h. bei Programmstart ist der richtige Typ dann bereits bekannt.
In den .class-Dateien, welche auf der Java Virtual Machine ausgeführt werden, ist er vom Compiler reingeschrieben worden.
Man kann also z.B. anstelle von `int n = 7;` auch `var n = 7;` tippen und der Compiler wird beim Parsen des Codes für *var* den
korrekten Typen, nämlich *int*, einsetzen.
 
Die Verwendung von *var* ist besonders nützlich, wenn man lange, unleserliche Typangaben, wie z.B. `ProjectContractChargingPeriodProjectAccountReferenceVMFactoryBuilderStrategy strategy = new ProjectContractChargingPeriodProjectAccountReferenceVMFactoryBuilderStrategy();` vermeiden möchte.
Dann kann man stattdessen einfach `var strategy = new ProjectContractChargingPeriodProjectAccountReferenceVMFactoryBuilderStrategy()` tippen,
und der Code wird zumindest ein bisschen leserlicher.
Oder wenn man Aufgaben zum Thema Typen stellen möchte ... 🙂.
Vom inflationären Gebrauch von *var* ist abzuraten, da er Code unleserlich und schwer verständlich macht.

### Arithmetische Operatoren

Die von Java unterstützten arithmetischen Operatoren sind `+`, `-`, `*`, `/` und `%` *(modulo)*.
Sie können jeweils zwei Werte vom gleichen Datentyp (z.B. zwei *int*s oder zwei *double*s) miteinander verknüpfen, aber auch zwei Werte von
unterschiedlichen Typen. In letzterem Fall ist logischerweise unklar, von welchem Datentyp das Ergebnis sein soll. 
Es gibt daher einen von Java fest vorgegebenen Regelsatz, nach dem sich aus den Eingabedatentypen der Datentyp der Rückgabe (also des Ergbnis) der Operation
bestimmt:
1. Der Operand mit dem ""kleineren"" (siehe Konversionen) Datentyp wird implizit in den ""größeren"" Typ gecastet.
2. Beide Operanden werden mindestens zu einem *int* gecastet.
3. Der Datentyp des Werts der Operation ist der, in den gecastet wurde.

Überlege dir nun, ohne sie auszuführen, was folgende Code-Schnipsel tun.
```java
int n = 2;
long l = 3L;
var x = n + l;
```
```java
int n = 2;
double d = 7.0;
var x = n + d;
```
```java
short s1 = 1;
short s2 = 2;
short s3 = s1 + s2;
```
Führe sie nun aus! Ist das erwartete Verhalten eingetreten? Wie erklären sich jeweils die Ergebnisse?

#### Division

Bei der Division ist es besonders wichtig, die Datentypen zu beachten. Der Wert, nicht nur der Datentyp, des Ergebnisses
hängt hier davon ab.
 
Überlege dir, welchen Wert die Variablen `d1` bis `d6` nach Ausführen des folgenden Codes jeweils haben werden.
```java
double d1 = 7 / 3;
double d2 = 7.0 / 3;
double d3 = 7 / 3.0;
double d4 = 7.0 / 3.0;

double d5 = 3 / 0.5;
double d6 = 3 / (1/2);
```
Führe den Code nun selbst aus (und lass dir am Ende den Wert aller Variablen ausgeben).
Entspricht das Ergebnis deinen Erwartungen? Wie erklärst du jeweils, was geschieht?

#### Modulo

Welchen Wert nehmen die Variablen `v1` bis `v9` nach Ausführen folgenden Codes an? Versuche wieder, den Inhalt der Variablen vorherzusagen, bevor du den Code ausführst.
```java
int v1 = 11 % 4;
int v2 = 0 % 4;
int v3 = 4 % 0;

int v4 = -11 % 4;
int v5 = 11 % -4;
int v6 = -11 % -4;

double v7 = 3.5 % 2;
double v8 = 3.5 % 2.5;
double v9 = (22/7) % (19/7);
```

### Inkrement- und Dekrement-Operatoren

Wiederhole mit deinem Tutor zusammen die vier Inkrement- bzw. Dekrement-Operatoren.
Überlege dir anschließend, ohne sie auszuführen, was folgende Code-Schnipsel ausgeben.
Führe sie danach aus und vergleiche das Ergebnis mit deinen Erwartungen.
```java
int n = 5;
--n;
int k = n++ - --n;
int l = ++n + n--;
n = n--;

System.out.println(""k = "" + k);
System.out.println(""l = "" + l);
System.out.println(""n = "" + n);
```
```java
double d = 3.14;
char c = 'L';
int n1 = (int) d--;
int n2 = ++c;

System.out.println(""d = "" + d);
System.out.println(""c = "" + c);
System.out.println(""n1 = "" + n1);
System.out.println(""n2 = "" + n2);
```

### Vergleichsoperatoren

Kompilieren folgende Zeilen Code (separat betrachtet)? Falls ja, welche Werte stehen jeweils nach ihrer Ausführung in den in ihnen gesetzten Variablen?
```java
boolean b1 = 4 == 4.0;
boolean b2 = 7L == (short) 5;
boolean b3 = true == 1;
boolean b4 = 'd' == 100;
boolean b5 = false == b4;
```

Gegeben sei nun die Klasse A:
```java
class A {
    private int n;
    public A(int n) { this.n = n; }
    
    public int getN() { return n; }
    public void setN(int n) { this.n = n; }
}
```
Betrachte nun folgenden Code. Was wird in den vier print-Statements ausgegeben? Warum?
```java
A a1 = new A(2);
A a2 = new A(3);
a2.setN(2);
A a3 = new A(3 - 1);
A a4 = new A(2);
A a5 = a1;

System.out.println(a1 == a2);
System.out.println(a1 == a3);
System.out.println(a1 == a4);
System.out.println(a1 == a5);
```

Probiere nun folgenden Code selbst aus. Was sind die Ausgaben?
Was folgerst du daraus für Situationen, in denen du zwei *String*s auf Gleichheit testen willst?

```java
String s1 = ""abc"";
String s2 = ""abc"";
String s3 = ""a"" + ""b"" + ""c"";
String s4 = new String(""abc"");
String s5 = s1 + """";

System.out.println(""s1 == s2: "" + (s1 == s2));
System.out.println(""s1 == s3: "" + (s1 == s3));
System.out.println(""s1 == s4: "" + (s1 == s4));
System.out.println(""s1 == s5: "" + (s1 == s5));

System.out.println(""s1.equals(s2): "" + s1.equals(s2));
System.out.println(""s1.equals(s3): "" + s1.equals(s3));
System.out.println(""s1.equals(s4): "" + s1.equals(s4));
System.out.println(""s1.equals(s5): "" + s1.equals(s5));
```

Probiere auch folgenden Code aus. Wie erklärst du hier die Ausgabe und wie lässt sich das hierbei entstehende Problem lösen?
```java
double d = Math.sqrt(2) * Math.sqrt(2);
System.out.println(d == 2.0);
```
*Hinweis:* Die mit dem Java Development Kit kommende Standardbibliothek von Java enthält unter anderem die Klasse `Math`,
welche einige nützliche Funktionalitäten zur Verfügung stellt. So berechnet `Math.sqrt(x)` die Wurzel von `x`,
`Math.sin(x)` den Sinus von `x`, `Math.abs(x)` den Betrag von `x` usw.

### Logische Operatoren

Der logische Operator *&* verknüpft zwei *boolean*s miteinander. Er wertet sich genau dann zu *true* aus, wenn beide Operanden sich ebenfalls zu *true* auswerten.
In allen anderen Fällen wertet er sich zu *false* aus. Das kann man einfach in einer Tabelle zusammenfassen:
 
 & false true 
 false false false 
 true false true 
 
Erstelle für die Operatoren *|* und *^* ähnliche Tabellen.

Betrachte nun den Code
```java
int n1 = 7;
boolean b1 = n1 < 4 & ++n1 % 2 == 0;

int n2 = 7;
boolean b2 = n2 < 4 && ++n2 % 2 == 0;

System.out.println(""n1 == "" + n1);
System.out.println(""b1 == "" + b1);
System.out.println(""n2 == "" + n2);
System.out.println(""b2 == "" + b2);
```
Was gibt er aus? Probiere es aus und erkläre das Ergebnis.

Was wird der Output für folgenden Code sein:
```java
boolean gutVorbereitet = für_ÜPA_angemeldet && (Themen_gut_gelernt || Themen_direkt_verstanden)
```
Wie verhalten sich die Operatoren **&&** und **||**?

### Zuweisungsoperatoren

Kompilieren die folgenden Code-Schnipsel? Wenn ja, was wird jeweils ausgegeben?
```java
int n1 = 1, n2 = 2, n3 = 3;
n1 = n2 = n3 = 4;

System.out.println(""n1 == "" + n1);
System.out.println(""n2 == "" + n2);
System.out.println(""n3 == "" + n3);
```
```java
int n1 = 1, n2 = 2, n3 = 3;
n1 += n2 += n3 += 4;

System.out.println(""n1 == "" + n1);
System.out.println(""n2 == "" + n2);
System.out.println(""n3 == "" + n3);
```
```java
int n1 = 1, n2 = 2, n3 = 3;
n1 += n2 + n3 = 4;

System.out.println(""n1 == "" + n1);
System.out.println(""n2 == "" + n2);
System.out.println(""n3 == "" + n3);
```
```java
int n1 = 1, n2 = 2, n3 = 3;
n1 += n2 = n3 + 4;

System.out.println(""n1 == "" + n1);
System.out.println(""n2 == "" + n2);
System.out.println(""n3 == "" + n3);
```"
404,Praktikum: Grundlagen der Programmierung WS24/25,14854,W03H01 - PinguPinguLos I - Die dunkle Suchmaschine,"# Suchmaschine

In dieser Aufgabe soll der Anfang für die Suchmaschine geschaffen werden. Wir wollen zunächst die Dokumente speichern, die wir durchsuchen wollen. Aber auch andere wichtige Informationen wie Autoren, Reviews von Dokumenten und eine einfache Datumsklasse sollen implementiert werden.
Auf dieser Basis wird dann unsere Suchmaschine namens ""PinguPinguLos"" aufbauen.

## Die Struktur (UML)

@startuml

class pgdp.searchengine.pagerepository.Author {
   228419 )>-firstName: String 
 228419 )>-lastName: String 
 228419 )>-address: String 
 228419 )>-email: String 
 228412 )>+Author(firstName: String, lastName: String, address: String , email: String, birthday: Date) 
 228449 )>+equals(Author): boolean 
 228449 )>+toString(): String 
 228449 )>+toPrintText(): String 
}

class pgdp.searchengine.pagerepository.Document {
   228467 )>-documentId: int 
 228467 )>-title: String 
 228467 )>-description: String 
 228467 )>-content: String 
 228447 )>+Document(title: String, description: String, content: String, releaseDate: Date, author: Author) 
 228466 )>+equals(Document): boolean 
 228466 )>+toString(): String 
 228466 )>+toPrintText(): String 
  {static}  228466 )>+numberOfCreatedDocuments(): int 
}

class pgdp.searchengine.pagerepository.Review {
   228455 )>-postId: int 
 228455 )>-title: String 
 228455 )>-content: String 
 228455 )>-rating: int 
 228417 )>+Review(title: String, content: String, postDate: Date, reviewer: Author, reviewedDocument: Document, rating: int) 
 228421 )>+equals(Review): boolean 
 228421 )>+toString(): String 
 228421 )>+toPrintText(): String 
  {static}  228421 )>+numberOfCreatedReviews(): int 
}

class pgdp.searchengine.util.Date {
   228406 )>-day: int 
 228406 )>-month: int 
 228406 )>-year: int 
 228420 )>+Date(day: int, month: int, year: int) 
 228422 )>+equals(Date): boolean 
 228422 )>+toString(): String 
}

pgdp.searchengine.pagerepository.Document o-- pgdp.searchengine.pagerepository.Author #testsColor( 228467 ): author
pgdp.searchengine.pagerepository.Review o-left- pgdp.searchengine.pagerepository.Document #testsColor( 228455 ): reviewedDocument
pgdp.searchengine.pagerepository.Review o-- pgdp.searchengine.pagerepository.Author #testsColor( 228455 ): reviewer

pgdp.searchengine.pagerepository.Author o-- pgdp.searchengine.util.Date #testsColor( 228419 ): birthday
pgdp.searchengine.pagerepository.Document o-- pgdp.searchengine.util.Date #testsColor( 228467 ): releaseDate, lastUpdateDate
pgdp.searchengine.pagerepository.Review o-- pgdp.searchengine.util.Date #testsColor( 228455 ): postDate


hide empty fields
hide empty methods

@enduml

Das UML Diagram gibt die geforderten Klassen sowie deren Attribute und Methoden an. Diese müssen wie angegeben implementiert werden. 
Zudem müssen für alle geforderten Attribute Getter implementiert werden. Setter müssen nur für die Attribute implementiert werden, die auch im Nachhinein noch verändert werden können müssen. Ein Autor kann zum Beispiel noch seinen Namen ändern, das Geburtsdatum sollte aber nicht mehr verändert werden können. 
Die Konstruktoren sollen alle Attribute mit sinnvollen Werte initialisieren. Die Objekte der Klassen `Document` und `Review` sollen dabei jeweils aufsteigende IDs haben. Das heißt das erste Dokument, das erstellt wurde, hat die documentId 0, das zweite Dokumet die documentId 1 und das Dokument, das als drittes erstellt wurde, soll eine documentId von 2 haben. Die IDs von den Dokumenten und Reviews sollen dabei  separat  hochgezählt werden.

### Desweiteren sollen folgende Methoden implementiert werden:

Die `equals()` Methode testet jeweils, ob zwei Objekte gleich sind und gibt bei Gleichheit `true` zurück.
- Bei einem Objekt, welches eindeutig durch eine ID identifizierbar ist, reicht es aus die IDs miteinander zu vergleichen, um herauszufinden, ob die Objekte gleich sind.
- Damit zwei Autorobjekte gleich sind, muss sicher gestellt werden, dass der volle Name und das Geburtsdatum von beiden übereinstimmt.
- Beim Datum müsst ihr euch selbst überlegen, was eine sinnvolle Implementierung ist, um eine Gleichheit zu erkennen.

Dann gibt es noch die `toString()` und `toPrintText()` Methoden, welche beide einen String zurückgeben, die das Objekt beschreiben. 
Die `toString()` gibt dabei jeweils eine kurze Beschreibung des Objektes zurück und muss dabei diese Information enthalten:
- Author: Den vollen Namen des Autors
- Document: Den Titel und das Veröffentlichungsdatum sowie eine kurze Beschreibung über den Autor
- Review: Den Titel und das Rating sowie eine kurze Beschreibung des reviewten Dokuments
- Date: Das Datum in Zahlenform, also zum Beispiel 4.2.1337

Die `toPrintText()` gibt in mehreren Zeilen eine ausführlichere Beschreibung der Objekte zurück. Die Informationen sollen in der genannten Reihenfolge im String enthalten sein und jede Information muss dabei in einer einzelnen Zeile stehen.
- Author: Der volle Name des Autors, sein Geburtstag, seine Adresse und die Emailadresse
- Document: Der Titel des Dokumentes, eine kurze Beschreibung des Autors, die Description des Dokumentes und das Datum, an dem es zuletzt verändert wurde
- Review: Eine kurze Beschreibung des reviewten Dokuments, das Rating, den Titel des Reviews, der Inhalt des Reviews, das Veröffentlichungsdatum und eine kurze Beschreibung des Autors vom Review

Zuletzt brauchen wir noch die Methoden `numberOfCreatedDocuments()` und `numberOfCreatedReviews()`, welche zurückgeben, wie viele Dokumente oder Reviews schon erstellt worden sind. Diese Methoden sollen unabhängig von den Objekten sein und auf den jeweiligen Klassen aufgerufen werden können.
 
Die Public Tests in dieser Aufgabe überprüfen dabei nur, ob die geforderte Struktur vorhanden ist.

*Hinweis:* Man kann durch "" \n "" einen Zeilenumbruch in einem String einfügen."
404,Praktikum: Grundlagen der Programmierung WS24/25,14855,W03H03 - What's in the box?,"# What's in the box?
Nach der erfolgreichen Halloweenparty an der PUM sind die Pinguine jetzt etwas in Aufruhr. Einer der Pinguine hat beim Aufräumen eine mysteriöse Box mit unbekanntem Inhalt gefunden. Bisherige Öffnungsversuche blieben erfolglos. Jetzt hat allerdings einer der Bibliothekaruine ein altes staubiges Buch in einer dunklen Ecke der PUM Bib gefunden. In diesem Buch sind Skizzen, die beschreiben, wie man das geheime Passwort zum Öffnen der Box generiert. Dafür zeigt das Buch Anleitungen mit denen man aus den Hinweise und Ausgangswerten, die auf den Seiten der Box eingraviert sind, ein Passwort generieren kann. Da die Pinguine aber noch ganz schön verkatert sind, bitte sie dich um Hilfe die Anweisungen aus dem Buch in Funktionen zu übersetzen, um das geheime Passwort der Box zu knacken.


Die Klasse Mysterybox haben die Pinguine für dich bereits angelegt. Sie repräsentiert die mysteriöse Box. Zusätzlich haben sie bereits angefangen eine Klasse Lockpicker zu schreiben, mit der das Passwort generiert werden kann. Die Methodensignaturen sind dabei bereits vorgegeben.

### Teil 0: Einführung
Mache dich mit den Klassen `MysteryBox` und `Lockpicker` vertraut und sieh dir die Attribute und Methoden an, die sie enthalten. Sieh dir insbesondere die Namen der Attribute von Mysterybox an. Sie geben einen Hinweis auf ihren späteren Verwendungszweck. Zusätzlich wurde auch noch eine Klasse `HelperBook` von einem der Bibliothekaruine bereitgestellt, die nützliche Hilfsmethoden für dich enthält. Am Ende der Problemstellung befinden sich ebenfalls einige Hinweise, die die Pinguine als wichtig erachten. Auch die solltest du dir durchlesen.

### Teil 1: Standardtypen dechiffrieren
- [task][decryptInteger(int): String]( 228504 , 228508 , 228541 , 228543 , 228493 , 228524 )
Implementiere die Methode `decryptInteger(int): String`. Sie erzeugt aus einem gegebenen int einen Teil des Lösungsstrings. Dazu wird der int quadriert und anschließend mit dem int-Hint der Box multipliziert. Dann wird per Division mit Rest der absolute Wert in den Bereich `[0;25]` gebracht. Diese Zahl wird dann in einen Buchstaben umgewandelt wobei A=0, B=1, … (dabei kann dir das HelperBook helfen).

- [task][decryptFloat(float): String]( 228506 , 228502 , 228532 , 228523 , 228533 , 228526 , 228531 , 228529 )
Implementiere die Methode `decryptFloat(float): String`. Sie erzeugt einen Teil des Lösungsstrings, in dem sie den int-Hint auf den gegebenen Float addiert und das Ergebnis mit dem float-Hint multipliziert. Anschließend wird der absolute Wert der Cosinus Funktion davon genommen und auf drei Nachkommanstellen gerundet. Die Zahlen davon bilden dann einen Teil des Lösungsstrings. (hier könnte [Math](https://devdocs.io/openjdk~17/java.base/java/math/package-summary) aus der Java Standardbibliothek hilfreich sein)

- [task][decryptNumericalString(String): String]( 228520 , 228530 , 228515 , 228511 )
Implementiere die Methode `decryptNumericalString(String): String`. Die Methode erhält eine String aus genau 8 Zahlen und teilt diese in 4 einzelne zweistellige Zahlen auf. Jede dieser Zahlenpaare wird dann als Integer interpretiert und auf einen Buchstaben A-Z gemappt (beachte den Wertebereich [0;25]). Anschließend gibt sie alle 4 Buchstaben konkatiniert zurück und bildet so einen Teil des Lösungsstrings. (beachte die Reihenfolge der Zahlenpaare).

### Teil 2: In Standardtypen dechiffrieren
- [task][decryptModular(int, int): float]( 228536 , 228528 , 228513 , 228517 , 228512 )
Implementiere die Methode `decryptModular(int, int): float`. Sie nimmt die zwei Ausgangsinteger von der Box und berechnet daraus einen float, der dann decrypted werden kann. Dabei wird der erste int mit dem float-Hint der Box multipliziert und der zweite durch den Hint dividiert. Zurückgegeben wird dann der Restwert der Division mit Rest von a durch b.

- [task][decryptMinimal(float, float): String]( 228535 , 228538 , 228534 , 228542 , 228521 )
Implementiere die Methode `decryptMinimal(float, float): String`. Die Methode nimmt die zwei Ausgangsfloats der Box und erzeugt daraus einen numerischen String, der dann decrypted werden kann. Dazu berechnet sie die Wurzel des größeren floats und multipliziert den kleineren Float mit dem float-Hint der Box. Anschließend werden beiden Ergebnisse in einen String formattiert, der genau 4 Nachkommastellen hat. Die Methode gibt einen numerischen String aus 8 Zahlen zurück, bestehend aus den ersten vier Nachkommastellen der Wurzel, gefolgt von den ersten 4 des anderen Werts.

- [task][decryptBytepolar(int, byte): int]( 228527 , 228518 , 228522 , 228519 , 228510 , 228514 )
Implementiere die Methode `decryptBytepolar(int, byte): int`. Die Methode gibt eine Integer zurück der anschließend decrypted werden kann. Dazu berechnet sie einen Quotienten. Der Dividend ist gleich dem Produkt der beiden Eingabeparameter. Der Divisor wird bestimmt, indem man den Rest der Divison von Integer durch Byte nimmt, um eine Stelle nach links shiftet und anschließend 1 addiert.

### Teil 3: Knack die Box
[task][solve()]( 228492 , 228486 , 228505 , 228507 , 228495 , 228488 , 228540 , 228501 , 228498 , 228503 , 228509 , 228500 )
Zuletzt soll noch die Methode `solve()` implementiert werden. Sie löst die Box in dem sie die Ausgangswerte der Box in die decrypt-Funktionen steckt und aus den Rückgabeteilen den kompletten Lösungsstring zusammensetzt.
Dabei ist die Struktur des Passworts wie folgt: ""` _ _ `"". Dazu müssen mit den anderen drei Methoden natürlich zuerst die entsprechenden Eingabeparameter aus den Ausgangsparametern der Box berechnet werden.
Zuletzt versucht solve mit dem generierten Passwort dann die Box zu öffnen und gibt true zurück, falls die Box die Lösung akzeptiert und false, falls der String falsch ist zurück.

### Hinweise
- In dieser Aufgabe geht es auch darum sich mit den Dokumentationen der verschiedenen Java Bibliotheken und Standardklassen vertraut zu machen.
- Für sehr viele mathematische Berechnungen bietet die Math Bibliothek Funktionen an, die euch sehr nützlich sein können.
- Für den Umgang mit Strings bietet die Hauptklasse `String` selbst einige nützliche Methode an. Beispielweise die Methode String.format(). Es lohnt sich ein Blick auf die von String.format() verwendete Syntax zu werfen. Damit lassen sich bspw. auch andere Datentypen als Parameter in bestimmte Formatierungen bringen.
- Für das Erstellen eines längeren Strings könnte euch ein StringBuilder nützlich sein. Auch bei diesem lohnt sich ein Blick in die JavaDocs.
- Explizite Casts sind in dieser Aufgabe nicht notwendig und nicht vorgesehen.
- Für Studenten mit Programmiererfahrung: Einige der Teilaufgaben sind zwar mit `if-Statements` lösbar, die gesamte Aufgabe soll aber ohne solche gelöst werden, da es um Bibliotheksfunktionen geht (Kontrollfluss kommt nächste Woche).

### Testbeispiel
Die Werte der Box werden durch einen Zufallsgenerator festgelegt. Mit dem gleichen Seed im Konstruktor hat die Box auch immer die gleichen Werte. Für den `Seed 0` hat die Box beispielsweise folgende Werte:

`Mysterybox {
  intHint=1327362106,
  floatHint=7309.947,
  minimalVal1=8314.578,
  minimalVal2=2406.1233,
  modularVal1=-1690734402,
  modularVal2=-1557280266,
  polarVal1=-1930858313,
  polarVal2=-99,
  pwd='G_70_SRAA'
}`

wobei das Passwort für Testzwecke von der Lösung vorrausberechnet ist. Für Testzwecke findet ihr hier eine Liste mit weiteren Seed-Passwort-Paaren.
- 1 = K\_641_EWAA
- 2 = Y\_995_QZAA
- 3 = E\_145_VQYA
- 4 = Z\_382_HAAA
- 5 = W\_478_DMYA
- 6 = N\_359_NHAA
- 7 = T\_814_DIAA
- 8 = E\_181_SRAA
- 9 = M\_720_CZAA"
404,Praktikum: Grundlagen der Programmierung WS24/25,14920,W03H02 - Testing über Dreiecke,"# Testing über drei Ecken

Die Pinguine sind begeistert von eurer `Vector2D`- und `Rechteck`-Klassen von der letzten Woche. Jedoch wurde den Pinguinen durch die Beschränkung auf Rechtecke ziemlich schnell langweilig. Sie wollen weitere geometrische Figuren erstellen und Eigenschaften dieser berechnen können. Deswegen haben sich einige Pinguine daran gesetzt, Dreiecks-Klassen zu implementieren. Dabei sind aber sehr unterschiedliche Programme entstanden, die auch unterschiedliche Ausgaben produzieren. Die Implementierungen der Pinguine müssen also erst noch getestet werden!

## Das Ziel
Im Template findest du unter `pgdp` die `PinguLib` und `TriangleTest` Klassen. Deine Tests sollst du in `TriangleTest` implementieren. Du sollst in allen anderen Klassen nichts ändern, damit deine Tests getestet werden können.

Unter pdgp.triangles sind vier Klassen gegeben: `Point2D`, `Vector2D`, `Triangle` und `TriangleFactory`.

Die gegebene Implementierung von `Point2D` und `Vector2D` ist bereits korrekt, und du kannst auch davon ausgehen, dass an dieser Klasse nichts verändert wird.

Mit der Klasse `TriangleFactory` werden Dreiecke über die Methode `createTriangle` mit Hilfe von drei 2D-Points erstellt. Nutze dabei immer `getInstance()` um eine Instanz der `TriangleFactory` zu bekommen. Nutze ausschließlich diese Instanz für die Erstellung der Dreiecke und erstelle keine neuen Instanzen der `TriangleFactory`.

In `Triangle` findest du unterschiedliche Methoden, die schon vorimplementiert sind. 

Über diese Methoden erhält man die Vektoren für die Seiten des Dreiecks, den Wert für den Flächeninhalt oder auch, ob es sich um ein gleichschenkliges Dreieck handelt. Du sollst mithilfe von [JUnit5-Tests](https://junit.org/junit5/docs/5.8.1/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html) verschiedene Implementierungen testen und sicherstellen, dass nur vollständig korrekte Versionen all deine Tests bestehen.

## Die Dreiecks-Klasse
 Die Klasse bietet verschiedene Methoden an, um Informationen über das erstellte Dreieck zu erhalten:
- `getAB()`, `getAC()`, `getBC()`: Gibt den Vektor zurück, der die jeweilige Seite des Dreiecks repräsentiert, wobei die Richtung zu berücksichtigen ist. Die Methode `getAB()` soll den Vektor von A zu B zurückgeben. Der Vektor $$\vec{BA}$$ wäre damit falsch.
- `getAngleAtA()`: Gibt den Innenwinkel bei Punkt A (im Bogenmaß) zurück
- `getArea()`: Gibt den Flächeninhalt des Dreiecks zurück.
- `isScalene()`: Gibt zurück, ob das Dreieck ungleichschenklig ist. Ein Dreieck ist genau dann ungleichschenklig, wenn alle drei Seitenlängen unterschiedlich sind. Dies ist gleichbedeutend dazu, dass alle drei Innenwinkel unterschiedlich sind.
- `isIsosceles()`: Gibt zurück, ob das Dreieck gleichschenklig ist. Ein Dreieck ist genau dann gleichschenklig, wenn mind. zwei Seiten gleichlang sind. Dies ist gleichbedeutend dazu, dass mind. zwei Innenwinkel identisch sind.
- `isEquilateral()`: Gibt zurück, ob das Dreieck gleichseitig ist. Ein Dreieck ist genau dann gleichseitig, wenn alle drei Seiten gleichlang sind. Dies ist gleichbedeutend dazu, dass alle drei Winkel identisch sind. Jedes gleichseitige Dreieck ist damit auch gleichschenklig.
- `isValidTriangle()`: Gibt zurück, ob das durch die drei Eckpunkte definierte Dreieck ein gültiges Dreieck ist. Ein Dreieck gilt dann als gültig, wenn die drei Eckpunkte nicht alle auf einer Linie liegen (was insbesondere auch, aber nicht ausschließlich, dann der Fall ist, wenn mindestens zwei Eckpunkte gleich sind).

Es ist möglich, ungültige Dreiecke zu erstellen. Falls ein ungültiges Dreieck mit dem Konstruktor erstellt wird, wird die Ausgabe "" Ungültiges⎵Dreieck! "" auf die Ausgabe geschrieben. 

Bei den Setter-Methoden wird verhindert, dass ein ungültiges Dreieck entsteht, indem die entsprechende `Point2D`-Variable nicht überschrieben wird. In diesem Fall hat der Setter keinen Effekt und die Ausgabe "" Ungültiges⎵Dreieck! "" wird erzeugt.

Da dem Konstruktor bereits erzeugte Punkte als Argumente übergeben werden, können diese auch außerhalb der Klasse `Triangle` geändert werden. Deswegen überprüfen alle Methoden außer den Settern (die das zuvor beschriebene Verhalten an den Tag legen) und der Methode `isValidTriangle()` (die die Gültigkeit ja gerade testet) zu Beginn ihrer Ausführung, ob das durch `this` repräsentierte Objekt ein gültiges Dreieck ist und gib andernfalls die Meldung "" Ungültiges⎵Dreieck! "" aus. 

`Triangle` ist aktuell korrekt implementiert und erfüllt alle obenstehenden Eigenschaften. Du kannst dir also auch den Code dazu ansehen und nachvollziehen. 

## Anforderungen
Die Klassen `Point2D` und `Vector2D` müssen nicht getestet werden. Du kannst davon ausgehen, dass sich die Implementierungen dieser Klassen nicht mehr ändern. Jedoch darfst du ebenfalls nichts an dieser Klasse verändern. Bei der Klasse `Triangle` müssen hingegen **alle** Methoden und auch der Konstruktor getestet werden. Dazu rufst du die zu testende Methoden aus der `Triangle`-Klasse in deinen Tests auf. Momentan enthält diese Klasse zwar eine korrekte Implementierung, wird aber bei den Tests durch falsche Implementierungen ersetzt. Die Methodenköpfe sind weiterhin identisch, sodass du diese ohne Probleme für deine Tests aufrufen kannst. Vertraue jedoch nicht darauf, dass der Methodenkörper ebenfalls der gleiche bleibt.

Bei Variablen des Types `double`, mit denen wir in dieser Aufgabe arbeiten, kann es zu Rundungsfehlern und Ungenauigkeiten kommen. Aus diesem Grund wird bei jedem Vergleich von zwei `doubles` ein `delta`-Parameter verwendet. Dieser gibt an, wie groß die Abweichung vom erwarteten Wert sein darf, damit zwei Werte als gleich angesehen werden. `delta` soll bei allen Vergleichen in dieser Aufgabe $$10^{-12}$$ betragen, in Java geschrieben als `1e-12`, wobei `e` für die Zehnerpotenz und die darauffolgende Zahl für den Exponenten der Zehnerpotenz steht. Die Zahl vor dem `e` ist der Vorfaktor (hier: `1`). 

Bei deinen Tests wirst du vermutlich ebenfalls `double`-Werte vergleichen wollen. Dafür kannst du die Methode `assertEquals(double expected, double actual, double delta)` verwenden. Dabei musst du ein Delta von `1e-12` angeben. Wie du aber schlussendlich den Vergleich von zwei `double`-Werten implementierst, ist deine Entscheidung, solange eine Abweichung von `1e-12` akzeptiert wird.

Für die Setter-Methoden (`setA()`, `setB()` und `setC()`) reicht es **eine** davon zu testen, also z.B. nur `setA()`. Dieser muss dann auf das oben spezifizierte Verhalten getestet werden, du musst aber die Tests auf das Verhalten nicht für `setB()` und `setC()` (sollte `setA()` der Setter deiner Wahl sein) wiederholen, sondern kannst davon ausgehen, das alle Setter immer das gleiche (potentiell falsche, aber dann trotzdem gleiche) Verhalten aufweisen werden.
Das Gleiche gilt für die drei Methoden `getAB()`, `getAC()` und `getBC()`. Auch hier muss nur **eine** getestet werden.

Das Verhalten der Klasse `Triangle` bei `null`-Werten ist nicht definiert und muss daher nicht getestet werden.

- [task][Basics]( 230728 , 230687 , 230732 )
- [task][Struktur Tests]( 230730 , 230734 , 231167 , 231168 , 231169 )
- [task][Korrekte Dreiecke Testen]( 230689 , 230696 , 230748 , 230739 , 230738 )
- [task][Winkel des Dreiecks]( 230742 , 230735 )
- [task][Fläche des Dreiecks]( 230729 , 230695 , 230693 )
- [task][isScalene() Tests]( 230733 , 230737 , 230683 )
- [task][isIsosceles() Tests]( 230691 , 230731 , 230746 , 230681 )
- [task][isEquilateral() Tests]( 230685 , 230744 , 230698 )

## Hinweise 
- Zukünftig werden Leerzeichen bei String-Ausgaben durch ein "" ⎵ "" repräsentiert.
- Die Konsolenausgabe kannst du mit PinguLib.`getConsoleOutput()` bekommen.
- Falls du etwas auf die Konsole ausgeben willst, darfst du ausschließlich die `write()`-Methoden von `PinguLib` benutzen. `System.out` funktioniert in dieser Aufgabe nicht!
- Du darfst eigene Hilfsmethoden und -klassen erstellen.
- Man kann mehrere assert-Statement in einem Test verwenden. Dies sollte man aber nur machen, wenn sie zusammengehörende Dinge testen."
404,Praktikum: Grundlagen der Programmierung WS24/25,14967,W04P01 - Kontrollstrukturen,"# Kontrollstrukturen
Implementiere die folgenden Funktionen in der Datei `ControlStructures.java`!

*Hinweis:* Du kannst das Befehl `System.out.print()` nutzen, um etwas ohne zusätzlichen Zeilenumbruch auf der Konsole auszugeben. Mit `System.out.println()` kann ein Zeilenumbruch ausgegeben werden. Alle Ausgaben sollen auf eine abschließende neue Zeile enden.

## Teil 1
Bevor du mit der Umsetzung einzelnen Teilaufgaben beginnst, mach dir Gedanken über die mögliche Randfälle. Schreibe für die Teilaufgaben 4, 5 und 6 JUnit5-Tests in der dafür vorgesehenen Klasse unter `src/tests/TestCS.java`.  

## Teil 2
### [task][1. Dreiecke aus Sternchen]( 232117 , 232116 , 232109 )
Vervollständige die Methode `printTriangle()` so, dass sie auf der Konsole ein Dreieck aus '*'-Charakteren mit Seitenlänge `sideLength` ausgibt, wie in den Beispielen gezeigt. Wird einen Wert $$ \leq\ 0 $$ übergeben, soll "" Eingabe⎵muss⎵größer⎵als⎵0⎵sein! "" zurückgegeben werden.

#### Beispiele: 
1. Ausgabe für Parameter 0: 
```
Eingabe muss größer als 0 sein!
```
2. Ausgabe für Parameter 1: 
```
*
```
2. Ausgabe für Parameter 3: 
```
***
**
*
```
2. Ausgabe für Parameter 6: 
```
******
*****
****
***
**
*
```

### [task][2. Collatz-Folge]( 232119 , 232112 , 232083 )

Die Collatz-Folge ist eine mathematische Folge, die wie folgt definiert ist:
- Beginne mit irgendeiner natürlichen Zahl $$ n > 0 $$.
- Ist $$ n $$ gerade, so nimm als nächstes $$\frac{n}{2}$$.
- Ist $$ n $$ ungerade, so nimm als nächstes $$ 3 *  n + 1 $$.
- Wiederhole die Vorgehensweise mit der erhaltenen Zahl.

Die bislang unbewiesene Collatz-Vermutung besagt, dass diese Folge für alle natürlichen Zahlen $$ n $$ im Zyklus (4, 2, 1) mündet.

Vervollständige die Methode `printCollatz()` so, dass sie von dem Parameter `n` ausgehende Collatz-Folge berechnet, bis die 1 erreicht wurde. Dein Programm soll alle Zahlen der Folge durch Leerzeichen getrennt auf der Konsole ausgeben. Ist die übergebene Zahl `n` $$ \leq\ 0 $$, soll "" Eingabe⎵muss⎵größer⎵als⎵0⎵sein! "" ausgegeben werden. Zusätzlich soll dein Programm die Länge der Folge mitzählen und abschließend in einer neuen Zeile "" Länge:⎵ "" sowie die Länge der Folge ausgeben.

#### Beispiele

1. Ausgabe für Parameter 0:
```
Eingabe muss größer als 0 sein!
```
2. Ausgabe für Parameter 4:
```
4 2 1
Länge: 3
```
3. Ausgabe für Parameter 11:
```
11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
Länge: 15
```
4. Ausgabe für Parameter 27:
```
27 82 41 124 62 31 94 47 142 71 214 107 322 161 484 242 121 364 182 91 274 137 412 206 103 310 155 466 233 700 350 175 526 263 790 395 1186 593 1780 890 445 1336 668 334 167 502 251 754 377 1132 566 283 850 425 1276 638 319 958 479 1438 719 2158 1079 3238 1619 4858 2429 7288 3644 1822 911 2734 1367 4102 2051 6154 3077 9232 4616 2308 1154 577 1732 866 433 1300 650 325 976 488 244 122 61 184 92 46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1
Länge: 112
```
*Dein Programm soll alle Folgenglieder in einer Zeile ausgeben, die Zeilenumbrüche sind nur der Darstellung halber hier*



### [task][3. 3 und 7]( 232106 , 232125 , 232089 )
Vervollständige die Methode `threeAndSeven()` so, dass diese die Summe aller positiven Zahlen, die durch 3 oder 7 teilbar und kleiner oder gleich einer gegebenen natürlichen Zahl `n` sind, berechnet und ausgibt. Die Methode soll zuerst die Aufforderung "" Bitte⎵Zahl⎵eingeben: "" ausgeben und eine Zahl `n` einlesen. Verwende die Methode `readInt(text)` aus PinguLib zum Einlesen von Nutzereingaben. Gibt der Nutzer dabei eine negative Zahl ein, soll "" Eingabe⎵muss⎵größer⎵oder⎵gleich⎵0⎵sein! "" ausgegeben werden und nichts weiteres ausgegeben werden.


#### Beispiele: 
*Hinweis:* Die Zeilen, die mit `""> ""` beginnen, markieren dabei die Nutzereingaben und werden nicht von dem Programm ausgegeben. Sie dienen nur der besseren Verständlichkeit.
1. Eingabe -3: 
```
Bitte Zahl eingeben:
> -3
Eingabe muss größer oder gleich 0 sein!
```
2. Eingabe 7:
```
Bitte Zahl eingeben:
> 7
16
```

### [task][4. Quersumme]( 232122 , 232095 , 232091 )
Vervollständige die Methode `sumOfDigits()` so, dass diese für eine übergebene Zahl `n` $$ \geq\ 0 $$ die Quersumme zurückgibt. Die Quersumme einer Zahl ist die Summe der Ziffernwerte dieser Zahl. Wird einen Wert $$ < 0 $$ übergeben, soll `-1` zurückgegeben werden.

#### Beispiele:
1. Für Eingabe `-5` soll der Rückgabewert `-1` produziert werden.
2. Für Eingabe `0` soll der Rückgabewert `0` produziert werden.
3. Für Eingabe `15` soll der Rückgabewert `6` produziert werden.


### [task][5. Zahlen Umdrehen]( 232115 , 232084 , 232092 )
Vervollständige die Methode `reverseNumber()` so, dass sie für eine übergebene Zahl $$ 0 \leq\ $$ `n` $$ \leq\ 999$$ $$999$$ $$999$$ umdreht, d.h. es soll die Zahl zurückgegeben werden, die im Dezimalsystem mit genau der gleichen Ziffernfolge, nur im umgekehrter Reihenfolge dargestellt wird. Falls die übergebene Zahl in Nullen endet, sollen diese als führende Ziffern der umgekehrten Zahl weggelasen werden. (z.B. 10 kehrt sich zu 01 um, was 1 entspricht, wenn man die führenden Nullen weglässt.) Wie übergebene Werte außerhalb des gegebenen Bereiches behandelt wird, ist irrelevant. Die Tests überprüfen solche Werte nicht.

#### Beispiele:
1. Für Eingabe `0` soll der Rückgabewert `0` produziert werden.
2. Für Eingabe `4` soll der Rückgabewert `4` produziert werden.
3. Für Eingabe `1002` soll der Rückgabewert `2001` produziert werden.
4. Für Eingabe `1200` soll der Rückgabewert `21` produziert werden.

### [task][6. Palindrome]( 232103 , 232101 , 232124 )
Vervollständigedie Methode `isPalindrome()` so, dass diese `true` zurückgibt, wenn die übergebene Zahl $$ 0 \leq\ $$ `n` $$ \leq\ 999$$ $$999$$ $$999$$ in Dezimaldarstellung ein Palindrom ist und `false`, wenn nicht. Ein Palindrom ist eine Zeichenfolge (hier: Ziffernfolge), die von vorwärts und rückwärts gelesen gleich sind. Wie übergebene Werte außerhalb des gegebenen Bereiches behandelt wird, ist wieder irrelevant.

#### Beispiele:
1. Für folgenden Eingaben soll `true` zurückgegeben werden:  `0`,`1`,`7`,`22`,`5005`,`1_234_554_321`
2. Für folgenden Eingaben soll `false` zurückgegeben werden: `21`,`264`,`5015`,`1_212_121_212`


### [task][7. Pyramide]( 232082 , 232098 , 232087 )
Vervollständige die Methode `printPyramid()` so, dass sie auf der Konsole eine Pyramide aus '*'-Charakteren mit der Höhe `height` ausgibt, wie in den Beispielen gezeigt. Wird einen Wert $$ \leq\ 0 $$ übergeben, soll "" Eingabe⎵muss⎵größer⎵als⎵0⎵sein! "" zurückgegeben werden.

#### Beispiele: 
1. Ausgabe für Parameter 0: 
```
Eingabe muss größer als 0 sein!
```
2. Ausgabe für Parameter 1: 
```
*
```
3. Ausgabe für Parameter 3: 
```
  *
 ***
*****
```
4. Ausgabe für Parameter 6: 
```
     *
    ***
   *****
  *******
 *********
***********
```

### [task][8. Primzahlen]( 232123 , 232794 , 232094 )
Vervollständige die Methode `printPrimesUpTo()` so, dass für eine übergebene Zahl `n` alle Primzahlen kleiner gleich dieser Zahl auf der Konsole - mit je einem Leerzeichen getrennt - ausgegeben werden.

#### Beispiele: 
1. Ausgabe für Parameter 1: (keine Ausgabe)
```
```
2. Ausgabe für Parameter 5:
```
2 3 5 
```
3. Ausgabe für Parameter 100:
```
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
```"
404,Praktikum: Grundlagen der Programmierung WS24/25,14968,W04P02 - Taschenrechner,"# Taschenrechner
Du sollst einen einfachen, konsolenbasierten Taschenrechner implementieren. Dabei soll der Nutzer zuerst nach der Operation gefragt werden, die durchgeführt werden soll. 
Dazu werden die zur Verfügung stehenden Operationen des Taschenrechners `+`,`-`,`*`,`/`, `%` und `Programm beenden` über Zahlen kodiert.
Die Eingabeaufforderung soll wie folgt aussehen:
```
Wählen Sie eine Operation:
1) +
2) -
3) *
4) /
5) %
6) Programm beenden
```

## Teil 1
Bevor du mit der Implementierung des Taschenrechners beginnst, mach dir Gedanken über die mögliche Randfälle!

## Teil 2

Der Nutzer soll anschließend eine ganze Zahl von `1` bis `6` eingeben, um festzulegen, was getan werden soll.
Falls der Nutzer sich für Option `6` entschieden hat, wird das Programm beendet.
Falls er sich für eine Option von `1` bis `5` entschieden hat, werden die beiden ganzzahligen Operanden mit "" Ersten⎵Operanden⎵eingeben: "" und "" Zweiten⎵Operanden⎵eingeben: "" nacheinander vom Nutzer abgefragt.
Das Programm soll dann das Ergebnis der Operation ausgeben (Hier könnte sich ein `switch` lohnen). Anschließend geht es von vorne los und es wird wieder nach der nächsten Operation gefragt.

Überprüfe jeweils, ob versucht wird, durch 0 zu teilen bzw. den Rest bzgl. 0 zu berechnen! Gib dann die Meldung "" Fehler:⎵Division⎵durch⎵0! "" anstelle des Ergebnisses aus.
Wird bei der Frage nach der auszuführenden Operation eine ganze Zahl kleiner als `1` oder größer als `6` eingegeben, so soll diese Eingabeaufforderung wiederholt werden.
Verwende für die Berechnungen die entsprechenden Operatoren auf dem Datentyp `int`.
Du musst keine Sonderbehandlung für einen etwaigen arithmetischen Überlauf implementieren.

### Beispiele:
*Hinweis:* Zur besseren Kenntlichmachung ist in den Beispielen Zeilen, die vom Programm ausgegeben werden, je ein ""<"" vorangestellt. Zeilen mit Nutzereingaben ist ein "">"" vorangestellt. Diese Zeichen gehören nicht zum Programmablauf.

1. [task][Task Short Description]( 232137 )
```
 6
```
2. [task][Addition und Subtraktion]( 232143 )
```
 1
 65
 34
<99
 2
 34
 -12
<46
 6
```
3. [task][Ungültige Auswahl]( 232141 )
```
 7
 6
```
4. [task][Rest]( 232145 )
```
 5
 -11
 3
<-2
 5
 65
 0
 6
```
5. [task][Division]( 232139 )
```
 4
 -34
 5
<-6
 6
```"
404,Praktikum: Grundlagen der Programmierung WS24/25,14969,W04P03 - Kontrollflussdiagramm,"# Kontrollflussdiagramm

Zeichne zu folgendem Programm ein Kontrollflussdiagramm gemäß den Regeln aus der Vorlesung.

```
1   int x, r, n;
2   r = 1;
3   n = 1;
4   x = readInt();
5   while (n <= x) {
6       if (r % 1 == 0) {
7           r = r * n;
8       } else {
9           r = r * (-n);
10          write(r);
11      }
12      n = n + 1;
13  }
14  write(r);
```
*Hinweis:* Dies ist eine Präsenzaufgabe, die im Tutorium besprochen wird. Du kannst Dateien hochladen, aber es erfolgt keine Korrektur.

[w04p03-solution.pdf](/api/core/files/markdown/Markdown_2024-10-30T23-08-14-219_ff3aeace.pdf)"
404,Praktikum: Grundlagen der Programmierung WS24/25,14970,W04H01 - PinguPinguLos II - Angriff der Suchmaschine,"# Suchmaschine, die Zweite

Letzte Woche haben wir die grundlegenden Klassen des Page-Repositorys implementiert. Dazu haben wir noch eine Klasse `Date` erstellt, welche zur Darstellung von Geburts-/Veröffentlichungs-/Änderungsdaten etc. verwendet werden kann. Da wir allerdings noch nicht die notwendigen Werkzeuge erlernt hatten, um nützliche Methoden für diese Klasse zu implementieren, bleibt uns diese Aufgabe für diese Woche.
Erweitere also im Folgenden die Suchmaschine um die in dieser Aufgabe beschriebenen Funktionalitäten. 


#### **Wichtig!**
   - In der ganzen Aufgabe ist das Benutzen der `java.time.*`, `java.util.Calendar`, `java.util.Date` Libraries (oder anderer ähnlicher Bibliotheken, die den von dir zu leistenden Anteil der Implementierung ersetzen) **untersagt**. Wir behalten uns vor, Abgaben, die diesem Kriterium widersprechen, entweder komplett oder einzelne Teilaufgaben davon mit 0 Punkten zu bewerten.
   - Auch wenn es für viele der im Folgenden zu implementierenden Methoden Sinn machen würde, sie als `private` zu kennzeichnen (z.B. da sie nur Hilfsmethoden sind und nicht von außen aus zugegriffen werden müssen), markiere dennoch alle Methoden als `public`, sodass du sie später leichter testen kannst.
   - Du kannst (musst aber nicht) deine Implementierung von letzter Woche weiter verwenden. Stelle aber sicher, dass du eine Version vorliegen hast, die alle Anforderungen von letzter Woche erfüllt. Die Funktionalitäten von letzter Woche werden nicht erneut getestet und bewertet werden. Allerdings könnten einige der neuen Funktionen auf alten aufbauen/diese erweitern. Dann müssen die alten natürlich funktionieren, um korrektes Verhalten der neuen garantieren zu können. Falls du es also vorige Woche nicht geschafft hast, alles zu implementieren bzw. dir unsicher bist, ob dein bisheriger Code korrekt funktioniert, kannst du deine bisherigen Implementierungen mit dem Template dieser Aufgabe abgleichen. 
   - Bevor du eine Methode weiterverwendest, stelle sicher, dass diese für alle Eingaben und Randfälle die richtige Werte zurückgibt. Deine Implementierungen kannst und sollst du auch lokal testen. 


##### [task][Struktur]( 232178 , 232179 , 232177 , 232181 )
Bevor nicht alle Methodensignaturen korrekt implementiert sind (also bevor Namen, Access Modifiers, Parameters, Return Types, etc. stimmen), **wird kein Behavioral Test ausgeführt**. Hinweise zu Fehlern in der Struktur liefern die Structural Tests (beispielsweise gibt ""testTestMethods[Date]"" Hinweise auf Fehler in den Methoden der Klasse Date). Um alle Structural Tests zu bestehen, müssen die Methoden noch keine Funktionalität haben. Es reicht aus, dass sie existieren. 

## Klasse `Date`

Die meisten Änderungen an der Suchmaschine werden diese Woche an der Klasse `Date` stattfinden. Nach Abarbeiten dieser Aufgabe sollte die Klasse `Date` durch beliebigen Code außerhalb der Klasse nicht mehr auf ungültige Daten gesetzt werden können.

 - ### Gültigkeit der Daten
    Als gültige Daten gelten alle nach dem gregorianischen Kalender gültigen Daten, wobei es aber ein Jahr 0 gibt, sodass das Attribut `year` beliebige Werte vom Typen `int` annehmen darf. Dabei hat der Februar in Schaltjahren 29, in allen anderen Jahren 28 Tage. Die Schaltjahre sind alle Jahre, die durch 4, aber nicht durch 100 teilbar sind. Zusätzlich sind alle Jahre, die durch 400 teilbar sind Schaltjahre, auch wenn sie ein Vielfaches von 100 sind.
    
    Implementiere hierzu vier Hilfsmethoden in der Klasse `Date`. Alle vier müssen (und sollen!) nicht von einem konkreten `Date`-Objekt aus aufgerufen werden müssen, da sie nicht von einem konkreten Datum abhängen. Stelle sicher, dass die Modifikatoren der Methoden entsprechend gesetzt sind.
     - [task][Leap Years]( 232188 )
      Die Methode `boolean isLeapYear(int year)` soll den Wahrheitswert zurückgeben, ob das übergebene Jahr ein Schaltjahr ist.
     - [task][Days in Year]( 232187 )
      Die Methode `int daysInYear(int year)` soll die Anzahl an Tagen zurückgeben, die das übergebene Jahr hat.
     - [task][Days in Month]( 232162 )
      Die Methode `int daysInMonth(int month, int year)` soll die Anzahl an Tagen im übergebenen Monat zurückgeben, abhängig von dem übergebenen Jahr.
     - [task][Valid Date]( 232186 )
      Die Methode `boolean isValidDate(int day, int month, int year)` soll überprüfen, ob die übergebenen Parameter ein gültiges Datum bilden.
       
      **Wichtig:** Es soll hier nicht für ein `Date`-Objekt bestimmt werden, ob es gültig ist, sondern ob die Parameter ein gültiges `Date-Objekt` formen könnten.
    
   [task][Date]( 232160 )
    Wir wollen nun sicherstellen, dass nur gültige Daten in die Attribute `day`, `month` und `year` geschrieben werden können. Dies soll der Konstruktor erzwingen. Du sollst ihn so anpassen, dass nur noch oben erlaubte
    Werte für die Attribute gesetzt werden können. Falls der Konstruktor von 'Date' ein ungültiges Datum übergeben bekommt, sollst du das Datum in einen Fehlerzustand setzen, nämlich alle Attribute auf -1, und eine passende Meldung auf der Konsole ausgeben, die das ungültige Datum beinhaltet.
    z.B.:
    "" Der⎵37.3.2021⎵ist⎵kein⎵valides⎵Datum ""
    oder
    "" Der⎵29.2.2022⎵ist⎵kein⎵valides⎵Datum. "".
    Die genaue Formulierung ist nicht weiter wichtig, solange sie das ungültige Datum, das zu erzeugen versucht wurde, im Format
    ""\ . \ . \ "" enthält.

 - ### Zeitspannen zwischen Daten
    Nun wollen wir die Zeitspanne zwischen zwei Daten berechnen können. Je nach Anwendung reicht uns teilweise eine grobe Angabe in (vollen) Jahren vom ersten Datum zum zweiten, teils wollen wir eine genaue Angabe in Tagen haben.

   [task][Days Left & Passed This Year]( 232157 , 232164 )
    Schreibe zuerst aber die zwei Methoden `int daysLeftThisYear()` und `int daysPassedThisYear()`, welche die Anzahl an Tagen ab dem durch `this` beschriebenen bis zum Ende des Jahres (ersteren ausgeschlossen) respektive die Anzahl an Tagen seit Jahresbeginn (den durch `this` beschriebenen eingeschlossen) ermitteln.

    Implementiere nun folgende zwei Methoden und verwende dabei `daysLeftThisYear()` und `daysPassedThisYear()`:
     - [task][Years Until]( 232155 )
        Die Methode `int yearsUntil(Date other)` soll die Anzahl an Jahren zwischen dem Datum, für das sie aufgerufen wird und dem Datum `other` berechnen und zurückgeben. Dabei zählen nur am zweiten Datum abgeschlossene Jahre. Liegt `other` vor `this`, wird in die Negativen gezählt. So beträgt der Abstand
         - vom 03.09.2001 bis zum 02.09.2005 3 Jahre (das vierte ist noch nicht abgeschlossen)
         - vom 03.09.2001 bis zum 03.09.2012 11 Jahre (hier ist das elfte gerade abgeschlossen)
         - vom 20.06.2020 bis zum 19.06.2020 -1 Jahre (alles vor dem ersten Datum zählt als negatives Jahr)
         - vom 20.06.2020 bis zum 08.11.2010 -10 Jahre (das -10te Jahre vor dem 20.06.2020 ist das Jahr vom 20.06.2010 bis zum 19.06.2011)
         - vom 29.02.2016 bis zum 28.02.2017 0 Jahre (auch trotz der Tatsache, dass es keinen 29.02.2017 gibt; erst ab 01.03.2017 gilt das erste Jahr als vergangen)
     - [task][Days Until]( 232154 )
        Die Methode `int daysUntil(Date other)` soll nun die Anzahl an Tagen zwischen den zwei Daten berechnen. Achte dabei auch auf Schaltjahre. Wieder gilt, dass wenn `other` vor `this` liegt, eine negative Zahl zurückgegeben werden soll. D.h.
         - vom 03.09.2001 bis zum 06.09.2001 sind es 3 Tage
         - vom 03.09.2001 bis zum 03.09.2002 365 Tage
         - vom 20.06.2020 bis zum 20.05.2020 -31 Tage
         - vom 20.06.2020 bis zum 20.06.2019 -366 Tage (da hier der 29.02.2020 mit dabei ist)
    
    - [task][Invalid Dates]( 232183 )
    Die vier in diesem Task implementierten Methoden sollen alle Objekt-Methoden sein. Wenn eine der vier Methoden auf einem ungültigen Datum bzw. mit einem ungültigen Datum als Parameter aufgerufen wird, soll eine Fehlermeldung, nämlich "" Methode⎵auf⎵ungültigem⎵Datum⎵aufgerufen! "", auf der Konsole ausgegeben werden. Achte, wie immer, auf Korrektheit des Textes.
         
 - ### Heutiges Datum
    Für viele Anwendungen möchte man das aktuelle Datum ermitteln können. Dieses kann man normalerweise recht leicht mit der Java Standardbibliothek ermitteln. Aber das wäre natürlich witzlos, weswegen du diese nicht verwenden darfst. Die einzige Ausnahme ist die Methode `long System.currentTimeMillis()`, welche die aktuelle (nach Systemzeit) Anzahl an Millisekunden seit Neujahr (also dem 01. Januar um Punkt 00:00 Uhr) 1970 zurückgibt. Diese darfst und sollst du im Folgenden verwenden. Folgende zwei Methoden müssen nicht von einem konkreten `Date`-Objekt aus aufgerufen werden müssen.

     - [task][Millis Since 1970]( 232156 )
        Implementiere die Methode `Date dateMillisecondsAfterNewYear1970(long millis)`, die das Datum `millis` Millisekunden nach Neujahr 1970 berechnet und es als neues `Date`-Objekt zurückgibt. *Tipp*: Die zuvor implementierten Hilfsmethoden kannst du hier wiederverwenden.
     - [task][Today]( 232185 ) 
        Implementiere die Methode `Date today()`, die das (nach der Systemzeit) aktuelle Datum berechnet und es als neues `Date`-Objekt zurückgibt. *Tipp*: Du kannst hierzu obige Methode und die Methode `long System.currentTimeMillis()` verwenden

    
## Klassen `Author`, `Document` und `Review`

Jetzt werden wir noch ein Paar Methoden für die drei Klassen `Author`, `Document` und `Review` schreiben. Stelle also wieder sicher, dass du eine Version der Klassen vorliegen hast, die die Anforderungen der letzten Woche erfüllt.

[task][Author]( 232191 )
Der `Author` soll nun eine neue Methode `int getAge()` bekommen, welche sein Alter in Jahren am heutigen Tage (zumindest nach der Systemzeit) zurückgibt.

[task][Document]( 232184 , 232190 , 232189 )
Dem `Document` sollst du zwei neue Methoden hinzufügen. Eine Methode mit dem Kopf `int yearsSinceRelease()`, welche die Anzahl an Jahren seit der Veröffentlichung ermittelt und eine Methode `int daysSinceLastUpdate()`, welche die Anzahl an Tagen seit dem letzten Update des Dokuments zurückgibt.
In beiden Fällen gilt wieder, dass das heutige Datum das der Systemzeit ist.
 
Außerdem sollst du das `lastUpdateDate` bei jedem Update (d.h. jedem Call eines Setters außer `setLastUpdateDate()`) auf das heutige Datum (nach Systemzeit) setzen.

[task][Review]( 232182 )
Der `Review` sollst du eine Methode `String getAgeText()` hinzufügen, die einen Text zurückgibt, welcher das Alter des Posts in Tagen (nach Systemzeit) enthält. Dieser Text soll von der Form "" Vor⎵ \ ⎵Tagen⎵gepostet "" sein.

Alle Zeitspannen sind wieder wie für `yearsUntil()` und `daysUntil()` beschrieben zu implementieren. D.h. ein am 03.09.2001 erstelltes Dokument soll, wenn die Systemzeit auf den 02.09.2005 eingestellt ist, 3 Jahre alt sein, wenn die Systemzeit auf den 03.09.2012 eingestellt ist, 11 Jahre usw."
404,Praktikum: Grundlagen der Programmierung WS24/25,14971,W04H03 - PinguMath,"# PinguMath

Unsere Freunde von der PUM kennen wir bereits aus der P-Aufgabe über die Verhaltensforschung an Hunden. Nun möchte die Universität ihr Forschungsgebiet im Bereich der Mathematik ausweiten. Dazu benötigen sie eine Erweiterung ihrer Forschungs-Libraries. 
- ***WICHTIG:*** In der gesamten Aufgabe sind die Signaturen der Methoden im Template vorgegeben und dürfen nicht verändert werden! 
- ***WICHTIG:*** In der gesamten Aufgabe ist es nur erlaubt Libraries aus `java.util` und `java.lang` zu importieren exklusive der `java.lang.Math` und `java.lang.StrictMath` Library. Sollten andere Libraries oder die `Math` Library genutzt werden, wird die Aufgabe mit 0P bewertet.
 
- Im Template findest du die zwei Klassen `src/tests/TestNC.java` und `src/tests/TestSAT.java`, wo du JUnit5-Tests schreiben kannst, um deine Implementierung zu testen. Deine Tests in dieser Klassen werden **nicht** bewertet.

## Number Base Conversion

Seit die Pinguine mit uns Menschen in Kontakt getreten sind, haben sie von uns das Dezimal-System beigebracht bekommen. Die Pinguine selbst zählen normalerweise in Pingu-Zahlen. Da diese aber für uns zu schwer zu verstehen sind, benötigen die Pinguine nun ein Programm, das Pingu-Zahlen in Dezimal-Zahlen und umgekehrt umrechnen kann. Deine Aufgabe ist es nun diese zwei Algorithmen zu implementieren. Unten findest du eine Beschreibung, wie sich Pingu-Zahlen in Dezimal-Zahlen umrechnen lassen:

### Pingu-Zahlen

-	Im Gegensatz zu Dezimal-Zahlen (Basis: 10) sind Pingu-Zahlen ein Ternärsystem (d.h. Basis: 3)
-	Eine Zahl kann im Dezimalsystem wie folgt dargestellt werden:  $$ D = d_n ... d_1 d_0 = \sum_{i=0}^{n} d_i \cdot 10^{i} \text{ mit } d_i \in \{0, ..., 9\} $$. (Die $$ d_i $$ entsprechen dabei den entsprechenden Dezimalstellen.)
-	Vergleichen wir dies nun mit einer Zahl im Ternärsystem: $$ T = t_m ... t_1 t_0 = \sum_{i=0}^{m} t_i \cdot 3^{i} \text{ mit } t_i \in \{0, 1, 2\} $$
-	Zwei Zahlen $$ 14_{(10)} $$ und $$ 112_{(3)} $$ sehen also völlig unterschiedlich aus, repräsentieren aber tatsächlich den selben Wert: $$ 14_{(10)} = 112_{(3)} $$, nämlich die Zahl, die wir im Deutschen als ""vierzehn"" bezeichnen (wobei dieses Wort natürlich bereits an das Dezimalsystem angelehnt ist)
-	Der einzige Unterschied zwischen herkömmlichen Ternär-Zahlen und unseren Pingu-Zahlen besteht darin, dass Pinguine keine arabischen Ziffern (0-2) kennen. Daher nutzen sie die Silben des Wortes ‚Pinguin‘ die Übersetzung gestaltet sich nach der einfachen Abbildung: `pin <-> 2, gu <-> 1, in <-> 0`
-	Die Pinguine haben sich jedoch einen kleinen Twist einfallen lassen. Jede Pingu-Zahl beginnt nämlich mit einem Großbuchstaben und alle folgenden Buchstaben werden klein geschrieben. (Die zuvor erwähnte Abbildung verzichtet auf die Unterscheidung von Groß- und Kleinbuchstaben, die Silben sind nämlich klein geschrieben und daher keine *echten* Pingu-Zahlen.)
-	Hier findest du eine Tabelle mit Beispielen, die dir dabei helfen, die Umrechnung besser nachvollziehen zu können (Tipp: wir haben auch ein paar Sonderfälle abgebildet, die für das Testen deiner Implementierung hilfreich sein könnten.): 
 
 Pingu-Zahl Ternärsystem Dezimalsystem 
 In 0 0 
 Gu 1 1 
 Pin 2 2 
 Pinguin 210 21 
 Gugupin 112 14 
 Gupinpinguin 12210 156 
 


### Nun deine Aufgaben für den Converter
1. [task][intToPinguNum]( 232215 , 232212 )
In der Klasse `NumberConverter` findest du die Methode `intToPinguNum`. Diese soll die übergebene Dezimal-Zahl in eine Pingu-Zahl umrechnen und diese als String zurückgeben. Beachte dabei genau die zuvor beschriebenen Kriterien. **Wichtig:** Achte auch darauf, dass unsere Pinguine keine negativen Zahlen kennen, d.h. wird der Methode eine strikt negative Zahl übergeben, wird der String „ Not Defined “ zurückgegeben. **Hinweis:** Natürlich suchen die Pinguine nach der kürzesten Darstellungsform, d.h. die Pinguzahl soll keine führenden Nullen enthalten um potenziell endlose Strings zu vermeiden.

2. [task][pinguNumToInt]( 232214 , 232213 )
In der Klasse `NumberConverter` findest du die Methode `pinguNumToInt`. Diese soll die übergebene Pingu-Zahl in eine Dezimal-Zahl umrechnen und diese als Ganzzahl zurückgeben. Du kannst davon ausgehen, dass die eingegebene Pingu-Zahl immer in einem Integer gespeichert werden kann. Mache dir also keine Gedanken über Overflows. Wichtig ist aber, dass bei einer Eingabe, die **KEINE** echte Pingu-Zahl ist (z.B. „ 123 “, „ Abc “, „ pingu “, etc.), immer der Default-Wert `-1` zurückgegeben wird. Hier ist ein erneuter Blick auf die Beschreibung zu den Pingu-Zahlen hilfreich. Findest du noch weitere fehlerhafte Eingaben? 
 Hinweis:   Für diese Aufgabe können dir folgende Methoden der Klasse `String` helfen, noch mehr dazu kannst du in den JavaDocs nachschlagen. ([String](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html)):
```java
 String str = ""Some String Here"";
 int l = str.length(); // length() gibt die Länge des Strings zurück -> l = 16
 char c = str.charAt(2); // charAt(i) gibt den char an Index i (wobei bei 0 begonnen wird) zurück -> c = 'm'
 String subStr = str.substring(1, 4) // substring(beginIndex, endIndex) gibt den Substring beginnend mit dem char an Stelle 'beginIndex' bis zum char an Stelle 'endIndex zurück' ('beginIndex' inklusive, aber 'endIndex' exklusive) -> subStr = ""ome""
```
 

## Sequence Analysis Tool (SAT)
Dank unseres Zahlen-Converters können die Pinguine nun gemeinsam mit uns über die faszinierende Welt der Mathematik philosophieren. Bei einem Kaffee-/Fisch-Kränzchen sind sie auf Zahlenfolgen aufmerksam geworden. Sie interessieren sich nun für ein Programm, das ihnen dabei hilft, eine Zahl auf Zugehörigkeit zu bestimmten Zahlenfolgen zu überprüfen. Hilfsbereit wie du bist, bietest du ihnen an, solch ein Tool zu implementieren.

***Hinweis 1:*** In dieser Aufgabe können auch kleinere Eingaben schnell zu Overflows führen. Du musst dir keine Gedanken darüber machen außer wir weisen direkt darauf hin. Die Tests sind so gestaltet, dass keine Overflows eintreten bzw. das Programm erwartungsgemäß terminiert, wenn alle Edge Cases beachtet wurden und du den Anweisungen in der Angabe folgst. Um dir die Sicherheit zu geben, dass deine Implementierung effizient genug ist, findest du unter jeder Aufgabe einen Wertebereich für die Eingabe(n) die korrekt und effizient ($$\Delta t < 1s$$) berechnet werden können müssen. Die Referenz hierfür sind die Artemisserver, diese sind in der Regel etwas langsamer als dein PC/Laptop. Mit den richtigen Tests werden die Methoden aber auch auf High-End PCs merkbar länger brauchen als gefordert.

***Hinweis 2:*** In der Klasse SAT findest du die Methode `checkSpecial`. Diese wendet alle von dir implementierten Methoden für die Eingabe an und gibt dir einen formatierten String der Ergebnisse zurück. Die Methode soll eine Hilfestellung bei der Implementierung und dem Testen sein. 

***Hinweis 3:*** In der Gesamten Aufgabe ist es nur erlaubt Libraries aus `java.util` und `java.lang` zu importieren exklusive der `java.lang.Math` und `java.lang.StrictMath` Library. Sollten andere Libraries oder die `Math` Library genutzt werden, wird die Aufgabe mit 0P bewertet.

1. [task][isPow]( 232195 , 232200 )
Die Methode isPow soll untersuchen, ob es für die Parameter `n` und `i` eine strikt positive Basis $$x \in \mathbb{N}^{+} $$ gibt, so dass gilt: $$ x^{i} = n $$. Existiert solch ein $$x$$, geben wir `true` zurück, ansonsten `false`. Die Methode behandelt nur nicht negative `i`, d.h. sollte `i` dieses Kriterium nicht erfüllen, wird der Default-Wert `false` zurückgegeben. Für diese Aufgabe reicht eine (naive) iterative Implementierung aus. Damit du diese umsetzen kannst, **ohne** die Potenzfunktion aus der Java eigenen Bibliothek importieren zu müssen, findest du im Template die Funktion `pow`. Nutze diese Methode, um die Potenz zu berechnen : $$ pow(a, b) = a^{b} $$  
Hier ein Beispiel: Seien $$i = 3$$ und $$n = 8$$. `isPow(3, 8)` gibt `true` zurück, da $$ x^{i} = 2^{3} = 8 = n $$. Somit existiert ein strikt positives $$x=2$$. 
Eingaben mit $$n \leq 10^9$$ und $$i \leq 10$$ müssen korrekt und effizient behandelt werden.

2. [task][isCentralBin]( 232193 , 232198 )
Die Methode `isCentralBin` soll untersuchen, ob die Eingabe `n` eine Zahl aus der Folge der [mittleren Binomialkoeffizienten](https://de.wikipedia.org/wiki/Mittlerer_Binomialkoeffizient) ist. Ist dies der Fall, gibt die Methode `true` zurück, ansonsten `false`.  
Der $$i$$-te mittlere Binomialkoeffizient $$b_i$$ für eine nichtnegative ganze Zahl $$i$$ ($$i \in \mathbb{N}_0$$) ist definiert als: $$b_i = \binom{2i}{i}$$.
Um einen Binomialkoeffizienten $$\binom{n}{k}$$ zu berechnen, musst du die Hilfsmethode `binom(n, k)` implementieren. Die Definition des Binomialkoeffizienten $$\binom{2i}{i} = \frac{(2i)!}{(i!)^{2}}$$ aus Wikipedia wird dir jedoch **nicht** ausreichen, um die Tests zu bestehen. Wir müssen daher von folgender Gleichung Gebrauch machen: $$\binom{n}{k+1} = \frac{n-k}{k+1} \cdot \binom{n}{k}$$. Gemeinsam mit dem Wissen, dass $$\binom{n}{0} = \binom{n}{n} = 1$$, lässt sich daraus schnell ein effizientes iteratives Verfahren zur Berechnung des Binomialkoeffizienten bestimmen, welches deutlich weniger anfällig gegenüber Overflows ist.  
Als kleine Hilfe: Die ersten mittleren Binomialkoeffizienten (und damit die Eingaben, für die die Methode `true` zurück geben muss) sind: $$1, 2, 6, 20, 70, 252, 924, …$$ 
Eingaben mit $$n \leq 10^{17}$$ müssen korrekt und effizient behandelt werden.

3. [task][isJacobsthal]( 232194 , 232202 , 232216 )
In der Methode `isJacobsthal` untersuchen wir, ob die Eingabe `n` eine Jacobsthal-Zahl ist. Ist dies der Fall, gibt die Methode `true` zurück, ansonsten `false`. 
Die Jacobsthal Zahlen sind wie folgt definiert: 
$$ J_i = \begin{cases} 0, & \text{wenn } i = 0 \\ 1, & \text{wenn } i = 1 \\ 2 \cdot J_{i-2}+J_{i-1}, & \text{wenn } i > 1\end{cases}$$
- Die ersten Jacobsthal Zahlen sind:  $$0, 1, 1, 3, 5, 11, 21, ...$$ 
Eingaben mit $$n \leq 10^{15}$$ müssen korrekt und effizient behandelt werden.

4. [task][isLucasLikeSequence]( 232217 , 232218 , 232192 )
Mit deiner Implementierung zu den Jacobsthal Zahlen hast du das Interesse der Pinguine geweckt. Du klärst sie darüber auf, dass die Jacobsthal Zahlen im Allgemeinen als Lucas-Folge betrachtet werden können. Wir haben jedoch gelernt, dass Pinguine keine negativen Zahlen kennen. Daher diskutierst du mit ihnen nur über eine Teilmenge der Lucas-Folgen. Wir beschränken uns nämlich nur auf monoton steigende Folgen (im Folgenden genannt Lucas-Like-Folge).

- Eine Lucas-Like-Folge ist wie folgt definiert:
$$ L_i (x_0, x_1, a, b) = \begin{cases}x_0, & \text{wenn } i = 0\\ x_1, & \text{wenn } i = 1\\ a \cdot L_{i-2} + b \cdot L_{i-1}, & \text{wenn } i > 1 \end{cases} $$
$$\text{mit } x_0, x_1, a, b \in \mathbb{N}_0$$


- Implementiere nun die Methode `isLucasLikeSequence`. Die übergebenen Parameter (`x0`, `x1`, `a`, `b`, `n`) sind die notwendigen Variablen entsprechend der Definition der Lucas-Like-Folge. `n` ist die Zahl, die untersucht werden soll, ob sie Teil der Folge $$ L (x_0, x_1, a, b) $$ ist. Ist dies der Fall, gibt die Methode `true` zurück, ansonsten `false`. 
Man sieht schnell, dass man mit dieser Methode viele bekannte Folgen, wie z.B. die Fibonacci-Zahlen, testen kann: $$F_i = L_i (0, 1, 1, 1) $$  
***Hinweis:*** Dir fällt hoffentlich auf, dass die Implementierung sehr ähnlich zu der der vorherigen Teilaufgabe ist. Achte aber darauf, dass sich durch die Verallgemeinerung ein kleiner neuer Edge Case ergibt. 
Eingaben mit $$x_0, x_1, a, b \leq 10^3$$ und $$n \leq 10^{15}$$ müssen korrekt und effizient behandelt werden.

Viel Erfolg!"
404,Praktikum: Grundlagen der Programmierung WS24/25,14988,W04H02 - Number Detective,"## Number Detective 🐧💭🔢


Nach einem stressigen Monat an der PUM haben die Pinguine beschlossen, dass es an der Zeit ist, sich ein wenig zu entspannen und Spaß zu haben. Sie sind auf die Idee gekommen, ein lustiges Zahlenratespiel zu entwickeln, doch sie sind gerade nicht erfahren im Programmieren. Deshalb bitten sie dich um Unterstützung, um das Spiel zu implementieren.


In diesem Spiel hat der Spieler zu Beginn 3 Leben. Ziel des Spiels ist es, eine zufällig generierte Zahl  zu erraten und Punkte sammeln. Der Spieler kann zwischen drei Schwierigkeitsgraden wählen. Je nachdem wird die gesuchte Zahl innerhalb eines bestimmten Bereichs liegen, und er erhält eine festgelegte Anzahl an Versuchen. Der Schwierigkeitsgrad beeinflusst auch, wie viele Punkte und Leben der Spieler für das richtige Raten der Zahl erhält.


 
 
   Zahl Anzahl Versuche Gewinn 
 Einfach [0;100) 8 +200 Punkte 
 Mittel [0;500) 10 +200 Punkte +1 Leben 
 Schwer [0;1000) 10 +500 Punkte +3 Leben 
 
 
Der Spieler erhält nach jedem Versuch immer Hinweise, ob die gesuchte Zahl höher oder niedriger als seine Eingabe ist. Wenn der Spieler die geheime Zahl nicht innerhalb der verfügbaren Versuche findet, verliert er ein Leben. Wenn der Spieler alle Leben verloren hat, wird das Spiel beendet.  


### Allgemeine Hinweise
- Um zufällige Zahlen zu generieren, musst du die schon implementierte Klasse `/src/pgdp/RandomNumberGenerator.java` und deren `generate(int upperBound)`-Methode benutzen. Diese Methode nimmt einen Parameter `upperBound` $$ >0 $$ entgegen und generiert eine Zahl im Intervall [0;`upperBound`).
An dieser Klasse darfst du nichts ändern.
- Zum Testen deiner Implementierung kannst du Seeds nutzen. Bei gleichem Seed und gleicher Reihenfolge der Aufrufe sind auch die zurückgegebenen Zufallszahlen identisch. **Den Seed sollst du nur zum Testen verwenden, nicht aber für die finale Abgabe.**
- Zum Einlesen von Nutzereingaben verwende die `readInt()`-Methode aus der Klasse `/src/pgdp/InputReader.java`. Du kannst davon ausgehen, dass der Spieler nur Ganzzahlen eingeben wird.
- Die Verwendung privater Hilfsmethoden und Hilfsvariablen ist erlaubt. Die `guessTheNumber()`-Methode muss aber ohne zusätzliche Aufrufe funktionieren. Außerdem gilt zu beachten, dass die Tests mehrere Methodenaufrufe hintereinander ausführen und statische Hilfsvariablen dazwischen nicht zurückgesetzt werden.
- In der Aufgabenstellung wird in jedem String das Zeichen ⎵ verwendet, um Leerzeichen zu kennzeichnen. Ersetze sie dann später im Code durch ein richtiges Leerzeichen.




### Guess The Number
Deine Aufgabe ist es, die Methode `guessTheNumber()` in der Klasse `/src/pgdp/game/GuessTheNumber.java` zu implementieren.


#### [task][Spielstart & Ende]( 232433 , 232440 , 232436 , 232441 , 232437 )
Wenn ein Nutzer das Spiel startet, wird er auf der Konsole mit "" Hello,⎵Number⎵Detective! "" begrüßt. Anschließend hat er die Möglichkeit, einen Schwierigkeitsgrad auszuwählen. Dazu wird ihm seinen aktuellen Lebens- und Punktestand ("" You⎵have⎵ \ ⎵lives⎵and⎵ \ ⎵points. "") angezeigt, gefolgt von einer Liste von möglicher Eingaben:
```
Choose⎵difficulty⎵level⎵to⎵start⎵a⎵new⎵game:
(1)⎵Easy⎵⎵⎵[0;100)⎵⎵⎵8⎵Attempts,⎵Reward:⎵+200⎵Points
(2)⎵Medium⎵[0;500)⎵⎵10⎵Attempts,⎵Reward:⎵+200⎵Points⎵+1⎵Life
(3)⎵Hard⎵⎵⎵[0;1000)⎵10⎵Attempts,⎵Reward:⎵+500⎵Points⎵+3⎵Lives
(4)⎵Exit
```
*Hinweis:* `printMenu()`-Methode!


Gibt der Spieler eine Zahl ein, die nicht zu den möglichen Optionen gehört, wird die Fehlermeldung "" This⎵was⎵not⎵a⎵valid⎵choice,⎵please⎵try⎵again. "" ausgegeben, und das Programm wartet erneut auf eine Eingabe, bis der Spieler eine gültige Option wählt. Falls der Spieler die vierte Option wählt, um das Spiel zu verlassen, wird auf der Konsole die Nachricht  Goodbye!  ausgegeben. 
  
Sobald das Spiel endet, entweder durch das Verlassen des Spiels oder durch das Aufbrauchen aller Leben, wird dem Spieler sein finaler Punktestand angezeigt: "" You⎵are⎵leaving⎵with⎵ \ ⎵points! ""


#### [task][Spielablauf]( 232434 , 232431 , 232432 , 232449 , 232446 , 232444 , 232447 , 232443 , 232435 , 232438 , 232439 )
Basierend auf der Auswahl des Schwierigkeitsgrads wird dann eine zufällige Zahl generiert und der Spieler hat eine festgelegte Anzahl an Versuchen, um die Zahl zu erraten. Vor jedem Versuch wird angezeigt, wie vielte der aktuelle Versuch ist: "" ( \ / \ )⎵Enter⎵your⎵guess: "", wobei X die aktuelle Versuchsnummer und Y die maximale Anzahl der Versuche ist. Dann wird eine Eingabe vom Spieler erwartet. Nach jeder Eingabe erfährt der Spieler, ob die gesuchte Zahl höher ("" The⎵number⎵is⎵higher. "") oder niedriger ("" The⎵number⎵is⎵lower. "") als seine Eingabe ist.


Wenn der Spieler die richtige Zahl errät, wird die Runde mit der Erfolgsmeldung "" Congrats!⎵You⎵guessed⎵the⎵correct⎵number. "" abgeschlossen, und er erhält die entsprechenden Preise. Sollte der Spieler alle Versuche aufgebraucht haben, ohne die richtige Zahl zu erraten, wird die gesuchte Zahl angezeigt ("" Sorry,⎵you've⎵used⎵all⎵attempts.⎵The⎵correct⎵number⎵was⎵ \ . "") und er verliert ein Leben. Falls der Spieler keine Leben mehr hat, wird er mit der Nachricht "" Game⎵over!⎵You⎵are⎵out⎵of⎵lives. "" darüber informiert, dass das Spiel beendet ist.


Hat der Spieler jedoch noch Leben übrig, wird ihm sein aktueller Punktestand und Lebensstand angezeigt, gefolgt vom Menü, damit er einen neuen Schwierigkeitsgrad auswählen kann, um eine neue Runde zu starten.


#### Hinweis
Sollte der Spieler im letzten Versuch angekommen sein, hat er, sofern er genügend Punkte hat, die Möglichkeit, für 600 Punkte einen speziellen Hinweis zu kaufen, der ihm verrät, ob die gesuchte Zahl gerade oder ungerade ist. Vor dem letzten Versuch wird der Spieler gefragt: "" LAST⎵ATTEMPT!⎵Do⎵you⎵want⎵to⎵buy⎵a⎵hint⎵for⎵600⎵points?⎵(1)⎵yes⎵(2)⎵no "". Sollte der Spieler eine andere Eingabe machen, wird ihm die Fehlermeldung "" This⎵was⎵not⎵a⎵valid⎵choice,⎵please⎵try⎵again. "" angezeigt, und das Programm wartet auf eine gültige Eingabe. Wenn der Spieler den Hinweis kauft, wird eine der folgenden Meldungen ausgegeben: "" The⎵number⎵is⎵even! "" oder "" The⎵number⎵is⎵odd! "". Dann wird der Spieler aufgefordert, seine letzte Schätzung abzugeben.


###### [task][Beispiel]( 232448 )
 
   Beispiel mit Seed 1304 (zum Ausklappen hier klicken) 
 
Hello, Number Detective!
You have 3 lives and 0 points.
Choose difficulty level to start a new game:
(1) Easy   [0;100)   8 Attempts, Reward: +200 Points
(2) Medium [0;500)  10 Attempts, Reward: +200 Points +1 Life
(3) Hard   [0;1000) 10 Attempts, Reward: +500 Points +3 Lives
(4) Exit
5
This was not a valid choice, please try again.
1
(1/8) Enter your guess:
50
The number is higher.
(2/8) Enter your guess:
75
The number is higher.
(3/8) Enter your guess:
77
Congrats! You guessed the correct number.
You have 3 lives and 200 points.
Choose difficulty level to start a new game:
(1) Easy   [0;100)   8 Attempts, Reward: +200 Points
(2) Medium [0;500)  10 Attempts, Reward: +200 Points +1 Life
(3) Hard   [0;1000) 10 Attempts, Reward: +500 Points +3 Lives
(4) Exit
2
(1/10) Enter your guess:
250
The number is higher.
(2/10) Enter your guess:
472
Congrats! You guessed the correct number.
You have 4 lives and 400 points.
Choose difficulty level to start a new game:
(1) Easy   [0;100)   8 Attempts, Reward: +200 Points
(2) Medium [0;500)  10 Attempts, Reward: +200 Points +1 Life
(3) Hard   [0;1000) 10 Attempts, Reward: +500 Points +3 Lives
(4) Exit
3
(1/10) Enter your guess:
585
Congrats! You guessed the correct number.
You have 7 lives and 900 points.
Choose difficulty level to start a new game:
(1) Easy   [0;100)   8 Attempts, Reward: +200 Points
(2) Medium [0;500)  10 Attempts, Reward: +200 Points +1 Life
(3) Hard   [0;1000) 10 Attempts, Reward: +500 Points +3 Lives
(4) Exit
1
(1/8) Enter your guess:
50
The number is lower.
(2/8) Enter your guess:
5
The number is higher.
(3/8) Enter your guess:
30
The number is lower.
(4/8) Enter your guess:
20
The number is lower.
(5/8) Enter your guess:
7
The number is higher.
(6/8) Enter your guess:
8723
The number is lower.
(7/8) Enter your guess:
-5
The number is higher.
LAST ATTEMPT! Do you want to buy a hint for 600 points? (1) yes (2) no
1
The number is even!
(8/8) Enter your guess:
10
Sorry, you've used all attempts. The correct number was 14.
You have 6 lives and 300 points.
Choose difficulty level to start a new game:
(1) Easy   [0;100)   8 Attempts, Reward: +200 Points
(2) Medium [0;500)  10 Attempts, Reward: +200 Points +1 Life
(3) Hard   [0;1000) 10 Attempts, Reward: +500 Points +3 Lives
(4) Exit
4
Goodbye!
You are leaving with 300 points!
 
 
 

#### [task][Games]( 232442 , 232445 )
Nun wird alles zusammengetestet. Diese Tests simulieren vollständige Spielsitzungen. Um diese Tests zu bestehen, müssen alle Teile des Spiels korrekt zusammenarbeiten. Vergiss nicht: Du kannst deine Implementierung testen, indem du die main-Methode ausführst. So kannst du eventuelle Probleme in deiner Implementierung einfach beim Spielen des Spiels entdecken!"
404,Praktikum: Grundlagen der Programmierung WS24/25,15062,W05H02 - Schiffe versenken,"# Schiffe versenken

Die drei Entdeckuine Antonia, Christian und Jonas sind schon lange auf der Suche nach dem Zepter der Unterwerfung. 
Jedoch ist die Eiswüste sehr eintönig und sie wollen sich abends mit einem Spiel ablenken. 
Dabei fällt Christian ein Spiel aus seiner Kindheit ein. Robben ... ähh ... Schiffe versenken. 
Er hat euch auch schon etwas vorbereitet. 
Ihr sollt ihm nun dabei helfen, das Spiel fertig zu programmieren.

## Aufbau
In dieser Aufgabe sollst du ein Programm schreiben, mit dem man ""Schiffe versenken"" gegen den Computer spielen kann. 
Der Spielablauf ist dabei wie folgt: Das Spielfeld besteht aus zwei 8x8 Feldern. 
Auf dem linken Feld befinden sich deine eigenen Schiffe, während auf dem rechten Spielfeld sich die feindlichen Schiffe befinden, die für den Spieler nicht sichtbar sind. 
Es gibt 1 Schiff der Länge 4, 2 Schiffe der Länge 3 und 3 Schiffe der Länge 2.
Die Schiffe dürfen sich nicht direkt berühren, über Eck ist aber erlaubt.
Der Spieler kann nun eines der Felder aussuchen, um darauf zu schießen. 
Befindet sich dort ein feindliches Schiff, wird das Feld als Treffer markiert, andernfalls als Fehlwurf. 
Sobald alle feindlichen Schiffe getroffen wurden, gewinnt der Spieler. 
Falls der Computer zuerst alle Schiffe des Spielers erwischt, gewinnt natürlich der Computer.

Im Programm wird das Spielfeld als zweidimensionales `int`-Array repräsentiert, wobei der erste Index die Zeile angibt und der zweite Index die Spalte, gezählt von links oben. 
Das Feld `[0][0]` ist die linke obere Ecke, das Feld `[1][0]` befindet sich darunter und `[0][1]` rechts daneben. 
An jeder Position im Array steht eine Zahl, die angibt, was sich am jeweiligen Punkt befindet: 0 steht für Wasser, 1 für ein noch nicht entdecktes Schiff, 2 für einen Fehlschuss und 3 für einen Treffer. 
Dem Spieler gegenüber werden die Zeilen mit den Ziffern 1-8 und die Spalten mit den Buchstaben a-h nummeriert. 

## **Wichtige Hinweise:**
1. In den 3 Klassen `AI`, `Battleship` und `Player` sind bereits alle benötigten Methodenköpfe vorgegeben. Du musst also keine neuen erstellen.
2. Einige der Hilfsmethoden sind bereits für dich vorgefertigt.
3. Du findest in allen Klassen ganz oben einige String-Konstanten. Diese kannst du verwenden, damit du dich beim Konsolenoutput nicht vertippst.
4. Die AI-Klasse darfst du beliebig anpassen, solange du die vorhandenen Methodenköpfe nicht löschst.
5. Im Code findest du den Teilaufgaben entsprechend `TODO`-Kommentare.
6. Die ersten 4 Teilaufgaben sind Hilfsmethoden und sollen mit Schiffen beliebiger Länge klarkommen können.

## Aufgabe

Die Aufgabe ist in kleinere Methoden aufgeteilt. 
Du kannst davon ausgehen, dass die Attribute und Parameter vom Typ `int[][]` immer quadratisch, nicht `null` sind und die Größe 8 haben.

1. [task][Spielfelder ausgeben]( 235406 , 235404 )
In der Klasse `Battleship` ist bereits der Kopf der `printBoard()`-Methode vorgegeben. 
Du sollst diese nun vervollständigen. 
Das `playerBoard` soll dabei links und das `aiBoard` rechts ausgegeben werden. 
Um das zu erreichen, müssen wir durch beide Boards zeilenweise durchgehen und folgendes ausgeben. 
Ganz oben findest du einen dazu passenden `String`, damit du es nicht selber abtippen musst. 
Die `\t` sorgen dafür, dass es auf der Konsole schöner aussieht.
    - "" Your⎵Board:\t\t\tAI⎵Board: ""
    - "" +⎵a⎵b⎵c⎵d⎵e⎵f⎵g⎵h\t\t+⎵a⎵b⎵c⎵d⎵e⎵f⎵g⎵h ""
    - Nun soll für jede Zeile des Bretts erst die aktuelle Zeilennummer (wir fangen bei 1 an zu zählen!) gefolgt von der aktuellen Zeile des `playerBoard`s ausgegeben werden. Dann "" \t\t "" gefolgt von der aktuellen Zeilennummer. Den Abschluss der aktuelle Zeile bildet dann die Zeile des `aiBoard`s. 
    - Bei beiden Boards soll Wasser durch "" ⎵⎵ "", ein getroffenes Schiff durch "" ⎵x "" und ein Fehlschuss durch "" ⎵o "" dargestellt werden. Zudem werden die unentdeckten Schiffe des Spielers durch "" ⎵■ "" und die unentdeckten Schiffe des Computers durch "" ⎵⎵ "" (also gleich wie Wasser) dargestellt. Auch dafür findest du die passenden `String`s oben in der Klasse.

 So könnte beispielsweise eine Ausgabe aussehen: 
 
 
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1 ■ ■ ■          		1                
2           o    		2         o      
3       ■        		3                
4       x       o		4             x  
5       x        		5     o       x  
6       ■     ■ ■		6             x  
7   o            		7             o  
8                		8                
 
 
 

2. [task][Test auf Ende]( 235403 )
Die Methode `shipsLeft()` prüft, ob das übergebene Spielfeld noch verdeckte Schiffe enthält. 
Enthält das übergebene Feld keine verdeckten Schiffe, soll `false` zurückgegeben werden, andernfalls `true`.

Die nächsten Aufgaben sind in der `Player`-Klasse

3. [task][Platziere das Schiff 1]( 235411 )
Die Methode `setShip()` bekommt 4 `int`s übergeben. 
Die ersten beiden sind die Reihe und Spalte der ersten Koordinate, die letzten beiden sind die Reihe und Spalte der zweiten Koordinate. 
Du kannst davon ausgehen, dass die erste Koordinate in beide Dimensionen kleiner-gleich der zweiten Koordinate ist und sich die Koordinaten in einer Linie (horizontal oder vertikal) befinden. 
Deine Aufgabe ist nun die Felder zwischen den beiden Koordinaten (inklusive) auf ein verdecktes Schiff zu setzen.

4. [task][Platziere das Schiff 2]( 235410 , 235409 )
Die Methode `placeShip()` bekommt eine Länge und eine Nachricht übergeben. 
Das Ziel ist, Platz für ein Schiff der übergebenen Länge zu finden und es dort zu platzieren.
Die Länge darf dabei beliebig sein, ist aber garantiert kleiner-gleich 8.
Die folgenden Schritte sollen solange wiederholt ausgeführt werden, bis eine geeignete Stelle gefunden wurde:
    - Gibt auf der Konsole die übergebene Nachricht aus.
    - Lese nacheinander 2 Koordinaten ein. Frage dabei jeweils zuerst nach der Zeilen-Nummer gefolgt von dem Spalten-Buchstaben (du findest weiter unten in der Klasse geeignete Hilfsmethoden, die eine Zahl zwischen 1 und 8 bzw. einen Buchstaben zwischen a und h einlesen und jeweils eine Zahl zwischen 0 und 7 zurückgeben). Beide Koordinaten sollen im Folgenden als inklusive Grenzen verwendet werden.
    - Die Koordinaten müssen in einer Linie liegen (entweder horizontal oder vertikal), müssen so weit auseinander sein, wie das Schiff lang ist und die erste Koordinate muss kleiner-gleich der zweiten Koordinate sein. Ein Beispiel für valide Koordinaten für ein Schiff der Länge 3 wäre `(1, 3)` und `(1, 5)`. Ein Beispiel für falsche Koordinaten wäre `(6, 1)` und `(3, 2)`, da die erste Koordinate größer als die zweite ist, die Distanz für das gegebene Schiff zu groß ist und die beiden Koordinaten weder horizontal noch vertikal in einer Linie sind.
    - Falls die Koordinaten diese Eigenschaften erfüllen, musst du als nächstes noch überprüfen, ob das neue Schiff eines der bereits existierenden Schiffe berühren würde. Du kannst jede Position zwischen den Koordinaten und die Koordinaten selbst mit einer bereits implementieren Methode überprüfen.
    - Falls die Koordinaten auch diese Überprüfung erfüllt haben, kannst du sie mit der `setShip()`-Methode auf dem Board platzieren und das aktuelle Board mit der Methode aus `Battleship` auf der Konsole ausgeben.
    - Falls die Korrdinaten irgendeine der Bedingungen nicht erfüllen, soll die Fehlernachricht "" There⎵is⎵a⎵problem⎵with⎵your⎵coordinates.⎵Try⎵again! "" auf der Konsole ausgegeben werden und die Methode beginnt von vorne.

 So könnte beispielsweise ein Ablauf für ein Schiff der Länge 3 mit der übergebenen Nachricht `PLACE_LENGTH_3` aussehen: 
 
 
Place a ship of length 3.
Enter number coordinate:
> 7
Enter letter coordinate:
> b
Enter number coordinate:
> 4
Enter letter coordinate:
> c
There is a problem with your coordinates. Try again!
Place a ship of length 3.
Enter number coordinate:
> 2
Enter letter coordinate:
> d
Enter number coordinate:
> 2
Enter letter coordinate:
> f
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1                		1                
2       ■ ■ ■    		2                
3                		3                
4                		4                
5                		5                
6                		6                
7                		7                
8                		8                
 
 
Die Zeilen, die mit `""> ""` beginnen, markieren dabei die Nutzereingaben und werden nicht von dem Programm ausgegeben. Sie dienen nur der besseren Verständlichkeit.

 

5. [task][Erstelle das Spielfeld]( 235408 )
Nun geht es darum, das komplette Spielfeld zu erstellen.
Initialisiere dafür das `board` mit der geeigneten Größe und platziere 1 Schiff der Länge 4, 2 Schiffe der Länge 3 und 3 Schiffe der Länge 2 auf dem Spielfeld (die passende Methode hast du bereits erstellt). Bei den Schiffen der verschiedenen Längen sollen folgende Nachrichten übergeben werden:
    - 4: "" Place⎵a⎵ship⎵of⎵length⎵4.⎵Enter⎵the⎵coordinates⎵of⎵both⎵ends. ""
    - 3: "" Place⎵a⎵ship⎵of⎵length⎵3. ""
    - 2: "" Place⎵a⎵ship⎵of⎵length⎵2. ""

6. [task][Das Spiel spielen]( 235414 )
Nachdem wir das Spielfeld erstellt haben, geht es nun darum, einen Spielzug durchzuführen.
Als Parameter wird das aktuelle `aiBoard` des Computers übergeben.
Dazu sollen so lange die folgenden Schritte ausgeführt werden, bis eine valide Koordinate eingegeben wurde:
    - Zunächst wird wie zuvor eine Reihen-Nummer und ein Spalten-Buchstabe eingelesen.
    - Falls das Feld bereits beschossen wurde (egal ob getroffen oder nicht), soll "" Field⎵is⎵already⎵hit! "" ausgegeben werden und die Methode beginnt von vorne.
    - Ansonsten befindet sich auf dem Feld entweder Wasser oder ein verdecktes Schiff. Falls Wasser getroffen wurde, soll "" You⎵missed.⎵Better⎵luck⎵next⎵time! "" ausgegeben und `false` zurückgegeben werden. Falls ein verdecktes Schiff getroffen wurde, soll "" You⎵hit⎵it! "" ausgegeben und `true` zurückgegeben werden. In beiden Fällen wird der Wert des Feldes auf den entsprechenden Wert gesetzt.

7. [task][Das Spiel vollenden]( 235413 , 235412 )
Zu guter Letzt muss jetzt nur noch die `game()` Methode in `Battleship` implementiert werden.
Diese soll die folgenden Schritte durchführen:
    - Zuerst soll auf der Konsole "" Welcome⎵to⎵Battleships "" ausgegeben werden.
    - Als nächstes soll ein komplett leeres Spielfeld ausgegeben werden.
    - Danach soll der `player` aufgefordert werden, das `playerBoard` zu initialisieren.
    - Nun soll "" Let's⎵start⎵the⎵game! "" ausgegeben werden und das eigentliche Spiel kann beginnen.
        - Das Spiel läuft solange, bis einer der beiden (`ai` oder `player`) keine Schiffe mehr übrig hat.
        - Beginnend mit dem `player` sollen die beiden abwechselnd spielen. 
        - Falls der aktuelle Spieler getroffen hat, darf er nochmal schießen.
        - Der aktuelle Spieler darf so oft hintereinander schießen, bis er nicht mehr trifft.
        - Falls nicht, ist der andere Spieler dran.
        - Nach jedem Schuss soll einmal das Spielfeld ausgegeben werden.
        - Falls der `player` es schafft, als erster alle Schiffe der `ai` zu treffen, soll "" Congrats!⎵You⎵won! "" ausgegeben werden und das Spiel beendet werden.
        - Falls die `ai` es schafft, als erster alle Schiffe des `player`s zu treffen, soll "" Too⎵bad,⎵you⎵lost! "" ausgegeben werden und das Spiel beendet werden.  
    
    Die Tests testen einmal ein Spiel, in dem der Spieler gewinnt, und ein Spiel, in dem der Computer gewinnt.

 Hier ist ein Beispielablauf des gesamten Spiels. Um es kurz und übersichtlich zu halten, wurden einige Spielrunden entfernt. Die Lücken sind durch zwei Reihen von ""-----"" gekennzeichnet. 
 
 
Welcome to Battleships
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1                		1                
2                		2                
3                		3                
4                		4                
5                		5                
6                		6                
7                		7                
8                		8                
Place a ship of length 4. Enter the coordinates of both ends.
Enter number coordinate:
> 2
Enter letter coordinate:
> b
Enter number coordinate:
> 2
Enter letter coordinate:
> e
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1                		1                
2   ■ ■ ■ ■      		2                
3                		3                
4                		4                
5                		5                
6                		6                
7                		7                
8                		8                
Place a ship of length 3.
Enter number coordinate:
> 3
Enter letter coordinate:
> g
Enter number coordinate:
> 5
Enter letter coordinate:
> g
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1                		1                
2   ■ ■ ■ ■      		2                
3             ■  		3                
4             ■  		4                
5             ■  		5                
6                		6                
7                		7                
8                		8                
--------------------------------------------------------
--------------------------------------------------------
Place a ship of length 2.
Enter number coordinate:
> 1
Enter letter coordinate:
> h
Enter number coordinate:
> 2
Enter letter coordinate:
> h
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1               ■		1                
2   ■ ■ ■ ■     ■		2                
3             ■  		3                
4     ■ ■     ■  		4                
5             ■  		5                
6   ■            		6                
7   ■     ■ ■    		7                
8   ■            		8                
Let's start the game!
Enter number coordinate:
> 4
Enter letter coordinate:
> d
You missed. Better luck next time!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1               ■		1                
2   ■ ■ ■ ■     ■		2                
3             ■  		3                
4     ■ ■     ■  		4       o        
5             ■  		5                
6   ■            		6                
7   ■     ■ ■    		7                
8   ■            		8                
The AI shoots at 2f and missed!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1               ■		1                
2   ■ ■ ■ ■ o   ■		2                
3             ■  		3                
4     ■ ■     ■  		4       o        
5             ■  		5                
6   ■            		6                
7   ■     ■ ■    		7                
8   ■            		8                
--------------------------------------------------------
--------------------------------------------------------
Enter number coordinate:
> 4
Enter letter coordinate:
> h
You hit it!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1               ■		1                
2   ■ ■ ■ ■ o   ■		2                
3           o ■  		3                
4     ■ ■     ■  		4   o   o   o   x
5             ■  		5                
6   ■            		6                
7   ■     ■ ■   o		7                
8   ■            		8                
Enter number coordinate:
> 3
Enter letter coordinate:
> h
You missed. Better luck next time!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1               ■		1                
2   ■ ■ ■ ■ o   ■		2                
3           o ■  		3               o
4     ■ ■     ■  		4   o   o   o   x
5             ■  		5                
6   ■            		6                
7   ■     ■ ■   o		7                
8   ■            		8                
The AI shoots at 8a and missed!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1               ■		1                
2   ■ ■ ■ ■ o   ■		2                
3           o ■  		3               o
4     ■ ■     ■  		4   o   o   o   x
5             ■  		5                
6   ■            		6                
7   ■     ■ ■   o		7                
8 o ■            		8                
Enter number coordinate:
> 5
Enter letter coordinate:
> h
You hit it!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1               ■		1                
2   ■ ■ ■ ■ o   ■		2                
3           o ■  		3               o
4     ■ ■     ■  		4   o   o   o   x
5             ■  		5               x
6   ■            		6                
7   ■     ■ ■   o		7                
8 o ■            		8                
Enter number coordinate:
> 6
Enter letter coordinate:
> h
You missed. Better luck next time!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1               ■		1                
2   ■ ■ ■ ■ o   ■		2                
3           o ■  		3               o
4     ■ ■     ■  		4   o   o   o   x
5             ■  		5               x
6   ■            		6               o
7   ■     ■ ■   o		7                
8 o ■            		8                
--------------------------------------------------------
--------------------------------------------------------
The AI shoots at 3c and missed!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1   o   o o o   x		1           o   x
2   x x ■ x o   x		2 o x x x o o o x
3     o o   o ■ o		3 o   o   o   o o
4 o   ■ ■   o ■  		4   o   o   o   x
5     o o   o x  		5 x x x x o   o x
6 o ■       o   o		6         x x x o
7   ■ o   ■ x   o		7 o   o   o o    
8 o ■     o o   o		8   o   o   o    
Enter number coordinate:
> 8
Enter letter coordinate:
> h
You hit it!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1   o   o o o   x		1           o   x
2   x x ■ x o   x		2 o x x x o o o x
3     o o   o ■ o		3 o   o   o   o o
4 o   ■ ■   o ■  		4   o   o   o   x
5     o o   o x  		5 x x x x o   o x
6 o ■       o   o		6         x x x o
7   ■ o   ■ x   o		7 o   o   o o    
8 o ■     o o   o		8   o   o   o   x
Enter number coordinate:
> 8
Enter letter coordinate:
> g
You hit it!
Your Board:			AI Board:
+ a b c d e f g h		+ a b c d e f g h
1   o   o o o   x		1           o   x
2   x x ■ x o   x		2 o x x x o o o x
3     o o   o ■ o		3 o   o   o   o o
4 o   ■ ■   o ■  		4   o   o   o   x
5     o o   o x  		5 x x x x o   o x
6 o ■       o   o		6         x x x o
7   ■ o   ■ x   o		7 o   o   o o    
8 o ■     o o   o		8   o   o   o x x
Congrats! You won!
 

Die Zeilen, die mit `""> ""` beginnen, markieren dabei die Nutzereingaben und werden nicht von dem Programm ausgegeben. Sie dienen nur der besseren Verständlichkeit."
404,Praktikum: Grundlagen der Programmierung WS24/25,15063,W05H03 - To Infinity And Beyond,"# To Infinity And Beyond

Die 3 Entdeckuine sind schon eine sehr lange Zeit unterwegs. 
Eines Tages erleben sie eine sternenklare Nacht, was wegen der Schneestürme nur selten passiert. 
Sie fragen sich, wie viele Sterne es im Universum gibt.
Sie fangen an zu zählen und stellen fest, dass sie schnell bei der Grenze der durch `long` darstellbaren Zahlen ankommen werden.
Auf einmal taucht ein Entdeckuin einer anderen Kolonie aus der Dunkelheit auf.
Er heißt Florian.
Die 3 begrüßen ihn und bieten ihm an sich zu ihnen zu setzen.
Sie erzählen ihm von deren Problem mit der begrenzten Darstellbarkeit von Zahlen.
Florian fällt ein, dass er schonmal etwas von der sagenumwobenen Datenstruktur `BigInteger` gehört hat und meint, dass man diese doch einfach nehmen könnte.
Den anderen gefällt die Idee sehr, nur gibt es ein Problem: 
Sie haben schon angefangen zu zählen und einen `long` dafür verwendet, welches aber die `BigInteger`-Klasse nicht unterstützt.
Deswegen brauchen sie deine Hilfe, eine eigene `BigInteger`-Datenstruktur zu implementieren. 
Da sie nur positive Zahlen benötigen, haben sie sich dazu entschieden, die Klasse `BigUInt` zu nennen (Big unsigned Integer).
Die Entdeckuine haben dir schon einiges an Arbeit abgenommen und viele Methoden bereits implementiert.

## How to arbeiten mit großen Zahlen

Falls du dich mit den verschiedenen Darstellungsformen von Zahlen auskennst und auch bitweise Operatoren kein Fremdwort für dich sind, kannst du folgenden Teil überspringen und direkt mit der Aufgabe starten.
Um die Erklärungen möglichst übersichtlich zu halten, wird alles anhand von 8-Bit-großen Zahlen erklärt.
Das Prinzip lässt sich aber auch auf beliebige andere Zahlen anwenden.
1. Zahlendarstellung: Es gibt verschieden Zahlensysteme, die ihre Darstellung auf ihre jeweilige Basis zurückführen. Du benutzt bereits ganz normal im Alltag das Dezimalsystem, welches die Zahlen mit der Basis 10 darstellt. Die Zahl $$123$$ lässt sich als $$1 \cdot 10^2 + 2 \cdot 10^1 + 3 \cdot 10^0$$ darstellen. Ebenso gibt es auch die in der Informatik weit verbreiteten Binär- und Hexadezimalsysteme (Basis 2 bzw. Basis 16). Da uns in $$Base_{16}$$ weitere Ziffern fehlen, wird hier mit Buchstaben weitergemacht. $$A$$ enspricht $$10$$, $$B$$ entspricht $$11$$ usw. bishin zu $$F$$, was $$15$$ entspricht. Zahlen lassen sich ganz einfach von einem Zahlensystem in ein anderes umrechnen. Beispielsweise wird die Zahl $$123$$ in $$Base_{16}$$ als $$7 \cdot 16^1 + 11 \cdot 16^0 = 7B$$ dargestellt. Die Umrechnung zwischen $$Base_{2}$$ und $$Base_{16}$$ ist sogar deutlich einfacher, da eine Ziffer in $$Base_{16}$$ exakt 4 Ziffern in $$Base_{2}$$ entspricht. Ziffern in $$Base_{2}$$ werden auch als Bits bezeichnet. Zahlen des Hexadezimalsystems bekommen üblicherweise den Präfix `0x` (bspw. `0x7B`), während Binärzahlen den Präfix `0b` bekommen (bspw. `0b1011`).
2. Bitweise Operatoren: Es gibt eine Reihe von bitweisen Operatoren, allerdings benötigst du für die Aufgabe nur den ""`<<`""-, ""`>>`""-/""`>>>`""-, ""`|`""- und ggf. den ""`&`""-Operator.  
    - ""`<<`"": Das ist der sog. Links-Shift-Operator. Er sorgt dafür, dass alle Bits einer Zahl um $$x$$ nach links verschoben werden. Das entspricht einer Multiplikation mit der $$Basis^x$$. Betrachte dazu folgendes Beispiel: $$0b00110110 << 2 = 0b11011000$$. Hier wurde jedes Bit um 2 Stellen verschoben, was einer Multiplikation der Zahl um den Faktor $$2^2$$ entspricht.
    - ""`>>`""/""`>>>`"": Das ist der sog. Rechts-Shift-Operator. Er funktioniert fast genau so wie ""`<<`"", aber mit dem kleinen Unterschied, dass er die einzelnen Bits nach rechts verschiebt. Dazu gibt es noch einen Unterschied, ob man ""`>>`"" oder ""`>>>`"" benutzt. Ersterer sorgt dafür, dass von links dasselbe Bit reingeschoben wird, wie das linkeste Bit in der ursprünglichen Zahl. Letzterer sorgt dafür, dass in jedem Fall eine `0` reingeschoben wird. Betrachte dazu folgende Beispiele: $$0b11001001 >> 2 = 0b11110010$$, während $$0b11001001 >>> 2 = 0b00110010$$. Da wir in dieser Aufgabe jede Bitfolge als positive Zahl (unsigned) interpretieren, solltest du immer ""`>>>`"" benutzen. Andernfalls kann es zu nervigen Bugs kommen, die nur schwer zu finden sind.
    - ""`|`"": Das ist das sog. bitweise Oder. Dieser Operator sorgt dafür, dass von beiden Zahlen alle `1`er-Bits übernommen werden. Dabei ist es egal, in welchem Operand das Bit auf `1` gesetzt ist. Betrachte dazu folgendes Beispiel: $$0b10101100\ |\ 0b01101001 = 0b11101101$$. Dieser Operator ist also hervorragend dazu geeignet, disjunkte Zahlenteile zu vereinen: $$0b11010000\ |\ 0b00001011 = 0b11011011$$.
    - ""`&`"": Der sog. bitweise Und Operator funktioniert ähnlich zu ""`|`"", mit einem kleinen Unterschied. Er sorgt dafür, dass im Ergebnis nur eine `1` steht, wenn in beiden Operanden am selben Bit eine `1` steht. Betrachte dazu folgendes Beispiel: $$0b10101100\ \&\ 0b1101001 = 0b10001000$$. Dieser Operator ist also hervorragend dazu geeignet, bestimmte Zahlenteile zu filtern: $$0b10101100\ \&\ 0b00001111 = 0b00001100$$. Hier wird nur die untere Hälfte übernommen.
3. Overflow, Carry und Borrow: Bei sämtlichen Rechenoperationen kann das Ergebnis zu groß (bzw. im negativen Bereich zu klein) werden. Bei der Addition kann das Ergebnis bspw. 1 Ziffer größer werden (Carry, im Deutschen auch Übertrag genannt), bei der Multiplikation kann sich die Länge des Ergebnisses aus der Summe der Längen der beiden Operanden ergeben (Overflow) und bei der Subtraktion kann es passieren, dass der 2. Operand größer als der 1. Operand ist, sodass ein Borrow benötigt wird. Ein Carry und auch ein Borrow sind quasi nichts anderes als ein Overflow mit dem Wert 1. Um diese Fehler aufzufangen, müssen wir uns darum kümmern, dass wir diesen Overflow/Carry/Borrow nicht verlieren, da sich sonst unser Gesamtergebnis ändert. Mehr dazu dann aber in der Aufgabe.
4. least- bzw. most-significant: In der Aufgabe wird immer wieder von den beiden Begriffen die Rede sein. Sie beschreiben bei einer Zahl die niedrigst- und höchstwertigste Stelle (least- und most-significant). Die niedrigstwertigste Stelle der Zahl $$123$$ wäre die `3`, während `1` die höchstewertigste Stelle ist.

## Aufgabe

Unsere `BigUInt`s basieren auf dem `long`-Array `digits`. 
Dabei stellt jedes `long` einen Block aus 64 Bit unserer Zahl dar.
Der least-significant Block steht am Index `0` und der most-significant Block am Index `digits.length - 1`.
Übertragen auf das Dezimalsystem, wo beispielsweise 2 Ziffern einen einzelnen Block bilden, wäre die Zahl $$12345$$ im Array also $$[45, 23, 01]$$.
Diese umgedrehte Reihenfolge erleichtert uns später die Umsetzung der Rechenoperationen.
Für sich ergeben die einzelnen Blöcke wenig Sinn und müssen zusammen als Ganzes interpretiert werden.
Somit ist es möglich beliebig große Zahlen darzustellen.
Der limitierende Faktor ist der Arbeitsspeicher.

Da die Division zu komplex ist, haben die 3 Entdeckuine das schon für dich übernommen.
Deine Aufgabe ist es nun, die Methoden zum Addieren, Subtrahieren, Multiplizieren und Exponenzieren zu implementieren.
Dazu aber erst einmal ein paar allgemeine Hinweise:
- Lass dich nicht durch die Größe des Templates verunsichern. Es ist bereits einiges implementiert, um dir die Arbeit zu erleichtern.
- Benutze keine Funktionen der `java.math`-Library!
- In der Klasse `Main` findest du eine `main()`-Methode, mit der du deine Implementierung testen kannst. Hier darfst du auch gerne Elemente der `java.math`-Library benutzen, da `Main` von Artemis nicht getestet wird.
- Unsere `BigUInt`s sind immutable. Das bedeutet, dass bei jeder Rechenoperation ein neuer `BigUInt` zurückgegeben wird.
- Es gibt 4 bereits implementierte Konstruktoren, die einen neuen `BigUInt` initialisieren. Der Konstruktor mit dem `String`-Parameter wird erst funktionieren, sobald du `add()` und `mul()` korrekt implementiert hast.
- Ebenso gibt es 3 bereits implementierte `toString()`-Methoden. Allerdings wird `toDecimalString()` erst funktionieren, wenn du `sub()` und `mul()` korrekt implementiert hast. Die anderen beiden kannst du von Anfang an zum Debuggen benutzen.
- Außerdem gibt es noch eine ganze Reihe von Hilfsmethoden. Bis auf `trim()` findest du sie alle ganz unten in der Klasse.
- Da wir in der ganzen Aufgabe ohne negative Zahlen arbeiten, werden die normalen Vergleichsoperatoren ""`<`"", ""`<=`"", ""`>`"" und ""`>=`"" nicht funktionieren. Stattdessen sollst du die Methode `Long.compareUnsigned` verwenden, welche 2 `long`s annimmt und eine Zahl größer `0` zurückgibt, falls der erste Parameter größer ist, eine Zahl kleiner `0` zurückgibt, falls der zweite Parameter größer ist, oder `0` zurückgibt, falls beide Zahlen gleich sind.
- Ganz oben stehen einige `BigUInt`-Konstanten, die dir bei den Methoden helfen könnten.
- Verändere keine der Methodensignaturen!
- Du kannst davon ausgehen, dass die Parameter stets nicht `null` sind und die `BigUInts` valide sind.
- Die folgenden Teilaufgaben sind eine Möglichkeit, wie man es umsetzen könnte. Solange am Ende das erwartete Ergebnis jeder Methode vorliegt, darfst du auch gerne Alternativen ausprobieren.

### Addieren

Starten wir mit der `add()`-Methode. Diese besteht aus 2 Teilaufgaben.

1. [task][safeAdd]( 235421 , 235423 )
Da wir mit `long`s arbeiten, kann es passieren, dass es zu unbemerkten Overflows kommt, auch bei der Addition.
Das Ergebnis der Addition ist maximal 1 Bit größer als die Länge des größeren Operanden, mindestens aber genauso groß.
Bei der Addition von 2 `long`-Variablen kann also eine Zahl mit 65 Bit entstehen.
Deswegen kümmern wir uns zuerst darum, dass wir 2 `long`-Variablen sicher addieren können.
Der Trick besteht darin, jede Variable in 2 Hälften zu teilen, beide jeweils 32 Bit groß.
Um die jeweilige Hälfte zu bekommen, kannst du die beiden Hilfsmethoden `low()` und `high()` benutzen.  
    - Nun können wir die unteren beiden Hälften addieren. Da beide Zahlen nur 32 Bit groß sind, passt das Ergebnis garantiert in 33 Bit und somit wieder in einen `long`. In der unteren Hälfte finden wir nun unser richtiges Ergebnis, in der oberen Hälfte den Übertrag, der bei der Addition eventuell entstanden ist.
    - Nach demselben Prinzip addieren wir nun die oberen beiden Hälften.
    - Jetzt müssen wir noch das Endergebnis richtig zusammenbauen. Der Übertrag der ersten Addition wird auf das Ergebnis der zweiten Addition addiert (auch hier könnten die beiden Hilfsmethoden nützlich sein, um den jeweiligen Zahlenteil zu erhalten). Der Übertrag der zweiten Addition wird zusammen mit dem Endergebnis zurückgegeben. Um die beiden Teilergebnisse richtig zusammenzubauen, muss das Ergebnis der zweiten Addition wieder zurück in die obere Hälfte geschoben werden (Stichwort Links-Shift). Als nächstes können beide Hälften durch Addition einfach verrechnet werden.
    - Zum Schluss sollst du ein Array mit dem Gesamtergebnis und dem zweiten Übertrag zurückgeben. Das Ergebnis soll bei Index 0 sein, der Übertrag bei Index 1.

    Letztendlich schaut es also so aus:  
        - $$Result_{low} = a_{low} + b_{low}$$  
        - $$Result_{high} = a_{high} + b_{high} + carry_{low}$$  
        - $$Carry = carry_{high}$$  
    $$carry_{low}$$ und $$carry_{high}$$ beschreiben hier die beiden Überträge, die bei der Addition der beiden Hälften (low und high) entstanden sind. Hier ist noch ein Beispiel mit 4-Bit-großen Zahlen in binär: $$0111 + 1011$$. Zuerst werden die beiden unteren Hälften addiert: $$11 + 11 = 0110$$, wobei wir hier zum Teilergebnis $$10$$ ein Carry haben. Danach folgt die zweite Addition (inklusive dem Carry): $$01 + 10 + 01 = 0100$$, wobei wir hier ebenfalls zum Ergebnis $$00$$ ein Carry haben. Nun bauen wir unser Array aus Ergebnis und Carry zusammen, also $$[0010, 0001]$$.

2. [task][add]( 235422 , 235427 )
Diese Hilfsmethode können wir nun dazu benutzen, um die beiden `long`-Arrays zu addieren. 
Du kannst davon ausgehen, dass die Länge des ersten Arrays größer-gleich der Länge des zweiten Arrays ist.
Da wir hier nur addieren, ist die Länge des Ergebnis-Arrays maximal 1 größer als die Länge des größeren Eingabe-Arrays, mindestens aber gleich lang.
Falls du dir schwer tust, überlege dir, wie du mit der Schulmethode auf Papier 2 Zahlen miteinander Ziffer für Ziffer addieren würdest.
Eine Ziffer auf dem Papier entspricht dann einem Block unserer Arrays.
Nun beginnen wir mit der Addition:
    - Gehe dafür beide Arrays von vorne nach hinten durch (least-significant zu most-significant) und addiere die beiden aktuellen Blöcke mit der zuvor implementierten Hilfsmethode.
    - Denk immer daran, dass du aus der Addition des vorherigen Blocks einen Übertrag bekommen könntest, der natürlich ebenfalls verrechnet werden muss.
    - Nachdem du das Ende des kürzeren Arrays erreicht hast, muss der Rest vom größeren Array nur noch mit dem Übertrag verrechnet werden.
    - Falls ganz zum Schluss immer noch ein Übertrag übrig bleibt, wird der in den Block ganz hinten im Ergebnis-Array geschrieben.

    Letztendlich schaut das Prinzip so aus:  
        - $$Result_i = a_i + b_i + carry_{i-1}$$  
    Hier bezieht sich das `i` auf den aktuellen Index im Array. Das Carry kommt somit aus der Rechnung des vorherigen Blocks, falls dieses zu groß geworden ist. Bei der allerersten Iteration (Index 0) gibt es natürlich noch kein Carry aus der vorherigen Rechnung, also ist $$carry_{-1} = 0$$.

### Subtrahieren

Nun geht es weiter mit der Subtraktion. Diese ist sogar etwas einfacher als die Addition.

3. [task][sub]( 235426 , 235425 )
Bei der Subtraktion von 2 `long`-Arrays kannst du davon ausgehen, dass der Wert des ersten Parameters größer-gleich dem Wert des zweiten Parameters ist (die Fehlerbehandlung findet bereits in der Wrapper-Methode drüber statt).
Das Ergebnis der Subtraktion ist maximal so groß wie die Länge des ersten Arrays.
Falls du dir schwer tust, überlege dir, wie du mit der Schulmethode auf Papier 2 Zahlen miteinander Ziffer für Ziffer subtrahieren würdest.
Eine Ziffer auf dem Papier entspricht dann einem Block unserer Arrays.
Du brauchst dir keine Sorgen machen, falls einer oder beide Blöcke oder das Ergebnis ""negativ"" sind.
Du kannst hier ganz normal Minus rechnen.
Nur beim Vergleich musst du aufpassen, dass du wie oben erwähnt `Long.compareUnsigned()` verwendest anstatt ""`<`"", ""`<=`"", ""`>`"" oder ""`>=`"".
Nun beginnen wir mit der Subtraktion:
    - Ähnlich wie bei der Addition iterieren wir von vorne nach hinten (least-significant zu most-significant) durch die beiden Arrays durch.
    - Anstatt einem Übertrag haben wir jetzt einen sogenannten Borrow. Wenn der aktuelle Block des ersten Arrays kleiner als der aktuelle Block des zweiten Arrays ist, müssen wir beim nächsten Iterationsschritt zusätzlich 1 abziehen. Denk daran diesen eventuellen Borrow bei deiner Überprüfung zu berücksichtigen!
    - Nachdem wir das Ende des zweiten Arrays erreicht haben, müssen wir nur noch von den verbleibenden Blöcken des ersten Arrays eventuell den Borrow weiterverrechnen.

    Letztendlich schaut das Prinzip so aus:  
        - $$Result_i = a_i - b_i - borrow_{i-1}$$, wobei $$borrow \in \{0, 1\}$$  
    Hier bezieht sich das `i` auf den aktuellen Index im Array. Das Borrow kommt somit aus der Rechnung des vorherigen Blocks, falls dort der 1. Operand kleiner als der 2. Operand gewesen ist. Bei der allerersten Iteration (Index 0) gibt es natürlich noch kein Borrow aus der vorherigen Rechnung, also ist $$borrow_{-1} = 0$$.

### Multiplizieren

Diese Teilaufgabe ist etwas komplizierter als die bisherigen. Starten wir mit der Hilfsmethode `safeMul()`.

4. [task][safeMul]( 235432 , 235424 )
Wie schon bei der Addition kann auch bei der Multiplikation ein Overflow enstehen.
Damit wir diesen Overflow korrekt behandeln, kümmern wir uns in `safeMul()` darum, 2 `long`-Variablen sicher zu multiplizieren.
Auch hier geben wir am Schluss ein Array zurück, in dem bei Index 0 das Gesamtergebnis und bei Index 1 der Overflow gespeichert werden soll.
Wie bereits zuvor könnten dir die beiden Methoden `low()` und `high()` sowie Bitshifts und der bit-wise OR Operator (""`|`"") helfen.
    - Die Multiplikation ist in 4 Multiplikationen aufgeteilt. Das Gesamtergebnis ist so groß wie 2 `long`s.
    - Wir müssen 
        1. die unteren beiden Hälften miteinander multiplizieren, 
        2. dann die untere Hälfte von `a` mit der oberen Hälfte von `b` multiplizieren, 
        3. dann die obere Hälfte von `a` mit der unteren Hälfte von `b` multiplizieren
        4. und zum Schluss die beiden oberen Hälften miteinander multiplizieren.
    - Jedes einzelne Teilergebnis für sich passt garantiert in einen `long`.
    - Das Ergebnis von 1. kann so in das Gesamtergebnis übernommen werden.
    - Das Ergebnis von 4. kann so in den Overflow übernommen werden
    - Die untere Hälften von 2. und 3. müssen auf die obere Hälfte des Gesamtergebnisses addiert werden.
    - Die oberen Hälften von 2. und 3. müssen auf die untere Hälfte des Overflows addiert werden.
    - Denk dran, dass bei jeder Addition (außer der letzten) ein Übertrag entstehen kann.
    
    Letztendlich schaut es also so aus:  
        - $$res_0 = a_{low} \cdot b_{low}$$  
        - $$res_1 = a_{low} \cdot b_{high}$$  
        - $$res_2 = a_{high} \cdot b_{low}$$  
        - $$res_3 = a_{high} \cdot b_{high}$$  
        - $$Result_{low} = (res_0)_{low}$$  
        - $$Result_{high} = (res_0)_{high} + (res_1)_{low} + (res_2)_{low}$$  
        - $$Overflow_{low} = (res_1)_{high} + (res_2)_{high} + (res3)_{low} + carry_{Result_{high}}$$  
        - $$Overflow_{high} = (res_3)_{high} + carry_{Overflow_{low}}$$  
    Um es übersichtlicher zu halten, wird jedes Teilergebnis ($$res_0$$ bis $$res_3$$) zwischengespeichert. $$carry_{Overflow_{low}}$$ und $$carry_{Result_{high}}$$ beziehen sich hierbei auf den Übertrag, der sich aus der Addition unmittelbar im vorherigen Schritt ergibt.

5. [task][mul]( 235431 , 235429 )
Nun können wir die Hilfsmethode dazu benutzen, 2 `long`-Arrays zu multiplizieren.
Das Gesamtergebnis wird maximal die Länge des ersten Arrays plus die Länge des zweiten Arrays haben.
Falls du dir schwer tust, überlege dir, wie du mit der Schulmethode auf Papier 2 Zahlen miteinander Ziffer für Ziffer multiplizieren würdest.
Eine Ziffer auf dem Papier entspricht dann einem Block unserer Arrays.
Das Prinzip funktioniert wie folgt:
    - Wir nehmen uns einen Block des ersten Arrays und multiplizieren den einmal auf alle Blöcke des zweiten Arrays drauf.
    - Das Ergebnis der Multiplikation von `a[i]` und `b[j]` wird auf das Gesamtergebnis an der Position `i + j` addiert. Denk daran, dass auch hier ein Übertrag entstehen kann, der später noch wichtig wird.
    - Ebenfalls auf das Gesamtergebnis an der Position `i + j` wird der Übertrag der vorherigen Iteration addiert.
    - Der neue Übertrag für die nächste Iteration berechnet sich als Addition aus dem Overflow der Multiplikation und den beiden Überträgen der beiden Additionen.
    - Nachdem du am Ende des zweiten Arrays angekommen bist und noch ein Übertrag übrig bleibt, kannst du diesen an die nächste Position im Gesamtergebnis schreiben.
    - Danach wird der Übertrag auf 0 gesetzt und wir machen mit dem nächsten Block des ersten Arrays weiter.

    Letztendlich schaut das Prinzip so aus:  
        - $$Result_{i+j} = Result_{i+j} + a_i \cdot b_j + carry_{i,j-1}$$  
    $$i+j$$ beschreibt den aktuellen Index im Ergebnis-Array, welcher sich aus den Indices `i` und `j` der beiden Operanden ergibt. $$carry_{i,j-1}$$ enspricht also dem Übertrag aus dem vorherigen Iterationsschritt. Bei der allerersten Iteration jeder einzelnen Multiplikationsreihe (also `i` ist beliebig und $$j=0$$) gibt es natürlich noch kein Carry aus der vorherigen Rechnung, also ist $$carry_{i,-1} = 0,\ \forall i \in [0; b.length)$$. Es wird außerdem niemals passieren, dass der Übertrag so groß wird, dass er nicht mehr in den carry passt.

### Exponenzieren

6. [task][pow]( 235433 , 235430 )
Nun haben wir das schwierigste geschafft.
Die Exponierung besteht dabei einfach nur aus mehreren Multiplikationen.
Da ein `BigUInt` hier keinen Sinn als Exponent macht (schon ab `10.000` dauert es spürbar lange), wird nur ein `int` übergeben.
Du kannst diesen `int` zum weiteren verrechnen in einen `BigUInt` umwandeln.
Nun gibt es 2 Möglichkeiten:  
    1. Die einfache Variante multipliziert einfach so oft die Basis (`this`) auf, wie der Wert des Exponenten ist.
    2. Die minimal schwierigere Variante, welche aber deutlich effizienter funktioniert, multipliziert hier gleich Quadrate der Basis. Solange der Exponent größer als 0 ist, soll folgendes passieren:
        - Falls der Exponent aktuell ungerade ist, soll die aktuelle Basis auf das Zwischenergebnis multipliziert werden.
        - In jedem Fall soll danach der Exponent halbiert werden und die aktuelle Basis durch das Quadrat der Basis ersetzt werden. Nutze hierfür eine lokale Variable, da wir unsere ursprüngliche Basis (`this`) nicht modifizieren wollen.
        - Das Verfahren funktioniert, da wir für jedes Halbieren des Exponenten das Quadrat der aktuellen Basis draufmultiplizieren würden. Das Beispiel $$a^4$$ kann zu $$(a^2)^{4/2}$$ umgeschrieben werden. Den Fall, dass der Exponent ungerade ist, haben wir im ersten Schritt schon behandelt. Betrachte dazu folgendes Beispiel: $$a^5$$ kann zu $$a\cdot (a^2)^{(5-1)/2}$$ umgeschrieben werden. Das $$5-1$$ im Exponenten brauchen wir nicht explizit rechnen, da dass durch die Ganzzahldivision übernommen wird.

### Beispiel

Hier wird noch ein kleiner Test durchgeführt, in dem mehrere Operationen hintereinander ausgeführt werden.

[task][Beispiel]( 235428 )"
404,Praktikum: Grundlagen der Programmierung WS24/25,15068,W05P02 - Grundlegende Array-Funktionen,"# Grundlegende Array-Methoden

In dieser Aufgabe sollen einige Funktionen auf Arrays implementiert werden. Verwende dabei keine Methoden aus der Java-Bibliothek.

Nutze zur Ausgabe die Methoden `write()` und `writeConsole()`. Erstere fügt am Ende einen Zeilenumbruch ein, während letztere in der aktuellen Zeile bleibt.

Die Aufgabe ist dabei in zwei Teile aufgeteilt:

1) Lies dir die Implementierungsdetails und die Aufgabenbeschreibung der einzelnen Aufgaben gründlich durch und schreibe `JUnit` Tests für die einzelnen Methoden. Hierfür haben die fleißigen Pinguine dir bereits eine Vorlage in `ArrayFunTest` zur Verfügung gestellt und auch schon einen simplen Testfall für dich implementiert. Vervollständige die restlichen Testmethoden und überlege dir sinnvolle Randfälle für `array`. _Die Tests werden nicht automatisch korrigiert, sondern dienen dir als Hilfe und auch schon als erstes Brainstorming, bevor du dich in die Implementierung stürtzt_

2) Implementiere die Methoden in `ArrayFun` und benutze deine Tests, um deine Implementierung zu prüfen, bevor du deinen Code auf Artemis pushst.


 - [task][Print]( 235469 , 235474 , 235482 )
`public static void print(int[] a)` - gibt das Array auf der Konsole aus.
Das Array soll mit einer öffnenden geschweiften Klammer beginnen und mit einer schließenden geschweiften Klammer enden. 
Die einzelnen Elemente des Arrays sollen durch ein Komma und ein Leerzeichen getrennt sein.  
Beispiel: `print(new int[] {1, 2, 3, 4, 5})` liefert auf der Konsole die Ausgabe "" {1,⎵2,⎵3,⎵4,⎵5} "".
 - [task][Min and Max]( 235468 , 235483 , 235478 , 235487 , 235488 )
`public static void minAndMax(int[] a)` - gibt das Minimum und Maximum des Arrays auf der Konsole aus.
Das Array soll in der Methode nur einmal durchlaufen werden. Falls das Array leer ist, soll gar nichts passieren.  
Beispiel: `minAndMax(new int[] {1, 10, 25, -13, 1000})` liefert auf der Konsole die Ausgabe "" Minimum⎵=⎵-13,⎵Maximum⎵=⎵1000 "".
 - [task][Invert]( 235480 , 235477 , 235479 )
`public static int[] invert(int[] a)` - gibt ein neues Array zurück, welches die Elemente von *a* in umgekehrter Reihenfolge enthält. Verändere dabei das übergebene Array nicht!  
Beispiel: `invert(new int[] {0, 1, 2, 3})` liefert ein Array `{3, 2, 1, 0}` zurück.
 - [task][Intersect]( 235476 , 235471 , 235473 , 235484 , 235486 , 235485 , 235475 )
`public static int[] intersect(int[] a, int length)` - gibt ein neues Array zurück,
welches Platz für genau *length* Elemente hat und die Elemente von *a* in der gleichen Reihenfolge und so viele wie möglich enthält.
Sollte das zurückgegebene Feld größer sein als das übergebene, sollen die zusätzlichen Positionen den Wert 0 haben. Sollte length <= 0 sein, so soll ein leeres Array zurückgegeben werden.
Verändere das übergebene Array nicht!  
Beispiel: `intersect(new int[] {1, 2, 3}, 2)` liefert ein Array `{1, 2}`
und `intersect(new int[] {1, 2, 3}, 5)` liefert ein Array `{1, 2, 3, 0, 0}`.
 - [task][Linearize]( 235470 , 235472 , 235467 , 235481 )
`public static int[] linearize(int[][] a)` - gibt ein neues, eindimensionales Array zurück, welches die Werte des übergebenen zweidimensionalen Arrays *a* enthält.
Die Zeilen des Arrays *a* sollen dabei nacheinander in der ihrem Zeilenindex entsprechenden Reihenfolge in dem eindimensionalem Array abgelegt werden.
Beachte, dass Zeilen nicht gleich lang sein müssen. Verändere das übergebene Array nicht!  
Beispiel: `linearize(new int[][] {{1, 3}, {25}, {7, 4, 6, 9}})` liefert ein Array `{1, 3, 25, 7, 4, 6, 9}`."
404,Praktikum: Grundlagen der Programmierung WS24/25,15069,W05P03 - Bubblesort,"## Einführung

Pinguin Ole macht jede Woche Mittwoch seinen Wocheneinkauf. Jeden Mittwochmorgen geht er zum Fischmarkt und sucht sich die schönsten Fische heraus. Da aber nicht jeder Fisch gleich groß ist, stellt sich für Ole die Frage, in welcher Reihenfolge er die Fische isst.  
Da Ole seine Selbstdisziplin üben möchte, hat er sich vorgenommen, erst die kleinen und erst zum Schluss die großen Fische zu essen.  
Um diesem Vorhaben auch nachzukommen, muss Ole ersteinmal seine Fische sortieren. Hierfür möchte er Bubblesort nutzen.

## Bubblesort

Das Bubblesortverfahren heißt so, weil die größeren Elemente wie Luftblasen im Wasser aufsteigen. Wenn man mit dem Sortieren fertig ist, sind die Elemente in aufsteigender Reihenfolge angeordnet.
Man beginnt, indem man das erste Element des Arrays mit dem zweiten vergleicht. Falls das erste Element größer als das zweite Element ist, tauschen die beiden Elemente die Plätze. Anschließend passiert das gleiche mit dem zweiten und dem dritten Element. Das ganze macht man nun bis man am Ende des Arrays angekommen ist. Da immer das größere Element weiter nach rechts verschoben wird, ist nun garantiert, dass das größte Element am Ende des Arrays steht.
Diesen Vorgang kann man nun wiederholen, muss jedoch nicht mehr bis ans Ende gehen, da ja das letzte Element bereits an der richtigen Stelle ist. So sortiert sich das Array bei mehrfachen Anwenden des oben genannten Algorithmus langsam aber sicher von rechts nach links.
Für weitere Informationen besucht eure Tutorübung oder schaut bei [Wikipedia](https://de.wikipedia.org/wiki/Bubblesort) nach.

## Beispiele:

1. [task][Umgedreht]( 235516 )

Hier wird der Worstcase für Bubblesort dargestellt, ein Array, welches absteigend sortiert ist.

2. [task][Array aus der main]( 235514 )

Hier wird das Array aus der `Main.java` getestet:
```
[6,1,6,8,9,1,9,1,5]
```
 
 So sollte das Ergebnis aussehen. (zum Ausklappen hier klicken) 
 
[1, 1, 1, 5, 6, 6, 8, 9, 9]
 
 


3. [task][Randfälle und weitere Beispiele]( 235518 , 235517 , 235515 , 235520 , 235519 )"
404,Praktikum: Grundlagen der Programmierung WS24/25,15070,W05P04 - Matrixmultiplikation,"# Einführung

Da ihr jetzt schon sehr gut mit eindimensionalen Arrays umgehen könnt, kümmern wir uns nun um mehrdimensionale Arrays. Um genau zu sein geht es jetzt um Matrizen. Diese haben eine sehr wichtige Bedeutung in der Informatik. Im Folgenden wollen wir die Matrixmultiplikation implementieren.  
Aus der Vorlesung solltet ihr bereits wissen, wie man Matrizen multipliziert. Hier aber noch mal eine kleine Wiederholung:

## Wiederholung

Falls ihr zwei Matrizen $$A$$ und $$B$$ multiplizieren wollt, müssen diese Dimensionen $$m\times n$$ und $$n \times p$$ haben. Das bedeutet, dass die zweite Dimension von Matrix $$A$$ gleich der ersten Dimension von Matrix $$B$$ sein muss. Das Ergebnis der Multiplikation ist eine neue Matrix $$C$$ mit Dimension $$m \times p$$.  
Für jede Zelle $$c_{x,y}$$ der Matrix $$ C $$ berrechnet man folgende Summe : $$ a_{x,0}\cdot b_{0,y} + a_{x,1}\cdot b_{1,y} + ... + a_{x,n}\cdot b_{n,y} $$.

## Anforderungen

Die `matrixMult` Funktion soll zwei zweidimensionale Arrays entgegen nehmen und miteinander multiplizieren. Die Eingabematrizen sollen nicht verändert werden. Das Ergebnis soll in eine neue Matrix geschrieben und zurück gegeben werden. Falls die Eingaben nicht multipliziert werden können, soll `null` zurückgegeben werden.

# Beispiele

1. [task][Quadratische Matrizen]( 235550 )

Zwei Quadratische Matrizen werden multipliziert. Die zweite Matrix sorgt hier für eine Spiegelung:

![Quadratische Multiplikation](/api/core/files/markdown/Markdown_2021-11-19T12-29-32-888_f4292fa7.png)

2. [task][Nichtquadratische Matrizen]( 235547 )
 
Jetzt werden zwei Matrizen multipliziert, welche nicht quadratisch sind. Hier muss man also auf die Dimensionen achten. Hier sorgt die zweite Matrix, dafür dass das Ergebnis gleich der ersten Matrix ist.

![Nichtquadratische Multiplikation](/api/core/files/markdown/Markdown_2021-11-19T12-31-25-202_8fed9ec1.png)

3. [task][Fehlerhafte Eingaben]( 235556 )

Hier wird geprüft ob invalide Eingaben akzeptiert werden. Eine $$2\times3$$ Matrix darf nicht mit einer $$4\times3$$ Matrix multipliziert werden.

4. [task][Power of 3]( 235554 )

Hier wird eine quadratische Matrix $$A$$ zwei mal mit sich selber multipliziert, also $$A\times A\times A$$ oder anders ausgedrückt $$A^3$$."
404,Praktikum: Grundlagen der Programmierung WS24/25,15075,W05H01 - PinguPinguLos III - Die Rache der Suchmaschine,"# Suchmaschine - Alle guten Dinge sind 3

### Wichtig!

- Die Tests sind wieder in Struktur und Verhalten aufgeteilt. Lies dir also erst die gesamte Aufgabenstellung gründlich durch und füge zuerst alle benötigten Klassen und Signaturen hinzu.
- In der gesamten Aufgabe ist das benutzen der `java.util.Arrays` Klasse verboten. **Abgaben die gegen das Verbot verstoßen werden mit 0 Punkten bewertet.**

### Das Ziel
Auch diese Woche soll die Suchmaschine erweitert werden. Wir wollen ein Maß für die Ähnlichkeit zweier Dokumente implementieren. Dazu nutzen wir das Verfahren aus der Vorlesung: Es sollen Felder mit der Anzahl der vorkommenden Wörtern der beiden Dokumente erstellt werden. Indem wir diese Felder als Vektoren interpretieren, erhalten wir schlussendlich über das Skalarprodukt ein Indikator für die Ähnlichkeit der beiden Dokumente.

### 1. Die Klasse `WordCount`

Die Klasse WordCount wird dazu verwendet, die Häufigkeit spezifischer Wörter in einem Dokument zu speichern. Hierfür besitzt sie zwei private Attribute: `word` und `count`. Diese werden über den Konstruktor `WordCount(String, int)` der Klasse initialisiert, wobei word den Begriff und count die Häufigkeit repräsentiert. Sollte dabei ein negativer Wert für count übergeben werden, wird dieser automatisch auf 0 gesetzt.

Da für bestimmte Zwecke `WordCount`-Objekte mit einem `count`-Wert von 0 erforderlich sind, gibt es zusätzlich einen zweiten Konstruktor `WordCount(String)`, der den Anfangswert von `count` auf 0 setzt.

Erstelle diese Klasse in `pgdp.searchengine.util` und implementiere zudem die öffentlichen Methoden `increment()`, welche den `count` eines `WordCount`-Objekts um genau 1 erhöht, sowie Getter für die beiden privaten Attribute.

[task][Alle Konstruktoren, Methoden und Variablen in WordCount haben die korrekte Signatur]( 235789 , 235797 , 235807 )
[task][Implementiere die Konstruktoren und Methoden von WordCount]( 235792 , 235794 )

### 2. Die Klasse Document

Die Klasse `Document` soll nun um ein paar Methoden erweitert werden, die unsere neue Klasse `WordCount` benutzen und uns erlauben `Document`-Objekte zu analysieren und zu vergleichen.

[task][Alle Methodensignaturen in Document sind korrekt]( 235795 )

### 2.1. Das WordCount Array eines `Document`-Objekts

Im ersten Schritt wollen wir den Inhalt des Dokuments in `WordCount`-Objekte herunterbrechen. Die Methode `getWordCountArray(): WordCount[]` soll den `content` des `Document`-Objekts in ein Array aus `WordCount`-Objekten umwandeln. Dazu soll die öffentliche Methode `getWordCountArray(): WordCount[]` zur Klasse `Document` hinzugefügt werden. Diese soll für jedes Wort im String `content` mithilfe der `WordCount`-Klasse die Häufigkeit des Wortes in einem Array abspeichern. Dieses Array soll am Ende zurückgegeben werden. 

Achte darauf, dass alle hinzugefügten Wörter kleingeschrieben sind und kein neues `WordCount`-Objekt für ein Wort aufgrund eines Sonderzeichens erstellt wird. Dabei beschränken wir uns auf folgende Sonderzeichen: `.` (Punkt), `;` (Semikolon), `!` (Ausrufezeichen), `?` (Fragezeichen), `(` (runde, öffnende Klammer), `)` (runde, schließende Klammer), `*` (Sternchen) und `,` (Komma). 

Beispiel: `Pinguin`, `Pinguin!`, `?Ping(uin!` sollen am Ende zum `WordCount`-Eintrag für `pinguin` zählen. Zwischen zwei Wörtern steht dabei immer mindestens ein Leerzeichen. Die Pinguine der PUM geben dir dabei folgenden Hinweis: Die Dokumentation der String Klasse hat viele praktische Methoden!

[task][Implementiere die getWordCountArray-Methode in Document]( 235798 , 235808 )

### 2.2. Zwei WordCount-Arrays abgleichen
Um am Ende das Skalarprodukt auf zwei WordCount-Arrays von zwei Dokumenten anwenden zu können, müssen wir sicherstellen, dass sie die gleichen Einträge an den gleichen Stellen enthalten. Um ein `WordCount`-Array mit den fehlenden Einträgen auffüllen zu können, soll die öffentliche Methode `static equalizeWordCountArray(WordCount[], WordCount[]): WordCount[]` in `Document` implementiert werden. Diese Methode soll für jedes Wort in Array `second` überprüfen, ob dieses Wort bereits in `first` vorhanden ist. Wenn ja, soll mit dem nächsten Wort aus `second` fortgefahren werden. Wenn nein, soll dieses Wort `first` hinzugefügt werden, aber mit `count` = 0, da das Wort nicht im Text vorhanden war. Am Ende enthält `first` damit alle Wörter von `second`. Die genaue Reihenfolge der `WordCount`-Objekte spielt dabei keine Rolle, solange die beschriebene Logik erfüllt ist.

[task][Implementiere die equalizeWordCountArray-Methode in Document]( 235802 , 235796 )

### 2.3. Sortieren der WordCount-Arrays
Jetzt haben zwei Arrays zwar die gleichen Einträgen, aber nicht zwangsläufig in der gleichen Reihenfolge bzw. am gleichen Index. Darum benötigen wir noch eine öffentliche Methode `static sort(WordCount[]): void`, die das übergebene Array lexikographisch nach dem Attribut `word` von `WordCount` sortiert. Welchen Sortieralgorithmus du verwendest, ist dir überlassen. Du kannst den Bubblesort-Algorithmus der P-Aufgabe anpassen oder einen anderen Algorithmus verwenden. Wichtig ist, dass du keine fertige Sortier-Funktion der Java-Library nutzen darfst, sondern den Sortieralgorithmus selbst implementierst!

[task][Implementiere die sort-Methode in Document]( 235800 )

### 2.4. Ähnlichkeitsmaß
Als letzten Schritt wird eine öffentliche Methode `static similarity(WordCount[], WordCount[]): double` benötigt, die für zwei `WordCount`-Arrays entsprechend der Vorlesung das Ähnlichkeitsmaß berechnet (siehe Folien Kapitel 4 und 5). Wir sehen die Arrays als Vektoren an und wenden das Skalarprodukt auf beide an. Dieses Teilergebnis soll noch durch das Produkt der beiden Arraylängen geteilt werden. Falls die beiden Arrays eine unterschiedliche Länge besitzen, soll `-1` zurückgegeben werden. Du darfst in dieser Methode davon ausgehen, dass die übergebenen arrays schon sortiert sind, es bedarf hier also keiner Sortierung.

Wir definieren das Ähnlichkeitsmaß wie folgt`


Sei n = `first.length`, m = `second.length` und `first[i]` bzw. `second[i]` der `count` des `i`-ten `WordCount` Objekts.
$$

\text{result} = 
\begin{cases} 
-1 & \text{falls } n \neq m, \\
0 & \text{falls } n * m = 0 , \\
\frac{\sum_{i=0}^{n-1} \text{first}[i] \cdot \text{second}[i]}{n \cdot m} & \text{andernfalls.}
\end{cases}
$$


[task][Implementiere die similarity-Methode in Document]( 235806 )

### 2.5. Alles zusammenführen
Wir haben nun 4 Hilfsmethoden implementiert, die jeweils einen Schritt zur Berechnung des Ähnlichkeitsmaßes zweier Dokumente übernehmen. Alle 4 Methoden nacheinander aufzurufen ist uns aber noch zu umständlich. Wir benötigen eine öffentliche Methode `computeSimilarity(Document): double`. Über diese erhalten wir die Ähnlichkeit zwischen dem Dokument, auf welchem wir die Methode aufrufen, und dem übergebenen Dokumentes als Rückgabewert. Rufe dafür die bis hierhin implementieren Methoden in der Reihenfolge in der sie implementiert werden mussten mit passenden Eingaben auf.

[task][Implementiere die computeSimilarity-Methode in Document]( 235805 )
 
### 3. Testen (Optional)
In dieser Aufgaben sollst du Tests für deine Implementierung schreiben. Schreibe diese in die `SearchEngineTesting`-Klasse. Die Klasse `WordCount` muss nicht getestet werden.

Für die neu implementierten Methoden in `Document` sollen pro Methode zwei Tests geschrieben werden: ein Test für einen allgemeinen, regulären Fall und einen Test für einen beliebigen Sonderfall. 

Es soll über jedem Test ein Kommentar existieren, warum ihr die Methode auf diese Art und Weise testet, also warum euer Test aussagekräftig ist, und bei den Sonderfällen noch zusätzlich, warum es sich bei den gewählten Testdaten um einen Sonderfall handelt. Die Kommentare dürfen wie immer auch auf Englisch sein.

_(Die Tests werden nicht automatisch getestet, sie dienen dir aber als eigenständige Übungsmöglichkeit)_

### Hinweise
- Für die Verarbeitung von Strings in dieser Aufgabe können folgende Methoden nützlich sein: [replace()](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replace(char,%20char)), [replaceAll()](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#replaceAll(java.lang.String,%20java.lang.String)), [split()](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split(java.lang.String)) und [compareTo()](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareTo(java.lang.String)). Diese müssen jedoch nicht verwendet werden.
 
# FAQ

Sobald die gleichen Fragen öfters vorkommen wird die Frage + Antwort hier hinzugefügt. Unklarheiten in der Aufgabenstellung werden sehr wahrscheinlich direkt in der Aufgabenstellung angepasst."
404,Praktikum: Grundlagen der Programmierung WS24/25,15076,W05P01 - Rubber Penguin Debugging,"**Schnapp dir deinen Sitznachbaren und geht gemeinsam mittels der `Rubber Ducky Debugging` Technik über die gegebenen Code Snippets und überprüft, ob sie die beschriebenen Anforderungen erfüllt.**

Zum Ausprobieren der Codeschnippsel eignet sich eine `main` Methode sehr gut. Dafür kannst du ein altes PGdP-Übungsprojekt oder ein frisches Java Projekt in Intellij hernehmen. Füge dann den folgenden Ausdruck bei dir in deiner IDE in einer Klasse hinzu:

```java
public static void main(String[] args) {

}
```

In dieser `main` Methode kannst du die anderen Codeschnippsel mit verschiedenem Input aufrufen und den Output betrachten. Vergiss nicht, den jeweiligen Codeschnippsel _auch_ in die Klasse zu kopieren. In der Seitenleiste neben der `main`-Methode taucht auch direkt ein grüner Pfeil auf, mit dem du sie ausführen kannst.

#### Snippet 1

Die Methode `countEvenDigits(int)` soll die Anzahl der geraden Ziffern in einer Zahl mittels passender arithmetischer Operationen zählen.

```java
public static int countEvenDigits(int n) {
    int count = 0;
    while (n > 0) {
        int digit = n % 10;
        if (digit % 2 == 1) {
            count++;
        }
        n = n / 10;
    }
    return count;
}
```

#### Snippet 2

Die Methode `collatzPrinter(int)` soll die [Collatz](https://de.wikipedia.org/wiki/Collatz-Problem) Folge für eine gegebene Zahl in die Standardausgabe schreiben. 

```java

public static void collatzPrinter(int n) {

    n = Math.max(n, -n);

    while (n != 1) {
        
        System.out.println(n);

        if ((n & 1) == 0) {
            n /= 2;
        } else {
            n = (3 * n) + 1;
        }
    }

    System.out.println(n);
}

```

#### Snippet 3

Die Methode `sumDigitsInString(String)` soll die Ziffern die im übergebenen String enthalten sind aufaddieren und die Summe zurückgeben.

```java
public static int sumDigitsInString(String s) {
    int sum = 0;
    for (int i = 0; i < s.length(); i++) {
        char ch = s.charAt(i);
        if (ch >= '0' && ch <= '9') {
            sum += ch;
        }
    }
    return sum;
}
```"
404,Praktikum: Grundlagen der Programmierung WS24/25,15232,W06P01 - Radixsort,"# Einleitung

Die Pinguindame Alsa möchte einen Serienmarathon mit ihren Freunden Claudia und Karl-Heinz veranstalten. 
Über die Jahre haben sich sehr viel Serien in der Bibliothek von Alsa angesammelt. 
Damit sie und ihre Freunde nicht erst lange ihre Serienbibliothek durchforsten müssen, möchte Alsa ihre Serien sortieren.

Die Serien sollen nach ihrem Titel sortiert werden. 
Da Alsa damals im Studien mal aus Spaß ""Grundlagen Algorithmen und Datenstrukturen"" gehört hat, kennt sie sich etwas mit Sortieralgorithmen aus. 
Sie bittet euch, den Radixsort-Algorithmus zu implementieren.

# Radixsort

Ihr erhaltet eine `StringList` aus der `PinguLib` zum sortieren. 
Die `StringList` verhält sich wie eine gewöhnliche Java Liste, kann jedoch nur Strings speichern.
Da wir Strings sortieren, ist unsere Vorgehensweise etwas anders als bei beispielsweise Zahlen (da würde man mit der hintersten Ziffer aller Zahlen anfangen).
Wir fangen beim letzten Zeichen des längsten Strings an.
Falls andere Strings kürzer sind, wird implizit das 0-Byte für das aktuelle Zeichen dieser Strings angenommen.
Ihr kommt an das jeweilige Zeichen über die `charAt()` Methode in der PinguLib.
Zurückgegeben wird euch der numerische Wert des Characters als `char`.
Entsprechend dieses Wertes werden die Strings nun auf sogenannte Buckets verteilt. 
Dabei entspricht jeder Bucket genau einem Character.
Überlege dir also im Voraus, wie viele Buckets du maximal benötigen wirst!
Als nächstes werden die Buckets wieder zusammengefügt, indem der Inhalt der Reihe nach beginnend beim ersten Bucket nach und nach wieder in eine gesamte Liste eingefügt wird. 
Nun beginnt der Spaß von vorne mit dem vorletzten Zeichen.
Nachdem man die Strings auch nach dem ersten Zeichen sortiert hat, erhält man am Ende die sortierte Liste.

Der Algorithmus:
1. Man initialisiert seine Buckets und stellt sicher, dass diese leer sind.
2. Man beginnt bei dem unwichtigsten Teilelement der Elemente:
    1. Bei Integern wäre das die Einerstelle
    2. Bei Strings, das letzte Zeichen des längsten Strings
3. Man fügt die Elemente in den passenden Bucket ein.  
    Hierbei muss beachtet werden, dass wenn ein Element hinter einem anderen stand und diese Elemente in den gleichen Bucket kommen, sie die gleiche Reihenfolge behalten müssen.
4. Man fügt nun alle Buckets hintereinander zusammen, angefangen bei dem niederwertigsten Teilelement.
5. Man schaut sich nun das nächst wichtigere Teilelement an und beginnt bei Schritt 1.


Für weitere Informationen schaut euch gerne den [Wikipedia Artikel](https://de.wikipedia.org/wiki/Radixsort) an.

# Der Serienmarathon

[task][Beispiel]( 240411 )

Alsa hat für euch alle ihre Serien zusammengetragen, und bittet euch, diese zu sortieren

*Den folgenden Code findet ihr auch in der `Main.java`*

```
    List  library = new ArrayList<>();

    library.add(""Game of thrones"");
    library.add(""Arcane"");
    library.add(""Magicians"");
    library.add(""Squid Game"");
    library.add(""The Walking Dead"");
    library.add(""The Witcher"");
    library.add(""Haus des Geldes"");
    library.add(""Loki"");
    library.add(""Vikings"");
    library.add(""Peaky Blinders"");
    library.add(""Bodyguard"");
    library.add(""Cursed"");
    library.add(""The Office"");
    library.add(""Brooklyn Nine-Nine"");
    library.add(""What if"");
    library.add(""Clone Wars"");
    library.add(""Sex Education"");
    library.add(""Prison Break"");
    library.add(""Breaking Bad"");
    library.add(""House of Cards"");
    library.add(""The Expanse"");
    library.add(""Gotham"");
    library.add(""Suits"");
    library.add(""The Queens Gambit"");
    library.add(""Chernobyl"");
    library.add(""Lucifer"");
    library.add(""The Boys"");
    library.add(""Taboo"");
    library.add(""Cloak and Dagger"");
    library.add(""Sherlock"");

    radixSort(library);

    System.out.println(library);
```

 
 Eine Ausführung der main-Methode sollte zu dieser Ausgabe führen (zum Ausklappen hier klicken) 
 
[Arcane, Bodyguard, Breaking Bad, Brooklyn Nine-Nine, Chernobyl, Cloak and Dagger, Clone Wars, Cursed, Game of thrones, Gotham, Haus des Geldes, House of Cards, Loki, Lucifer, Magicians, Peaky Blinders, Prison Break, Sex Education, Sherlock, Squid Game, Suits, Taboo, The Boys, The Expanse, The Office, The Queens Gambit, The Walking Dead, The Witcher, Vikings, What if]

 
 

[task][Sonstige Tests]( 240413 , 240415 , 240409 , 240414 )

Getestet werden natürlich auch noch ein paar andere Fälle."
404,Praktikum: Grundlagen der Programmierung WS24/25,15233,W06H01 - PinguPinguLos IV - Eine neue Suchmaschine,"# PinguPinguLos IV - Eine neue Suchmaschine 

Wir können nach letzter Woche für zwei Dokumente ein Gleichheitsmaß berechnen. Für unsere Suchmaschine müssen wir dies jedoch für eine Vielzahl von Dokumenten erledigen. Wir brauchen also eine Datenstruktur, um auf alle uns zur Verfügung stehenden Dokumente zuzugreifen. Diese `DocumentCollection` wollen wir jetzt implementieren.

### Die Datenstrukturen
In der W06P02 hast du bereits einfach verkette Listen kennengelernt. Um bei diesen an ein Element zu kommen, muss jedoch im schlimmsten Fall über die gesamte Liste iteriert werden. Bei einem Array hingegen können wir direkt auf das Element zugreifen, wenn wir seinen Position im Array kennen. Jedoch können wir die Größe des Arrays im Nachhinein nicht mehr verändern und müssten immer ein neues Array erstellen. Um die Vorteile von beiden ausnutzen zu können, kombinieren wir beide Datenstrukturen.

![hashSet.jpg](/api/core/files/markdown/Markdown_2021-11-24T17-55-45-931_1b52ae3e.jpg)

Die Grundlage unserer Collection stellt ein Array dar, dessen Größe wir beim Erstellen der Collection festlegen. Dies ist links in der Abbildung dargestellt. Jedes Array-Element enthält eine Referenz auf eine Liste. Im Falle der Abbildung handelt es sich um eine einfach verkettete Liste (wie aus Aufgabe W06P02), die Strings speichert. Wir wollen jedoch statt einer einfach verketteten Liste eine doppelt verkettete Liste nutzen und statt Strings `Document`s abspeichern. Beim Einfügen eines Elementes (egal ob String oder Dokument) wird als erster Schritt diesem Objekt ein Index im Array zugewiesen und anschließend in dessen Liste eingefügt. Dadurch können wir beliebig viele Elemente hinzufügen, da sich unsere doppelt verketteten Listen dynamisch erweitern lassen.

Der Unterschied zwischen einer einfach und doppelt verketteten Liste ist, dass bei einer doppelt verketten Liste jedes Listenelement zusätzlich noch eine Referenz auf das vorherige Element besitzt. 

An jedem Index des Arrays befindet sich damit eine Referenz auf eine doppelt verkette Liste, in welcher wir die Dokumente letztendlich einfügen. Unsere Datenstruktur ist damit ein Array von doppelt verketteten Listen.

### Die Aufgabe

[task][Die doppelt verkettete Liste]( 240421 , 240417 , 240434 , 240416 )
Auch für eine doppelt verkettete Liste benötigen wir eine eigene Klasse `DocumentListElement` für jedes Element in der Liste:
1. Füge die Attribute `document`, `pre` und `next` der Klasse `DocumentListElement` hinzu. `document` soll die Referenz auf das in diesem Listenelement gespeicherte Dokument beinhalten. Die Variable `pre` besitzt die Referenz auf das vorherige Listenelement oder `null`, falls keines existiert. Entsprechend hat `next` die Referenz auf das nächste Listenelement oder `null`.
2. Erstelle einen Konstruktor `DocumentListElement(Document)`, welcher nur das zu speichernde Dokument entgegen nimmt. Die anderen Variablen sollen mit dem Wert `null` initialisiert werden. Die Behandlung von `null` beim Parameter ist an dieser Stelle nicht erforderlich.
3. Füge zuletzt noch den Getter `Document getDocument()` hinzu.

Du darfst weitere private Attribute, sowie öffentliche Hilfsmethoden und Konstruktoren hinzufügen, wenn du diese im Laufe der Aufgaben benötigst. Sofern du Hilfsmethoden nur in `DocumentListElement` verwendest, ist es sinnvoll, diese ebenfalls als private zu markieren.

Damit haben wir schon einmal unsere Listenelemente. Wir möchten jedoch auch noch eine übergeordnete Klasse `Bucket` haben, über welcher wir auf den Anfang oder das Ende der Liste zugreifen können:  
Füge der Klasse `Bucket` die beiden Attribute `head` und `tail` hinzu. `head` soll dabei immer auf das erste Element in der Liste zeigen und `tail` auf das letzte. Wenn die Liste leer ist, sollen beide den Wert `null` besitzen.


[task][Die DocumentCollection]( 240418 , 240419 )
Damit haben wir eine funktionsfähige doppelt verkettete Liste, in welche wir theoretisch Elemente einfügen können. Jedoch wollen wir nicht alle Elemente in eine Liste einfügen, sondern diese auf mehrere Listen verteilen. Dies soll in der Klasse `DocumentCollection` passieren:
1. Erstelle in der Klasse `DocumentCollection` das Attribut `Bucket[] buckets`. Das Array `buckets` speichert sämtliche Referenzen auf unsere Listen und soll nach der Initialisierung nicht mehr vergrößert oder verkleinert werden.
2. Implementiere einen Konstruktor, welcher die Anzahl an doppelt-verketteten Listen entgegennimmt, die entsprechende Anzahl an Listen erstellt und in `buckets` speichert. Sollte eine Anzahl übergeben werden, die kleiner oder gleich 0 ist, soll `buckets` genau eine Liste enthalten.

Der Strukturtest wird erst durchlaufen, sobald auch alle nachfolgenden Methoden implementiert wurden. 


[task][Den Bucketindex berechnen]( 240425 )
Unsere Datenstruktur verhält sich ähnlich zur HashMap aus der Standardbibliothek.
Damit wir unsere Elemente sinnvoll verteilen können, brauchen wir eine Hilfsfunktion, welche uns den Index für ein Dokument berechnet.
Füge dafür eine private Methode `int indexFunction(int)` hinzu, die den Index im `bucket`-Array für ein Dokument mit der übergebenen ID nach folgender Funktion zurückliefert: `index = documentID % numberOfBuckets`.


[task][Einfügen von Elementen]( 240424 , 240426 )
Als erstes wollen wir Elemente einfügen können. Implementiere dafür eine Methode `boolean add(Document)`. Wie oben beschrieben, müssen wir jedem Element eine doppelt verkettete Liste in unserem Array zuweisen.
Mit der gerade implementierten Hilfsfunktion können wir das Dokument in die entsprechende Liste, die am berechneten Index in `buckets` steht, einfügen. 
Achte dabei darauf, dass nach dem Einfügen die IDs der Dokumente innerhalb der Liste vom `head` ausgehend aufsteigend sortiert sind. Stelle auch sicher, dass `head` und `tail` auf die richtigen Elemente zeigen.
Falls ein Dokument mit der identischen ID bereits in der Collection vorhanden oder die ID des übergebenen Dokumentes negativ ist, soll nichts eingefügt werden. Gleiches gilt, wenn Document `null` ist.
Zurückgegeben werden soll `true` genau dann, wenn `Document` in unsere Collection eingefügt wurde und ansonsten `false`.  
Im Test `DocumentCollection add() Basic` ist auch ein Test dabei, welcher versucht 100.000 pseudo-zufällige Documents in die Collection einzufügen. Achte also darauf, dass deine Implementierung nicht allzu langsam ist.


[task][Eine weitere kleine Hilfsmethode]( 240431 )
Implementiere als nächstes in `DocumentCollection` die Methode `boolean isEmpty()`, welche genau dann `true` zurückgeben soll, wenn sich kein Dokument in unserer Collection befindet. Diese kannst du unter Umständen für die nachfolgenden Methoden gebrauchen.


[task][Finden von Elementen]( 240427 , 240420 )
Wir wollen auch in der Lage sein, ein Dokument in der Collection mithilfe der ID zu finden. Dafür soll eine Methode `Document find(int)` hinzugefügt werden, welche das Dokument mit der übergebenen ID zurückliefert. Falls kein solches Dokument existiert, soll `null` zurückgegeben werden. 


[task][Entfernen von Elementen]( 240433 , 240429 , 240423 , 240428 )
Zu den Grundoperationen auf eine Datenstruktur gehört auch das Löschen von Elementen. Dafür wollen wir unserem Kontext entsprechend vier Methoden in `DocumentCollection` implementieren:
- `boolean removeDocument(int)`: Entfernt das Listenelement, welches ein Dokument gespeichert hat, dessen ID mit dem Parameter übereinstimmt. Gibt false zurück, wenn das Dokument nicht existiert.
- `boolean removeDocumentsFromAuthor(Author)`: Entfernt alle Dokumente des übergebenen Autors. Gibt false zurück, wenn kein Dokument vom Autor in der Collection existiert.
- `boolean removeAll()`: Entfernt alle Dokumente aus unserer Collection. Gibt false zurück, wenn die Collection bereits leer ist.
- `boolean removeOldDocuments(Date releaseDate, Date lastUpdated)`: Entfernt alle Dokumente, die vor dem übergebenen `releaseDate` veröffentlicht und zudem vor `lastUpdated` zuletzt aktualisiert wurden.  
Falls der übergebene Parameter `lastUpdated` null ist, kann `lastUpdateDate` von `Document` ignoriert werden und ein Dokument soll nur gelöscht werden, wenn es vor `releaseDate` veröffentlicht wurde.  
Falls der übergebene Parameter `releaseDate` null ist, kann das Veröffentlichungsdatum des Dokumentes ignoriert werden und es sollen alle Dokumente gelöscht werden, die vor `lastUpdated` zuletzt aktualisiert wurden.  
Falls beide Parameter null sind, sollen alle Dokumente gelöscht werden. Wenn `lastUpdated` vor `releaseDate` liegt, soll nichts entfernt werden.  
Der Rückgabewert der Methode ist genau dann `true`, wenn mindestens ein Dokument erfolgreich entfernt wurde.


[task][Und noch mehr kleine Methoden!]( 240441 , 240439 , 240435 , 240422 )

Zuletzt sollen noch einige weitere, kleinere Methoden ebenfalls in `DocumentCollection` hinzugefügt werden:
- `getHead(int bucketIndex)`: Gibt den head der doppelt verketteten Liste an Index `bucketIndex` oder `null`, wenn der übergebene Index ungültig ist, zurück.
- `getTail(int bucketIndex)`: Gibt den tail der doppelt verketteten Liste an Index `bucketIndex` oder `null`, wenn der übergebene Index ungültig ist, zurück.
- `contains(Document)`: Gibt `true` zurück, wenn ein Dokument mit der identischen ID in der Collection vorhanden ist. 
- `size()`: Gibt die Anzahl an gespeicherten Elementen zurück.


### Testen der DocumentCollection

In dieser Aufgabe sollst du lediglich Tests für `DocumentCollection` schreiben. Für den Konstruktor, `add(Document)`, `find(int)` und alle vier `remove()`-Methoden sollst du mit deinen Tests jeweils einen allgemeinen Fall abdenken und durch einen zweiten Test einen beliebigen Sonderfall. 

Es soll weiterhin über jedem Test ein Kommentar existieren, warum ihr den Konstruktor oder die Methode auf diese Art und Weise testet, also warum euer Test aussagekräftig ist, und bei den Sonderfällen noch zusätzlich, warum es sich bei den gewählten Testdaten um einen Sonderfall handelt. Die Kommentare dürfen wie immer auch auf Englisch sein!

_(Die Tests werden nicht automatisch getestet, sie dienen dir aber als eigenständige Übungsmöglichkeit)_

[Quelle der Abbildung](https://www.cs.wcupa.edu/rkline/ds/hash-sets.html)"
404,Praktikum: Grundlagen der Programmierung WS24/25,15234,W06P02 - Pinguin Parade,"# Pinguin Parade 

In dieser Aufgabe wollen wir unser wissen über die Objekt orienterte Programmierung nutzen um eine dynamisch wachsende List zu implementieren. Leider können wir die List Methoden nur bedingt unabhängig voneinender testen. Dementsprechend sind die Tests der späteren Methoden abhängig von den Methoden davor. Für dich heißt das, dass du die Aufgaben in der angeführten Reihenfolge bearbeiten **musst**.

## Element

Wie du weißt, kann man sich eine Liste wie eine Kette vorstellen. Viele Implementierungen nutzen dafür Arrays. Wir wollen jedoch unser Wissen zur OOP nutzen. Daher Modellieren wir unsere Liste durch einzelne Elemente (einzelnes Ketten-Segment) und bilden eine Kette durch das aneinander hängen der einzelnen Elemente. Jedes Element speichert dabei einen entsprechenden `String` der Liste im privaten Attribut `value` und seinen Nachfolger im privaten Attribut `next`. Implementiere nun die beiden fehlenden Konstruktoren der inneren Klasse `List.Element`.

[task][Implementiere den ersten Konstruktor von Element!]( 240517 )
Der erste Konstruktor initialisiert ein Element ohne Nachfolger. Er bekommt ausschließlich einen `String` übergeben. Diese soll als value des Elements gespeichert werden. Da kein Nachfolger bekannt ist, muss die Referenz `next` auf null gesetzt werden.
 
[task][Implementiere den zweiten Konstruktor von Element!]( 240521 )
Der zweite Konstruktor initialisiert ein Element dessen Nachfolger bekannt ist. Er bekommt einen `String` und die Referenz zu seinem Nachfolger übergeben. `value` und `next` müssen dementsprechend passend zugewiesen werden.


## List

Da lose Elemente für andere Entwickler nicht benutzerfreundlich sind, versteckt die Implementierung die Klasse Element im inneren. Ein Nutzer kann so auf der Liste einfach Operationen ausführen, ohne dass ihm oder ihr bewusst sein muss, wie genau du diese komplexe Datenstruktur implementiert hast. Zusätzlich kannst du auch im nachhinein Änderungen vornehmen, ohne dass ein anderer Entwickler davon beeinflusst wird, solange das Verhalten identisch bleibt. Unsere List hat drei private Objektattribute: `size` welches immer die aktuelle Länge der Liste speichert, `head` als Referenz zum ersten Element der Liste und `tail` als Referenz zum letzten Element der Liste. Ist die Liste leer zeigen die Referenzen auf `null`. Implementiere nun die fehlenden Code-stellen in der Klasse List.

[task][Implementiere den Konstruktor der List Klasse!]( 240511 )
Der Konstruktor von List erstellt eine Leere liste. Eins fällt dir bestimmt jetzt schon auf: Obwohl im Template kein einziges Statement im Konstruktor steht, schlägt der entsprechende Test nicht fehl? Woran liegt das? Diskutiere dies mit deinen Kommilitonen/innen und dem Tutor.

[task][Implementiere die isEmpty Methode in der List Klasse]( 240509 )
`isEmpty` soll zurückgeben, ob die Liste aktuell leer ist. Wenn ja gibt sie den Boolean `true` zurück, ansonsten `false`.

[task][Implementiere die clear Methode in der List Klasse]( 240506 )
`clear` soll die Liste unabhängig von den aktuell gespeicherten Daten leeren. D.h. nach einem Aufruf von `clear` soll die Datenstruktur danach alle Eigenschaften einer leeren Liste erfüllen. Achte dabei auf die zuvor beschriebenen Kriterien.

[task][Implementiere die add(String) Methode in der List Klasse]( 240513 )
`add(String)` soll den übergebenen String an das Ende der Liste anhängen. Hier siehst du auch wieso die Referenz `tail` so hilfreich ist. Eine Diskussion mit deinen Nachbarn oder dem Tutor ist hier bestimmt sinnvoll. Überlegt euch welche Nachteile eine Implementierung ohne `tail` hätte.

[task][Implementiere die add(int, String) Methode in der List Klasse]( 240510 )
`add(int, String) `fügt ein neues Element mit dem Wert `value` an der Stelle `index` ein. Unsere Liste beginnt dabei bei Index 0, d.h. möchte man eine Zahl ganz am Anfang der Liste einfügen nutzt man den Index 0, um eine Zahl nach der ersten Zahl einzufügen, nutzt man Index 1, usw. Einen String ganz an das Ende der Liste anzuhängen ist auch erlaubt (Welcher Index wird hierfür benutzt?). War das Einfügen der neuen Strings erfolgreich, gibt die Methode `true` zurück, andernfalls `false`.


[task][Implementiere die get(int) Methode in der List Klasse]( 240516 )
Mit `get(int)` soll der Wert des durch den index spezifizierten Elements zurückgegeben werden. Existiert solch ein Element nicht, geben wird der Defaul-Wert `null` zurück. Weiterhin beginnt unsere Liste mit dem Index 0`

[task][Implementiere die remove(int) Methode in der List Klasse]( 240518 )
Um auch Einträge aus der Liste entfernen zu können implementieren wir zuletzt die Methode `remove(int)`. Diese soll das Element an der Stelle index aus der Datenstruktur entfernen. Weiterhin beginnt unsere Liste mit dem Index 0. Negative oder zu große Eingaben für index sollen kein Element entfernen.


## Stack und Queue

Um die Flexibilität unserer Implementierung zu zeigen, wollen wir nun zwei weiter klassische Datenstrukturen implementieren: Stack & Queue. Um die Implementierung einfach zu machen, nutzen wir in den jeweiligen Klassen intern einfach eine Instanz der Klasse `List` die wir eben implementiert haben. Stelle sicher, dass diese Liste im jeweiligen Konstruktor auch richtig initialisiert wird!

Zudem wollen wir die beiden Methoden `push` und `pop` implementieren. Die Methode `push` fügt ein Element hinzu und die Methode `pop` entfernt ein Element und gibt den Wert von dem Element zurück. Beachte hier, dass ein `Stack` dem LIFO (Last in, first out) und eine `Queue` dem FIFO (First in, First out) Prinzip folgen.

[task][Implementiere die Methoden push und pop in der Klasse Queue!]( 240519 )
[task][Implementiere die Methoden push und pop in der Klasse Stack!]( 240520 )

Viel Erfolg!"
404,Praktikum: Grundlagen der Programmierung WS24/25,15235,W06P03 - Studenten-Zoo,"# Studenten-Zoo

Wie immer sind die Pinguine der PUM auf eure exzellente Hilfe angewiesen! Dieses Mal benötigen ihre Biologuinen Unterstützung bei der Implementierung eines Programms, das die verschiedenen Tiere, die sie beobachten, darstellen kann. Wir nutzen diese Gelegenheit natürlich, um ihnen die Vorteile von Vererbung in der objektorientierten Programmierung näherzubringen.

---

@startuml
class Animal {
    # name: String
    # age: int
    + Animal(String, int)
    + eat(): void
    + sleep(): void
    + makeSound(): void
    + getName(): String
    + getAge(): int
}

class Mammal extends Animal {
    - isPregnant: boolean
    + Mammal(String, int)
    + isPregnant(): boolean
}

class Bird extends Animal {
    - canFly: boolean
    + Bird(String, int, boolean)
    + fly(): void
    + canFly(): boolean
}

class Cat extends Mammal {
    - name: String
    + Cat(String, String, int)
    + eat(): void
    + sleep(): void
    + makeSound(): void
    + getNickname(): String
}
@enduml

Für die gesamte Aufgabe sind Methoden mit dem Präfix `get` sowie `isPregnant` und `canFly` als Getter für die jeweiligen Attribute zu verstehen.

## Die Klasse Animal 

Diese Klasse ist die Grundlage aller Tiere. Folge dem UML-Diagramm um die Attribute der Klasse zu implementieren.

Jetzt kommen wir zu den Methoden: 
- Der Konstruktor soll den Namen und das Alter des Tieres entgegennehmen und die Attribute entsprechend setzen.
- `eat(): void`: soll auf der Konsole den "" Some⎵animal⎵called⎵\<`name`\>⎵is⎵eating⎵food! ""
- `sleep(): void`: soll auf der Konsole den "" \<`name`\>⎵is⎵sleeping. ""
- `makeSound(): void`: soll auf der Konsole den "" Some⎵animal⎵called⎵\<`name`\>⎵is⎵making⎵a⎵sound? "" ausgeben.

## Die Klasse Mammal

Die Klasse `Mammal` soll die Klasse `Animal` erweitern. Benutze dabei Vererbung, damit du nicht den ganzen Code aus `Animal` rüberkopieren musst. Wie du schnell bemerkst, beschwert sich deine Entwicklungsumgebung aufgrund eines fehlenden Konstruktors. Diskutiere mit deinem Sitznachbar:innen und/oder deiner/m Tutor:in, wieso das der Fall sein könnte und behebe diesen Fehler sinnvoll. Setze dabei `isPregnant` im Konstruktor auf `false`.

## Die Klasse Bird

Die Klasse `Bird` soll die Klasse `Animal` erweitern. Benutze auch hier wieder Vererbung. Der `boolean` Parameter im Konstruktor ist der Wert für das `canFly` Attribut. Auch hier musst du beim Implementieren des Konstruktors aufpassen.

Zusätzlich soll die Methode `fly(): void` implementiert werden, die falls `canFly` `true` ist, auf der Konsole "" \<`name`\>⎵is⎵flying⎵to⎵PUM! "" ausgeben soll und sonst "" \<`name`\>⎵is⎵staying⎵home... ""

## Die Klasse Cat 

Die Klasse `Cat` soll nun die Klasse `Mammal` erweitern. Da Katzen ganz besonders von ihren Besitzern geliebt werden, bekommen sie einen Spitznamen. Leider sind wir nicht sehr kreativ beim Benennen von Attributen und nennen das Attribut, wie in Animal, auch hier einfach `name`. Der Konstruktor der Klasse `Cat` muss also drei Parameter akzeptieren: `String name` für den Namen, `String nickName` für den Spitznamen und `int age` für das Alter.

Diese Klasse ist dabei auch im Verhalten speziell, da wir nun das Verhalten der Superklasse überschreiben wollen. Hierfür haben wir uns Folgendes überlegt:

- `eat(): void`: soll auf der Konsole den String "" \<`name`\>⎵is⎵eating⎵their⎵favourite⎵treat! "" ausgeben. Hierbei ist \<`name`\> der Name der Katze.
- `sleep(): void`: soll auf der Konsole den String "" \<`name`\>⎵is⎵loafing⎵around! "" ausgeben. Hierbei ist  \<`name`\> der **Spitzname** der Katze.
- `makeSound(): void`: soll auf der Konsole den String "" Meow "" ausgeben.

Benutze auch hier wieder Vererbung. Diskutiere mit deinem Sitznachbar:innen und/oder deiner/m Tutor:in, wie man an die Attribute der Superklasse kommt, wenn es ein Attribut in der Baseklasse gibt, dass den gleichen Namen trägt."
404,Praktikum: Grundlagen der Programmierung WS24/25,15238,W06H03 - PUM Server Upgrade,"# PUM Server Upgrade

Die Forschuine der PUM sind begeistert von unserem LRZ. Um noch besser forschen zu können, wollen sie nun auch einen eigenen Hochleistungsrechner bauen. Die Softwareuine wurden beauftragt, einige notwendige Komponenten zu implementieren. Als exzellenter Freund unterstützt du sie dabei.

## RingBuffer

Um Daten asynchron zwischen den Server-Nodes hin und her zu senden, benötigen die Pinguine einen effizienten Buffer, genauer einen `RingBuffer`. Ein `RingBuffer` wird mit seiner Kapazität initialisiert (das ist die maximale Anzahl an Einträgen, die gespeichert werden kann). In den `RingBuffer` können dann Werte gelegt (`put(int)`) und aus ihm wieder entnommen (`get()`) werden.

Hier siehst du eine Visualisierung eines `RingBuffer`s:

   

Wie du siehst, speichern wir die Werte in einem Array (`mem`). Um festzuhalten, in welchem Bereich valide Daten gespeichert sind, benutzen wir die beiden Felder `in` und `out`. `in` speichert dabei den Index, an dem der nächste Wert, der via `put(int)` eingefügt werden soll, in `mem` abgespeichert wird. `out` zeigt auf den Index, von dem bei der nächsten `get()`-Operation gelesen wird. Durch eine Sequenz von `put`- und `get`-Operationen kann dieser Bereich also durch das Array ""wandern"", auch über die Grenzen des Arrays hinaus. Dazu musst du dir vorstellen, dass das Array ein Ring ist. Wir interpretieren also `mem[0]` als Nachfolger von `mem[mem.length-1]` und `mem[mem.length-1]` als Vorgänger von `mem[0]`.

Die folgenden Teilaufgaben beschreiben die Implementierung step-by-step:

1. [task][Als aller Erstes!]( 240659 )
Lies dir zunächst die folgenden Teilaufgaben durch und erstelle erst die erforderten Methoden, um sie anschließend zu implementieren. So hast du schonmal Code, den Artemis kompilieren und testen kann. Dies bezieht sich auch auf die Methoden, die in `MultiStack` implementiert werden müssen.
2. [task][Implementiere die Methode isEmpty!]( 240635 )
Erstelle die Methode `isEmpty`, die einen `boolean` zurückgeben soll: `true` - keine Einträge im `RingBuffer` gespeichert, `false` - einer oder mehr Einträge im `RingBuffer` gespeichert.
3. [task][Implementiere die Methode isFull!]( 240651 )
Erstelle die Methode `isFull`, die einen `boolean` zurückgeben soll: `true` - der `RingBuffer` speichert die maximale Anzahl von Einträgen, `false` - der `RingBuffer` speichert weniger als die maximale Anzahl von Einträgen.
4. [task][Implementiere die Methode put!]( 240628 , 240630 , 240629 , 240641 )
Erstelle die Methode `put`, die einen `int` erwartet, um diesen im `RingBuffer` zu speichern. Sollte der Buffer voll sein, dürfen keine Werte in den Buffer eingefügt werden, stattdessen akzeptiert der `RingBuffer` den neuen Wert nicht. Ist das Speichern erfolgreich, soll der `boolean` `true` zurückgegeben werden, andernfalls `false`.
5. [task][Implementiere die Methode get!]( 240634 , 240645 , 240631 )
Erstelle die Methode `get`, die einen `int` zurückgeben soll. Wenn möglich soll der Wert zurück gegeben werden, der am längsten im `RingBuffer` liegt - dieser wird dann auch aus dem aktuellen Speicherbereich des Buffers entfernt - andernfalls erwarten wir den Default-Rückgabewert `Integer.MIN_VALUE`.
6. [task][Konstruktor & Performance!]( 240642 , 240647 )
Der erste Test dient nur als Sicherheit, damit du sofort erkennst ob du ausversehen den Konstruktor verändert hast. Mach dir aber nicht zu viele Gedanken. Entscheidend ist nur, dass du nicht zu viele irrelevante Operationen ausführst (z.B. Kopien des Arrays erstellst).

## MultiStack

Die Pinguine möchten auf ihrem HPC natürlich viele Java-Programme ausführen. Um komplexere Programme entwickeln zu können, benötigen sie einen Stack, der mehr Daten speichern kann. Ein erster Prototyp dafür soll in den folgenden Teilaufgaben entwickelt werden.

`MultiStack` nutzt die Klasse `Stack`, in der die Daten gespeichert werden. Jeder `Stack` ist dabei wie ein Listen-Element und enthält, abgesehen von dem Array `mem` (zum Speichern der Daten) und `top` (um auf den obersten Wert dieses `Stack`s zu zeigen), auch eine Referenz auf einen (möglichen) Nachfolger-`Stack`. Der Beginn dieser Liste von `Stack`s wird als Referenz `stacks` in `MultiStack` gespeichert.

   


1. [task][Als aller Erstes!]( 240658 , 240656 )
Lies dir zunächst die folgenden Teilaufgaben durch und erstelle erst die erforderten Methoden, um sie anschließend zu implementieren. So hast du schonmal Code, den Artemis kompilieren und testen kann.
2. [task][Implementiere die Methode Push!]( 240638 , 240637 , 240646 , 240640 )
Erstelle die Methode `push`, die einen `int` auf den `MultiStack` legen soll. Dabei soll wie folgt vorgegangen werden: Da der Wert in der Liste aus `Stack`s gespeichert wird, müssen wir zunächst den Ort finden, an dem der Wert abgelegt werden soll. Dazu starten wir bei dem ersten `Stack`. Ist dieser bereits gefüllt, führen wir unsere Suche im Nachfolger (`next`) fort bis wir uns im passenden `Stack` befinden. Sollten alle `Stack`s gefüllt sein, müssen wir einen neuen `Stack` mit der doppelten Kapazität des Vorgängers erstellen (Je weiter du durch die Liste iterierst, desto größer werden die Stacks - Faktor 2). Da wir nun den richtigen `Stack` gefunden oder initialisiert haben, können wir in dem entsprechenden `Stack` den Wert in `mem` speichern und das Feld `top` anpassen. *Tipp:* Dieses Verfahren kann am einfachsten rekursiv implementiert werden, d.h. der `MultiStack` ruft die gleichnamige rekursive Methode in `Stack` auf. (Rekursion ist hier aber nicht unbedingt verlangt.)
3. [task][Implementiere die Methode Top!]( 240650 , 240648 , 240632 , 240652 )
Erstelle die Methode `top`, die den Wert (`int`) zurückgeben soll, der ganz oben auf dem `MultiStack` liegt. (Das ist der Wert, der als letztes eingefügt wurde.) Der Wert soll dabei *NICHT* entfernt werden. Ist der Stack leer, erwarten wir den Default-Rückgabewert `Integer.MIN_VALUE`. *Tipp:* Auch diese Teilaufgabe lässt sich sehr einfach rekursiv lösen.
4. [task][Implementiere die Methode pop!]( 240643 , 240636 , 240633 , 240644 )
Erstelle die Methode `pop`, die den Wert (`int`) zurückgeben *UND* entfernen soll, der ganz oben auf dem `MultiStack` liegt. (Das ist der Wert der als letztes eingefügt wurde.) Ist der letzte Stapel der `Stack`-Liste leer, soll dieser aus der Liste gelöscht werden. Ausgenommen ist davon der erste Stack mit Kapazität `1`. Dieser soll immer erhalten bleiben, auch wenn er aktuell keine Werte speichert. (Mach dir gerne Gedanken darüber, warum.) Ist der Stack leer, erwarten wir den Default-Rückgabewert `Integer.MIN_VALUE`. *Tipp:* Wie du dir bestimmt denken kannst, kannst du auch diese Teilaufgabe durch eine rekursive Methode in `Stack` lösen.
5. [task][Implementiere den Konstruktor von Multistack!]( 240692 )
Der Test dient nur als Sicherheit, damit du sofort erkennst ob du ausversehen den Konstruktor verändert hast.

Viel Erfolg!"
404,Praktikum: Grundlagen der Programmierung WS24/25,15239,W06H02 - Saleuine Grosshandel,"# Saleuine Großhandel
Seitdem du Claudia und Karl-Heinz mit ihrem Fischmarkt geholfen hast, ist einige Zeit vergangen. Das Geschäft läuft sehr gut und die Saleuine haben einen fairen Preis für ihre Produkte gefunden. Jetzt haben sie sich entschieden, ihr Angebot dem globalen Pinguinmarkt zu öffnen, was jedoch mit einigen neuen Pflichten verbunden ist. Um nämlich im Großhandel mitzuspielen, müssen einige Auflagen der Pinguinbehörden erfüllt werden. So müssen z.B. Sardellen ein gewisses Alter und Gewicht erreicht haben, bevor sie verkauft werden dürfen. Außerdem müssen Claudia und Karl-Heinz jederzeit eine Statistik über nicht genutztes Essen abgeben können. Die beiden haben sich auch schon eine Struktur überlegt, wie sich das umsetzen lässt, brauchen für die Implementierung allerdings wieder deine Hilfe!

---

**Hinweis:** Die Tests sind diese Woche bemüht die Struktur inkrementell zu testen, damit ihr nicht erstmal alle Klassen und Signaturen erstellen müssen, wunder dich also nicht über die ganzen verschiedenen Fehlermeldungen und arbeite einfach die Aufgaben nacheinander ab. Außerdem ist diese Aufgabe bewusst freier gestellt und gibt euch bei der Implementierung mehr Freiheit. Die Tests sind dafür extra robust gebaut und geben euch (soweit möglich) sehr detailliertes Feedback.  


### PinguFood
Zuerst bitten sie dich, eine praktikable Darstellung für ihre angebotenen Waren zu implementieren:

@startuml

class PinguFood {
- age: int
- weight: int
+ isEdible(): boolean
+ toString(): String
}

class Anchovie extends PinguFood {
- {static} MIN_AGE: int
- {static} MIN_WEIGHT: int
}

class Crustacean extends PinguFood {
}

class Sardine extends PinguFood {
- {static} MIN_AGE: int
- {static} MIN_WEIGHT: int
- {static} MIN_LENGTH: int
- length: int
}

@enduml

- [task][PinguFood Struktur, Konstruktor und Getter]( 240735 , 240719 , 240722 )
  Implementiere die im UML-Diagramm angegebenen Attribute, zugehörigen Getter und einen Konstruktor, der initiale Werte für `age` und `weight` (in dieser Reihenfolge) erwartet. Du kannst außerdem davon ausgehen, dass dem Konstruktor nur sinnvolle Werte übergeben werden. Gleiches gilt für alle Konstruktoren dieser Aufgabe.
    - `age` wird in dieser Aufgabe in Jahren und `weight` in (ganzen) Gramm angegeben.

- [task][Anchovie Konstanten und Konstruktor]( 240703 , 240718 , 240731 )
  Der Konstruktor von `Anchovie` soll die gleichen Parameter wie der von `PinguFood` übernehmen.
  Die groß geschriebenen und unterstrichenen Variablen im UML-Diagramm sind `static` Konstanten. Du musst sie direkt bei der Deklaration initialisieren.
    - `MIN_AGE` soll *1* betragen
    - `MIN_WEIGHT` soll *5* betragen

- [task][Crustacean Konstruktor]( 240699 , 240725 )
  Wenn von Krustentieren als PinguFood die Rede ist, so ist vor allem Krill gemeint. Deshalb übernimmt der Konstruktor von `Crustacean` lediglich einen Wert für `weight`. `age` soll hingegen immer mit *0* initialisiert werden.

- [task][Sardine Attribute, Konstanten und Konstruktor]( 240723 , 240729 , 240696 , 240714 )
  Implementiere die für `Sardine` im UML-Diagramm gegebenen Attribute und Konstanten, sowie einen Konstruktor, der nach Werten für `age` und `weight` auch einen für `length` erwartet (in dieser Reihenfolge), und die Getter-Methode für `length`.
    - `MIN_AGE` soll *1* betragen
    - `MIN_WEIGHT` soll *100* betragen
    - `MIN_LENGTH` soll *14* betragen

- [task][isEdible]( 240706 , 240730 , 240693 , 240713 )
  Die `isEdible`-Methode gibt an, ob die Nahrung gemäß den Pingurichtlinien verkauft und gegessen werden darf.
    - Da `PinguFood` erst zugelassen werden muss, soll diese Methode standardmäßig `false` zurückgeben.
    - `Anchovie` dürfen nur verkauft und gegessen werden, sobald sie das vorgeschriebene Mindestalter (`MIN_AGE`) und -Gewicht (`MIN_WEIGHT`) erreicht haben.
    - `Crustacean` dürfen immer verkauft und gegessen werden.
    - Wie `Anchovie` sind auch `Sardine` nur dann für den Verkauf und Verzehr freigegeben, wenn sie die entsprechenden Auflagen erfüllen. In diesem Fall also Mindestalter, -Gewicht und -Länge.

- [task][toString]( 240702 , 240709 , 240694 , 240720 )
  Implementiere jetzt die `toString`-Methode wie folgt:
    - Für `PinguFood` sollen die allgemein verfügbaren Informationen wie folgt zurückgeben werden:  Alter:⎵ \ ⎵Jahre,⎵Gewicht:⎵ \ g 
    - Für `Anchovie` soll folgendes zurückgegeben werden:  Sardelle(Alter:⎵ \ ⎵Jahre,⎵Gewicht:⎵ \   g)  
    - Für `Crustacean` dies:  Krill( \ g)  
    - Und für `Sardine`:  Sardine(Alter:⎵ \ ⎵Jahre,⎵Gewicht:⎵ \ g,⎵Länge:⎵ \ ) 


### TradeOrder
Nun, da die verschiedenen Waren implementiert sind, kannst du dich den Bestellungen widmen. Claudia und Karl-Heinz bieten drei verschiedene Bestellungstypen an: Einzeltier Bestellungen (`TradeOrder`), Zielgewicht Bestellungen (`WeightOrder`), sowie Mengen-Bestellungen (`AmountOrder`). Auch hier haben sie dir den ersten Schritt abgenommen und stellen dir eine passende Hierarchie zur Verfügung:

@startuml

class TradeOrder {
- totalCost: BigDecimal
- currentWeight: int
+ supplyOrder(supply: PinguFood, cost: BigDecimal): boolean
+ isOrderFulfilled(): boolean
+ orderType(): String
+ toString(): String
}

class WeightOrder extends TradeOrder {
- targetWeight: int
}
class AmountOrder extends TradeOrder {
- targetAmountAnchovies: int
- targetAmountCrustaceans: int
- targetAmountSardines: int
- currentAmountAnchovies: int
- currentAmountCrustaceans: int
- currentAmountSardines: int
}

@enduml

Wie du schon im UML-Diagramm erkennen kannst, haben Claudia und Karl-Heinz aus Woche 05 gelernt und verwenden kein `double` mehr, um Geldbeträge zu speichern. Stattdessen setzen sie auf deine gesammelte Erfahrung und lassen dich mit `BigDecimal` arbeiten. `BigDecimal`-Objekte sind unveränderlich. Jede Operation erzeugt ein neues `BigDecimal`-Objekt. Um `double` in  `BigDecimal` umzuwandeln, gibt es die Methode `BigDecimal.valueOf()`. Operationen werden mittels `bigDecimal1.operation(bigDecimal2);` ausgeführt (`operation` duch entsprechenden Funktionsnamen ersetzen). Welche Operationen und nützlichen Konstanten es gibt, kannst du in der [JavaDoc]( https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigDecimal.html) nachlesen.

Mit diesen Informationen ausgestattet kannst du jetzt auch mit der Implementierung fortfahren.

- [task][Order Struktur und Konstruktoren]( 240717 , 240710 , 240704 , 240707 , 240697 , 240711 )
  Implementiere die drei im UML-Diagramm gegebenen Klassen mit den angegebenen Attributen. Die `targetXXX` Attribute sollen dabei `final` sein. Für die Konstruktoren soll gelten:
    - `TradeOrder`: keine Parameter, `totalCost` und `currentWeight` werden mit *0*, bzw. dem `BigDecimal` equivalent initialisiert.
    - `WeightOrder`: erwartet einen initialen Wert für `targetWeight`
    - `AmountOrder`: erwartet initiale Werte für die `target`-Attribute in alphabetischer Reihenfolge (Anchovies, Crustaceans, Sardines). Die `current`-Attribute werden mit *0* initialisiert.

- [task][orderType]( 240726 , 240698 , 240712 )
  Implementiere jetzt die Methode `orderType`, sodass sie je nach aufrufendem Objekt folgende Strings zurückgibt:
    - für `TradeOrder`:  Einzeln 
    - für `WeightOrder`:  Zielgewicht:⎵ \ g 
    - für `AmountOrder`:  Anzahl:⎵[ \ , \ , \ ] 

- [task][toString]( 240716 , 240708 , 240724 )
  Implementiere jetzt die Methode `toString`, so dass je nach aufrufendem Objekt folgende Strings zurückgegeben werden:
    - `TradeOrder`:  Die⎵Bestellung(Einzeln)⎵hat⎵ein⎵Gesamtgewicht⎵von⎵ \ g⎵und⎵kostet⎵ \ PD. 
    - `WeightOrder`: Die⎵Bestellung(Zielgewicht:⎵ \ g)⎵hat⎵ein⎵Gesamtgewicht⎵von⎵ \ g⎵und⎵kostet⎵ \ PD. 
    - `AmountOrder`:  Die⎵Bestellung(Anzahl:⎵[ \ , \ , \ ])⎵hat⎵ein⎵Gesamtgewicht⎵von⎵ \ g⎵und⎵kostet⎵ \ PD. 

- [task][isOrderFulfilled]( 240728 , 240721 , 240701 )
  Die Methode `isOrderFulfilled` soll `true` zurückgeben, falls alle für die Bestellung relevanten Lieferungen eingegangen sind (was später mit `supplyOrder` passieren wird). Genauer heißt das:
    - `TradeOrder`: es wurde bereits ein `PinguFood`-Objekt geliefert.
    - `WeightOrder`: mindestens das geforderte Gewicht wurde erreicht.
    - `AmountOrder`: die geforderten Mengen für Sardellen, Krustentiere und Sardinen wurden erreicht.

- [task][supplyOrder]( 240705 , 240715 , 240695 )
  Die Methode `supplyOrder` erhält von unseren Saleuinen ein Objekt von Typ `PinguFood`, sowie die entsprechenden Kosten und soll damit die entsprechende Bestellung aktualisieren. Die Bestellung wird nicht aktualisiert, falls 1.) die Bestellung bereits erfüllt ist (oder in dem Fall, dass für `AmountOrder` z.B. ein `Anchovie`-Objekt übergeben wird und `targetAmountAnchovies` bereits erreicht wurde. Entsprechendes gilt natürlich auch für `Crustacean` und `Sardine`) oder 2.) das übergebene `PinguFood` nicht zum Verzehr geeignet ist. In diesen Fällen soll `false` zurückgegeben werden, sonst `true`.

Damit hast du nun auch die Bestellungen vollständig implementiert. Jetzt fehlt noch das Logistikzentrum von Claudia und Karl-Heinz.

### PinguFoodLogistics
Für ihr Logistikzentrum geben dir Claudia und Karl-Heinz folgendes Diagramm vor:

@startuml

class PinguFoodLogistics {
- orderBook: TradeOrderQueue
- ppgAnchovies: BigDecimal
- ppgCrustaceans: BigDecimal
- ppgSardines: BigDecimal
+ acceptNewOrder(order: TradeOrder): void
+ clearOrderBook(): void
- registerUnusedFood(food: PinguFood): void
+ printWasteStatistics(): void
}

@enduml

**Hinweis:** Die Klasse `PinguFoodLogistics` erhältst du bereits als Teil des Templates zusammen mit einigen Methoden, die es dir erlauben, Sardellen, Krustentiere und Sardinen gezielt oder zufällig zu erstellen. Es ist wichtig, dass du nichts an diesen Methoden änderst, da die Tests sonst falsche Ergebnisse liefern und du Punkte verlierst. (Um Compilerfehler im Template zu vermeiden und dir das Testen unfertiger Implementierungen zu ermöglichen, sind die Methoden auskommentiert. Du kannst den Kommentarblock entfernen, sobald die Konstruktoren von `PinguFood` und den zugehörigen Unterklassen implementiert sind.)

- [task][PinguFoodLogistics Konstruktor]( 240734 , 240739 )
  Implementiere die im UML-Diagramm angegebenen Attribute, sowie einen Konstruktor, der initiale Werte für `ppgAnchovies`, ` ppgCrustaceans` und `ppgSardines` übernimmt (in dieser Reihenfolge). *ppg* steht dabei für „price per gram“.
    - Die Klasse `TradeOrderQueue` erhälst du bereits als Teil des Templates. Sie bietet alle für die Aufgabe benötigten Methoden (Konstruktor, `isEmpty`, `size`, `add`, `poll`), die wie in der Standard Java [Queue](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Queue.html) bzw. wie in der P-Aufgabe Pinguin Parade funktionieren.
    - Die Klasse ist nur dazu da, dass du nicht mit *Generics* arbeiten musst, die noch nicht in der Vorlesung oder den P-Aufgaben besprochen wurden.
    - Solltest du bereits mehr Erfahrung haben und Generics schon kennen, verwende trotzdem die vorgegebene Klasse. Andernfalls werden die Tests nicht funktionieren.

- [task][acceptNewOrder]( 240740 )
  `acceptNewOrder` soll das übergebene `TradeOrder`-Objekt dem `orderBook` am Ende hinzufügen.

- [task][registerUnusedFood und printWasteStatistics]( 240737 , 240741 )
  Die Methoden `registerUnusedFood` und `printWasteStatistics` sollen Auskunft über bisher beim Abarbeiten von Bestellungen ""verschwendetes"" (bzw. ungenutztes) Essen geben. Es sollen dabei Stückzahl und Gesamtgewicht des bisher ungenutzten `PinguFood`s, sowie der durch Nichtverkauf dieser Waren eingebußte Profit aufsummiert ausgegeben werden können.
  `registerUnusedFood` übernimmt dabei ein Objekt von Typ `PinguFood`. Dieses repräsentiert eine Ware, die nicht mehr verwendet wird/werden kann. Die Methode ist dafür zuständig, die später für `printWasteStatistics` benötigten Informationen über diese Ware abzuspeichern.
    - `printWasteStatistics` soll folgende Ausgabe auf der Konsole erzeugen:   Bisher⎵konnten⎵ \ ⎵Tiere⎵mit⎵einem⎵Gesamtgewicht⎵von⎵ \ g⎵nicht⎵verwertet⎵werden.\nClaudia⎵und⎵Karl-Heinz⎵ist⎵dadurch⎵ein⎵Profit⎵von⎵ \ PD⎵entgangen. 
    - Der Wert eines `PinguFood`-Objekts berechnet sich durch *weight\*ppg*
    - Die Statistik über ungenutztes `PinguFood` wird nie zurückgesetzt!
    - Für die Ausgabe soll nicht gerundet werden (was dank `BigDecimal` auch nicht notwendig ist).

- [task][clearOrderBook]( 240732 , 240733 )
  Jetzt bist du fast am Ziel. Es fehlt nur noch die Methode `clearOrderBook`. Diese soll folgendes machen:
    - Die Anzahl der Bestellungen wird wie folgt auf der Konsole ausgegeben:  Es⎵können⎵ \ ⎵Bestellungen⎵abgearbeitet⎵werden. 
    - Die Bestellungen werden der Reihe nach abgearbeitet. Dabei ist es wichtig, dass so wenig `PinguFood` wie möglich verschwendet wird. Unsere Saleuine haben bisher leider keine Methode entwickelt, in ihrem Logistikzentrum zu testen, ob `PinguFood` essbar ist. Daher wird jedes von ihnen erzeugte `PinguFood` immer an die aktuell abgearbeitete Bestellung übergeben und sie erfahren erst im Nachhinein, ob es zur Erfüllung der Bestellung nutzbar war. Claudia und Karl-Heinz ist aufgefallen, dass du das Ganze auch so implementieren kannst (und deshalb auch sollst), dass kein essbares `PinguFood` verloren geht.
    - Claudia und Karl-Heinz wollen den Mix aus `PinguFood` immer so groß wie möglich halten, weshalb sie außer bei `AmountOrder` immer zufälliges `PinguFood` verschicken. Bei `AmountOrder` erfüllen sie erst den vollständigen Bedarf an `Anchovie`, dann an `Crustacean` und schließlich an `Sardine`.
    - Nachdem eine Bestellung abgearbeitet wurde, wird die Information der Bestellung (`toString`) auf der Konsole ausgegeben.
    - Vergiss nicht, ungenutztes `PinguFood` in die Statistik aufzunehmen!
    - Bei Bestellungen des Typs `WeightOrder` lässt es sich dabei nicht vermeiden, dass das erwünschte Gewicht (deutlich) überschritten wird, was allerdings einkalkuliert und kein Problem ist.
    - Es gibt vier Methoden zum Erstellen von `PinguFood` (siehe Hinweis weiter oben). Du solltest alle vier benutzen.
    - **Hinweis:** die Zufallszahlen, mit deren Hilfe die gegebenen Methoden `PinguFood` generieren, werden standardmäßig bei jedem Programmstart in der selben Reihenfolge generiert. Dadurch kannst du dein Programm besser testen. 
    
 
  Dieses Beispiel befindet sich im Template 

```java
PinguFoodLogistics market = new PinguFoodLogistics(BigDecimal.ONE, BigDecimal.valueOf(0.5), BigDecimal.valueOf(2));
market.acceptNewOrder(new TradeOrder());
market.acceptNewOrder(new WeightOrder(1000));
market.acceptNewOrder(new AmountOrder(2, 2, 2));
market.clearOrderBook();
market.printWasteStatistics();
```

 
 
  Und das ist der zugehörige Output (je nachdem wie die BigDecimal-Werte berechnet werden kann es sein, dass bei ganzzahligen Werten "".0"" angefügt wird. Dies ist aber OK und wird von den Tests berücksichtigt) 

```bash 
Es können 3 Bestellungen abgearbeitet werden.
Die Bestellung(Einzeln) hat ein Gesamtgewicht von 116g und kostet 232PD.
Die Bestellung(Zielgewicht: 1000g) hat ein Gesamtgewicht von 1076g und kostet 1592.5PD.
Die Bestellung(Anzahl: [2,2,2]) hat ein Gesamtgewicht von 593g und kostet 1103.5PD.
Bisher konnten 28 Tiere mit einem Gesamtgewicht von 3679g nicht verwertet werden.
Claudia und Karl-Heinz ist dadurch ein Profit von 7293PD entgangen.
```
 

Desweiteren nützlich für das Lösen dieser Aufgabe könnte der [instanceof](https://www.javatpoint.com/downcasting-with-instanceof-operator)-Operator sein.

### FAQ

- **Wann wird PinguFood verschwendet?** Pingu Food wird immer dann verschwendet, wenn es von einer Bestellung nicht angenommen wird. Bei korrekter Implementierung trifft dies nur auf nicht-essbares PinguFood zu.
- **Bei meiner Ausgabe des Beispiels wird hinter BigDecimal-Werte `.0` eingefügt (z.B. ""... kostet 232.0PD""). Ist das ein Problem?** Solange die Zahlen equivalent sind ist das kein Problem und wird von den Tests berücksichtig.
- **Soll ich Methode XY so und so implementieren?** Diese Aufgabe ist bewusst freier formuliert. Wichtig ist, dass eine Methode das geforderte Verhalten hat. Wie du dieses Verhalten genau implementierst, bleibt dir überlassen und wir werden dazu keine Fragen beantworten.
- **Wo sollen die Unterklassen implementiert werden?** Jede Unterklasse erhält eine eigene Datei. Jede dieser Dateien ist in dem Package der Aufgabe abzugeben. Dies ist in PGdP immer der Fall, es sei denn die Aufgabenstellung verlangt etwas anderes.
- **Soll die Statistik zu verschwendetem `PinguFood` über alle Instanzen gelten?** Nein, jede Instanz von `PinguFoodLogistics` hat ihre eigene Statistik. Diese wird nie zurückgesetzt.
- **Was sind die Einheiten der verschiedenen `TradeOrder`-Klassen?** `TradeOrder` und `AmountOrder` arbeiten mit Stückzahlen, wobei jedes `PinguFood`-Objekt genau Anzahl eins hat. `WeightOrder` arbeitet mit Gewicht.
- **Darf ich zusätzliche Attribute oder Methoden implementieren?** Ja!
- **Muss bei WeightOrder das Zielgewicht direkt getroffen werden? Darf das Zielgewicht überschritten werden und was muss der Kunde dann Zahlen?** Ja, das Zielgewicht darf überschritten werden und muss nicht direkt getroffen werden. Zu zahlen ist der vollständige Preis aller zur Erfüllung der Bestellung verwendeter PinguFood-Objekte. Beispiel: WeightOrder(1000) hat bisher PinguFood mit einem Gesamtgewicht von 975g mit Kosten von 10PD erhalten. Jetzt erhält die Bestellung eine Lieferung (supplyOrder) mit einem 50g schweren, essbaren PinguFood für 1PD. Dann wird die Bestellung aktualisiert und ist mit einem Gesamtgewicht von 1025g und Kosten von 11PD vollständig erfüllt.


 
  Bezüglich dem Überschreiben bzw. instancof  
Um Fragen darüber, wann man eine Methode überschreibt und wann man instanceof nutzt vorzubeugen habe ich hier ein kleines Beispiel zur Erklärung vorbereitet:

```java
public class ParentClass {
	public String description;

	public String toString() {
		return ""Beschreibung: "" + description;
	}

	public boolean someMethod() {
		return true;
	}

	public String badMethod() {
		if (this instanceof GoodClass) {
			return ""GoodClass"";
		} else if (this instanceof BadClass) {
			return ""BadClass"";
		} else {
			return ""ParentClass"";
		}
	}

	public void goodMethod(ParentClass other) {
		if (other instanceof GoodClass good) {
			// Do something with  
		} else if (other instanceof BadClass bad) {
			// Do something different with  
		} else {
			// Do something completely different
		}
	}
}

public class GoodClass extends ParentClass {
public boolean feature;

	@Override
	public String toString() {
		return ""good use!"" + super.toString();
	}
}

public class BadClass extends ParentClass {

	@Override
	public String toString() {
		return ""Beschreibung: "" + description;
	}

	@Override
	public boolean someMethod() {
		return true;
	}
}
```

- toString: In GoodClass wird die Rückgabe von ParentClass erweitert, weshalb es sinnvoll ist die Methode hier zu überschreiben. Durch den super.toString-Aufruf können wir uns hier außerdem duplizierten Code spaaren. In BadClass hingegen wird keine Funktionalität hinzugefügt, sondern die exakte Implementierung aus der ParentClass kopiert. Hier könnten wir uns die Methode also sparen.
- someMethod: Die Methode sollte immer true zurückgeben. Da wir hier also keine Funktionalität in den Unterklassen erweitern wollen, sollten wir sie auch nicht überschreiben (wie in GoodClass). In BadClass haben wir wieder unnötigen, duplizierten Code.
- badMethod: Diese Methode gibt je nach Klasse des aufrufenden Objekts einen anderen String aus. Die Funktionalität ist also für jede Klasse anders. Deshalb wäre es hier sinnvoll, die Methode in den Unterklassen zu überschreiben und jeweils nur den entsprechenden String zurückzugeben. Dadurch lässt sich auch die Verwendung von instancof vermeiden.
- goodMethod: Diese Methode interagiert mit einem anderen ParentClass Objekt und hat unterschiedliche Funktionalität in Abhängigkeit vom Typ des übergebenen Objektes. Hier können wir instancof nutzen, um zwischen den verschiedenen Typen zu unterscheiden. Außerdem erlaubt uns die Nutzung ein sicheres Casten zum jeweiligen Typ. Ein Überschreiben wäre nicht sinnvoll, da die Funktionalität nicht von der aufrufenden Instanz, sondern dem übergebenen Parameter abhängig ist. 

Abschließend noch ein Hinweis zu instanceof: object instanceof ParentClass wertet auch zu true aus, wenn object die Instanz einer Unterklasse ist!"
404,Praktikum: Grundlagen der Programmierung WS24/25,15341,W07P01 - Generischer Stack,"# Der Stack
Stacks eignen sich, um Objekte abzulegen, welche man in umgekehrter Reihenfolge wieder aufnehmen möchte. Das Prinzip nennt sich ""Last In First Out"" kurz LIFO. Der Stack unterstützt im Grunde zwei wichtige Operationen:

## **TIPP**
Da die Pinguine bisher noch keine Erfahrung mit Collections haben, werfen wir einen Blick auf die
`private final LinkedList  stackList  = new LinkedList<>();`, schaut euch dazu
https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/LinkedList.html
 an und überlegt euch, welche Methoden ihr verwenden würdet, um die Aufgaben zu lösen!

[task][Push]( 243821 )
  Mit dieser Operation werden Elemente in den Stack geschrieben. Wenn ein Element mit `push()` auf den Stack geschrieben wird, findet man dies an oberster Stelle des Stacks. (gleicher Test wie pop)
  
[task][Pop]( 243821 )
  Dies ist die Gegenoperation zu `push()`. Mit `pop()` wird das oberste Element vom Stack entfernt und zurück gegeben. Falls es keine Elemente mehr auf dem Stack gibt, soll `null` zurück gegeben werden. (gleicher Test wie push)
  

# Generics
Letzter Woche haben wir unsere Klasse List verwendet um unsere Stack für Strings zu implementieren, das war aber nicht general genug und wenn wir ein neues Datentyp in Stack speichern wollen würden, müssten wir eine neue Stack explizit dafür schreiben. Deswegen verwenden wir dieses Mal generics.   

[task][Beipiel]( 243819 )

Im Folgenden ist beispielhaft die Priorisierung der Hausaufgaben eines Erstsemesters dargestellt:
```
 Stack  stack = new Stack<>();

        stack.push(""A"");
        stack.push(""B"");
        stack.push(""C"");
        stack.push(""D"");

        System.out.println(stack.pop());
        System.out.println(stack.pop());

        stack.push(""E"");

        System.out.println(stack.pop());
        System.out.println(stack.pop());

        stack.push(""F"");
        stack.push(""G"");

        System.out.println(stack.pop());
        System.out.println(stack.pop());

        stack.push(""H"");

        System.out.println(stack.pop());
        System.out.println(stack.pop());
```
 
 So sollte das Ergebnis aussehen. (zum Ausklappen hier klicken) 
 
Pushed: A
Pushed: B
Pushed: C
Pushed: D
Popped: D
Popped: C
Pushed: E
Popped: E 
Popped: B 
Pushed: F 
Pushed: G
Popped: G
Popped: F 
Pushed: H
Popped: H 
Popped: A 
 
 

[task][Weitere Tests]( 243818 , 243820 , 243817 , 243816 )
Weitere Tests."
404,Praktikum: Grundlagen der Programmierung WS24/25,15342,W07P03 - Polymorphie,"# Polymorphie

Besprecht mit eurem Tutor folgende Begriffe: Statischer Typ, dynamischer Typ, Methodensignatur,
Überschreiben, Überladen, dynamic Dispatch.

Schaut euch anschließend folgendes Programm an und bestimmt, welche Ausgabe die jeweiligen Aufrufe
erzeugen unter der Annahme, dass jeweils nur ein Ausdruck einkommentiert ist.

Begründet außerdem euer Ergebnis, indem ihr eine Tabelle mit folgenden Spalten ausfüllt:
- Aufruf (die im Kommentar angegebene Nummer)
- Zeilennummer (die Zeilennummer des Aufrufs, der gerade behandelt wird)
- statischer Typ (der statische Typ des Objekts, auf dem aufgerufen wird)
- kompatible Methoden (die Zeilennummern aller Methoden, die gemäß statischem Typ aufgerufen werden könnten)
- statisch gewähle Methode (die Zeilennummer derjenigen Methode, die statisch ausgewählt wird)
- Signatur (die Methodensignatur der statisch gewählten Methode, z.B. `f(B)`)
- Begründung (z.B. `speziellste Signatur` oder `Eindeutig`)
- dynamischer Typ (der dynamische Typ des Objekts, auf dem aufgerufen wird)
- zur Laufzeit ausgeführt (die Zeilennummer derjenigen Methode, die letzendlich ausgeführt wird)
- Begründung (z.B. `static, kein Dispatch` oder `statischer Typ = dynamischer Typ`)
- Ausgabe (die Ausgabe, die durch den Aufruf verursacht wird)

```
01 | public class Poly {
02 |     static class A {
03 |         int x() {
04 |             return 0;
05 |         }
06 | 
07 |         int y = 3;
08 | 
09 |         static void f(A a) {
10 |             System.out.print(a.x() + ""-"");
11 |             a.g(a);
12 |         }
13 | 
14 |         static void f(B b) {
15 |             System.out.print(b.y + ""-"");
16 |             b.g(b);
17 |         }
18 | 
19 |         void g(A a) {
20 |             System.out.println(a.y);
21 |         }
22 | 
23 |         void g(B b) {
24 |             System.out.print(b.y + ""-"");
25 |             this.f(this);
26 |         }
27 |     }
28 | 
29 |     static class B extends A {
30 |         int x() {
31 |             return 1;
32 |         }
33 | 
34 |         int y = 9;
35 | 
36 |         static void f(A a) {
37 |             System.out.print(a.y + ""-"");
38 |             (new A()).g(a);
39 |         }
40 | 
41 |         static void f(B b) {
42 |             System.out.print(b.y + ""-"");
43 |             ((B) b).f((A) b);
44 |         }
45 | 
46 |         void g(A a) {
47 |             System.out.print(a.y + ""-"");
48 |             a.f((B) a);
49 |         }
50 | 
51 |         void g(B b) {
52 |             System.out.print(b.x() + ""-"");
53 |             b.f(b);
54 |         }
55 |     }
56 | 
57 |     public static void main(String[] args) {
58 |         A a1 = new A();
59 |         A a2 = new B();
60 |         B b = new B();
61 | 
62 |         b.f(b); // Aufruf 1
63 |         a1.g(b); // Aufruf 2
64 |         a2.f(b); // Aufruf 3
65 |         a2.g(a1); // Aufruf 4
66 |         a2.f(a2); // Aufruf 5
67 |     }
68 | }
```

*Anmerkung: Zugunsten einer kompakten Darstellung wurden die Klassen alle als Innere Klassen von `Poly` definiert;
damit Sie nur einmal definiert werden und nicht einmal pro Objekt von `Poly`, müssen sie `static` sein.
Das hat aber auf die Ausführung keinen Einfluss. Die Klassen könnten ebenso in getrennten Dateien sein.*


[Lösungsvorschlag](/api/core/files/markdown/Markdown_2022-11-09T10-38-22-906_2db7fea2.pdf)"
404,Praktikum: Grundlagen der Programmierung WS24/25,15343,W07P02 - TUMobile,"# TUMobile

In dieser Aufgabe sollst du die Funktionalität einer Automanufaktur testen.

**WICHTIG:** Die Klassen `Car`, `CarFactory`, `Engine`, `Fueltank` und `Wheel` dürfen unter keinen Umständen verändert werden. Andernfalls wird deine Abgabe mit 0P bewertet.  
**WICHTIG:** Du sollst in dieser Aufgabe keine eigenen Instanzen von `Car`, `CarFactory`, `Engine`, `Fueltank` und `Wheel` erstellen. Die Objekte, mit denen die Tests ausgeführt werden sollen, erhältst du ausschließlich von der `CarFactory`.  
**WICHTIG:** Nutze zum testen bitte nur `@Test`, aber keine weiteren Testmechanismen wie parameterisierte Tests. `@BeforeAll` und `@BeforeEach` können für Testsetups verwendet werden.

Hier findest du ein UML Diagramm, das die Klassen visualisiert. In den folgenden Absätzen werden dir die einzelnen Komponenten detailliert erläutert.

@startuml

class Car {
  + getEngine() : Engine
  + getFueltank() : Fueltank
  + getFrontLeftWheel() : Wheel
  + getFrontRightWheel() : Wheel
  + getRearLeftWheel() : Wheel
  + getRearRightWheel() : Wheel
  + getRange() : double
  + getMaxRange() : double
}

class CarFactory {
  {static}- instance : CarFactory
  {static}+ getInstance() : CarFactory
  + getAssembledCar() : Car
}

class Engine {
  - consumption : double
  + getConsumption() : double
}

class Fueltank {
  - capacity : double
  - fuelLevel: double
  + getCapacity() : double
  + getFuelLevel() : double
  + fill(double) : double
  + consume(double) : double
}

class Wheel {
  - diameter : double
  - width : double
  - pressure : double
  + getDiameter() : double
  + getWidth() : double
  + getPressure() : double
}

Car o--- ""1"" Engine : - engine
Car o--- ""1"" Fueltank : - fueltank
Car o--left- ""4"" Wheel : - frontLeftWheel, frontRightWheel, rearLeftWheel, rearRightWheel

@enduml

## Engine
Die Klasse `Engine` repräsentiert einen Motor, der speichert, wie viele Liter Benzin pro 100km für den Antrieb verbraucht werden (`consumption`). Die Klasse stellt einen Konstruktor `Engine(double)` bereit, der als Eingabe den Verbrauch (`consumption`) erwartet, und einen passenden Getter (`getConsumption()`), der den gespeicherten Wert zurückgibt.

Eine von der Fabrik korrekt hergestellte `Engine` muss stets einen sinnvollen Verbrauch haben, d.h. Motoren können weder ohne Verbrauch fahren noch auf magische Weise Treibstoff generieren.

## Fueltank
Die Klasse `Fueltank` repräsentiert einen Tank, der speichert, wie viele Liter maximal enthalten sein können (`capacity`), sowie den aktuellen Füllgrad (`fuelLevel`) in Litern. Die Klasse stellt einen Konstruktor `Fueltank(double, double)` bereit, der als Eingabe die maximale Kapazität (`capacity` als erstes Argument) und die initiale Betankung (`fuelLevel` als zweites Argument) erwartet. Für beide Attribute werden entsprechende Getter (`getCapacity()` und `getFuelLevel()`) implementiert.

Ein `Fueltank` kann mit der Methode `fill(double)` um die übergebene Menge (`amount`) in Litern betankt werden. Ist `amount` negativ, kann nicht betankt werden, und `amount` wird unverändert zurück gegeben. Ist im Tank noch Platz, wird so viel Sprit wie möglich getankt. Sollte die zu tankende Menge mit dem bereits enthaltenen Sprit die maximale Kapazität überschreiten, wird der Überschuss zurückgegeben. (Bsp: Tank mit 3L Kapazität und 1L Füllung soll mit 6L betankt werden -> Befüllung mit 2L möglich -> Rückgabe 4L Überschuss).

Die Methode `consume(double)` verhält sich genau gegensätzlich. Sie entnimmt dem Tank die übergebene Menge (`amount`) in Litern wenn möglich. Ist `amount` negativ kann nichts entnommen werden und `amount` wird unverändert zurückgegeben. 

## Wheel
Die Klasse `Wheel` repräsentiert ein Rad, welches einen Durchmesser (`diameter`), Breite (`width`) und Luftdruck (`pressure`) in Bar hat. Die Klasse stellt einen Konstruktor `Wheel(double, double, double)` bereit, der als Eingabe die drei eben genannten Attribute erwartet. Für die drei Attribute werden entsprechende Getter (`getDiameter()`, `getWidth()` und `getPressure()`) implementiert.

Im Gegensatz zu Motor und Tank können Räder nie falsch produziert werden. Dies bedeutet insbesondere, dass wir davon ausgehen können, dass Räder nie mit nicht positiven Durchmesser, Breite oder Luftdruck gefertigt werden.

## Car
Die Klasse `Car` repräsentiert ein Auto, welches aus Motor (`engine`), Benzintank (`fueltank`) und vier Rädern (`frontLeftWheel`, `frontRightWheel`, `rearLeftWheel` und `rearRightWheel`) besteht. Die Klasse stellt einen Konstruktor `Car(Engine, Fueltank, Wheel, Wheel, Wheel, Wheel)` bereit, der als Eingabe den Motor (`engine`), Benzintank (`fueltank`), das vordere linke Rad (`frontLeftWheel`), vordere rechte Rad (`frontRightWheel`), hintere linke Rad (`rearLeftWheel`) und zuletzt das hintere rechte Rad (`rearRightWheel`) erwartet.

Ein Auto kann nur dann als valide bezeichnet werden, wenn einige Eigenschaften erfüllt sind. Zunächst sind alle Bauteile (Motor, Tank und Räder) essentiell, d.h. keines der Bauteile darf fehlen.

Der Motor (`engine`) als auch der Tank (`fueltank`) müssen korrekt produziert worden sein.

Wir haben gesehen, dass Räder im Gegensatz zu Motor und Tank nie falsch produziert werden können. Bei der Montage können jedoch Fehler passieren. Für das Auto ist es wichtig, dass vier Reifen verbaut wurden, die sowohl den gleichen Durchmesser (`diameter`) als auch Breite (`width`) haben. Der Reifendruck kann durchaus unterschiedlich sein. Wichtig ist auch, dass ein Reifen nur einmal verbaut werden kann, d.h. er kann nicht an mehreren Radaufhängungen angebracht werden.

Die Methode `getRange()` gibt die Reichweite aus, die das Auto mit dem aktuellen Füllstand fahren kann. Hierfür wird die aktuelle Füllmenge des Tanks durch den Verbrauch des Motors geteilt und mit `100` mulipliziert.

Die Methode `getMaxRange()` gibt die maximale Reichweite zurück, die das Auto zurücklegen kann. Hierfür wird die maximale Füllmenge des Tanks durch den Verbrauch des Motors geteilt und mit `100` multipliziert.

## CarFactory
Die Klasse `CarFactory` ist die Fabrik, in der die Autos produziert werden. Diese existiert nur einmal weltweit. Um die Referenz auf die Fabrik zu erhalten, stellt die Klasse die statische Methode `getInstance()` zur Verfügung, die dir die `CarFactory` zurückgibt. Um ein Auto zu erhalten, das von der Manufaktur produziert wurde, gibt es die Methode `getAssembledCar()`, die dir das Auto `Car` zurückliefert.

## Aufgabe

[task][TUMobileTest]()
Implementiere in der Klasse `TUMobileTest` einige JUnit Tests, um die produzierten Autos und deren Bauteile auf Korrektheit zu überprüfen. Wie schon bei den Hausaufgaben wird die `CarFactory` verschiedene fehlerhafte Autos produzieren, die du mithilfe deiner Tests erkennen musst.  

**WICHTIG:** Die Klassen `Car`, `CarFactory`, `Engine`, `Fueltank` und `Wheel` dürfen unter keinen Umständen verändert werden. Andernfalls wird deine Abgabe mit 0P bewertet.  
**WICHTIG:** Du sollst in dieser Aufgabe keine eigenen Instanzen von `Car`, `CarFactory`, `Engine`, `Fueltank` und `Wheel` erstellen. Die Objekte mit denen die Tests ausgeführt werden sollen, erhältst du ausschließlich von der `CarFactory`.  
**WICHTIG:** Nutze zum testen bitte nur `@Test`, aber keine weiteren Testmechanismen wie parameterisierte Tests. `@BeforeAll` und `@BeforeEach` können für Testsetups verwendet werden."
404,Praktikum: Grundlagen der Programmierung WS24/25,15354,W07H02 - FlipperFlow,"### FlipperFlow: Ein zweidimensionales Grid zur Simulation eines Stromkreise

In dieser Übung hat der äußerst kluge Elektroingenieur Donald Duck sein Programmierprojekt an unsere fantastischen Pinguine ausgelagert. Seine Aufgabe besteht darin, für einen gegebenen Stromkreis die Spannung und Stromstärke an jedem Bauteil zu ermitteln. Unsere Pinguine haben diese Herausforderung angenommen, um ihre Fähigkeiten in Polymorphie und Generics in der objektorientierten Programmierung zu perfektionieren – ein leichtes Spiel für sie!


Die Simulation besteht aus zwei Teilen. Die Elemente von dem Stormreis werden erst in einem Grid platziert. Da geht es um ihre Position im Stromkreis zu bestimmen. Aus dem Grid wird berechnet, welche Elemente zusammengeschaltet sind; und es ergibt sich einen Stromkreis. Vereinfachend werden wir nur Stromkreise behandeln, die aus einem geschlossenen Kreis bestehen. Es gibt also keinen parallelen Verbindungen.

### WICHTIG

Bevor nicht alle Attribute, Konstruktoren und Methodensignaturen korrekt implementiert sind (also alle Structural Tests bestanden), werden keine Behavioural Tests ausgeführt! 
FAQ: Leider können die strukturellen Tests keine Methoden, Attribute, Konstruktoren oder Klassen auf Existenz prüfen, wenn diese einen generischen Typ in der Signatur haben. Daher wird, falls sie fehlen, nur die Meldung 'Test not executed' angezeigt.


### Teil 1: Helferklassen für den Stromkreis

Da unsere ausgezeichneten Pinguin-Entwickler sauberen und qualitativ hochwertigen Code lieben, haben sie vorgeschlagen, einige Helferklassen zu implementieren, um die Umsetzung des Stromkreises zu erleichtern. Diese Klassen dienen dazu, Funktionen zu kapseln, die sie voraussichtlich häufig verwenden werden.


Das folgende UML-Diagramm beschreibt die Gesamtstruktur der Implementierung. Es soll dir dabei helfen, den Überblick zu behalten. Du musst das Diagramm noch nicht im Detail verstehen. Die Erklärungen zu den einzelnen Komponenten folgen später.


**WICHTIG** in UML fehlt getOutputDirection, siehe die Structural tests 
@startuml

abstract class pgdp.FlipperFlow.Components.Piece {
   244122 )>- boolean inserted 
 244122 )>- double resistance 
 244122 )>- Direction inputDirection 
 244122 )>- Direction outputDirection 
 244124 )>+ getInputDirection() : Direction  
}

interface pgdp.FlipperFlow.Components.Conductive {
   244121 )>+ getCurrentInput() : double 
 244121 )>+ getCurrentOutput() : double 
 244121 )>+ getVoltageInput() : double 
 244121 )>+ getVoltageOutput() : double 
}

class pgdp.FlipperFlow.Components.Cable extends pgdp.FlipperFlow.Components.Piece implements pgdp.FlipperFlow.Components.Conductive {
   244126 )>- double currentInput 
 244126 )>- double voltageInput 
 244112 )>+ setCurrentInput(double) : void 
 244112 )>+ setVoltageInput(double) : void 
}

class pgdp.FlipperFlow.Components.PowerSource extends pgdp.FlipperFlow.Components.Piece {
   244128 )>- double voltage 
 244128 )>- double current 
 244127 )>+ PowerSource(Direction inputDirection, Direction outputDirection) 
 244127 )>+ setCurrent(double) : void 
 244127 )>+ setVoltage(double) : void 
 244127 )>+ getCurrent() : double 
 244127 )>+ getVoltage() : double 
}

class pgdp.FlipperFlow.Components.Resistor extends pgdp.FlipperFlow.Components.Cable {
   244120 )>- double minCurrent 
 244120 )>- double maxCurrent 
 244120 )>- double minVoltage 
 244120 )>- double maxVoltage 
 244120 )>- Vector2 positionInGrid   
 244129 )>+ Resistor(double, double, double, double, double) 
 244129 )>+ setPositionInGrid(Vector2) : void  
 244129 )>+ getVoltageOutput() : double 
 244129 )>+ getStatus() : String  
 244129 )>+ toString() : String  
}

enum pgdp.FlipperFlow.Helpers.Direction {
  UP(0, 1)
  DOWN(0, -1)
  LEFT(-1, 0)
  RIGHT(1, 0)
  
   244110 )>- final Vector2 vector 
 - Direction(int, int)  
 244116 )>+ getVector() : Vector2 
 244116 )>+ {static}reverse(Direction) : Direction 
 244116 )>+ {static}getCoordinatesFromDirection(Direction, Vector2) : Vector2 
 244116 )>+ {static}getDirectionFromCoordinates(Vector2, Vector2) : Direction 

}

class pgdp.FlipperFlow.Helpers.Pair  {
  - T first
  - R second
  + Pair(T,R) 
  + getFirst() : T
  + getSecond() : R
  + setFirst(T) : void
  + setSecond(R) : void
  + equals(Object) : boolean
}

class pgdp.FlipperFlow.Helpers.Vector2 {
   244141 )>- Pair  xy 
 
   244150 )>+ Vector2(int, int) 
 244142 )>+ setX(int) : void  
 244142 )>+ setY(int) : void  
 244142 )>+ getX() : int 
 244142 )>+ getY() : int 
 244142 )>+ add(Vector2) : Vector2  
 244142 )>+ equals(Object) : boolean  
 244142 )>+ toString() : String  
}


class pgdp.FlipperFlow.LinkedCircuit  {
 
   244125 )>- CableLink start 
 244125 )>- CableLink end 
  - R powerSource 
   244123 )>+ getStart() : CableLink 
 244123 )>+ getEnd() : CableLink 
  + link(T) : void
  + setPowerSource(R) : void 
  + getPowerSource() : R
   244123 )>+ isClosed() : boolean  
 244123 )>+ getTotalResistance() : double  
 244123 )>+ printStatusReport() : String  
}


class pgdp.FlipperFlow.CableLink {
    - T cable
    - CableLink next
    + getCable() : T
    + getNext() : CableLink
    + propagate() : void 
}




class pgdp.FlipperFlow.Circuit {
   244115 )>- Piece[][] grid 
 244115 )>- Vector2 powerSourcePosition 
 244115 )>- Vector2 openEnd 
 244131 )>+ Circuit(int, int, int, int) 
 244111 )>+ getPowerSource() : PowerSource 
 244111 )>+ setSourceVoltage(double) : void 
 244111 )>- setSourceCurrent(double) : void 
 244111 )>+ getAt(int, int) : Piece 
 244111 )>- positionIsEmpty(Vector2) : boolean  
 244111 )>- getPossibleLinkPositions() : Vector2[] 
  + insertAt(Piece, int, int) : boolean
  + generateLinked() : LinkedCircuit 
}


Circuit ""1"" o-left- ""nxm"" Piece : grid
Circuit ""1"" o-- ""2"" Vector2 : powerSourcePosition, openEnd
Direction ""1"" o-- ""1"" Vector2 : vector
CableLink ""1"" o-- ""1"" CableLink : next
LinkedCircuit ""1"" o-up- ""2"" CableLink : start, end
Vector2 ""1"" o-left- ""1"" Pair : xy


@enduml






Wir werden die Schaltkomponenten in ein Grid einsetzen. Dafür verwenden wir Methoden wie `insertAt(x,y)`, bei denen uns Klassen aus dem Helpers-Package helfen.
Wenn unsere Schaltung vollständig ist, wandeln wir sie mit der Methode `generateLinked()` in eine Linked List um, die eine `LinkedCircuit` erstellt. Alle Methoden müsst ihr selbst implementieren!

#### Aufgaben
1. [task][Implementiere die Pair-Klasse]( 244165 , 244160 , 244169 , 244167 , 244179 ) 

    Wir brauchen eine Möglichkeit, die Positionen der Elemente im Schaltkreis zu repräsentieren. Dazu werden wir gleich die `Vector2` Klasse implementieren. Als Grundlage dazu haben wir die Klasse `Pair`.
   `Pair` ist eine sehr einfache Datenstruktur, in der zwei Werte gespeichert werden. Da wir möchten, dass `Pair` vielseitig ist und nicht nur für Integer funktioniert, machen wir die Klasse generisch.  
   Implementiere die Methoden aus dem Diagramm. Beachte, dass die `equals`-Methode überschrieben werden sollte – wann sind zwei `Pair` gleich?

2. [task][Implementiere die Vector2-Klasse]( 244136 , 244141 , 244142 , 244168 , 244172 , 244170 , 244150 )
   `Vector2` ist eine Spezialisierung von `Pair `. Beachte, dass wir nicht von `Pair` erben, sondern Komposition verwenden (für Interessierte: [composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)).  
   Die Methode `add` soll komponentenweise Addition mit dem Parameter `other` durchführen und das Ergebnis in einem neuen `Vector2` zurückgeben (ohne `this` oder `other` zu verändern). Vergiss außerdem nicht, die `equals`-Methode zu überschreiben. Dafür kannst du die bereits implementierte `Pair`-`equals`-Methode nutzen.
   Die `toString`-Methode soll auch überschrieben werden, für einen Vektor mit Koordinaten (3,5) sollte `(3, 5)` als String ausgegeben werden.

3. [task][Implementiere den Direction-Enumerator]( 244171 , 244178 , 244188 , 244180 , 244119 , 244116 , 244110 )
    Ein Schaltelement kann auf einer Position unterschiedlich platziert werden, abhängig davon mit welchen Nachbarn es verbunden ist. Daher brauchen wir eine Möglichkeit, Richtungen darzustellen.

   Der Enumerator `Direction` soll die Berechnung von Positionen im Grid vereinfachen. Jede Richtung (`UP`, `DOWN`, `LEFT`, `RIGHT`) speichert einen `Vector2` mit der 2D-Darstellung einer Richtung (z.B. `(0, 1)` für `UP`).  
   - `reverse` gibt die entgegengesetzte Richtung des Parameters zurück.  
   - `getCoordinatesFromDirection(dir,pos)` liefert die benachbarte Position von `pos` in Richtung `dir` mithilfe von Vektoraddition mit den gespeicherten Direction-Vektoren (Beispiel: `(2, 4)` + `UP` -> `(2, 5)`).
   - `getDirectionFromCoordinates(currentCoordinates, nextCoordinates)` führt die umgekehrte Berechnung durch, indem die Richtung bestimmt wird, in der sich `nextCoordinates` von der Position `currentCoordinates` aus befindet. Die Funktion gibt null zurück, wenn die Positionen nicht benachbart sind.

---

### Teil 2: Komponenten des Stromkreises + LinkedCircuit 

Unsere Pinguine haben in ihren Vorlesungen über Polymorphie und Vererbung gelernt und beschlossen, eine Hierarchie der Komponenten ihres Stromkreises zu erstellen. Die Idee ist, eine generische Oberklasse (`Piece`) zu erstellen, von der spezifischere Komponenten wie Kabel, Widerstände oder Stromquellen abgeleitet werden. Dadurch können sie Objekte verschiedener Klassen im selben Array speichern. Wie das funktioniert? Indem der statische Typ des Objekts beim Speichern in die generelle Klasse gecastet wird und beim Abrufen für spezielle Fälle in ihre spezifischere Klasse zurückgecastet werden kann.

Damit steht die nächste Aufgabe der Übung fest: Wir werden alle benötigten Klassen für die Komponenten implementieren.  

1. [task][Implementiere die `Piece`-Klasse]( 244114 , 244122 , 244124 , 244189 , 244182 , 244176 )
Zunächst möchten wir die abstrakte Klasse `Piece` implementieren. Diese Klasse muss abstrakt sein, da sie noch kein echtes Bauteil repräsentiert, sondern lediglich eine Anforderung bzw. Vorlage für alle realen Bauteile darstellt, und somit nicht instanziiert werden soll.

- Jedes `Piece` hat genau eine Eingangs- und eine Ausgangsrichtung. Diese Richtungen repräsentieren, wie der Stromfluss später durch das `Piece` verlaufen soll. Wir beschränken uns auf nur vier Richtungen (die in der `Direction`-Hilfsklasse definiert sind). Standardmäßig sollen beide Richtungen `null` sein.
    - **Erklärung Directions:** Stellen wir uns vor, wir haben einen Pfeil, der im `Piece` beginnt und in die Richtung zum nächsten `Piece` zeigt – das ist unsere Ausgangsrichtung. Die Richtung zum vorherigen `Piece`, von dem der Strom kommt, ist die Eingangsrichtung, also die Richtung, aus der der Strom kommt. 

  **Wichtig:** Unsere `Pieces` können nicht verbogen werden, somit können die Eingangs- und Ausgangsrichtung nur einmal gesetzt werden. Bitte berücksichtige dies bei der Implementierung der Setter - bei mehrmaligem Versuch diese zu setzen soll dementsprechend nichts passieren.
  Darüber hinaus enthält jedes `Piece` einen Widerstandswert. Standardmäßig soll dieser auf 0 gesetzt werden.  
  Es gibt auch ein Boolean-Flag `inserted`, um zu verhindern, dass ein `Piece` mehr als einmal eingefügt wird. Sobald die Eingangsrichtung eines `Piece` gesetzt ist, wissen wir, dass es in einen Stromkreis eingesetzt wurde, und können das Flag auf `true` setzen.

2. [task][Implementiere das `Conductive`-Interface]( 244117 , 244121 )
Das `Conductive`-Interface kennzeichnet `Pieces`, die Elektrizität übertragen können. Jedes leitfähige `Piece` muss in der Lage sein, seine Eingangsstärke (`currentInput`) und die Eingangsspannung (`voltageInput`) sowie die Ausgangsstärke (`currentOutput`) und die Ausgangsspannung (`voltageOutput`) zu liefern.

3. [task][Implementiere die `Cable`-Klasse]( 244108 , 244126 , 244112 , 244159 )
Als nächstes implementieren wir echte  Komponenten für unseren Stromkreis. Ein Kabel ist ein `Piece`, und hat zusätzlich noch die Eigenschaft, leitfähig zu sein. Daher sollte ein Kabel alle Funktionen des `Conductive`-Interfaces implementieren. 
  - Ein Kabel speichert Eingangsstärke und Eingangsspannung. Wir nehmen an, dass ein Kabel keinen Einfluss auf die Spannung eines Stromkreises hat (d.h., wir ignorieren dessen Widerstand). Somit sind `getVoltageOutput` und `getCurrentOutput` trivial.

4. [task][Implementiere die Resistor-Klasse]( 244118 , 244120 , 244129 , 244132 , 244107 , 244181 , 244184 )
  Nun wollen wir Widerstände implementieren. Wichtig zu beachten ist, dass ein Widerstand die Spannung in unserem Stromkreis beeinflusst. Wenn Strom durch einen Resistance fließt, dann wird sich der outputVoltage nach folgender Formel ändern:
  **VoltageOutput = VoltageInput - Resistance × Current**
    Der Konstruktor der `Resistor`-Klasse muss folgende Parameter in der angegebenen Reihenfolge entgegennehmen:
    1. **resistance (double)**: Der Widerstandswert in Ohm.
    2. **minCurrent (double)**: Der minimale Strom, den der Widerstand handhaben kann.
    3. **minVoltage (double)**: Die minimale Spannung, die durch den Widerstand fließen kann.
    4. **maxCurrent (double)**: Der maximale Strom, den der Widerstand sicher verarbeiten kann.
    5. **maxVoltage (double)**: Die maximale Spannung, die durch den Widerstand fließen darf.


    - `getStatus` prüft, ob der Resistor innerhalb seiner Spezifikationen arbeitet. Das heißt, es wird geprüft, ob der aktuelle Strom (currentInput) und die Spannung (voltageInput) innerhalb der definierten Minimal- und Maximalwerte liegen.
    Die Methode soll als Ergebnis entweder `WORKING` oder `NOT WORKING` zurückgeben, je nachdem, ob der Resistor alle Spezifikationen erfüllt. 

    - `toString` überschreibt diese Methode, um einen sinnvolles Output in Textform über den Zustand des Resistors zu bekommen. Ach auf eine gute Formatierung der Werte, z.B. auf zwei Nachkommastellen für die Ausgabe der Spannung und des Stroms. Ihr dürft `String.format(""%.2f"", DOUBLE_VALUE)` aufrufen. Wenn z.B. positionInGrid == null also nicht gesetzt ist, fügen wir in String ganz normal `positionInGrid` hinzu (auch wenn null) (Erinnerung: Wir haben `toString` in `Vector2` überschrieben).
     
  Beispielausgabe für die `toString`-Methode:  
 
    ""HI I AM RESISTOR AT: (x, y), CURRENTLY WORKING 
    MY STATS ARE: RESISTANCE 10.00, CURRENT 5.00, VOLTAGE_INPUT 20.00, VOLTAGE_OUTPUT 15.00
    MY SPECIFICATIONS ARE: MIN_CURRENT 1.00, MAX_CURRENT 10.00, MIN_VOLTAGE 5.00, MAX_VOLTAGE 25.00""
     
 


5. [task][Implementiere die `PowerSource`-Klasse]( 244149 , 244130 , 244128 , 244127 , 244138 )
Nun wollen wir die Stromquelle implementieren. Da eine Stromquelle kein Kabel ist (unsere Pinguine haben das durch Nachfragen im MI-Gebäude in Garching herausgefunden), besitzt sie andere Eigenschaften.  
Am wichtigsten ist, dass eine Stromquelle keine Eingangs-/Ausgangswerte für Spannung und Strom hat, da Spannung und Strom des Stromkreises erst durch die Stromquelle festgelegt werden. Daher hat sie zwei festgesetzte Attribute: `voltage` und `current`.  
Eine Stromquelle ist die allererste Komponente, die wir in unser Grid einfügen, und muss daher im Konstruktor mit einer festen Eingangs- und Ausgangsrichtung initialisiert werden.
Standardmäßig sollte `voltage` auf 10.0 und `current` auf 0.0 gesetzt werden.
Für PowerSource gilt - wie auch bei `Piece` -, dass die input-/output-Direction nur einmal gesetzt werden darf.
Ausserdem brauchen wir hier einen Konstruktor: `PowerSource(Direction inputDirection, Direction outputDirection)`, der die Directions setzt. 



6. [task][Implementiere die `LinkedCircuit`-Klasse]( 244113 , 244125 , 244123 , 244175 , 244183 , 244187 , 244270 , 244268 , 244173 , 244249 )
  Vereinfachend begrenzen wir uns auf Schaltkreise, die aus einem geschlossenen Kreis bestehen, also keine parallelen Verbindungen haben. Da jedes Schaltelement somit einen Vorgänger und einen Nachgänger hat, eignet sich eine verkettete Liste, um solche Schaltkreise zu repräsentieren.

   `LinkedCircuit ` ist unsere spezielle Implementierung einer verketteten Liste. Wir speichern die `PowerSource`, `start` sowie `end` der Liste. Um die Klasse zukunftssicher für eventuell bessere Stromkreise mit besseren Komponenten zu machen, fordern wir mit Generics, dass unsere Kabel (Generic `T`) lediglich eine Unterklasse von `Cable` sind, und die Stromquelle (Generic `R`) von `PowerSource` erbt.

   #### ACHTUNG: Das T in `CableLink` kommt aus `LinkedCircuit `! `CableLink` ist eine INNERE KLASSE von `LinkedCircuit `!!! deswegen `CableLink ` ist totales quatsch! 
   - Innere Klasse `CableLink`: Repräsentiert ein Element in der Liste, speichert ein `T cable`  und eine Referenz auf das nächste Element `CableLink next`. Die Methode `propagate` leitet den Strom weiter zum nächsten Schaltelement, indem sie den `currentInput` des nächsten Schaltelements auf den `currentOutput` des aktuellen Schaltelements setzt. Ähnlich wird der `voltageInput` des nächsten Schaltelements auf den `voltageOutput` des aktuellen Schaltelementss gesetzt. Wenn `next` `null` ist, geschieht nichts.  
   - `link`: Fügt ein neues `CableLink` mit dem gegebenen `Cable` am Ende der Liste hinzu.  
   - `isClosed`: Gibt `true` zurück, wenn der `LinkedCircuit` geschlossen ist, d. h. wenn die `powerSource` ungleich `null` ist.  
   - `getTotalResistance`: Liefert den Gesamtwiderstand (Summe) aller Schaltelemente in der Liste (unabhängig davon, ob Widerstände WORKING/NOT WORKING sind). Hier wird klar, warum wir wollen, dass T von Cable erbt, damit wir den Getter für den Widerstand der Komponente aufrufen können.
   - `printStatusReport`: Hier sollte die String-Darstellung Jedes Resistors im Schaltkreis gesammelt und zurückgegeben werden. Ihr dürft annehmen, dass Resistor irgendwo in grid liegt, wenn diese Methode aufgerufen werden kann. 
--- 

### Teil 3: Der Stromkreis 
[task][Übersicht für Circuit]( 244145 , 244115 , 244111 , 244131 , 244174 , 244186 , 244164 , 244166 , 244271 , 244269 ) 

Jetzt kommen wir endlich zum Herz der Übung, der `Circuit`-Klasse. Wir speichern ein zweidimensionales Array `grid`, das alle Positionen repräsentiert, an denen ein `Piece` platziert werden kann, wobei `(0, 0)` die untere linke Ecke darstellt.

- Konstruktor: Initialisiere `grid` mit den gegebenen Dimensionen. Speichere die Position der Stromquelle. Erstelle eine neue Stromquelle an der angegebenen Position. Der Konstruktor von Circuit sieht so aus: `public Circuit(int width, int height, int sourceX, int sourceY)`. **WICHTIG: ** Hier dürft ihr annehmen, dass 2 < width und 2 < height und dass sourceX und sourceY immer in grid liegen.  
    - Standardmäßig hat die Stromquelle die Eingangsrichtung `LEFT` und die Ausgangsrichtung `RIGHT`. Befindet sich die Stromquelle jedoch entlang des rechten Randes, sollte die Ausgangsrichtung `UP` sein, falls sie in der oberen rechten Ecke platziert wurde, sollte sie `DOWN` sein. Wenn sie sich entlang des linken Randes befindet, sollte ihre Eingangsrichtung `DOWN` sein, in der unteren linken Ecke sollte sie `UP` sein.  
    - `openEnd` sollte immer die Position des zuletzt platzierten `Piece` angeben, das aktuelle ""offene Ende"" des Stromkreises. Wenn der Stromkreis geschlossen ist (siehe später), sollte es `null` sein.
- `getPowerSource`: Gibt die `PowerSource` des Stromkreises zurück.  
- `setSourceVoltage`, `setSourceCurrent`: Setzt die Spannung bzw. die Stärke der Stromquelle.  
- `getAt`: Gibt das `Piece` an einer bestimmten Position zurück oder `null`, wenn die Position leer oder ungültig (out of bounds) ist.  
- `insertAt(x,y)`: Versucht, ein `Piece` an einer bestimmten Position einzufügen. Gibt `true` bei Erfolg zurück. Statische Funktionen aus    `Direction` werden für diese Methode hilfreich sein 🙂. Constraints:  
    - Es darf nur eine Stromquelle im Stromkreis existieren.  
    - Ein `Piece` darf nicht zweimal eingefügt werden.  
    - Ein `Piece` darf keine andere Komponente an einer Position ersetzen, d.h., wenn eine Position bereits besetzt ist, kann dort kein weiteres `Piece` eingefügt werden.  
    - Ein `Piece` darf nur an einer der 3 angrenzenden Positionen von `openEnd` eingefügt werden. Wenn z.B. die `inputDirection` von `openEnd` `LEFT` ist, d.h. der Strom kommt von links bzw. das vorherige `Piece` ist eine Position links von `openEnd`, so darf ein neues `Piece` nur darüber, darunter, oder rechts von `openEnd` eingefügt werden (sofern diese Positionen frei sind).
    - Kann ein `Piece` erfolgreich platziert werden, stelle sicher dass die `inputDirection` vom neu platzierten `Piece`, sowie die `outputDirection` von `openEnd` richtig gesetzt werden! 
    - Sobald ein `Piece` an der Eingangsposition der Stromquelle (also an der anliegenden Position in Richtung inputDirection) platziert wird, ist der Stromkreis geschlossen, und `openEnd` kann auf `null` gesetzt werden (vergiss nicht, in dem Fall direkt die `outputDirection` des neu platzierten `Piece` zu setzen ;)).
    - Wenn ein Resistor hinzugefügt ist, man muss entsprechend die `positionInGrid` dafür setzen. 
    - Wenn der Stromkreis bereits geschlossen ist, dürfen keine weiteren `Pieces` eingefügt werden.
    - Hilfsmethoden für `insertAt(x,y)`: `positionIsEmpty` soll `true` returnen, wenn die gegebene Position innerhalb der Grenzen des `grid`s liegt, und kein `Piece` an dieser Position ist. `getPossibleLinkPositions` gibt ein Array mit den **maximal drei** anliegenden Positionen von `openEnd` zurück, an welchen das nächste `Piece` platziert werden kann (Achtung - wenn die `PowerSource` aktuell das einzige `Piece` im Stromkreis ist, vergiss nicht, dass das nächste `Piece` nur an der anliegenden Position in Richtung `outputDirection` der Stromquelle gesetzt werden kann).
- `generateLinked`: Wird nach dem Platzieren aller `Piece`s verwendet. Erstelle eine verkettete Liste aller `Pieces` mit unserer `LinkedCircuit`-Klasse, die dann verwendet werden kann, um endlich den Strom durch unseren Stromkreis zu leiten! 
    - Beachte, dass die Klasse die `PowerSource` seperat speichert (also diese kein Teil der LinkedList ist). 
    - Das heißt wir starten am ersten Kabel neben der Stromquelle, folgen den Ausgangsrichtungen und fügen jedes Kabel zu `LinkedCircuit` hinzu (`link`-Methode)
    - Wenn wir bei der `PowerSource` ankommen, d.h. unser Stromkreis geschlossen ist, setzen wir uns das powerSource-Attribut von `LinkedCircuit`. Wenn unser Stromkreis nicht geschlossen ist, bleibt das powerSource-Attribut in `LinkedCircuit` `null`.
- `propagate`: Hier kommt nun alles zusammen. Erstelle einen `LinkedCircuit`. Wenn dieser nicht geschlossen ist, verlasse die Methode sofort. Berechne die Stromstärke, indem die Spannung der Stromquelle durch den Gesamtwiderstand des Stromkreises geteilt wird (`getTotalResistance` in `LinkedCircuit`). Setze die Stromstärke der Stromquelle auf den berechneten Wert. Setze dann die Eingangsspannung und -stärke des ersten Kabels (`getStart`) auf die Ausgangswerte der Stromquelle. Iteriere über alle Kabel im `LinkedCircuit` und rufe `propagate` für jedes Kabel auf, um den Strom Kabel für Kabel weiterzuleiten.
- `printStatusReport`: Hier sollte ein wrapper für `printStatusReport` von `LinkedCircuit` implementiert werden. (wird nicht getestet)

## **WICHTIG** 
`Circuit` hängt von der korrekten Implementierung aller Klassen ab, auf die es angewiesen ist. Gleichzeitig benötigt `LinkedCircuit` eine funktionierende Implementierung der Helper-Klassen, damit `Circuit` korrekt arbeiten kann. Das bedeutet: Damit `Circuit` funktioniert, muss auch `LinkedCircuit` korrekt implementiert sein, was wiederum voraussetzt, dass die zugrunde liegenden Komponenten richtig umgesetzt sind."
404,Praktikum: Grundlagen der Programmierung WS24/25,15364,W07H01 - PinguPinguLos V - Die Suchmaschine schlaegt zurueck,"# PinguPinguLos V - Die Suchmaschine schlägt zurück!

## Ziel

Diese Woche wollen wir zunächst ein verbessertes Ähnlichkeitsmaß implementieren. Durch unsere `DocumentCollection` haben wir einen Überblick über sämtliche zur Verfügung stehenden Dokumente und können damit auch ermitteln, in wie vielen Dokumenten ein konkretes Wort vorkommt. Wenn ein Wort in vielen Dokumenten vorkommt, ist es vermutlich nicht so ausschlaggebend, um die Ähnlichkeit zweier Texte zu beurteilen. Zusätzlich wollen wir Verweise auf andere Dokumente hinzufügen, um herausfinden zu können, zu welchen anderen Dokumenten man von einem Ausgangsdokument noch gelangen kann.

## 1. Die komplexe Vektorähnlichkeit

### 1. Die neuen Attribute 
Zuerst müssen wir unsere vorhandenen Klassen, um zusätzliche Attribute erweitern, die in den nachfolgenden Aufgaben benötigt werden:

1. Füge der Klasse `WordCount` die Attribute `double weight` und `double normalizedWeight` hinzu. Diese sollen dazu genutzt werden, gewisse Wörter als ausschlaggebender im Vergleich zu anderen Wörtern zu markieren. Bei einem Wert für `count` von größer 0 sollen die beiden Attribute im Konstruktor mit 1, ansonsten mit 0 initialisiert werden. 
[task][Testing Structure WordCount]( 244557 , 244571 )
2. Füge der Klasse `DocumentListElement` die Attribute `WordCount[] wordCountArray` und `double similarity` hinzu. Das erste Attribut soll immer das aktuelle WordCount-Array speichern und soll dementsprechend im Konstruktor passend initialisiert werden. Das Attribut `similarity` soll später die Ähnlichkeit mit einer Suchanfrage speichern und soll daher zu Beginn den Wert 0 haben. 
[task][Testing Structure DocumentListElement]( 244585 )
 
Denke bei den nachfolgenden Aufgaben daran, dass diese Attribute ggf. aktualisiert werden müssen!

### 2. Alle Wörter unserer Collection
Als Erstes wollen wir einen Überblick erhalten, welche Wörter sich insgesamt in unserer Collection befinden, und anschließend sicherstellen, dass sämtliche WordCount-Arrays vergleichbar sind:

1. Implementiere in `DocumentCollection` eine Methode `WordCount[] getCompleteWordCountArray()`. Diese Methode soll die WordCount-Arrays aller in der Collection vorhandenen Dokumente zusammenfügen, sodass das zurückgegebene WordCount-Array zu jedem Wort in einem Text eines beliebigen Dokumentes ein WordCount-Objekt enthält. Der Wert des `count`-Attributes jedes WordCount-Objektes im Array ist undefiniert. Das zurückgegebene Array muss zusätzlich lexikographisch sortiert sein.
[task][Testing Structure DocumentCollection]( 244581 )
2. Implementiere in `DocumentCollection` eine Methode `void equalizeAllWordCountArrays()`, welche für alle `DocumentListElement`-Objekte in unserer Collection sicherstellt, dass das gespeicherte WordCount-Array mit jedem beliebigen Dokument in unserer Collection verglichen werden kann. Das bedeutet, dass das WordCount-Array von jedem `DocumentListElement` jedes vorkommende Wort in unserer Collection enthält und lexikographisch sortiert ist.
[task][Testing equalizeAllWordCountArrays, might depend on correct getCompleteWordCountArray]( 244839 )

### 3. Die Gewichtung vornehmen
Unsere Gewichte sollen sich unter anderem daran orientieren, in wie vielen Dokumenten ein Wort vorkommt. Je seltener ein Wort ist, desto maßgeblicher sollte es bei der Berechnung der Ähnlichkkeit zweier Dokumente sein. Für die Berechnung der Gewichte eines beliebigen WordCount-Objektes mit dem Wort `w` in einem gegebenen WordCount-Array `a` als Teil der DocumentCollection `d` soll gelten:

$$\text{invertedFrequency}(w,\, d) = \text{log}_2{(\frac{\text{Anzahl Dokumente in}\ d\; +\ 1}{\text{Anzahl der Dokumente in}\ d \text{, die}\ w\ \text{enthalten}})}$$

$$\text{weight}(w,\ a,\ d) = (\text{Häufigkeit von}\ w\ \text{in}\ a) \cdot \text{invertedFrequency}(w,\, d)$$

$$\text{normalizedWeight}(w,\ a,\ d) = \frac{\text{weight}(w,\ a,\ d)}{\sqrt{\sum_{v \in a} \text{weight}(v,\ a,\ d)^2}}$$

Der Ausdruck $$\sum_{v \in a} \text{weight}(v,\ a,\ d)^2$$ bedeutet dabei, dass wir für alle Wörter v in a das berechnete Gewicht quadrieren und die quadrierten Gewichte dann addieren.

1. Implementiere in `DocumentCollection` eine Methode `int getNumberOfDocumentsContaining(String)`, welche die Anzahl an Dokumenten zurückgibt, in denen das übergebene Wort im Text vorkommt. Groß- und Kleinschreibung und Sonderzeichen sind zu ignorieren, d.h. das Wort ""pinguine"" kommt im Text ""Pinguine sind großartig!"" vor, genauso wie ""großartig"". Falls der übergebene String `null` ist, soll 0 zurückgegeben werden.
[task][Testing getNumberOfDocumentsContaining]( 244578 , 244560 )

2. Implementiere in `DocumentCollection` eine Methode `private void calculateWeights(WordCount[])`, welche für alle WordCount-Objekte im übergebenen WordCount-Array beide Gewichte nach den obigen Formeln berechnet und entsprechend setzt. Falls das übergebene Array `null` ist, soll nichts passieren. Den natürlichen Logarithmus einer Zahl x erhälst du über `Math.log(x)` und die Quadratwurzel über `Math.sqrt(x)`. 
[task][Testing calculateWeights]( 244582 , 244590 )

3. Implementiere in `Document` eine Methode `static double complexSimilarity(WordCount[], WordCount[])`, welche erneut das Skalarprodukt aller enthaltenen WordCount-Objekte berechnet, aber dieses Mal mit den `normalizedWeight`-Werten, statt den `count`-Werten. Falls einer der beiden Parameter `null` ist oder die Längen ungleich sind, soll `-1` zurückgegeben werden.
[task][Testing testComplexSimilarity]( 244556 , 244617 , 244574 )


### 4. It's all coming together
Mit diesen Methoden sind wir in der Lage, die Ähnlichkeit zwischen einem Text und allen Dokumenten in unserer Collection zu berechnen. Es ist also endlich Zeit für die Suchanfrage: 
1. Implementiere in `DocumentCollection` eine Methode `Document[] query(String)`, welche für alle Dokumente die Ähnlichkeit mit dem übergebenen String mithilfe von `complexSimilarity()` berechnet und anschließend ein  Ranking nach Ähnlichkeit zurückgibt (die Methode hierfür implementieren wir erst im nächsten Schritt). Du kannst dabei wie folgt vorgehen:
    1. Füge die als String übergebene Suchanfrage unserer Collection hinzu.
    2. Sorge dafür, dass die WordCount-Arrays aller Dokumente die gleichen Einträge an der gleichen Stelle haben. 
    3. Berechne zunächst die Gewichte des Dokuments der Suchanfrage, damit die Ähnlichkeiten nicht Null werden.
    4. Führe nun für jedes Dokument in der Collection folgende Schritte durch:
        1. Berechne die Gewichte für das WordCount-Array des Dokumentes.
        2. Berechne die Ähnlichkeit des Dokumentes mit der Suchanfrage.
    5. Entferne das Dokument mit der Suchanfrage aus der Collection.
    6. Gebe ein Array zurück, welches nach dem berechneten `similarity`-Wert absteigend sortiert alle Dokumente der Collection enthält. Die Methoden hierfür implementieren wir als nächstes.
Wenn der übergebene String `null` ist, soll ein leeres Array zurückgegeben werden. 
[task][Helper Test für Query, prüfen ob getNumberOfDocumentsContaining korrekt kombiniert mit EqualizeAllWordCount ist]( 247659 )
[task][Testing Query Public]( 244618 )

### 5. Ein Ranking erstellen
Als letztes benötigen wir noch Hilfsmethoden, die aus den berechneten `similarity`-Werten ein Ranking erstellen können.

1. Implementiere in `DocumentCollection` eine Methode `void sortBuckets()`. Diese soll die doppelt verkettete Liste in jedem einzelnen Bucket unserer Collection nach dem gespeicherten `similarity`-Wert absteigend sortieren. Nach Ausführung der Methode soll das `DocumentListElement`, auf welches `head` verweist, das Dokument mit dem höchsten `similarity`-Wert beinhalten und `tail` soll auf das `DocumentListElement` mit dem Dokument, welches den niedrigsten Wert besitzt, zeigen. Ein Listenelement ist dabei allein über seine Attribute eindeutig identifiziert. Wenn zwei Dokumente den identischen `similarity`-Wert besitzen, sollen diese nach der ID aufsteigend eingereiht werden. Welchen Sortieralgorithmus du verwendest, ist dir erneut freigestellt. 
Durch die Sortierung nach dem `similarity`-Wert wird logischerweise die Sortierung nach der ID zerstört. Ein Dokument kann also nun nicht der ID entsprechend eingefügt werden. Deswegen spielt es keine Rolle mehr, an welcher Stelle ein Dokument in unsere doppelt verkettete Liste eingefügt wird, sobald die Buckets einmal nach der `similarity` sortiert wurden. Lediglich der Bucket muss beim Einfügen eines Elementes weiterhin stimmen.
[task][Testing sortBucket]( 244569 , 244584 )
2. Implementiere in `DocumentCollection` eine Methode `Document[] similarityRanking()`, welche ein Array aus Dokumenten zurückliefert, bei welchem das erste Element das Dokument mit der größten und das letzte Element das Dokument mit der kleinsten Ähnlichkeit ist. Du kannst dabei ausnutzen, dass du durch die Methode `sortBuckets` erreichen kannst, dass sich an der Stelle `head` eines Buckets immer das Element mit der größten Ähnlichkeit befindet. Dokumente mit identischer Ähnlichkeit sollen nach ID aufsteigend im Array vorkommen. [task][Testing Similarity Ranking und Query vollständige Query]( 244580 , 244622 , 244619 , 244606 , 244564 )

Damit ist unsere Suchmaschine in der Lage, eine Suchanfrage entgegenzunehmen, die Ähnlichkeit für jedes Dokument zu berechnen und ein entsprechendes Ranking der Dokumente nach der Ähnlichkeit zurückzugeben!

  

## 2. Verbindungen zwischen Dokumenten

Wir wollen nun Links auf andere Webseiten bzw. in unserem Fall andere Dokumente handhaben können. Dazu kreieren wir eine Unterklasse von Dokumenten, die derartige Links verwalten kann: `AbstractLinkedDocument`. Dies ist lediglich eine abstrakte Klasse, da wir später verschiedene Ausprägungen von Dokumenten in Zusammenhang mit Links benötigen. Diese `AbstractLinkedDocument` erhalten zusätzlich ein Attribut `address`, über welches sie eindeutig identifizierbar sind. Diese Adressen sind dann auch Teil der Links, die ein Dokument enthalten kann. Die Links selbst widerrum sind ausschließlich Teil des Inhaltes eines Dokumentes, also dem Attribut `content`. 
Die Idee ist nun folgende, wobei wir ausschließlich Dokumente mit Links betrachten: Wenn ein neues Dokument `dn` in unsere Collection hinzugefügt werden soll, suchen wir den Inhalt des Dokumentes nach möglichen Links ab. Dadurch erhalten wir die Adressen aller Dokumente auf die `dn` einen ausgehenden Link besitzt, d.h. man kann von `dn` zu diesem anderen Dokument gelangen. Diese Information wollen wir uns irgendwie merken, um nicht immer den Inhalt aller Dokumente in unserer Collection durchgehen zu müssen. Dies speichern wir in den Attributen `incomingLinks` und `outgoingLinks`. 

Beispiel: Das Dokument `dn` enthält einen Link auf die Dokumente `da` und `db`. Wir suchen also in unserer Collection nach diesen Dokumenten. Dann wird in die `incomingLinks`-Collection von `da` das Dokument `dn` hinzugefügt und in die `outgoingLinks`-Collection von `dn` das Dokument `da`. Angenommen das Dokument `db` befindet sich noch nicht in unserer Collection. In diesem Fall wollen wir einen Platzhalter hinzufügen, bis das ""richtige"" Dokument `db` unserer Collection hinzugefügt wird. Darum benötigen wir zwei Unterklassen von `AbstractLinkedDocument`, einmal `LinkedDocument`, welches ein normales Dokument mit ausgehenden Links repräsentiert, und `DummyLinkedDocument`, welches nur als Platzhalter für eingehende Links dient und deswegen auch nur eine `incomingLinks`-Collection benötigt. Wir erstellen also ein Dummy-Dokuemnt `db`, fügen dieses unserer Gesamtcollection hinzu, `dn` wird in die `incomingLinks` von `db` hinzugefügt und das Dummy-Dokument `db` in die `outgoingLinks`-Collection von `dn`.

Damit haben wir alle ausgehenden Links von `dn` abgearbeitet.
Wir müssen nun jedoch noch überprüfen, ob in unserer Gesamtcollection ein `Dummy`-Dokument für `dn` existiert. Wenn ja, müssen wir dieses Dummy-Dokument durch das ""richtige"" Dokument `dn` in unserer Gesamtcollection und in allen `outgoingLinks`-Collection, in die das Dummy-Dokument zuvor eingefügt wurde, ersetzen.
Dieser Prozess des Aktualisieren sämtlicher eingehender und ausgehender Links der Dokumente in unserer Gesamtcollection, wenn ein neues `LinkedDocument` hinzugefügt wird, soll nun schrittweise implementiert werden.

### 1. Zwei Unterklassen
Nicht jedes Dokument enthält ein Link zu einem anderen Dokument oder ist von einem Link eines anderen Dokumentes erreichbar. Deswegen implementieren wir diese Funktionalität als Unterklasse von `Document` und `DocumentCollection`, um zwar die gesamten Funktionalitäten der beiden Oberklasse zu behalten, aber gleichzeitig nicht jedes Dokument mit Links ausstatten zu müssen.

1. Stelle sicher, dass die Klasse `AbstractLinkedDocument` eine abstrakte Klasse und Unterklasse von `Document` ist.

2. Der Konstruktor der Klasse `AbstractLinkedDocument` soll identisch wie bei `Document` sein, nur als zusätzliche letzte Parameter einen `String` und einen `int` (in dieser Reihenfolge) erhalten. Dieser übergebene String soll in einem neuen Attribut `final String address` gespeichert werden. Dieses Attribut speichert die Adresse, unter der dieses Dokument aufgerufen werden kann. Erstelle zusätzlich noch ein Attribut `final LinkedDocumentCollection incomingLinks`, welche alle Dokumente speichern soll, über die man zu diesem LinkedDocument gelangen kann. Der übergebene `int` gibt dabei die Größe der Collection vor. Beide Attribute sollen auch Getter erhalten.

3. Füge der Klasse `LinkedDocument` den identischen Konstruktor wie der Klasse `AbstractLinkedDocument` hinzu. Erstelle außerdem ein Attribut `final LinkedDocumentCollection outgoingLinks`, welches die LinkedDocuments speichert, die von diesem Dokument erreichbar sind. Auch hier soll der übergebene `int` die Größe vorgeben. Auch dieses Attribut soll einen Getter erhalten.

4. Füge der Klasse `DummyLinkedDocument` einen Konstruktor `DummyLinkedDocument(String, int)` hinzu, welcher nur eine Adresse und die Größe der Collection entgegennimmt. Alle anderen Attribute sollen mit leeren Strings, wenn möglich, ansonsten mit `null` initialisiert werden. Diese Klasse nutzen wir später, um Dokumente darzustellen, von denen wir die Adresse kennen, sie aber noch nicht besucht haben.

    [task][testing inheritance]( 244612 )

5. Stelle sicher, dass die Klasse `LinkedDocumentCollection` eine Unterklasse von `DocumentCollection` ist. Überschreibe die Methode `boolean add(Document)`, sodass sichergestellt wird, dass nur Elemente der Klasse `AbstractLinkedDocument` hinzugefügt werden können. Diese überschriebene Methode soll auch eine überladene Version der indexFunction() nutzen, aber nun mit der Methodensignatur `private int indexFunction(String)`. Diese bestimmt den Index des Buckets anhand der Adresse eines LinkedDocuments. Die Formel dafür lautet folgendermaßen: (address.hashCode % numberOfBuckets + numberOfBuckets) % numberOfBuckets. Wenn die übergebene Adresse `null` ist, soll -1 zurückgegeben werden. Die Sortierung der Dokumente innerhalb eines Buckets nach der ID bleibt jedoch weiterhin bestehen. Implementiere außerdem eine Methode `AbstractLinkedDocument find(String)`, welche zur übergebenen Adresse das gespeicherte `AbstractLinkedDocument`-Objekt zurückgibt. Wenn kein solches Objekt in der Collection existiert, soll `null` zurückgegeben werden.
*Hinweis*: Ob ein Objekt o ein Objekt der Klasse c ist, kannst über den Ausdruck `o instanceof c` überprüfen. 

6. Implementiere eine Methode `boolean removeDummy(DummyLinkedDocument)` in `LinkedDocumentCollection`. Diese soll das übergebene `DummyLinkedDocument` aus der Collection entfernen. Der Rückgabewert ist genauso wie bei `removeDocument(int)` aus der letzten Woche definiert. Diese Methode kann später genutzt werden, um die Dummy-Elemente wieder aus unserer Collection zu entfernen.
    [task][Testing removeDummy]( 244609 )
    [task][testing getIncomingLinks]( 244621 )
    [task][testing LinkedDocument]( 244602 , 244579 )
    [task][testing DummyLinkedDocument Constructor]( 244563 )

    [task][Testing LinkedDocumentCollection inheritance]( 244624 )
    [task][Testing Add and indexFunction]( 244583 , 244562 , 244568 , 244616 )


### 2. Die Verbindungen erkennen
Die Links zu anderen LinkedDocuments sind im `content` eines LinkedDocuments gespeichert. Ein Link beginnt immer mit `link::` und darauf folgt eine Adresse unbekannter Länge. Diese Adresse verweist immer auf ein anderes `AbstractLinkedDocument`-Objekt. Du kannst davon ausgehen, dass die Adresse mindestens die Länge 1 besitzt und sich vor und hinter dem gesamten Link-Ausdruck mindestens ein Leerzeichen befindet, außer wenn sich der Link ganz am Anfang oder Ende des Dokuments befindet. Dann folgt auf den Link nur am Ende bzw. Anfang ein Leerzeichen. Ein Dokument kann beliebig viele Links auf andere Dokumente besitzen. Du musst die Adresse in keinster Weise auf Gültigkeit überprüfen, sondern lediglich aus dem Text herauslesen. 
Diese Funktionalität implementieren wir allein in `LinkedDocument`, da wir die ausgehenden Links eines `DummyLinkedDocument`-Objektes nicht kennen.

1. Implementiere in `LinkedDocument` eine Methode `String[] getOutgoingAddresses()`, welche den `content` des LinkedDocuments durchsucht und alle gefundenen Adressen (ohne ""link::"") zurückgibt. Sonderzeichen dürfen vorher nicht entfernt werden! Das Array muss nicht sortiert werden. Wenn keine Adressen gefunden wurden, soll ein leeres Array zurückgegeben werden. [task][Testing Public getOutgoingAddresses]( 244588 )
2. Überschreibe die Methode `WordCount[] getWordCountArray()` in `LinkedDocument`, sodass sämtliche Links nicht mehr im zurückgegebenen WordCount-Array enthalten sind.
[task][getWordCountArray LinkedDocument]( 244586 )
### 3. Links empfangen
#### **WICHTIG** LinkedDocumentes sind durch das Attribute address eindeutig identifiziert!
Bevor wir die gesamte Collection durchgehen und sämtliche eingehenden und ausgehenden Links aktualisieren, benötigen wir zwei Hilfsmethoden:

1. Implementiere in `LinkedDocument` eine Methode `boolean addOutgoingLink(AbstractLinkedDocument)`. Diese soll das übergebene Dokument der `outgoingLink`-Collection von `this` hinzugfügen. Falls das Dokument bereits enthalten ist und ein Objekt der Klasse `LinkedDocument` ist, soll nichts hinzugefügt werden. Falls das Dokument bereits enthalten ist und ein Objekt der Klasse `DummyLinkedDocument` ist, soll das Dummy-Objekt aus der Collection entfernt werden und das übergebene `AbstractLinkedDocument` eingefügt werden. Selbstreferenzen sollen nicht eingefügt werden, d.h. das übergebene Dokument darf nicht die gleiche Adresse besitzen wie `this`. Es soll genau dann `true` zurückgegeben werden, wenn das übergebene Dokument eingefügt wurde.
[task][Testing outgoingLink]( 244576 , 244572 , 244615 )

2. Implementiere in `AbstractLinkedDocument` eine Methode `boolean addIncomingLink(AbstractLinkedDocument)`. Diese soll das übergebene Dokument der `incomingLinks`-Collection von `this` hinzufügen. Falls das Dokument bereits enthalten ist, soll nichts hinzugefügt werden. Selbstreferenzen sollen nicht eingefügt werden, d.h. das übergebene Dokument darf nicht die gleiche Adresse besitzen wie `this`. Es soll genau dann `true` zurückgegeben werden, wenn das übergebene Dokument eingefügt wurde. 
[task][Testing incomingLink]( 244610 , 244577 , 244558 , 244614 )

Die Methode `addOutgoingLink()` wird lediglich von einem `LinkedDocument` benötigt, da ein Dummy-Objekt keine ausgehenden Links besitzt, jedoch eingehende Links, weswegen auch ein Dummy-Objekt `addIncomingLink()` benötigt.

### 4. Alle AbstractLinkedDocuments updaten
Immer wenn wir der LinkedDocumentCollection unserer Suchmaschine ein neues Dokument hinzufügen, müssen die `outgoingLinks`- und `incomingLinks`-Collections aller gespeicherten Dokumente aktualisiert werden. Dabei kann jedoch der Fall auftreten, dass ein neu hinzugefügtes Dokument einen Link auf ein Dokument enthält, welches sich noch gar nicht in unserer Collection befindet. In diesem Fall soll ein `DummyLinkedDocument` der Collection hinzugefügt werden, bis das eigentliche Dokument in unserer Collection landet.

1. Implementiere in `LinkedDocumentCollection` eine private Methode `void updateIncomingLinks(LinkedDocument, String[])`. Das Array enthält dabei die Adressen aller Dokumente, auf welche das übergebene LinkedDocument einen ausgehenden Link besitzt. Die Methode soll genau diesen Dokumenten einen eingehenden Link von dem übergebenen LinkedDocument hinzufügen. Gleichzeitig soll das übergebene LinkedDocument auch immer einen ausgehenden Link erhalten. Falls eine Adresse in der Collection nicht vorhanden ist, soll stattdessen ein `DummyLinkedDocument`-Objekt mit der entsprechenden Adresse hinzugefügt werden und mithilfe diesem die ausgehenden Links des übergebenen LinkedDocuments bzw. die eingehenden Links des Dummy-Dokuments aktualisiert werden. Die Größe der Collection des Dummy-Objektes soll identisch zu der Größe der LinkedDocumentCollection sein, die das Dummy-Objekt erstellt. Falls einer der beiden Parameter null ist, soll nichts passieren. 
[task][Testing updateIncomingLinks]( 244589 , 244567 , 244607 )

2. Implementiere in `LinkedDocumentCollection` eine private Methode `void updateOutgoingLinks(AbstractLinkedDocument)`. Diese soll bei allen Dokumenten in der Collection, die einen Link auf das übergebenen AbstractLinkedDocument besitzen, den Verweis auf das Dummy-Element in ihrer `outgoingLinks`-Collection durch das übergebene AbstractLinkedDocument ersetzen. Das Dummy-Element soll am Ende nicht mehr in der LinkedDocumentCollection enthalten sein. Genauso soll das übergebene `AbstractLinkedDocument`-Objekt am Ende alle Dokumente mit eingehenden Links in seiner `incomingLinks`-Collection gespeichert haben. Falls das übergebene Dokument null ist, soll nichts passieren.
[task][Testing updateOutgoingLinks]( 244559 , 244613 )

3. Implementiere in `LinkedDocumentCollection` eine Methode `boolean addToResultCollection(AbstractLinkedDocument)`. Du kannst davon ausgehen, dass diese Methode nur auf die Collection unserer Suchmaschine aufgerufen wird, die sämtliche vorhandenen Dokument verwaltet. Diese Methode soll das übergebene AbstractLinkedDocument der Collection hinzufügen und dabei die eingehenden und ausgehenden Links aller Dokumente aktualisieren. Der Rückgabewert und das Verhalten bei `null` dieser Methode ist genauso wie beim normalen `add()` definiert. [task][Testing addToResultCollection]( 244565 , 244566 )

[task][Finaler Strukturtest für den 2. Teil]( 244591 , 244570 , 244620 , 244561 , 244608 )

 

## OPTIONAL Testing 
Teste diese Woche folgende sechs Methoden jeweils inklusive eines Kommentars, der die Auswahl der Tests begründet, wie du es von den letzten Wochen gewohnt bist:
- `WordCount[] getCompleteWordCountArray()`
- `int getNumberOfDocumentsContaining(String)`
- `double complexSimilarity(WordCount[], WordCount[])`
- `Document[] similarityRanking()`
- `Document[] query(String)`
- `String[] getOutgoingAddresses()`

Schreibe mindestens drei Tests pro Methode, d.h. verwende pro zu testende Methode drei unterschiedliche DocumentCollections. Es ist also erlaubt, sich am Anfang drei Collections zu überlegen und diese für die drei Tests jeder Methode wiederzuverwenden. Eine Collection muss mindestens drei Dokumente beinhalten.

# FAQ
### Q: Wofür ist das FAQ da?
A: Wenn es Fragen gibt, die häufiger aufkommen, werden sie hier gepostet und ebenfalls beantwortet werden. Wer sie danach noch auf Zulip postet macht Pinguine traurig!
### Q: Wie berechnet man den Logarithmus zur Basis 2, wenn Java nur den natürlichen Logarithmus kann?
A: [Wikipedia weiß die Antwort](https://en.wikipedia.org/wiki/Logarithm#Change_of_base)
### Q: Muss die Collection nach dem Ausführen von ""query()"" wieder in den Ausgangszustand zurückgebracht werden?
A: Nein, das ist nicht erforderlich.
### Q: Muss für die Ähnlichkeit immer noch durch das Produkt der Arraylängen geteilt werden?
A: Nein.
### Q: Wie soll man damit umgehen, wenn bei der Berechnung der Gewichte durch 0 geteilt wird?
A: Wir nehmen an, dass durch 0 teilen hier 0 ergibt.

[Leaked 2-te ÜPA Lösungsvorschlag](https://zulip.in.tum.de/#narrow/stream/33-PGdP-Memes/topic/Did.20you.20fall.20for.20this.3F)"
404,Praktikum: Grundlagen der Programmierung WS24/25,15462,W08P01 - Rekursion,"### Rekursion 
In dieser Aufgabe lernst du das Prinzip der Rekursion kennen. 

Zur Veranschaulichung findest du eine nicht-rekursive Beispielimplementierung der Methoden in der Klasse `NonRecursiveMethods`. Zum Testen deiner rekursiven Methoden kannst du innerhalb der `OutputTesting` Klasse ** JUnit-Tests ** schreiben. Ein Beispiel für den Testaufbau ist bereits im Template enthalten.


## Teil 1: Pingu Rekursion 

[task][Pingu Passwort]( 248150 , 248157 , 248144 , 248149 , 248148 ) 

Die Pinguine haben sich ein besonderes Passwort für ihren PUMOnline-Account ausgedacht. Das Passwort wird wie folgt berechnet:

- Jeder Pinguin berechnet zuerst die Fakultät seines Alters.
- Anschließend wird die Quersumme der Fakultät ermittelt und zum Ergebnis addiert.
- Danach wird der größte gemeinsame Teiler des Alters und des Geburtsjahres berechnet und ebenfalls zum Ergebnis hinzugefügt.
- Zu diesem Wert wird dann noch die Umkehrung des Namens des Pinguins angehängt.
Das endgültige Ergebnis bildet das Passwort des Pinguins.
Um einen Integer-Overflow bei der Berechnung der Fakultät zu vermeiden, verwenden wir die Klasse [BigInteger](https://docs.oracle.com/javase/8/docs/api/?java/math/BigInteger.html) aus java.math. 

Implementiere die Methode `penguPassword(int age, int birthYear, String name)`, die das Passwort für einen Pinguin als String berechnet.

Zur Vereinfachung implementiere zunächst die folgenden **rekursiven** Hilfsmethoden:

`sumOfDigitsRec(int n)`, `findGCDRec(int n, int k)`, `reverseString(String s)`, `factorialRecursive(int n)`.


Nun kannst du deine rekursiven Methoden in `OutputTesting` testen. Im Template findest du auch eine `main` -Methode zum Ausprobieren.


 
  Beispiel mit penguPassword(28, 1996, ""Leo"")  
 

```java
Fakultät von 28:
28!=304888344611713860501504000000

Quersumme der Fakultät:
Die Quersumme von 304888344611713860501504000000 ist 90.

GGT von 28 und 1996:
Der GGT von 28 und 1996 ist 4.

Umkehrung des Namens: Die Umkehrung von ""Leo"" ist ""oeL"".

Das endgültige Passwort wird dann gebildet als:
304888344611713860501504000000 + 90 + 4 + ""oeL"" = ""304888344611713860501504000094oeL""
```

 
 

[task][Pingu Pyramide]( 248147 ) 

   

Die Pinguine bilden eine Pingupyramide, bei der sie eine horizontale Reihe am Boden bilden und zusätzliche Reihen von Personen auf deren Rücken klettern. Jede Reihe enthält einen Pinguin weniger als die Reihe darunter. Die oberste Reihe besteht aus nur einem Pinguin.
Implementiere **rekursiv** die Methode `weightOnPengu(int row, int col, double [][] weights)`, die das gesamte Gewicht berechnet, das auf die Beine eines Pinguins in einer Pyramide lastet. Die Pyramide besteht aus mehreren Reihen von Pinguinen, und jeder Pinguin trägt das halbe Gewicht der beiden Pinguine, die direkt über ihm stehen. Zusätzlich trägt jeder Pinguin sein eigenes Gewicht.

Auf dem Bild links würden wir beispielsweise für den Pinguin Nummer 5 sein eigenes Gewicht berechnen und zusätzlich die Hälfte des Gewichts, das jeweils auf den Pinguinen 2 und 3 lastet, dazurechnen.

[Referenz](https://web.stanford.edu/class/archive/cs/cs106b/cs106b.1176/assnFiles/recursion/spec.pdf)



## Teil 2: Rekursive Mathematik

In diesem Teil sollst du rekursiv zwei mathematische Methoden implementieren. Um es dir leichter zu machen, enthält das Template bereits iterative Implementierungen.

- [task][Binomialkoeffizient ]( 248146 )
Vervollständige die Methode `binomCoeffRecursive(int n, int k)`so, dass sie den Binomialkoeffizienten berechnet. Die Rekursive Definition lautet $$\binom{n}{k} = \binom{n - 1}{k - 1} + \binom{n - 1}{k}$$. Außerdem gilt:

    - $$\binom{n}{n} = \binom{n}{0} = 1$$ für nicht-negative n
    - für $$k>n$$ soll *0* zurückgegeben werden
    - andere fehlerhafte Eingaben werden nicht getestet. Du musst sie also nicht behandeln.


- [task][Fibonacci Zahlen]( 248163 )
Vervollständige die Methode `fibonacciRecursive(int n)`so, dass sie die n-te Fibonacci-Zahl ausgibt. Die n-te Fibonacci-Zahl berechnet sich durch $$f\_n=f\_{n-1}+f\_{n-2}$$.
    - Als Startwerte nehmen wir $$f\_0=0$$ und $$f\_1=1$$


### Teil 2.1: Endrekursion

Nachdem du die Methoden rekursiv implementiert hast, sollst du sie jetzt endrekursiv implementieren. Es reicht, wenn die geforderten Methoden dabei eine andere endrekursive Methode aufrufen.

- [task][Binomialkoeffizient]( 248145 )
Vervollständige die Methode `binomCoeffEndRec(int n, int k)` mit einer endrekursiven Implementierung des Binomialkoeffizienten.

- [task][Fibonacci Zahlen]( 248164 )
Vervollständige die Methode `fibonacciEndRec(int n)` mit einer endrekursiven Implementierung.

#### Hinweise 💡
- Sollten die endrekursiven Tests mit einem Timeout fehlschlagen, hast du die Methoden wahrscheinlich nicht endrekursiv geschrieben.
- Die Klasse Output Testing in dieser Aufgabe wird nicht getestet. Diese ist für dich zum Testen deiner eigenen Methoden da.
- Die Tests dieser Aufgabe liefern genügend Feedback. D.h, was im Tutorium nicht besprochen könnte, kannst du als Übung bearbeiten."
404,Praktikum: Grundlagen der Programmierung WS24/25,15463,W08P02 - Potenzmenge,"### Potenzmenge von einer Menge finden 

Die Potenzmenge einer Menge $M$ besteht aus allen Teilmengen von $M$, einschließlich der Menge selbst und der leeren Menge.  

z.B ist $P(\{1, 2\})$ die Menge $\{  \emptyset, \{1\}, \{2\}, \{1, 2\} \}$.   

Die Anzahl der Teilmengen einer Menge kann dann durch $$2^n$$ gefunden werden, wobei n die Anzahl der Elemente in der Menge ist.   

Die einzige Teilmenge der leeren Menge, ist die leere Menge selbst, also gilt:

$$ P(\emptyset)=\{\emptyset\} $$

Wenn wir eine Menge $M$ um ein Element $x$ erweitern, besteht $P(M \cup \{x\})$ aus:
1. allen Teilmengen, die $x$ beinhalten
2. allen Teilmengen, die $x$ nicht beinhalten, also die, die bereits in $P(M)$ enthalten sind.


Insgesamt: 

$$P(M \cup \{x\}) = \{\{x\} \cup m | m \in P(M)\} \cup P(M) $$

Von dieser rekursiven Definition kannst du die rekursive Implementierung einfacher ableiten. 

[task][Teilmengen]( 248173 , 248170 , 248175 , 248186 )

Implementiere nun die Methode `powerSet(LinkedList  inputSet)`, die von der gegebenen Liste `inputSet` alle Teilmengen berechnet. Wir verwenden hier für die Darstellung der Menge Listen. Innerhalb einer Liste kommt jedes Element nur einmal vor, und die Reihenfolge der Elemente ist für uns nicht wichtig.


**Hinweise:** 
- Finde hier einen rekursiven Ansatz, wie du alle Teilmengen finden kannst. 
- Um zu überprüfen, ob eine Liste Elemente enthält, steht die `isEmpty()`-Methode zur Verfügung. 
- Mit einer forEach-Schleife kannst du eine Operation auf jedes Element der Liste ausführen. 
- Zum Erstellen einer Kopie der Eingabeliste `inputSet` kannst du `new LinkedList<>(inputSet)`verwenden. 
- Nehme in dieser Aufgabe an, dass `inputSet` nur positive Werte enthält. 

Die Potenzmengenkonstruktion mit einer dreielementigen Liste sieht wie folgt aus: 

```{.console}
inputSet consists of: 1, 2, 3
Finding all power sets:
[] [1] [2] [2, 1] [3] [3, 1] [3, 2] [3, 2, 1] 
```

### Teilmenge mit einer bestimmen Summe finden 
Gegeben $M$, suchen wir eine Teilmenge $T\subseteq M$ mit $\sum_{t\in T} t = s$.

Wir wollen nicht über alle im letzten Aufgabenteil erzeugten Teilmengen iterieren, sondern für jedes Element $x$ bereits während der Konstruktion überprüfen, ob die Summe noch kleiner als $s$ ist. Falls nicht, probieren wir es ohne $x$. Wenn wir später feststellen, dass wir auch  mit  $x$ keine Lösung finden können, müssen wir offenbar eine Lösung  ohne  $x$ suchen.

[task][Teilmenge mit Summe]( 248172 , 248177 , 248179 , 248168 , 248181 )
Implementiere die Methode zur Suche nach einer Teilmenge, deren Summe einen bestimmten Wert ergibt. Da wir Listen verwenden, gilt: Jedes Element kann nur einmal in einer Teilmenge vorkommen, und die Reihenfolge der Elemente spielt keine Rolle.

**Hinweis:**
- Überlege dir, welche Abbruchbedingungen für die rekursive Lösung notwendig sind. Wann kann die Rekursion gestoppt werden, ohne dass weiter nach Teilmengen gesucht wird?

Die Teilmenge mit Summe 5 einer dreielementigen Liste sieht wie folgt aus: 

```{.console}
inputSet consists of: 1, 2, 3
Finding subset with sum = 5:
[3, 2]
```"
404,Praktikum: Grundlagen der Programmierung WS24/25,15464,W08P03 - Rekursives Sortieren,"## Rekursives Sortieren 


  

In dieser Aufgabe lernst du einige rekursive Sortieralgortihmen kennen. Im Template findest du Klassen für jede Sortierverfahren und die Klasse `OutputTesting`. Die Funktionalität deiner rekursiven Merge/Stooge Sort Methoden kannst du testen, indem du 
- die Ausgabe deiner Methode mit der bereits sortierten Liste vergleichst. 
- die Implementierung mit der iterativen Bubble Sort Methode von [W05P03](https://artemis.cit.tum.de/courses/404/exercises/15069) vergleichst. 
Für beide Möglichkeiten findest du ein Beispiel im Template. 

 Diese Merge Sort Aufgabe ist *optional*.  Falls du dich, über die Implementierung von MergeSort noch nicht vertraut fühlst, bearbeite die Aufgabe. Ansonsten kannst du direkt mit StoogeSort anfangen. Die Implementierung von MergeSort brauchst du für die W08P03. 
[task][Merge Sort]( 248212 , 248213 , 248215 , 248214 , 248208 , 248209 , 248218 , 248210 , 248219 ) 

Gerade um größere Mengen an Daten zu sortieren eignet sich Mergesort. Mergesort teilt sich das Problem in viele kleinere auf und macht das ganze somit beherrschbar.  
Implementiere die Methode `mergeSort()` rekursiv.

 
  Beispielbeschreibung mit Eingabe: [3, 6, 2, 8, 4].  
 
[3, 6, 2, 8, 4]                        // Teile das Array in zwei Hälften.
[3, 6, 2]       ||    [8, 4]           // Teile weiter, bis nur einzelne Elemente bleiben.
[3, 6] | [2]    ||    [8] | [4]        // Weiter teilen.
[3] | [6] | [2]  |    [8] | [4]        // Teilung abgeschlossen. Beginne mit Sortieren und Zusammenführen.
[3, 6] | [2]     |    [4, 8]           // Sortiere und kombiniere Nachbarn.
[2, 3, 6]        |    [4, 8]           // Sortiere und kombiniere weiter.
[2, 3, 4, 6, 8]                        // Alles zusammenführen.

 
 

Die unterschiedlichen Farben auf der Abbildung rechts sollen die Rekursionsebenen der einzelnen Schritte darstellen.   


##### Der Algorithmus

Der Algorithmus funktioniert nach dem  Divide & Conquer  Prinzip.  
 1.  Ihr bekommt eine Liste übergeben. Falls diese sortiert ist oder weniger als zwei Elemente beinhaltet, kann diese so wieder zurückgegeben werden. 
 2.  Falls die Liste noch sortiert werden muss, wird sie in zwei gleichgroße Teillisten aufgeteilt. 
 3.  Diese Teillisten werden nun rekursiv mit Mergesort sortiert. 
 4.  Es wird eine Ausgabeliste aus diesen beiden sortierten Teillisten konstruiert. 
 
 a.  Man initialisiert Zugriffsindizes für Liste eins und zwei auf `0`. 
 b.  Man vergleicht die Elemente an den Indizes. 
      Falls ein Index das Ende seiner Liste erreicht hat, können alle verbliebenen Elemente der anderen Liste der Ausgabeliste hinzugefügt werden. 
      Man springt zu Schritt  5 . 
 
 c.  Das kleinere der beiden Elemente wird der Ausgabeliste hinzugefügt. 
 d.  Der Zugriffsindex der entsprechenden Liste wird inkrementiert. 
 e.  Man springt zu Schritt  4.2 . 
 
 5.  Die Ausgabeliste ist nun sortiert und wird zurückgegeben.

Ihr bekommt eine `List ` übergeben, und müsst auch eine Liste vom selben Typ zurückgeben. Die Listen enthalten keine `null` Werte.


[task][Stooge Sort]( 248216 )

Das zweite Verfahren ist `StoogeSort()`. Mit diesem Verfahren kannst du Elemente rekursiv in aufsteigender Reihenfolge sortieren.  

##### Der Algorithmus
Der Stooge-Sort-Algorithmus funktioniert nach folgendem Prinzip:

-  Basisfall: 
Wenn der Teilbereich des Arrays, der sortiert werden soll, nur zwei Elemente enthält:

Vertausche die beiden Elemente, falls das aktuelle größer ist als das nächste.
Falls die Länge des Bereichs kleiner oder gleich 2 ist, beende die Funktion.

-  Rekursiver Fall: 
Ist der Bereich größer als zwei Elemente:

Teile das Array in drei gleich große Teile (oder so nahe wie möglich). Wenn die Länge nicht durch 3 teilbar ist, kann der mittlere 1 oder 2 Elemente mehr enthalten.

1. Wende Stooge-Sort auf die ersten zwei Drittel des Arrays an.
2. Wende Stooge-Sort auf die letzten zwei Drittel des Arrays an.
3. Wende Stooge-Sort erneut auf die ersten zwei Drittel an.

-  Rekursionsende: 
Die Rekursion endet, wenn der gesamte Bereich in Teilbereiche zerlegt ist, die nur noch ein oder zwei Elemente enthalten. An diesem Punkt sind die Elemente sortiert. 
Die Sortierung der kleineren Arrays erfolgt je über einen rekursiven Aufruf von `stoogeSort()`.
Implementiere dafür die Methode `stoogeSort(int[] array)`. Als Hilfsmethode kannst du `stoogeSortHelper(int[] array, int from, int to)`nutzen und diese dann in `stoogeSort(int[] array)` aufrufen und dabei die beiden Parametern für Startindex `(int from)` und Endindex (exklusiv)`(int to)` des zu sortierenden Arrays festlegen. 

-  Funktionsweise :
Die Methode überprüft, ob der Basisfall vorliegt (Bereich mit zwei oder weniger Elementen). Falls nicht, wird der Bereich in Drittel unterteilt, und die Sortierung wird rekursiv auf die entsprechenden Teilbereiche angewandt.

Beispiel: 
```java
int[] array = {5, 3, 8, 1, 2};
stoogeSort(array);
```

 
 Erklärung der Schritte  
 
 Schritt 1: Gesamtes Array sortieren  
Initiales Array:  {5, 3, 8, 1, 2} 

1. Sortieren der ersten zwei Drittel:
    - Bereich:  {5, 3, 8, 1} 
    - Vertausche 5 und 3, da 5 > 3.
        Zwischenergebnis:  {3, 5, 8, 1, 2} 
2. Sortieren der letzten zwei Drittel:
    - Bereich:  {5, 8, 1, 2} 
    - Vertausche 8 und 1, da 8 > 1.  
        Zwischenergebnis:  {3, 5, 1, 8, 2} 
3. Sortieren der ersten zwei Drittel erneut:
    - Bereich:  {3, 5, 1, 8} 
    - Vertausche 5 und 1, da 5 > 1.  
        Zwischenergebnis:  {3, 1, 5, 8, 2} 
 Schritt 2: Teilbereiche weiter sortieren 

1. Sortieren der ersten zwei Drittel des Arrays:
    - Bereich:  {3, 1, 5} 
    - Vertausche 3 und 1, da 3 > 1.  
        Zwischenergebnis:  {1, 3, 5, 8, 2} 
2. Sortieren der letzten zwei Drittel des Arrays:
    - Bereich:  {3, 5, 8} 
    - Keine Vertauschung notwendig, da alles korrekt ist.  
        Zwischenergebnis:  {1, 3, 5, 8, 2} 
3. Sortieren der ersten zwei Drittel erneut:
    - Bereich:  {1, 3, 5} 
    - Keine Vertauschung notwendig, da alles korrekt ist.  
        Zwischenergebnis:  {1, 3, 5, 8, 2} 
 Schritt 3: Letzte Elemente sortieren 

1. Sortieren der letzten beiden Elemente:
    - Bereich:  {8, 2} 
    - Vertausche 8 und 2, da 8 > 2.  
        Zwischenergebnis:  {1, 3, 5, 2, 8} 
2. Sortieren der mittleren drei Elemente:
    - Bereich:  {5, 2, 8} 
    - Vertausche 5 und 2, da 5 > 2.  
        Zwischenergebnis:  {1, 3, 2, 5, 8} 
3. Sortieren der ersten vier Elemente:
    - Bereich:  {3, 2, 5, 8} 
    - Vertausche 3 und 2, da 3 > 2.  
        Zwischenergebnis:  {1, 2, 3, 5, 8} 
4. Sortieren der ersten zwei Drittel erneut:
    - Bereich:  {1, 2, 3} 
    - Keine Vertauschung notwendig, da alles korrekt ist.

Ausgabe:
 {1, 2, 3, 5, 8} 
 
  


#### Hinweise 💡
- Die Tests dieser Aufgabe überprüfen jeweils nur, ob der in die jeweilige Methode geschriebene Code das übergebene Array korrekt sortiert. Du passt also alle Tests, wenn du drei Mal iteratives BubbleSort implementierst. Die Tests sind also nur dazu da, dir Feedback zu geben, was an deiner Implementierung noch falsch sein könnte. Wie du sie verwendest, liegt in deiner Verantwortung. 
- In der Klasse `SortingComparison`kannst du mit unterschiedlich langen Eingaben die Effizienz von Bubble, Stooge und Merge Sort Algorithmen vergleichen. Beachte hier, dass Stooge Sort bei längeren Eingaben längere Laufzeit hat als Bubble Sort. Gerne kannst du weitere Eingaben ausprobieren und die benötigte Zeit vergleichen. 

 
  Noch mehr Infos über Laufzeitvergleich für Interessierenden:    
 
  
Beispiel:  
Testing with the large list (20,000 elements):  
Bubble Sort Time: 2138 ms  
Merge Sort Time: 24 ms  
Die Zeitkomplexität von Bubble Sort ist $$ O(n^2) $$ im schlimmsten Fall, wobei `n` die Anzahl der Elemente ist.   
Dies liegt daran, dass benachbarte Elemente wiederholt verglichen und bei Bedarf getauscht werden, was zu einer quadratischen Zeitkomplexität führt.   
Im Gegensatz dazu hat Merge Sort eine Zeitkomplexität von $$ O(n log n) $$ in allen Fällen, da es das Array rekursiv in Hälften teilt und diese in sortierter Reihenfolge zusammenführt.
Stooge Sort hat eine Zeitkomplexität von $$ O(n^{\log 3/\log 1.5}) $$. Damit ist das Sortieren bei den längeren Eingaben langsamer als Bubble Sort."
404,Praktikum: Grundlagen der Programmierung WS24/25,15465,W08H01 - Rekursive Pinguologie,"# Rekursive Pingulogie 🐧🧬

Die Forschuine der PUM haben vor kurzem große Fortschritte in ihrer Forschung gemacht. Einige ihrer Thesen müssen aber noch überprüft werden und dafür brauchen sie deine Hilfe! Da es sich bei der PUM aber um eine Exzellenzuniversität handelt, haben die Forschuine einige Anforderungen an dich, die du unter den einzelnen Aufgaben findest. 

## Allgemeine Anforderungen
- Im Template findest du die Klasse `PingulogyTesting`, in der du deine JUnit-Tests schreiben und deine Implementierungen testen kannst. 
- Jede Teilaufgabe **muss** rekursiv gelöst werden. Insbesondere sind Schleifen in der gesamten Aufgabe verboten und eine Verwendung dieser führt zu einer Bewertung mit 0 Punkten bei den entsprechenden Teilaufgaben. Das Gleiche gilt für Streams (wer diese schon kennt).
- Private Hilfmethoden, sowie (statische) Hilfsvariablen sind erlaubt. Die Methoden müssen aber ohne zusätzliche Aufrufe funktionieren (also so, wie sie in der `main`-Methode verwendet werden). Außerdem gilt zu beachten, dass die Tests mehrere Methodenaufrufe hintereinander ausführen und statische Hilfsvariablen dazwischen **nicht** zurückgesetzt werden. 
- Die Signatur der vorgegebenen Methoden (Name, Rückgabetyp, Parametertypen) darf **nicht** verändert werden.


## Aufgaben

[task][Aufgabe 1 - Rekursive Pinguin-Reihe]( 248245 , 248233 , 248241 , 248243 , 248247 )

Als Erstes musst du die neuste Pinguin-Reihe implementieren. Diese ist abhängig von einem Start-Vektor p = (p0, p1, p2) und folgt dieser Berechnungsvorschrift:


```
pinguSequenceRec(0) = p0
pinguSequenceRec(1) = p1
pinguSequenceRec(2) = p2
pinguSequenceRec(n) = 2 * pinguSequenceRec(-n), falls n < 0
pinguSequenceRec(n) = pinguSequenceRec (n - 1) - pinguSequenceRec(n - 2) + 2 * pinguSequenceRec(n - 3), sonst
```

Für deine Implementierung geben dir die Forschuine den Vektor komponentenweise mit, sodass deine Methode insgesamt vier Parameter übernimmt. Außerdem gelten folgende Einschränkungen:
- -122 < n < 145
- Die Berechnung muss auf einem durchschnittlichen PC für jede Eingabe in unter einer Sekunde terminieren. Für größere n (~>30) musst du dir also etwas einfallen lassen.
- Bei getesteten Kombinationen aus n und p wird es beim Ergebnis nicht zu long-Overflows kommen.

Hier wird pinguSequenceRec mit p = (1, 1, 2) getestet. Dafür die `main` - Methode mit `testTask = 1` ausführen.
 
 
Beispiel Task 1 
 
 
 

 Task 1 example output 
0: 1
1: 1
2: 2
3: 3
4: 3
5: 4
6: 7
7: 9
8: 10
9: 15
10: 23
11: 28
12: 35
13: 53
14: 74
15: 91
16: 123
17: 180
18: 239
19: 305
20: 426
21: 599
22: 783
23: 1036
24: 1451
25: 1981
26: 2602
27: 3523
28: 4883
29: 6564
30: 8727
31: 11929
32: 16330
33: 21855
34: 29383
35: 40188
36: 54515
37: 73093
38: 98954
39: 134891
40: 182123
41: 245140
42: 332799
43: 451905
44: 609386
45: 823079
46: 1117503
47: 1513196
48: 2041851
49: 2763661
50: 3748202
51: 5068243
52: 6847363
53: 9275524
54: 12564647
55: 16983849
56: 22970250
57: 31115695
58: 42113143
59: 56937948
60: 77056195
61: 104344533
62: 141164234
63: 190932091
64: 258456923
65: 349853300
66: 473260559
67: 640321105
68: 866767146
69: 1172967159
70: 1586842223
71: 2147409356
72: 2906501451
73: 3932776541
74: 5321093802
75: 7201320163
76: 9745779443
77: 13186646884
78: 17843507767
79: 24148419769
80: 32678205770
81: 44216801535
82: 59835435303
83: 80975045308
84: 109573213075
85: 148269038373
86: 200645915914
87: 271523303691
88: 367415464523
89: 497183992660
90: 672815135519
91: 910462071905
92: 1232014921706
93: 1667183120839
94: 2256092342943
95: 3052939065516
96: 4131212964251
97: 5590458584621
98: 7565123751402
99: 10237091095283
100: 13852884513123
101: 18746040920644
102: 25367338598087
103: 34327066703689
104: 46451809946890
105: 62859420439375
106: 85061743899863
107: 115105943354268
108: 155763040333155
109: 210780584778613
110: 285229431153994
111: 385974927041691
112: 522306665444923
113: 706790600711220
114: 956433789349679
115: 1294256519528305
116: 1751403931601066
117: 2370014990772119
118: 3207124098227663
119: 4339916970657676
120: 5872822853974251
121: 7947154079771901
122: 10754165167113002
123: 14552656795289603
124: 19692799787720403
125: 26648473326656804
126: 36060987129515607
127: 48798113378299609
128: 66034072902097610
129: 89357933782829215
130: 120920087637330823
131: 163630299658696828
132: 221426079587024435
133: 299635955202989253
134: 405470474933358474
135: 548686678904418091
136: 742488114377038123
137: 1004742385339336980
138: 1359627628771135039
139: 1839861472185874305
140: 2489718614093413226
141: 3369112399449808999
142: 4559116729728144383
143: 6169441558465161836
144: 8348549627636635451
 
 


[task][Aufgabe 2 - Pingu Zwillinge]( 248242 , 248237 , 248234 )
Als Nächstes musst du für die Forschuine die Zwillingsreihe `pinguF` und `pinguM` implementieren, die sich wie folgt berechnet:

```
pinguF(0) = 1 
pinguF(n) = n - pinguM(pinguF(n-1)), falls n > 0 
pinguM(0) = 0 
pinguM(n) = n - pinguF(pinguM(n-1)), falls n > 0 
```


Die Forschuine versichern dir außerdem, dass die Eingabe `n` niemals negativ sein wird und beim Ergebnis zu keinem `int`-Overflow führen wird.

Hier wird `pinguF` und `pinguM` mit n = 0 ... 9 getestet. Dafür die `main`- Methode mit `testTask = 2` ausführen: 
 
 
Beispiel Task 2 
 
 
 
 Task 2 example output 
 pinguF:  1, 1, 2, 2, 3, 3, 4, 5, 5, 6
 pinguM:  0, 0, 1, 2, 2, 3, 4, 4, 5, 6
 
 

[task][Aufgabe 3 - Der Pingu Code]( 248232 , 248238 )
Im Land der Pinguine gilt der ""Pingu Code"" als eins der am schwersten zu verstehenden Geheimnisse. Die Forscher der PUM haben einen Ansatz gefunden, diesen Code zu berechnen.

- Das Ergebnis ist von zwei Eingabezahlen `n` und `m` abhängig und lässt sich außerdem rekursiv unter Beachtung des Zwischenergebnisses berechnen. 
- Anfangs ist das Zwischenergebnis natürlich 0. Falls n=0 gilt, so ist das Endergebnis die Summe aus `m` und dem Zwischenergebnis. Ansonsten muss unterschieden werden, ob die Summe aus `n` und dem Zwischenergebnis gerade ist oder nicht. Falls es gerade ist, wird rekursiv weitergerechnet, wobei das neue `n` den Wert von `m` erhält und das neue `m` die Hälfte des alten `n` (abgerundet). 
- Außerdem werden `n`- halbe (altes `n`, abgerundet) zum Zwischenergebnis addiert. Falls obige Summe ungerade ist, wird auch rekursiv weitergerechnet. In diesem Fall wird jedoch `m` zum Zwischenergebnis addiert, `n` um eins reduziert und `m` halbiert (abgerundet). 

Auch bei dieser Aufgabe werden nur nicht-negative Eingaben verwendet und es wird nicht zu `int`- Overflows kommen. ""Abgerundet"" meint in dieser Aufgabe das normal Java - Rundungsverhalten (Richtung 0).

Hier wird pinguCode mit n = 0 ... 9, m = 0 ... 9  getestet. Dafür die `main`- Methode mit `testTask = 3` ausführen: 
 
  Beispiel Task 3 
 
 
 
 Task 3 example output 
0, 0: 0
0, 1: 1
0, 2: 2
0, 3: 3
0, 4: 4
0, 5: 5
0, 6: 6
0, 7: 7
0, 8: 8
0, 9: 9
 ---------- 
1, 0: 0
1, 1: 1
1, 2: 3
1, 3: 4
1, 4: 6
1, 5: 7
1, 6: 9
1, 7: 10
1, 8: 12
1, 9: 13
 ---------- 
2, 0: 2
2, 1: 1
2, 2: 2
2, 3: 3
2, 4: 4
2, 5: 3
2, 6: 6
2, 7: 8
2, 8: 8
2, 9: 7
 ---------- 
3, 0: 2
3, 1: 1
3, 2: 3
3, 3: 4
3, 4: 6
3, 5: 7
3, 6: 9
3, 7: 11
3, 8: 12
3, 9: 13
 ---------- 
4, 0: 4
4, 1: 5
4, 2: 4
4, 3: 5
4, 4: 6
4, 5: 9
4, 6: 9
4, 7: 9
4, 8: 10
4, 9: 14
 ---------- 
5, 0: 4
5, 1: 3
5, 2: 7
5, 3: 6
5, 4: 8
5, 5: 9
5, 6: 11
5, 7: 11
5, 8: 14
5, 9: 15
 ---------- 
6, 0: 6
6, 1: 5
6, 2: 7
6, 3: 5
6, 4: 7
6, 5: 7
6, 6: 9
6, 7: 10
6, 8: 11
6, 9: 13
 ---------- 
7, 0: 6
7, 1: 5
7, 2: 7
7, 3: 8
7, 4: 11
7, 5: 9
7, 6: 11
7, 7: 13
7, 8: 15
7, 9: 17
 ---------- 
8, 0: 8
8, 1: 10
8, 2: 8
8, 3: 10
8, 4: 10
8, 5: 12
8, 6: 11
8, 7: 15
8, 8: 14
8, 9: 16
 ---------- 
9, 0: 8
9, 1: 7
9, 2: 12
9, 3: 10
9, 4: 12
9, 5: 14
9, 6: 16
9, 7: 15
9, 8: 18
9, 9: 19
 ---------- 
 
 


[task][Aufgabe 4 - Pingu DNS]( 248240 , 248244 , 248236 , 248246 , 248239 )
Zu guter Letzt musst du den Forschuinen noch helfen, die DNS eines Pinguins zu bestimmen, bei dem nur die Pingu-Werte der Eltern (`f` und `m`) bekannt sind. Für die rekursive Berechnung ist vor allem die binäre Darstellung dieser Werte relevant, die dir in Form eines (nicht negativen) `int` übergeben wird.  

Zur Bestimmung des DNA -`Strings` haben die Forscher folgende Prozedur gefunden:  

- Sollten die Pingu-Werte beider Eltern 0 sein, so ist die resultierende DNS der leere `String` """".  
Falls nur `f` 0 ist, so wird für jedes Bit von `m` abzüglich führender 0er-Bits ein "" A "" angehängt, im ungekehrten Fall (nur `m`=0) ein "" T "". `pinguDNA(0,2)` gibt also "" AA "" zurück, da 2=10b entspricht. Für `pinguDNA(10,0)` ist die Lösung "" TTTT "", da 10=1010b ist.  
- Interessant wird es, falls beide Pingu-Werte nicht 0 sind. In diesem Fall muss zuerst unterschieden werden, ob `f` und `m` mit dem selben Bitwert enden (Tipp: gerade/ungerade).  
    Falls ja hängt das Basenpaar davon ab, ob `f` > `m` ("" GT ""), `f` < `m` ("" GA "") oder `f` = `m` ("" GC "") gilt.  
    Falls nein, ist es relevant, welcher Pingu-Wert mit einem 1-er Bit endet. Sollte `f` so enden, wird "" TC "" angehängt, sonst "" AC "".  

- Jedes Bit wird für genau eine Nukleinbase im Ausgabestring verwendet und kann daher für die Rekursion verworfen werden  (Tipp: Division durch 2) .  

Ein Schritt-für-Schritt Beispiel findest du unten im Beispiel. 


Hier wird `pinguDNA`  getestet. Dafür die `main`-Methode mit `testTask = 4` ausführen: 
 
  Beispiel Task 4 
 
 
 
 Task 3 example output  
 pinguDNA(21, 25) = GCACTCGAGA 

21 in binär ist ""10101b""  
25 in binär ist ""11001b""  

 1.   21 != 0 != 25, beide enden mit 1er Bit und 21 < 25 => "" GA ""
 2.   Bits entfernen => f=""1010b""=10, m=""1100b""=12
 3.   f,m != 0, enden mit 0er Bit, f  "" GA "" => insgesamt "" GAGA ""
 4.   Bits entfernen => f=""101b""=5, m=""110b""=6
 5.   f,m != 0, enden mit unterschiedlichem Bitwert, m ist durch 2 teilbar => "" TC "" => insgesamt "" TCGAGA ""
 6.   Bits entfernen => f=""10b""=2, m=""11b""=3
 7.   f,m != 0 enden mit unterschiedlichem Bitwert, f ist durch 2 teilbar => "" AC "" => insgesamt "" ACTCGAGA ""
 8.  Bits entfernen => f=""1b""=1, m=""1b""=1
 9.   f,m != 0, enden mit 1er Bit und sind gleich => "" GC "" => insgesamt "" GCACTCGAGA ""
 10.  Bits Entfernen => f=0, m=0 => """", fertig => insgesamt "" GCACTCGAGA ""
 
 

## Hinweise 💡
- Allgemeine Anforderungen findest du über den Aufgaben
- Falls ein Test ""Es gibt ein Problem mit den Tests selbst!"" ausgibt, wurde eine Exception geworfen. Dies liegt dann an deiner Abgabe, die mit einer getesteten Eingabe Probleme hat."
404,Praktikum: Grundlagen der Programmierung WS24/25,15466,W08H03 - Mega Merge Sort,"# Mega Merge Sort

In dieser Aufgabe geht es darum, `MegaMergeSort` zu implementieren. Dabei handelt es sich um eine Variante des bekannten Divide-and-Conquer Sortieralgorithmus MergeSort. Bei MergeSort werden die zu sortierenden Elemente zuerst in möglichst gleichgroße Bereiche geteilt, indem jeder Bereich immer wieder halbiert wird. Anschließend werden diese Bereiche wieder zusammengeführt (gemergt), wobei sie sortiert werden. Wenn du die Implementierung von MergeSort nochmal üben willst, kannst du die erste Teilaufgabe von der [W08P03](https://artemis.cit.tum.de/courses/404/exercises/15464) bearbeiten. MegaMergeSort funktioniert sehr ähnlich, allerdings werden Bereiche nicht halbiert, sondern in eine festgelegte Anzahl an Teilbereiche zerlegt.

[task][Mergen zweier Arrays]( 248576 , 248582 , 248575 , 248577 , 248574 )
Zuerst sollst du die Methode `int[] merge(int[], int[])` implementieren, die die beiden übergebenen Arrays zu einem neuen zusammenfügt (merget) und dieses zurückgibt. Das Mergen funktioniert dabei wie bei normalem MergeSort: Man beginnt bei beiden Arrays beim ersten Element, vergleicht diese und fügt das kleinere im Ausgabe-Array ein. Das eingefügte Element überspringt man nun im Eingabe-Array und wiederholt die Prozedur, bis alle Elemente in der Ausgabe eingefügt wurden. Die Länge des zurückgegebenen Arrays entspricht natürlich der Summe der Längen der beiden Eingabearrays.

 
  Beispiel für das Mergen zweier Arrays  
 
merge([1, 3], [2, 4])

Vergleiche 1 und 2 -> füge 1 in die Ausgabe ein: [1]
Vergleiche 3 und 2 -> füge 2 in die Ausgabe ein: [1, 2]
Vergleiche 3 und 4 -> füge 3 in die Ausgabe ein: [1, 2, 3]
Nur 4 ist noch übrig -> füge 4 in die Ausgabe ein: [1, 2, 3, 4]
 
 

[task][Mergen mehrerer Arrays]( 248579 , 248581 , 248580 , 248583 )
Jetzt sollst du `int[] merge(int[][], int, int)` implementieren. Diese Methode soll rekursiv die inneren Arrays aus `arrays` im Indexbereich `from` (inklusiv) bis `to` (exklusiv) mergen (also `arrays[from]`, `arrays[from + 1]`, ... und `arrays[to - 1]` sollen gemerget werden) und das daraus resultierende Array zurückgeben. Falls der Bereich `[from, to[` leer ist, soll ein Array der Länge `0` zurückgegeben werden. Die genaue Mergereihenfolge siehst du in folgendem Beispiel:

 
  Beispiel für das Mergen mehrerer Arrays  
 
merge([[1], [2], [3], [4]], 0, 4)

merge von [3] und [4] -> [3, 4]
merge von [2] und [3, 4] -> [2, 3, 4]
merge von [1] und [2, 3, 4] -> [1, 2, 3, 4]
 
 

[task][MegaMergeSort]( 248263 , 248258 , 248265 , 248264 )
Als Letztes fehlt noch die Methode `int[] megaMergeSort(int[], int, int, int)` (die zugehörige Methode `int[] megaMergeSort(int[], int)`, mit der MegaMergeSort ausgeführt wird, ist schon gegeben). Diese Methode sortiert das `array` im Bereich `[from, to[` mit MegaMergeSort, wobei das Array in jeder Ebene in `div`-Teile aufgeteilt werden soll. Auch hier soll, falls `[from, to[` leer ist, ein Array der Länge `0` zurückgegeben werden. Beim Aufteilen gibt es Folgendes zu beachten: Es wird rekursiv aufgeteilt, bis ein Bereich maximal `1` Element enthält. Falls die Länge des zu sortierende Bereichs nicht restlos durch `div` teilbar ist, so sollen die ersten Teilbereiche entsprechend um 1 größer sein. Im Beispiel sieht das wie folgt aus:

 
  Beispiel für das Splitten eines Arrays  
 

megaMergeSort([1, 2, 3, 4, 5, 6, 7, 8], 3, 0, 8)

8/3 = 2 Rest 2
Split der 1. Ebene: [1, 2, 3], [4, 5, 6], [7, 8]
Split der 2. Ebene: 
  für [1, 2, 3]: 3/3 = 1 Rest 0 => [1], [2], [3]
  für [4, 5, 6]: 3/3 = 1 Rest 0 => [4], [5], [6]
  für [7, 8]: 2/3 = 0 Rest 2 => [7], [8], []
 
 


### Hinweise 💡
- In der gesamten Aufgabe sind Methoden aus `java.util.Arrays` verboten.
- Die Methoden in dieser Aufgabe die Köpfe wie `protected int[] merge(..)`. Dies ist eine Notwendigkeit dafür, wie unsere Tests aufgebaut sind. Du kannst von einer der drei Methoden aus die anderen wie gewohnt mit einem Call wie `merge(.. parameter ..)` aufrufen. Von der `main()`- Methode aus kannst du das allerdings nicht mehr genauso. Daher haben wir dir die `main()`- Methode bereits implementiert. Um dein Verfahren zu testen, musst du nur noch `arr` und den zweiten Parameter im Call darunter entsprechend abändern."
404,Praktikum: Grundlagen der Programmierung WS24/25,15467,W08P04 - Rekursive Datenstrukturen,"# Rekursive Datenstrukturen

In dieser Aufgabe lernst du die Lieblingsdatenstrukturen von Informatikern kennen:  Bäume .
Bäume sind hierarchische Datenstrukturen bestehend aus Knoten und Kanten.
 

Die rekursive Definition lautet: Ein Baum ist entweder leer oder besteht aus einer Wurzel mit null oder mehr Teilbäumen, von denen jeder auch ein Baum ist. Die Wurzel jedes Teilbaums ist durch eine Kante mit der Wurzel des übergeordneten Baums verbunden. [Quelle]( https://de.wikipedia.org/wiki/Baum_%28Datenstruktur%29#Definitionen)

Bäume sind dynamische Datenstrukturen und ermöglichen das Einfügen und Löschen von Daten effizient, ohne die gesamte Datenstruktur umzuordnen.
Die Daten müssen nach Einfügen oder Löschen eines Elements nicht nochmal neu sortiert werden. 
Bevor du in die tiefe Welt der Bäume in der Informatik gehst, lernst du noch paar wichtige Begriffe kennen: 


- Knoten, die keine Nachfolger, auch Kinder genannt, haben, nennt man  Blätter . Der einzige Knoten im Baum, der keinen Vorgänger bzw. Elternknoten hat, ist die  Wurzel . Anders als bei echten Bäumen wachsen Bäume in der Informatik von oben nach unten.

- Die  Höhe  ist die Länge des längsten Pfades von der Wurzel zu einem Blatt, wobei je nach Definition die Anzahl der Knoten (wie in dieser Aufgabe) bzw. Kanten des Pfades verwendet wird. Im Gegensatz dazu bezeichnet die `size` des Baumes die Gesamtzahl der Knoten im ganzen Baum.

In dieser Aufgabe werden wir uns von einer Verallgemeinerung von  Knoten  schrittweise zu  Binärbäumen  vorarbeiten. Bei Binärbäumen hat jeder Knoten *maximal zwei Nachfolger*, weshalb man auch vom linken und rechten Kind eines Knoten spricht. 

 

Es gibt verschiedene Möglichkeiten, die Knoten eines solchen Baumes in sinnvoller Weise zu besuchen. Das nennt man auch  Traversierungsreihenfolge . Dabei unterscheidet man zwischen
-	**In-Order:** Zuerst wird der linke Teilbaum besucht, dann die Wurzel und zuletzt der rechte Teilbaum
-	**Pre-Order:** Zuerst wird die Wurzel besucht, dann der linke und zuletzt der rechte Teilbaum
-	**Post-Order:** Zuerst wird der linke Teilbaum, dann der rechte und zuletzt die Wurzel besucht
Um zwischen den Reihenfolgen zu unterscheiden, enthält das Template das Enum `Order`.

### Teil 1: Node 
Der erste Schritt auf dem Weg zu deinem eigenen Baum ist die generische Klasse `Node`. Die Klasse ist bereits im Template enthalten und es müssen nur noch einige Methoden ergänzt werden.
- [task][getChild]( 248312 )
Die Methode soll das `i`-te Kind des Knoten zurückgeben oder `null` für ungültige Werte von `i`.
- [task][setChild]( 248316 )
Die Methode soll das `i`-te Kind auf die übergebenen `Node` setzen, falls der Wert von `i` gültig ist.
- [task][isLeaf]( 248318 )
Die Methode soll `true` zurückgeben, falls der Knoten ein Blatt ist.
- [task][height]( 248317 )
Die Methode soll die Höhe des Teilbaums zurückgeben, der an der aktuellen `Node` beginnt. Implementiere die Methode rekursiv!
- [task][size]( 248310 )
Die Methode soll die Anzahl der Knoten im aktuellen Teilbaum zurückgeben. Implementiere die Methode rekursiv!


### Teil 2: Binary Node
Mit der Klasse `Node` können wir schon allgemeine Bäume darstellen. Da wir aber an Binärbäumen interessiert sind, spezialisieren wir die Knoten mit der Klasse `BinaryNode`.
- [task][BinaryNode Konstruktoren, getter und setter]( 248320 , 248311 )
`BinaryNode` soll zwei Konstruktoren enthalten:
    - Der erste Konstruktor soll nur ein `T` für den Wert des Knoten übernehmen. Gehe sicher, dass nach dem Aufruf genug Platz für genau zwei Kinder in `children` ist.
    - Der zweite Konstruktor soll zusätzlich `BinaryNodes` für das linke und rechte Kind übernehmen (in dieser Reihenfolge).
    - **Tipp:** Falls du die Schreibweise noch nicht kennst: Der Konstruktor von `Node` übernimmt eine variable Anzahl an `Node`-Parametern, die Komma-separiert übergeben werden können und automatisch in ein Array der entsprechenden Länge umgewandelt werden.
    - Außerdem sollen Getter und Setter für das linke und rechte Kind existieren (`get/setLeft`, `get/setRight`).
- [task][toList]( 248321 )
Die Methode soll eine Liste der Elemente des Baums (also der `value`-Werte, nicht der `Node`-Objekte!) zurückgeben, dessen Wurzel die aktuelle `BinaryNode` ist. Dabei soll die übergebene Traversierungsreihenfolge beachtet werden.
    - Ist der Baum leer, dann auch die Liste
    - Als Listenimplementierung soll `java.util.LinkedList` verwendet werden
    - Implementiere die Methode rekursiv!
- [task][toString]( 248319 )
Du sollst zwei `toString`-Methoden implementieren: die normale `Object.toString` ohne Parameter, welche eine String-Repräsentation in-order zurückgibt, und eine, die die Traversierungsreihenfolge wie die `toList`-Methode übernimmt und die String-Repräsentation entsprechend dieser Reihenfolge zurückgibt.
    - Ein Blatt soll folgenden String zurückgeben: "" [ \ ] ""
    - Für einen inneren Knoten (Knoten mit mindestens einem Kind) hängt die Ausgabe von der Traversierungsreihenfolge ab. Für in-order soll z.B. folgender String zurückgegeben werden: "" [ \ ,⎵ \ ,⎵ \ ] ""
    - Ein leerer Teilbaum wird durch "" - "" symbolisiert, ohne die Klammern.
    - Der Ausgabestring für eine `BinaryNode ` mit `value`=*3*, ohne linkes Kind und mit rechtem Kind mit `value`=*5*, welches ein Blatt ist, in post-order würde wie folgt aussehen: "" [-,⎵[5],⎵3] ""
    - Implementiere die Methode rekursiv!

### Teil 3: BSTNode
Jetzt kommen wir zu der `Node`-Klasse, die wir letztlich in dieser Aufgabe für den Baum nutzen wollen. Ziel ist nämlich ein binärer Suchbaum (BST), in dem folgende Invariante gilt: Für einen Knoten a mit linkem Kind b und rechtem Kind c gilt: b.value < a.value < c.value. Wir erlauben keine doppelten Werte. Diese Invariante erlaubt es uns, deutlich effizienter zu überprüfen, ob ein Element in der Datenstruktur vorhanden ist, als es z.B. für Listen der Fall ist.
- [task][BSTNode Konstruktoren]( 248302 )
`BSTNode` soll die gleichen Konstruktoren haben, wie `BinaryNode`. (Für die Kinder wird hier natürlich je eine `BSTNode` erwartet)
- [task][insert]( 248304 )
Die Methode soll den übergebenen Wert gemäß der oben beschriebenen Invariante in den Baum einfügen. Zum Überprüfen, ob ein Element größer oder kleiner ist als ein anderes, kannst du das [Comparable](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Comparable.html)-Interface nutzen, welches vom generischen Typ `T` implementiert werden muss (siehe Klassen-Kopf).
    - Wie oben beschrieben sollen keine Duplikate eingefügt werden. In diesem Fall ändert sich der Baum nicht.
    - Implementiere die Methode rekursiv!
- [task][contains]( 248308 )
Die Methode gibt `true` zurück, falls der übergebene Wert im Baum enthalten ist, sonst `false`.
    - Implementiere die Methode rekursiv!

### Teil 4: BST 
Mit `BSTNode` hast du die interne Struktur des Baums bereits implementiert. Jetzt fehlt nur noch der Baum an sich. Benutze für die folgenden Aufgaben soviel Code aus den `Node`-Klassen, wie möglich.
- [task][BST Attribut und Konstruktor]( 248307 )
BST soll ein `private`-Attribut `root` vom Typ `BSTNode` enthalten, welches die Wurzel des Baumes darstellt. Der einzige, parameterlose Konstruktor soll dieses Attribut mit null initialisieren.
- [task][insert]( 248315 )
`insert` fügt den übergebenen Wert gemäß der oben beschriebenen Invariante in den Baum ein.
- [task][isEmpty]( 248313 )
Die Methode `isEmpty` gibt `true` zurück, wenn der Baum leer ist, sonst `false`.
- [task][size]( 248309 )
Soll die die Anzahl der Knoten im Baum zurückgeben.
- [task][contains]( 248306 )
Gibt `true`, wenn der übergebene Wert im Baum vorhanden ist, sonst `false`.
- [task][toList]( 248314 )
Gibt eine Liste der im Baum enthaltenen Werte in-order zurück.
Auch hier soll wieder eine `LinkedList` verwendet werden.
Für einen leeren Baum soll eine leere Liste zurückgegeben werden.
- [task][toString]( 248303 )
Gibt eine String-Repräsentation des Baumes zurück. Die Regeln sind dabei die selben wie für `BinaryNode.toString(Order.IN)`. Für einen leeren Baum soll "" [] "" zurückgegeben werden."
404,Praktikum: Grundlagen der Programmierung WS24/25,15471,W08H02 - Rekursionsrätsel,"# Rekursionsrätsel - Schneeballturnier der Pinguine

In der Antarktis hat es geschneit, und die Pinguine bereiten sich auf ihr traditionelles Schneeballturnier vor. Deine Aufgabe ist es, den Pinguinen bei der Organisation ihrer Startpositionen zu helfen. Damit die Plätze so schnell wie möglich belegt werden und das Turnier losgehen kann, kannst du die rekursiven Methoden benutzen. 

Insgesamt gibt es in der Antarktis 9 Pingu-Familien. Jeder Pingu trägt dabei die Nummer der Familie, also von 1 bis 9. Das gesamte Turnier teilt sich dabei in zwei Runden auf. In der ersten Runde des Turniers wollen die Pinguine natürlich nicht gegen ihre eigene Familie, sondern gegen die anderen Familien spielen. In die zweite Runde kommen nur bestimmt Pinguine. Wie viele das schaffen, steht natürlich nicht fest. Deine Implementierung soll aber für jede Zahl eine mögliche Belegung liefern können. 

#### Hinweise 💡 
- Die beiden Runden sind von der Geschichte her verbunden. Jedoch kannst du die beiden Teile unabhängig voneinander bearbeiten. Bedeutet: Die Tests sind unabhängig voneinander und mocken vorherige Teilaufgaben.
- Allerdings soll der Gedankengang der ersten Runde dich für die zweite Runde vorbereiten. Empfehlenswert ist es, dass du diese der Reihe nach bearbeitest. 
- Deine Abgabe wird mit beliebig großen Feldern getestet. Damit du keine Time Outs bei unseren Tests bekommst, sollst du deine Methoden rekursiv schreiben, besonders die `place..` Methoden. Eine effiziente und iterative Implementierung ist Möglich erfordert jedoch die Simulation des Callstacks der Rekursion. Wir raten davon ab dies zu versuchen.
- Die Lösung des Problems erfordert systematisches Ausprobieren aller Möglichkeiten, wobei ungültige Konfigurationen verworfen werden.
- Beachte, dass das Problem mehrere Lösungen haben kann. Die Methode sollte jedoch stets mindestens eine Lösung finden.
- Du darfst die Zugriffsmodifier auf deinem Template auf keinen Fall ändern. Ansonsten wirst du von unseren Tests einen Build Fail bekommen. 
- Es werden nur Eingaben getestet die auch eine Lösung für das Problem erlauben.

Im Template findest du die folgenden Klassen:  `BigGameField`, `FirstRoundPositions`,`SecondRoundPositions` & `Penguin`. 

Jeder Pinguin hat, wie du in der Klasse `Penguin` sehen kannst, folgende Attribute: `familyNumber`, `isBest`. In der `Penguin` Klasse musst du nichts ergänzen.
Wir fangen nun mit der Initialisierung des Spielfelds an.

   

Das Spiel findet auf einem 9x9-Spielfeld statt, das in 9 kleinere 3x3-Felder unterteilt ist.

### Runde 1: Startposition der Pinguine
In dieser Runde gibt es insgesamt 9 Spiele, die jeweils auf den 3x3 Spielfeldern stattfinden. Auf diesen kleineren Spielfeldern sollst du die Pinguine nach ihrer `familyNumber` platzieren. Wie oben erwähnt wurde, gibt es insgesamt 9 Pinguin-Familien, die durch Zahlen (1 bis 9) gekennzeichnet sind. D.h, jeder Pinguin aus Familie 1 hat die `familyNumber` 1.   
 Ziel:  Platziere die Pinguine so, dass folgende Regeln eingehalten werden:
-  Zeilenregel:  In jeder Reihe darf nur ein Pinguin derselben Familie sein.
-  Spaltenregel:  In jeder Spalte darf nur ein Pinguin derselben Familie sein.
-  Blockregel:  In jedem der 9 kleineren 3x3-Felder darf nur ein Pinguin derselben Familie sein.

Deine Aufgabe ist es, die Pinguine aller Familien so zu platzieren, dass die Regeln nicht verletzt werden.
Manche Pinguine sind ungeduldig und können nicht mehr auf das Spiel warten. Es kann deswegen sein, dass manche Pinguine sich schon einen Platz gesucht haben, jedoch nicht alle. Gehe davon aus, dass diese Pinguine sich schon an die Regeln gehalten haben. Deine Implementierung soll also das Feld korrekt belegen, auch wenn am Anfang manche Positionen schon durch die Pinguine belegt sind. Nutze dafür die `boolean isFixed(int, int)` Methode aus `BigGameField`. Sie gibt zurück ob der Platz von einem der ungeduldigen Pinguine besetzt wurde. 

#### BigGameField
Diese Klasse verwaltet das 9x9-Spielfeld, das aus 9 3x3-Spielfeldern besteht und überprüft, ob eine Position sicher für einen Pinguin ist.

Damit du deine Implementierung mit Beispielen testen kannst, findest du in `BigGameField` die Methode `printGrid()`.

[task][Konstruktor]( 248466 )
Der Konstruktor soll ein BigGameField-Objekt erstellen. Es nimmt ein zweidimensionales Array `initialBoard` als Parameter, das die Anfangswerte des Fields enthält.
Das Board besteht aus 9 Zeilen und 9 Spalten, wobei jedes Element entweder eine Zahl von 1 bis 9 oder 0 ist (0 steht für ein leeres Feld). Die anfangs bereits belegte Felder sind als `isFixed` bezeichnet. Implementiere den Konstruktor und setze dabei die belegten Felder von `initialBoard` als fixed. 

[task][isSafe()]( 248471 , 248467 , 248436 , 248452 )
Um die Implementierung dieser Methode einfacher zu machen, implementieren wir zunächst die folgenden Hilfsmethoden. Du kannst natürlich auch selber weitere Hilfsmethoden hinzufügen. 
- [task][isColSafe()]( 248454 , 248446 , 248480 , 248448 , 248456 , 248473 , 248478 ) Überprüfe, ob die `col` für den Pinguin mit Nummer `num` sicher ist.
- [task][isRowSafe()]( 248438 , 248440 , 248434 , 248479 )
Überprüfe, ob die `row` für den Pinguin mit Nummer `num` sicher ist. 
- [task][isBlockSafe()]( 248477 , 248485 , 248483 ) Überprüfe, ob der 3x3 Block mit `startRow`und `startCol`für den Pinguin mit Nummer `num` sicher ist.
Nutze nun die drei Hilfsmethoden um zu überprüfen, ob ein Pinguin eienr bestimmten Familie an der Position platziert werden kann.

Die Methode `boolean isSafe(int, int)` überprüft ob ein Pinguin einer bestimmten Familie `num` an der Position (`row`, `col`) platziert werden kann, ohne die Regeln zu verletzen. Eine Position ist dann sicher, wenn die Spalte, Reihe und Block, in der sie sich befindet sicher ist.

[task][placePenguin]( 248469 , 248465 , 248460 , 248468 , 248463 )
Platziert einen Penguin an der gegebenen Position im Spielfeld. Die Methode `placePenguin(int row, int col, int num)` nimmt die Zeilen-/Spaltennummer von der Position und die Nummer der Pinguin entgegen. 

[task][removePenguin]( 248476 , 248470 , 248475 ) 
Entfernt den Penguin an der gegebenen Position im Spielfeld. Die Methode `removePenguin(int row, int col)` nimmt die Position entgegen, auf der der Pinguin entfernt werden muss. Nach der Entfernung soll diese Position wie am Anfang wieder leer sein.  

#### FirstRoundPositions 
Die Klasse  `FirstRoundPositions ` organisiert die erste Runde des Turniers und implementiert die Logik für die Platzierung der Pinguine.

[task][placeAllPenguins]( 248417 , 248415 , 248419 , 248420 , 248414 , 248418 )
- Entwickle eine  rekursive  Methode, die alle Pinguine auf dem Spielfeld platziert. Überprüfe dabei, ob alle Regeln eingehalten werden. Falls eine gültige Lösung gefunden wird, gibt die Methode `true` zurück, andernfalls `false`. Denk hier daran, dass dir viele Methoden aus der Klasse `BigGameField`zur Hilfe stehen. 

Durch das Ausführen der  `main `-Methode könnt ihr eure Implementierung testen. Die Methode  `solvePuzzle() ` startet den Prozess zum Lösen des Pinguin-Puzzles. Es versucht, Pinguine beginnend bei der Zelle (0,0) durch den Aufruf  `placePenguins() ` zu platzieren. Deine Implementierung soll bei den vorgegebenen Beispiele, auf die leeren Plätze Pinguine setzen können, ohne dass die oben gennannten Regeln der ersten Runde verletzt werden. 

 
   Eine richtige Ausgabe vom 9x9-Spielfeld kann z.B. wie folgt aussehen:    

```java
Solution found:
1 2 3 4 5 6 7 8 9 
4 5 6 7 8 9 1 2 3 
7 8 9 1 2 3 4 5 6 
2 1 4 3 6 5 8 9 7 
3 6 5 8 9 7 2 1 4 
8 9 7 2 1 4 3 6 5 
5 3 1 6 4 2 9 7 8 
6 4 2 9 7 8 5 3 1 
9 7 8 5 3 1 6 4 2
```
 
 

### Runde 2: Turnier der Queens
   
Nach der ersten Runde treten die besten Pinguine als `Queens` in einem neuen Turnier an.

Regeln für Runde 2
-  Zeilenregel:  Jede Zeile darf nur eine *Queen* enthalten.
-  Spaltenregel:  Jede Spalte darf nur eine *Queen* enthalten.
-  Diagonalenregel:  Keine Diagonale darf mehr als eine *Queen* enthalten.  
Das Ziel ist es, alle Queens gemäß diesen Regeln auf dem Feld zu platzieren. Am Anfang steht nicht fest, wie viele Queens in der zweiten Runde spielen werden. Deine Implementierung soll für beliebige Größen des Feldes und die Anzahl der Queens die richtige Belegung finden. Das Feld ist immer quadratisch und die Kanten sind genauso lang wie die Anzahl der Queens.  

#### SecondRoundPositions

Diese Klasse organisiert die zweite Runde des Turniers und platziert die besten Pinguine gemäß den Regeln.

Am Anfang ist das Feld leer, also mit  '.'  gefüllt, da sich noch keine *Queen* auf dem Feld befindet. Die Liste `bestPenguins` enthält die Pinguine, die du für die zweite Runde auf das Feld platzieren sollst. 

Wie in der ersten Runde hast du hier wieder Hilfsmethoden, die du für die Methode `placeQueens` brauchst. Fange am Besten mit den Hilfsmethoden an.
In der folgenden Teilaufgabe erklären wir dir genauer wieder Algorithmus funktioniert. Für die folgenden Methoden, die auf Regelverstöße checken, reicht es aus nach Regelverstößen links der aktuellen Spalte zu suchen. Alle Spalten auf der rechten Seite der aktuellen Spalte können ignoriert werden.
[task][isSafe(int row, int col)]( 248453 ) Eine Position ist in der zweiten Runde genau dann safe, wenn die Diagonale, Spalte & Zeile safe sind. Implementiere die einzelnen Methoden, die diese Regeln überprüfen müssen. 
- [task][isUpperDiagonalSafe(int row, int col)]( 248439 , 248443 ) Überprüfe, ob auf der oberen Diagonale sich schon eine `Queen` befindet. Es reicht aus die linke-obere Diagonale zu untersuchen.
- [task][isLowerDiagonalSafe(int row, int col)]( 248445 , 248459 ) Überprüfe, ob auf der unteren Diagonale sich schon eine `Queen` befindet. Es reicht aus die linke-untere Diagonale zu untersuchen.
- [task][isRowSafe(int row, int col)]( 248441 , 248455 , 248451 , 248435 ) Überprüfe, ob auf der Zeile sich schon eine `Queen` befindet. Es reicht aus die Einträge der Zeile die sich links von der gegebenen Spalte befinden zu untersuchen.

Nachdem du die Hilfsmethoden für die Regeln implentiert hast, kannst du nun die Queens platzieren. 

- [task][placeQueens(int col)]( 248464 , 248462 , 248472 ) 
Implementiere nun die Methode `placeQueens(int col)`. Um eine *Queen* auf das Feld zu platzieren sollst du diese Position durch  'Q'  ersetzen. Wie du es auf dem Template sehen wirst, sind hier die leeren Positionen durch  '.'  gekennzeichnet. 

Der Parameter `col` in der Methode `placeQueens(int col)` gibt die aktuelle Spalte an, in der versucht wird, eine Queen zu platzieren. Der Algorithmus soll von links nach rechts arbeiten, indem er in jeder Spalte (beginnend bei 0) prüft, ob eine sichere Position in einer der Zeilen gefunden werden kann.
Sobald eine Queen platziert ist, wird  rekursiv  zur nächsten Spalte weitergegangen.

Deine Implementierung kannst du innerhalb der `main`-Methode testen. Wenn du es richtig implentiert hast, soll deine Methode für alle Eingaben `tournament.placeQueens(col)` eine Lösung ausgeben. 

 
  Die richtige Ausgabe mit `tournament.placeQueens()` mit 9 Queens soll wie folgt aussehen:   

```java
col = 0 
Tournament final board:
Q . . . . . . . . 
. . . . Q . . . . 
. Q . . . . . . . 
. . . . . Q . . . 
. . . . . . . . Q 
. . Q . . . . . . 
. . . . . . . Q . 
. . . Q . . . . . 
. . . . . . Q . .


col = 2 
Tournament final board:
. . Q . . . . . . 
. . . . . . Q . . 
. . . Q . . . . . 
. . . . . . . Q . 
. . . . Q . . . . 
. . . . . . . . Q 
. . . . . Q . . . 
. . . . . . . . . 
. . . . . . . . .  

col = 8
Tournament final board:
. . . . . . . . Q 
. . . . . . . . . 
. . . . . . . . . 
. . . . . . . . . 
. . . . . . . . . 
. . . . . . . . . 
. . . . . . . . . 
. . . . . . . . . 
. . . . . . . . .
```"
404,Praktikum: Grundlagen der Programmierung WS24/25,15553,W09H01 - Pinguin Roboter,"# W09H01 - Pinguin Roboter

Nach einer sehr langen Reise haben die Entdeckuine endlich die Höhle gefunden, in der das Zepter ist.
Vor dem Eingang entdecken sie aber ein Schild, welches auf tödliche Gefahren hinweist:

 
 Schild 

Tritt nicht ein, wo Schatten lauern,  
Eis und Dunkel Kräfte kauern.  
Was du suchst, mag Glanz versprechen,  
doch hier enden Mut und Zechen.  

Frost umklammert Herz und Seele,  
Winde zischen, droh'n mit Fehle.  
Wer das Zepter wagt zu heben,  
wird verlieren mehr als Leben.  

Kehre um, lass Gier vergeh'n,  
nur die Leere wirst du seh'n.  
Denn die Kälte ohne Gnade  
birgt den Tod als letzte Lade.  

 
 

Die Entdeckuine sind aber schlau.
Sie kennen sich mit Elektronik aus, können programmieren und beschließen deswegen, einen Roboter zu bauen, welcher mit Sensoren ausgestattet ist, um das Zepter zu finden.


Die Roboter werden sich also in der Höhle bewegen, die durch die Klasse `World` dargestellt wird. Die Höhle besteht teilweise aus Eiswänden. An anderen Stellen befinden sich Untergründe unterschiedlicher Art, worauf sich die Roboter bewegen können. Eine detalierte Beschreibung der Höhle folgt erst später, aber du kannst dir jetzt schon die Höhle und die Roboter gemütlich über die bereitgestellte UI anschauen, indem du einfach die `User` Klasse laufen lässt.


In der Mitte dieser Aufgabe stehen die Roboter. Du wirst erst einen programmierbaren Roboter entwickeln. In dem zweiten Teil wirst du dann Roboter erstellen, die sich durch ihre Programmierung unterschiedlich verhalten. 

Die Roboter sind kreisförmig und haben einen Durchmesser von `0.5` bis `1`m.
Sie können sich frei drehen und vorwärts/rückwärts bewegen und sind sogar mit Lautsprechern ausgestattet, sodass sie sprechen können
Die Entdeckuine haben auch schon einiges vorbereitet (siehe weiter unten), nur macht der Roboter aktuell leider nicht viel.
Die Roboter können weder die Außenwelt wahnehmen, noch können sie denken.
Sie können aber programmiert werden.
Sie bekommen also eine `Function` als Programm.
Darin können sie die Sensordaten auswerten und eine Liste von Befehlen generieren, die der Roboter anschließend ausführen kann.
Die Befehle an sich sind wiederum ebenfalls Objekte eines funktionalen Interfaces.
Somit können wir die Funktion erst definieren und zu einem späteren Zeitpunkt an anderer Stelle ausführen.
Das Programm als `Function` hat zudem den Vorteil, dass man es einfach austauschen kann.
Somit ist es möglich, zu bestimmten Zeitpunkten zu einer anderen Aufgabe zu wechseln.
Dazu aber später mehr.

Deine Aufgabe ist es nun, den Roboter zu vervollständigen.
Da du dich mit funktionalen Interfaces sehr gut auskennst, sollte das kein Problem für dich sein.
Bei ihren Experimenten haben sie zudem festgestellt, dass die Sensoren nach einiger Zeit kaputt gehen können.
Diesen Fall wollen wir hier mithilfe von Exceptions verwalten.

## Part 1 - Der Basisroboter

### Eine erste Übersicht

Das folgende UML-Diagramm zeigt die zu implementierenden Klassen.
Damit das Diagramm übersichtlich bleibt, stehen im Diagramm nur Dinge, die noch nicht implementiert sind.
Damit du dir auch sicher sein kannst, dass du alle Mindestanforderungen erfüllst, stehen hier ebenfalls Getter, Setter und toString-Methoden.
Achte darauf, dass kursiv geschriebene Methoden abstrakt sind!
Zu den Konstruktoren findest du weiter unten genauere Anweisungen.
Damit die Tests ausgeführt werden können, muss jede Klasse zumindest existieren, auch wenn sie noch nicht vollständig ist.
Bei den Tests für die `Robot`-Klasse wird zudem erwartet, dass alle Methoden existieren, auch wenn du noch bei den **Robot Basics** bist.
Stelle sicher, dass zunächst alle Teilaufgaben in **Part 1** funktionieren, bevor du mit **Part 2** weitermachen kannst.

Nun zu den bereits vorgegebenen Klassen:
- `Position`: Diese Klasse wird benutzt, um Koordinaten darzustellen. Du wirst die folgenden Methoden brauchen:
    - `void moveBy(double, double)`: Diese Methode verschiebt die Position um die gegebene Distanz in die gegebene Länge.
    - `double distanceTo(Position)`: Diese Methode berechnet die Distanz zur gegebenen Position.
    - `double directionTo(Position)`: Diese Methode berechnet die Richtung, in der die gegebene Position von der eigenen Position liegt. Sie gibt eine Zahl zwischen $$-\pi$$ und $$+\pi$$ zurück.
     
- `Robot`: Diese Klasse hat schon einige Methoden vorgegeben. Den Kern musst du aber noch selber implementieren. Du findest dort Methoden, um sich zu bewegen,  
mit `boolean say(String)` kannst du was auf der grafischen Oberfläche ausgeben lassen (das sind unsere ""Lautsprecher"") und mit `boolean paintWorld(Position, char)` kannst du die Welt verändern.  
Zudem könnten auch einige Getter und Setter für dich relevant sein.
- `World`: Diese Klasse dient hauptsächlich zur Erstellung der grafischen Oberfläche. Sie speichert außerdem die Oberfläche, welche aus einem String generiert wird.  
Du kannst für lokales testen den Konstruktor `World(mapData: String)` benutzen, um dir deine eigene Welt zu erstellen.
Weitere nützliche Methoden sind:
    - `char getTerrain(Position)`: Diese Methode gibt den Untergrund an der gegebenen Position zurück.
    - `boolean setTerrain(Position, char)`: Diese Methode setzt den Untergrund auf den gegebenen Wert an der gegebenen Position.
    - `String getKey(int, int)`: Diese (und die nächste) Methode wirst du erst am Ende brauchen. Sie gibt den Key nur dann zurück, falls die übergebene Position korrekt ist.
    - `Scepter getScepter(int, int, String)`: Diese Methode gibt das Zepter zurück, falls die Position und der Schlüssel stimmen.  

    #### ***Du darfst die Klasse World nicht verändern! Selbst Formatierung wird die Tests sonst failen lassen!***
- `User`: Diese Klasse darfst du zum freien Testen verwenden. Du findest dort bereits eine kleine Spielwiese als `String`-Konstante gespeichert. 
Um die Simulation zu starten, musst du einfach nur die `main`-Methode laufen lassen, welche dann `World.run()` aufrufen sollte.

Zum Testen deiner Roboter kannst du später einfach den `SimpleFailureSimulator` benutzen, welchen du ganz unten in der Klasse `Robot` findest.

Alle Klassen sollen sich in `pgdp.robot` befinden.

@startuml

class Memory  {
    - label: String
    - data: T
    + get(): T
    + set(T): void
    + toString(): String
}

interface Command {
    {abstract}+ execute(robot: Robot): boolean
}

class MalfunctionException {
    + getSensor(): Sensor 
    + toString(): String
}

abstract class Sensor  {
    # processor: Consumer 
    # name: String
    # reliability: double
    + setOwner(Robot robot): void
    + setProcessor(processor: Consumer ): Sensor 
    {abstract}+ getData(): T
    {abstract}+ createNewSensor(): Sensor 
}

class ProximitySensor extends Sensor {
    # directionOffset: double
    # accuracy: double
    # maxRange: double
    + getData(): Double
    + createNewSensor(): Sensor 
    + toString(): String
}

class ControllerReceiver extends Sensor {
    + getData(): World.Controller
    + createNewSensor(): Sensor 
    + toString(): String
}

class TerrainSensor extends Sensor {
    + getData(): Character
    + createNewSensor(): Sensor 
    + toString(): String
}

class Robot {
    - sensors: List >
    - memory: List >
    - program: Function >
    - todo: Queue 
    + work(): void
    - sense(): void
    - processSensor(sensor: Sensor ): void
    - think(): void
    - act(): void
    + attachSensor(sensor: Sensor ): void
    + createMemory(newMemory: Memory ): Memory 
    + setProgram(program: Function >): void
    + memoryToString(): String
}

class RobotFactory {
    {static}+ makePanicPenguin(name: String, rotation: double, failureSimulator: FailureSimulator): Robot
    {static}+ makeLineFollower(name: String, direction: double, failureSimulator: FailureSimulator): Robot
    {static}+ makeCar(name: String, failureSimulator: FailureSimulator): Robot
    {static}+ makeMazeRunner(name: String, direction: double, failureSimulator: FailureSimulator): Robot
    {static}+ makeTempleRunner(name: String, direction: double, failureSimulator: FailureSimulator): Robot
}

MalfunctionException o-- Sensor : - sensor
Sensor o-left- Robot : # owner
RobotFactory .down.> Robot

@enduml

### Die Basiskomponenten

1. [task][Command]( 251210 )
Der Roboter soll letztendlich sein Programm dazu nutzen, um eine Reihe von `Command`s zu generieren.
Erstelle dazu das *Functional Interface* `Command`, welches nur eine einzige Methode `boolean execute(Robot)` haben soll.

2. [task][Memory]( 251207 )
Starten wir mit dem Speicher. Jeder Sensor produziert Daten, welche für die spätere Verarbeitung irgendwo gespeichert werden sollen.
Dafür benutzen wir die generische Klasse `Memory`.
Jedes `Memory`-Objekt hat ein `label` und ein Attribut `data`.
Implementiere zudem einen Konstruktor, welcher die beiden Attribute in dieser Reihenfolge übergeben bekommt.
Füge Getter und Setter für `data` hinzu, sowie eine `toString()`, welche folgenden String zurückgeben soll:  
""\ :⎵ \ "". Zum Beispiel soll `new Memory (""x"", 42).toString` den Wert ""`x: 42`"" zurückgeben.

3. [task][Sensor]( 251206 )
Als nächstes geht es mit der abstrakten generischen Klasse `Sensor` weiter.
Jeder `Sensor` hat eine Referenz `owner` auf den Roboter, zu dem er gehört, einen `processor`, welcher die Daten verarbeiten kann, einen Namen und eine Zuverlässigkeit.
Füge einen Konstruktor ein, welcher den Namen und die Zuverlässigkeit entgegen nimmt.
Zudem brauchen wir noch 2 Setter für `owner` und `processor`.
Letzterer soll dabei auch diesen Sensor zurückgeben, was uns später die Nutzung angenehmer gestaltet.
Zum Schluss brauchen wir noch die beiden abstrakten Methoden `getData()` und `createNewSensor()`, welche von den jeweiligen konkreten Sensortypen implementiert werden.

### Die Exception

4. [task][MalfunctionException]( 251208 )
Da unsere Sensoren kaputt gehen können, müssen wir dem Roboter irgendwie mitteilen, dass die Sensoren ausgetauscht werden müssen.
Da kommt unsere `MalfunctionException` ins Spiel.
Diese soll eine *checked Exception* sein und wird dann geworfen, wenn ein Sensor kaputt geht.
Sie soll eine Referenz auf den `sensor` speichern, welcher die Exception verursacht hat.
Implementiere dazu einen Konstruktor, der einen `Sensor ` annimmt und auch einen passenden Getter.
Zudem wollen wir auch eine `toString()`-Methode haben, damit wir beim Testen und Debuggen wissen, was passiert:  
""\ ⎵malfunctioned⎵and⎵needs⎵to⎵be⎵replaced "". 
Zum Beispiel würde `new MalfunctionException(new TerrainSensor(""terrain""), 1).toString()` den Wert ""`TerrainSensor terrain malfunctioned and needs to be replaced`"" zurückgeben.
Was der TerrainSensor macht, wirst du später noch erfahren.  
Verändere nun auch die Methode `Sensor.getData()` so, dass sie eine `MalfunctionException` werfen könnte.

### Der Roboter

5. [task][Robot Basics]( 251221 )
Nun da wir alles haben, können wir den Roboter implementieren.
Füge zuerst die fehlenden `4` Attribute hinzu und initalisiere diese passend entweder im Konstruktor oder direkt bei der Deklaration.
Die Datenstrukturen sollen leer sein und die `Function` soll als default eine leere `List`e zurückgeben können.
Nun gehen wir Schritt für Schritt die weiteren Anforderungen durch:
    - Implementiere die Methode `void attachSensor(Sensor )`, welche den übergebenen Sensor in seine Liste einfügt und sich selber als `owner` des Sensors setzt.
    - Implementiere die Methode `Memory  createMemory(Memory  memory)`, welche die Speichereinheit entgegennimmt, in die Liste einfügt und anschließend auch zurückgibt. Das wird uns die Nutzung später vereinfachen.
    - Implementiere die Methode `String memoryToString()`, welche eine `String`-Repräsentation des Speichers zusammenbaut. Nutze dafür einen `StringBuilder` anstelle von `String`-Konkatenation mit `+`. 
    Jedes `Memory`-Objekt soll mit der Form "" [ \ ] "" an den `StringBuilder` mit `append()` angeheftet werden.
    Zum Schluss kann dann der komplette String mit der `toString()`-Methode vom `StringBuilder` zurückgegeben werden. Für 3 `Memory`-Objekte ` `, ` ` und ` ` würde dann der ""`[ ][ ][ ]`"" zurückgegeben werden.
    - Implementiere einen Setter für `program`.

6. [task][Robot Programmablauf]( 251226 , 251224 , 251222 )
Als nächstes geht es um den Programmablauf. Der Roboter soll die Sensordaten verarbeiten, darauf aufbauend eine Liste aus `Command`s erstellen und dann ausführen.
Das entspricht somit einem Simulationsschritt, also einem einzelnen Frame im Spiel. Alle Methoden außer der letzten sollen *private* sein:
    - Implementiere zuerst die Methode `void processSensor(Sensor )`, welche den übergebenen Sensor auswertet und eventuell eine `MalfunctionException` werfen kann.
    Um den Sensor auszuwerten, sollen die Daten des Sensors einfach an seinen `processor` übergeben werden. Denk daran, was der `processor` ist und was er somit kann.
    - Implementiere als nächstes die Methode `void sense()`, welche durch alle Sensoren iteriert und diese mit der zuvor implementierten Methode auswerten soll.
    Sollte einer der Sensoren dabei eine `MalfunctionException` werfen, musst du diese abfangen. 
    Der betroffene Sensor soll aus der Liste entfernt werden und stattdessen soll ein neuer Sensor wieder an den Roboter angebracht werden, welcher exakt dasselbe kann wie der alte Sensor. 
    Die Hilfsmethoden dazu hast du bereits implementiert oder existieren zumindest als abstrake Methode. Danach soll ein weiteres mal `sense()` rekursiv aufgerufen werden.
    Falls alle Sensoren ohne Exception ausgewertet wurden, soll gar nichts weiter passieren.
    - Implementiere nun die Methode `void think()`, welche das `program` des Roboters ausführen soll und die dabei entstandenen `Command`s in seine `todo`s aufnimmt.
    - Implementiere die Methode `void act()`, welche die `todo`s abarbeitet. Solange die `Queue` nicht leer ist, soll der nächste `Command` geholt und ausgeführt werden.
    Falls der `Command` *false* zurückgibt, sollst du die Methode allerdings vorzeitig abbrechen. 
    Das hat für die Simulation den Vorteil, dass wir gleich mehrere Bewegungsbefehle auf einmal in die `todo`s einfügen können, allerdings immer nur einer pro Frame ausgeführt wird, falls gewünscht.
    Dadurch bekommt der Roboter den Effekt als würde er gehen und sich nicht teleportieren.
    - Implementiere als letztes die *public* Methode `void work()`. Falls die `todo`-Queue aktuell leer ist, sollen die Sensoren ausgewertet werden und über neue Befehle nachgedacht werden. 
    In jedem Fall sollen danach die `todo`s abgearbeitet werden.

Da haben wir es, einen funktionierenden programmierbaren Roboter. 
Jetzt müssen wir ihn nur noch für konkrete Aufgaben zusammenbauen.

## Part 2 - Verschiedene Roboter erstellen

Wir können einen neuen Roboter erstellen, Sensoren installieren, ihn programmieren und in der Welt platzieren.
Die Welt ist ein zweidimensionales Raster aus 1m x 1m großen Blöcken, wobei jeder Block durch ein Zeichen repräsentiert wird. 
Das Zeichen '#' steht für eine Wand, die die Roboter nicht betreten können. 
Die Roboter können auf allen anderen Blocktypen laufen. 
Zusätzlich können wir einen Block mit einem der Zeichen '0' bis '9' markieren, um dann den Roboter auf diesem markierten Block zu platzieren. 
Jedes andere Zeichen kann vom Roboter beliebig (bzw. der Aufgabe entsprechend) interpretiert werden.

 
 Beispiel (aufklappen) 
 
World world = new World(""""""
                ################
                #  #0     1    #
                #  #   ##   #  #
                #  ###   #T #  #
                #   3# a ### W #
                # ###   # 2   ##
                #      #       #
                ###########$$$##
                """""");
new Robot(""Pengu"", Math.toRadians(90), 1).spawnInWorld(world, '3');
world.run();
 
In der letzten Zeile soll es nicht ein ""$"", sondern drei sein. Artemis kann das aber aus unerklärlichen Gründen nicht darstellen.
Der obige Code würde einen Roboter mit einem Durchmesser von 1m mit Blickrichtung Süden auf dem mit `'3'` markierten Block platzieren:
 
 
 
 

Der Ursprung des Weltkoordinatensystems (0; 0) liegt in der linken oberen Ecke der durch einen String beschriebenen Welt (siehe Beispiel), mit positiver x-Richtung nach Osten und positiver y-Richtung nach Süden. 
Richtungen sind im Bogenmaß definiert:   
0 nach Osten/Rechts, $$\frac{1}{2} \cdot \pi$$ nach Süden/Unten, $$\pi$$ nach Westen/Links und $$\frac{3}{2} \cdot \pi$$ nach Norden/Oben   
bzw. vielfache davon (ein Kreis entspricht $$2 \cdot \pi$$).
Du kannst zum einfachen umrechnen `Math.toRadians(double)` verwenden. `Math.toRadians(180)` würde bspw $$\pi$$ ergeben, also die Richtung nach Westen.
Alle Blöcke, die nicht explizit durch den angegebenen String definiert sind, werden implizit als ' ' (ein Leerzeichen) betrachtet.

Nun können wir damit anfangen, die konkreten Roboter zu implementieren.
Wir nutzen dazu die Klasse `RobotFactory` und die darin zu implementierenden statischen Methoden, welche unsere Roboter erstellen sollen.
Du kannst im weiteren Verlauf alle Sensoren mit einer `reliability` von `0.97` initialisieren.
Wie du die Sensoren oder auch die `Memory`-Objekte benennst bleibt dir überlassen.

### Panic Penguin

Starten wir mit einem ganz einfachen Roboter.
Dieser soll im Kreis laufen und dabei alles ausgeben, was er auf dem Boden sieht.
Damit wir den Boden scannen können, brauchen wir einen neuen Sensor.

1. [task][TerrainSensor]( 251219 )
Implementiere die Klasse `TerrainSensor`, welche `Sensor ` erweitert.
So wie `Sensor` soll auch diese Klasse einen Konstruktor haben, welche einen `String` und einen `double` annimmt.
Nun zu den 3 Methoden:
    - `Character getData()`: Diese soll einfach genau das Zeichen zurückgeben, an dem der Roboter steht. Dafür könnte die Methode `World.getTerrain()` hilfreich sein. 
    Wie du an die Welt rankommst, kannst du im Roboter herausfinden.
    Der Sensor kann außerdem kaputt gehen. Um das zu simulieren, gibt es im Roboter das *Interface* `FailureSimulator`. Darüber kannst du einen nächsten zufälligen Wert bekommen.
    Sollte dieser Wert größer als die `reliability` sein, soll eine neue `MalfunctionException` geworfen werden.
    - `Sensor  createNewSensor()`: Diese Methode soll eine Kopie von diesem `TerrainSensor` erstellen und zurückgeben. 
    Name, Zuverlässigkeit und der Processor sollen dabei übernommen werden.
    - `String toString()`: Diese soll einfach einen `String` nach folgendem Schema zurückgeben: "" TerrainSensor⎵ \ "".

2. [task][Panic Penguin]( 251234 , 251244 )
Nun können wir damit schon unseren ersten Roboter bauen und ausprobieren.
Implementiere dazu in der Klasse `RobotFactory` die statische Methode `Robot makePanicPenguin(String, double, FailureSimulator)`, welche einen `name`, eine `rotation` und einen `failureSimulator` annimmt und einen neuen Roboter zurückgibt.
Der Roboter soll den übergebenen `name` und `failureSimulator` bekommen, eine Größe von `0.8` haben und nach Osten/Rechts (also `0`) ausgerichtet sein.
Der Roboter soll außerdem genau ein `Memory `-Objekt haben, und einen `TerrainSensor`, womit er den Untergrund lesen und im Speicher speichern kann.
Letzteres ist Aufgabe des `processor`s.  
Nun zum Programm des Roboters:
Man muss nur das Programm für einen Iterationsschritt in der `Function` definieren.
Das Programm wird dann in jedem Frame ausgeführt, falls keine Befehle existieren (siehe **Part 1**).
Bei der Ausführung soll der Roboter nun in jedem Frame ausgeben, welchen Untergrund er gerade sieht (`World.say` könnte hilfreich sein), sich um `rotation` drehen und `0.1`m nach vorne gehen.
Achte darauf, dass jeder `Command` *true* zurückgibt, damit diese 3 Schritte in einem Frame ausgeführt werden.

 
 Beispiel (aufklappen) 
 
#######
#  0  #
#Don't#
#PANIC#
#     #
#######
 
 
 
 

### Line Follower

3. [task][Line Follower]( 251225 , 251242 )
Mit dem `TerrainSensor` können wir auch einen Linienverfolger programmieren.
Implementiere dazu in der Klasse `RobotFactory` die statische Methode `Robot makeLineFollower(String, double, FailureSimulator)`, welche einen `name`, eine `direction` und einen `failureSimulator` annimmt und einen neuen Roboter zurückgibt.
Der Roboter soll den übergebenen `name` und `failureSimulator` bekommen, eine Größe von `0.8` haben und nach `direction` ausgerichtet sein.
Genauso wie der Panic Penguin soll der Linienverfolger ein `Memory `-Objekt haben und einen `TerrainSensor` benutzen, um den Speicher zu beschreiben.
Nun zum Programm:
Falls der Roboter das Zeichen `>` liest, soll er sich nach rechts drehen und geradeaus laufen.
Falls der Roboter das Zeichen `v` liest, soll er sich nach unten drehen und geradeaus laufen.
Analog dazu gibt es noch die Fälle `<` und `^`, zu denen er sich entsprechend verhalten soll.
Falls die Linie unterbrochen wird, soll der Roboter einfach weiter geradeaus laufen, bis er die Linie wieder gefunden hat.
Denk daran, dass der Befehl für das Geradeausgehen *false* zurückgeben kann, falls du mehrere hintereinander einfügst, damit sie nicht in einem Frame ausgeführt werden.
Dadurch entsteht in der Simulation eine flüssigere Bewegung.
In jedem Fall soll die maximal erlaubte Schritteweite pro Frame `1`m nicht übersteigen.

 
 Beispiel (aufklappen) 
 
 
################
#v<#           #
#v^#   #v<< #  #
#v^<<<<<<0^ #  #
#v   # >>>^#   #
#v###  ^#     ##
#>>>>>>^       #
################
 
 
 

### RC Car

Der Panic Penguin ist ganz witzig und für den Anfang sehr einfach, aber nicht besonders nützlich.
Der Linienverfolger ist deutlich cooler, aber wir wollen noch mehr!
Deswegen bauen wir nun einen ferngesteuerten Roboter.
Dazu benötigen wir aber erst einen `Sensor`, welcher Funksignale wahrnehmen kann.

4. [task][ControllerReceiver]( 251217 )
Implementiere die Klasse `ControllerReceiver`, welche `Sensor ` erweitert.
Der Konstruktor soll dabei genauso wie beim `TerrainSensor` funktionieren.
Nun zu den 3 Methoden:
    - `World.Controller getData()`: Diese soll einfach das `Controller`-Objekt der Welt zurückgeben (`World.getController()` dürfte dir weiterhelfen).
    Im Fehlerverhalten soll sich die Methode genauso verhalten wie der `TerrainSensor`
    - `Sensor  createNewSensor()`: Diese Methode soll ähnlich wie der `TerrainSensor` einen neuen `ControllerReceiver` zurückgeben.
    - `String toString()`: Diese Methode soll einen String nach folgendem Schema zurückgeben: "" ControllerReceiver⎵ \ "".

5. [task][RC Car]( 251249 )
Nun können wir damit einen ferngesteuerten Roboter bauen.
Implementiere dazu in der Klasse `RobotFactory` die statische Methode `Robot makeCar(String, FailureSimulator)`, welche einen `name` und einen `failureSimulator` annimmt und einen neuen Roboter zurückgibt.
Der Roboter soll den übergebenen `name` und `failureSimulator` bekommen, eine Größe von `0.8` haben und nach Süden/Unten (also `90` Grad) ausgerichtet sein.
Der Roboter soll außerdem einen `ControllerReceiver`-Sensor benutzen, um die Tastatur-Inputs zu verarbeiten.
Du kannst dabei einfach im `processor` das `World.Controller`-Objekt benutzen, um zu überprüfen, ob eine bestimmte Taste gedrückt ist. 
Benutze bitte `Controller.isKeyPressed()`. Alle anderen Interface-Methoden werden von den Tests nicht verwendet! Die restlichen Methoden (z.B. die ganezn Mouse-Evenets) könnten dir aber bei der Bonusaufgabe helfen.
Wir benutzen die Tasten *W*, *A*, *S*, *D* zum Steuern.
Die entsprechenden Keycodes findest du als Konstanten in `java.awt.event.KeyEvent` und heißen `VK_W`, `VK_A`, `VK_S` und `VK_D`.
*A* und *D* benutzen wir zum Lenken, *W* und *S* für die Fortbewegung.
Falls *A* gedrückt wird, soll sich der Roboter um `-0.1` drehen, für *D* analog dazu `0.1`.
Die beiden Werte sind bereits im Bogenmaß.
Falls *W* gedrückt wird, soll sich der Roboter um `0.1`m nach vorne bewegen, für *S* analog dazu `-0.1`m.
Die Tasten sollen sich zudem nicht gegenseitig ausschließen, sondern unabhängig voneinander funktionieren.
Falls also *A* und *D* bspw gleichzeitig gedrückt werden, sollen sie sich gegenseitig aufheben, da sich der Roboter gleichzeitig nach rechts und nach links dreht.
Falls *A* und *W* gleichzeitig gedrückt werden, fährt das Auto nach vorne und lenkt nach links.
Achte darauf, dass jeder `Command` dann `true` zurückgibt, damit diese beiden Schritte in einem Frame ausgeführt werden.
Du darfst so viele `Memory`-Objekte benutzen wie du brauchst.

 

### Maze Runner

Damit wir unserem ursprünglichen Ziel näher kommen, wollen wir nun einen Maze Runner bauen.
Dafür brauchen wir aber auch wieder einen weiteren `Sensor`, der diesmal seine physikalische Umgebung wahrnehmen kann.

6. [task][ProximitySensor]( 251205 )
Dieser Sensor wird am Roboter angebracht und kann damit die Distanz in seine Richtung bestimmen.
Zum Beispiel kann man einen Sensor nach vorne ausgerichten, um die Distanz zum nächsten Block nach vorne zu messen.
Einen weiteren Sensor kann man zur Seite ausrichten, um analog dazu die Distanz zum nächsten Block zur Seite zu messen.
Implementiere die Klasse `ProximitySensor`, welche `Sensor ` erweitert.
Der Konstruktor soll die folgenden Parameter in dieser Reihenfolge annehmen:
    - `String name`: der Name des Sensors
    - `double directionOffset`: Eine Verschiebung der Blickrichtung des Roboters. Dadurch können wir bspw einen Sensor seitlich an den Roboter montieren.
    - `double accuracy`: Da wir nicht kontinuierlich die komplette Strecke messen können, wollen wir das ganze diskret umsetzen. Die `accuracy` gibt uns die Schrittweite der Diskretisierung vor.
    - `double maxRange`: Der Sensor soll nur eine maximale Sichtweite haben.
    - `double reliability`: Die Zuverlässigkeit des Sensors.
    
     

    `name` und `reliability` sollen an die Oberklasse weitergegeben werden.
    Für die anderen Parameter sollst du hier gleichnamige `protected` Attribute erstellen.
    `createNewSensor()` und `toString()` sollen sich genauso wie die anderen Sensoren verhalten, nur eben an den `ProximitySensor` angepasst.
    Nun zu `Double getData()`. Der Fehlerfall funktioniert genauso wie bei allen anderen Sensoren auch.
    Andernfalls müssen wir jetzt die Distanz messen.
    Die Idee funktioniert so: Wir erstellen eine Kopie von unserer Position und schieben sie in Blickrichtung des Sensors nach vorne, bis wir dann eine Wand gefunden haben oder die maximale Reichweite erreicht haben.
    Die Methode `Robot.getPosition()` ist so implementiert, dass sie dir eine Kopie zurückgeht, welche du somit komplett frei bewegen kannst.
    Nun können wir schrittweise die Position verschieben und überprüfen, ob wir an der Stelle in der Welt eine Wand (`#`) finden oder nicht.
    In jedem Fall geben wir am Schluss die gemessene Distanz zurück, also die Distanz bis zur Wand, oder die gemessene Distanz, bis wir `maxRange` überschritten haben.
    Da unsere Ausgangsposition zentriert im Roboter ist, müssen wir noch die Größe des Roboters berücksichtigen.
    Sonst würden wir von der Mitte aus messen, was allerdings Blödsinn wäre.
    Die Distanz von der Mitte bis zum Rand ist einfach die Hälfte des Durchmessers.
    Das soll sich aber nicht auf die maximale Reichweite der Sensoren auswirken.
    Falls der Sensor maximal 3m weit sehen kann und der Pinguin 1m dick ist, soll man von der Mitte aus gesehen 3.5m weit sehen können.

7. [task][Maze Runner]( 251227 , 251231 )
Mit dem `ProximitySensor` können wir nun einen Maze Runner bauen.
Implementiere hierzu in der Klasse `RobotFactory` die statische Methode `makeMazeRunner(String, double, FailureSimulator)`, welche einen `name`, eine `direction` und einen `failureSimulator` annimmt und einen neuen Roboter zurückgibt.
Der Roboter soll den übergebenen `name` und `failureSimulator` bekommen, eine Größe von `0.8` haben und nach `direction` ausgerichtet sein.
Der Roboter darf maximal 2 `ProximitySensor`en und beliebig viele `Memory`-Objekte benutzen, um das Labyrinth zu lösen.
Der Ausgang ist dabei mit einem `$` markiert.
Du kannst davon ausgehen, dass das Labyrinth keine Inseln hat (die Wände sind also alle miteinander verbunden) und der Ausgang befindet sich immer direkt an einer Wand dran.
Der Roboter darf keine Wände verändern und sich nicht teleportieren (die maximal erlaubte Schrittweite pro Frame ist `1`m).
Wie du den Ausgang findest, bleibt dir überlassen.
Der Roboter muss den Ausgang mindestens einmal erreicht haben.
Danach verdient der Roboter seine Freiheit und darf sich beliebig verhalten.

 
 Beispiel (aufklappen) 
 
 
##############
#  0   #   ##  $
#  #  ##   #   #
####   # ### ###
#      #       #
#  #      ##   #
################
 
 
 

### Temple Runner

Jetzt haben wir alle Komponenten, um den Temple Runner zu bauen.
Dieser Roboter soll uns helfen das Zepter zu finden, ohne dass sich die Entdeckuine selber in Gefahr bringen müssen.
Dazu müssen wir aber zuerst einen Schlüssel finden, damit wir die Truhe des Zepters öffnen können.
Der Schlüssel wird in der Welt mit `!` dargestellt, das Zepter mit `?`.
Die Klasse `World` hat die beiden Methoden `String getKey(int, int)` und `Scepter getScepter(int, int, String)`.
Erstere gibt den Schlüssel zurück, falls der Roboter sich an der richtigen Position befindet.
Letztere gibt das Zepter zurück, falls der Roboter sich an der richtigen Position befindet und den richtigen Schlüssel hat.
Um die gerundeten Koordinaten zu bekommen, gibt es 2 Hilfsmethoden in `Robot`.
Nun zu den beiden Fällen:
- Wir finden den Schlüssel vor dem Zepter: Das ist der Normalfall. Der Roboter nimmt den Schlüssel, öffnet die Truhe des Zepters und läuft danach zu seiner Startposition zurück.
- Wir finden das Zepter vor dem Schlüssel: Dann soll sich der Roboter mit den Pfeilen (`<`, `^`, `>` und `v`) den gelaufenen Weg von Zepter zum Schlüssel auf dem Boden markieren.
Achte darauf, einen durchgehenden Pfad zu markieren, wobei jedes Symbol auf das Feld zeigen soll, von dem der Roboter hergekommen ist.
Wenn der Schlüssel dann gefunden wird, soll der Roboter wie in Teilaufgabe 3 den markierten Pfad zum Zepter zurücklaufen. Dadurch müssen wir das Zepter nicht nochmal suchen.
Achte darauf keine existierenden Markierungen zu übermalen! Nachdem wir danach wieder beim Zepter angekommen sind, laufen wir ebenfalls wieder zur Startposition zurück.
Der letzte Schritt darf wieder nach belieben umgesetzt werden.  

Um die Objekte zu suchen, kannst du bspw. einen modifizierten Maze Runner benutzen.
Du kannst davon ausgehen, dass alle Wände zusammenhängend sind, es nur einen Eingang mit nur einer Startmarkierung gibt und Zepter, Schlüssel und die Startmarkierung sich direkt neben Wänden befinden.
Wenn der Roboter den Start wieder erreicht hat, darf er sich beliebig verhalten.
Da es verschiedene Abschnitte gibt, könnte es Sinn machen, mehrere Funktionen für die einzelnen Teilprogramme zu definieren und diese im richtigen Moment auszutauschen.

8. [task][Temple Runner]( 251236 , 251229 )
Implementiere in der Klasse `RobotFactory` die statische Methode `Robot makeTempleRunner(String, double, FailureSimulator)`, welche einen `name`, eine `direction` und einen `failureSimulator` annimmt und einen neuen Roboter zurückgibt.
Der Roboter soll den übergebenen `name` und `failureSimulator` bekommen, eine Größe von `0.8` haben und nach `direction` ausgerichtet sein.
Der Roboter darf beliebig viele Sensoren und `Memory`-Objekte benutzen.
Der Roboter darf keine Wände verändern und sich nicht teleportieren (die maximal erlaubte Schrittweite pro Befehl ist `1`m).
Welchen Suchalgorithmus du verwendest bleibt dir überlassen.

 
 Beispiel (aufklappen) 
 
 
World world = new World(""""""
			################
			#          ?   #
			#0             #
			#              #
			#              #
			#          !   #
			################
			"""""", ""1234"", 11, 5, 11, 1);
RobotFactory.makeTempleRunner(""Temple Runner"", 0, new SimpleFailureSimulator(69)).spawnInWorld(world, '0');
world.run();
 
 
 

## Part 3 - Bonusaufgabe

Werde kreativ und erstelle deinen eigenen Roboter mit deinen eigenen ganz besonderen Aufgaben!
Du kannst neue Sensoren erstellen, einen komplett neuen Roboter bauen und die Welt verändern (wortwörtlich)!
Gib dein fertiges Programm in der Aufgabe `W09B01` ab, um 10 Bonuspunkte zu erhalten!
Weitere Infos findest du in `W09B01`.



























 
 
  🐧  
  ❆  
  ❆  
  ❄️  
  ❆  
  ❄ 
  ❆  
  🕯️  
  ❆  
  ❄️  
  ❆  
  ❆️  
  ❆  
  ❄️  
  ❆  
  🎄  
  ❆  
  ❆️  
  ❆  
  ❄️  
  ❆️  
  ❆  
  ❄️  
  ❆  
  ❆️  
  ❆  
  ❆   
  ☃️  
  ❆  
  ❆  
  ❆️  
  ❆  
  ❆  
  ❆️  
  ❆  
  🌟  
  ❆  
  ❆  
  ❆  
  ❆️"
404,Praktikum: Grundlagen der Programmierung WS24/25,15554,W09H02 - Baumiteration,"# Baumiteration

Die Forschuine der PUM führen aktuell ein kleines Projekt an der Pinguin Schule durch. Für das Projekt muss als nächstes ein Iterator für eine vorgegebene Baum-Datenstruktur geschrieben werden. Leider ist das Forschungsbudget mal wieder ausgeschöpft, weshalb die Forschuine dich als günstige studentische Arbeitskraft mit der Implementierung der Lösung für die Aufgabe engagieren.

## Datenstruktur

Du solltest bereits den binären Suchbaum kennen.
Dieser ist so aufgebaut, dass jeder Knoten einen Wert hat, welcher gleichzeitig als Trennschlüssel fungiert.
Alle Elemente des linken Teilbaums sind kleiner(-gleich) als der Trennschlüssel und alle Elemente des rechten Teilbaum sind größer-gleich als der Trennschlüssel.
Dieses Konzept werden wir nun auf einen Baum übertragen, welcher bis zu 3 Trennschlüssel und 4 Teilbäume haben kann.
Im Template erhältst du die Klassen `QuarternaryNode` und `QuarternarySearchTree`, die zusammen einen Suchbaum mit drei Elementen pro Knoten bilden. 
Gleich große Elemente befinden sich auch im rechten Teilbaum, falls es welche gibt (dies sollte für diese Aufgabe aber irrelevant sein).
Für die vorherige Invariante bedeutet dies folgendes:

Elemente Teilbaum 0 <= 0. Trennschlüssel <= Elemente Teilbaum 1 <= 1. Trennschlüssel <= Elemente Teilbaum 2 <= 2. Trennschlüssel <= Elemente 3. Teilbaum. 

Verständlicher wird das durch die unten abgebildeten Beispiele.

Das Template enthält bereits alle benötigten Methoden, um mit dem Baum arbeiten zu können (du wirst aber nicht alle zur Bearbeitung der Aufgabe benötigen, einige sind nur der Vollständigkeit halber enthalten):
- Konstruktor zum Erstellen eines leeren Baumes.
- Methode `insert` zum Einfügen eines neuen Elements.
- `size` für die Anzahl der gespeicherten Elemente und `height` für die Höhe des Baums.
- `contains` zur Überprüfung, ob ein Element enthalten ist.
- `toString` für eine geklammerte String-Repräsentation des Baums (funktioniert für alle Bäume).
- `toGraphvizString` für eine Graphviz Repräsentation des Baums, die z.B. über [diese Website](https://dreampuf.github.io/GraphvizOnline/) zu einer Grafik wie unten umgewandelt werden kann (funktioniert nur richtig für Bäume ohne Duplikate, die natürlich trotzdem vorkommen können).
- Alle Getter und Setter.
- `QuarternaryNode.nodeSize` gibt an, wie viele Elemente bereits im Knoten gespeichert werden.

## Aufgabe

Deine Aufgabe ist es nun, die Methode `iterator()` des Interface [Iterable](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html) in `QuarternarySearchTree` zu implementieren (die leere Methode ist bereits im Template vorgegeben). Iteratoren kennst du bereits aus W09P03. Der Iterator soll die im Baum enthaltenen Elemente in ihrer natürlichen Ordnung (""inorder"", siehe Beispiel für Binärbaum [hier](https://en.wikipedia.org/wiki/Tree_traversal#In-order,_LNR)) iterieren. Für die beiden Beispiele mit `Integer`n unten bedeutet dies in numerisch aufsteigender Reihenfolge.

Dabei gelten folgende Einschränkungen:
- Die vorgegebenen Methoden dürfen nicht verändert werden (außer zum lokalen Testen).
- Die Implementierung des Iterators muss iterativ umgesetzt werden. Rekursion darf in dieser Aufgabe **NICHT** genutzt werden.
- Private Hilfsmethoden, -Attribute und Klassen sind erlaubt. Wie immer gilt Vorsicht bei der Nutzung statischer Attribute, da diese zwischen Tests nicht zurückgesetzt werden.
- Du darfst davon ausgehen, dass der Baum während einer vollständigen Iteration mit dem Iterator nicht verändert wird.
- Der zurückgegebene `Iterator` muss explizit nur die Methoden `hasNext` und `next` unterstützen.
- Die Methode [next](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Iterator.html#next()) wirft unter bestimmten Umständen (wenn keine Elemente zum Iterieren mehr vorhanden sind) eine `NoSuchElementException`, wie du in der verlinkten JavaDoc nachlesen kannst. Dieser Iterator soll sich ebenfalls so verhalten.
- Der Iterator muss für alle möglichen Bäume, die mit den gegebenen Methoden erstellt werden können, funktionieren.

## Beispiele

- [task][Kleines Beispiel]( 251268 )
Testet ein kleines Beispiel nur bestehend aus einer vollen Wurzel ([Graphviz Repräsentation](https://dreampuf.github.io/GraphvizOnline/#digraph%20G%20%7B%0D%0Asubgraph%20%22cluster_1_2_3_%22%20%7B%0D%0A%7Brank%3Dsame%20%221%22%20-%3E%20%222%22%20-%3E%20%223%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%7D)). Die Elemente sollten in numerisch aufsteigender Reihenfolge vom Iterator zurückgegeben werden (1, 2, 3).

![Kleines Beispiel](/api/core/files/markdown/Markdown_2022-11-07T15-56-48-951_1a65b1de.svg)

- [task][Größeres Beispiel]( 251266 )
Testet das Beispiel, das schon in der Template `main` enthalten ist und den folgenden Baum darstellt ([Graphviz Repräsentation](https://dreampuf.github.io/GraphvizOnline/#digraph%20G%20%7B%0D%0Asubgraph%20%22cluster_4_8_12_%22%20%7B%0D%0A%7Brank%3Dsame%20%224%22%20-%3E%20%228%22%20-%3E%20%2212%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0Asubgraph%20%22cluster_1_2_3_%22%20%7B%0D%0A%7Brank%3Dsame%20%221%22%20-%3E%20%222%22%20-%3E%20%223%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0A%224%22%20-%3E%20%222%22%0D%0A%0D%0Asubgraph%20%22cluster_5_6_7_%22%20%7B%0D%0A%7Brank%3Dsame%20%225%22%20-%3E%20%226%22%20-%3E%20%227%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0A%228%22%20-%3E%20%226%22%0D%0A%0D%0Asubgraph%20%22cluster_9_10_11_%22%20%7B%0D%0A%7Brank%3Dsame%20%229%22%20-%3E%20%2210%22%20-%3E%20%2211%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0A%2212%22%20-%3E%20%2210%22%0D%0A%0D%0Asubgraph%20%22cluster_13_14_15_%22%20%7B%0D%0A%7Brank%3Dsame%20%2213%22%20-%3E%20%2214%22%20-%3E%20%2215%22%5Bstyle%3Dinvis%5D%7D%0D%0Acolor%3Dgreen%0D%0A%7D%0D%0A%0D%0A%2212%22%20-%3E%20%2214%22%0D%0A%7D)). Auch hier gilt die numerisch aufsteigende Reihenfolge (1, 2, 3, 4, 5 ..., 11, 12, 13, 14, 15). Leider kann Graphviz den Baum nicht so schön darstellen, deswegen gibt es drunter einen Vergleich, wie dieser Baum mit Graphviz ausschauen würde

![Größeres Beispiel](/api/core/files/markdown/Markdown_2024-12-11T11-39-22-919_a27aee58.png)

 
 So würde Graphviz diesen Baum darstellen 

![Größeres Beispiel](/api/core/files/markdown/Markdown_2022-11-07T15-55-05-406_b3ef7fdf.svg)

 
 

- [task][Weitere Tests]( 251271 , 251273 , 251264 , 251270 , 251259 , 251269 )
Hier werden weitere Tests ausgeführt. Der Testname sollte dabei mehr als ausreichend sein, damit du herausfinden kannst, warum dein Iterator noch nicht korrekt ist.
Beim `Very large tree`-Test wird erwartet, dass ihr auf Artemis einen Baum mit ca. 40.000 Elementen in maximal 5 Sekunden schafft. Lokal sollte es somit (je nach Rechner) schneller als 2 Sekunden sein.

## Testing

Schreibe eigene JUnit-Tests, welche überprüfen ob dein Iterator korrekt ist, also einen beliebigen Baum in ""inorder"" traversiert."
404,Praktikum: Grundlagen der Programmierung WS24/25,15556,W09P01 - Passwortpruefung,"# Passwortprüfung

In dieser Aufgabe wollen wir einige Exceptions implementieren,
die bei der Überprüfung der Gültigkeit eines Passworts verwendet werden können.
Dafür soll die folgende Klassenhierarchie umgesetzt werden, wobei [Exception](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Exception.html)
eine Klasse aus der Java-Standardbibliothek ist.

### Struktur

@startuml
class Exception{}
class IllegalCharException{
    -used: char
}
class NotEnoughException{
    -should: int
    -is: int
}
class NotEnoughLetterException{}
class NotEnoughUpperCaseException{}
class NotEnoughLowerCaseException{}
class NotLongEnoughException{}

IllegalCharException -up-|> Exception
NotEnoughException -up-|> Exception
NotEnoughLetterException -up-|> NotEnoughException
NotEnoughUpperCaseException -up-|> NotEnoughLetterException
NotEnoughLowerCaseException -up-|> NotEnoughLetterException
NotLongEnoughException -up-|> NotEnoughException
hide empty fields
hide empty methods
@enduml

[task][Struktur Tests]( 251321 , 251326 , 251331 , 251301 , 251315 , 251323 , 251322 , 251311 , 251314 , 251337 , 251312 , 251309 , 251310 , 251333 , 251300 , 251325 , 251330 , 251305 , 251308 , 251336 )
Stelle sicher, dass du die geforderte Struktur erfüllst, bevor du mit der Funktionalität weitermachst!

### Exceptions

Für ein Passwort können die folgenden Mindestanforderungen gestellt werden, die bei
Missachtung zu einer entsprechenden Exception führen:
- Das Passwort muss eine Mindestlänge haben, andernfalls wird eine `NotLongEnoughException` geworfen.
- Das Passwort muss eine Mindestanzahl an Großbuchstaben enthalten, andernfalls wird eine
`NotEnoughUpperCaseException` geworfen.
- Das Passwort muss eine Mindestanzahl an Kleinbuchstaben enthalten, andernfalls wird eine
`NotEnoughLowerCaseException` geworfen.
- Das Passwort darf bestimmte Sonderzeichen **nicht** enthalten, andernfalls wird eine
`IllegalCharException` geworfen. Du kannst dafür später zum Prüfen die statische Methode `matchesIllegalCharacter` benutzen.

Wir betrachten hier alle Zeichen zwischen `'a'` und `'z'` als Kleinbuchstaben, alle Zeichen zwischen `'A'`
und `'Z'` als Großbuchstaben, alle Zeichen zwischen `'0'` und `'9'` als Ziffern und alles andere als Sonderzeichen.

Für die konkrete Implementierung gelten folgende Anforderungen:
[task][Die Exceptions]( 251324 , 251307 , 251320 , 251335 , 251306 , 251317 ) Die Klasse `NotEnoughException` hat die beiden Parameter `is` und `should`.
Diese repräsentieren die Mindestanzahl Zeichen einer bestimmten Kategorie,
die ein Passwort enthalten muss und die echt kleinere Anzahl an Zeichen, die das Passwort,
das die Exception auslöst, hat. Die Variablen sollen im Konstruktor `public NotEnoughException(int should, int is)` gesetzt werden.
Sollte `is` nicht echt kleiner sein als `should`, soll eine [IllegalArgumentException](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/IllegalArgumentException.html)
geworfen werden.
- Jede Unterklasse von `NotEnoughException` soll im Konstruktor die gleichen Parameter entgegennehmen und dann
entsprechend die Attribute der Oberklasse setzen.
- Jede Klasse soll ihre `toString()` Methode überschreiben und dabei eine Fehlermeldung zurückgeben, die alle Informationen enthält (also insbesondere alle bekannten Attributwerte). Nutzen Sie bei der Klasse IllegalCharException die mitgelieferte Methode escapeSpecial.

### Testing
Überlege dir als nächstes im Voraus, welches Verhalten du von deiner `Password`-Klasse erwartest.
Also in welchen Fällen soll welche Exceptions geworfen werden.
Schreibe dazu JUnit-Tests in der Klasse `PasswordTest`, welche dieses Verhalten testen sollen.
Um zu testen, ob eine Methode eine Exception geworfen hat, kannst du die Methode `assertThrows` wie im Beispiel zu sehen benutzen.

### Passwörter

[task][Der Passwort-Check]( 251329 , 251316 , 251313 , 251328 , 251334 )
Implementiere dann die Methode `checkFormat(String pwd)` in `Password`, die das übergebene Passwort nach den
im Konstruktor übergebenen Kriterien prüft und ggf. die entsprechende Exception wirft.

[task][Passwort-Check mit Logging]( 251332 , 251304 , 251327 , 251318 , 251319 )
Zuletzt soll noch die `checkFormatWithLogging(String pwd)` Methode implementiert werden, die `checkFormat(pwd)` aufruft, evtl. geworfene hier implementierte Exceptions abfängt, den Rückgabewert von `toString()` auf die Konsole schreibt und wieder wirft.

Vermeide Codeduplikate so gut wie möglich durch Verwendung von `super`.
Alle vorgegebenen Membervariablen müssen als `final` deklariert werden."
404,Praktikum: Grundlagen der Programmierung WS24/25,15557,W09P03 - Funktionale Pingus,"# Funktionale Pingus

Die Pinguine haben in letzter Zeit öfters von funktionaler Programmierung gehört, und möchten das jetzt auch selbst ausprobieren. Besonders sind sie an sogenannten *higher order functions* interessiert. Das sind Funktionen, die andere Methoden als Parameter nehmen. Sie können vielseitig eingesetzt werden und sehr mächtig sein. Zu ihrer Freude finden sie in der Standardbibliothek das [`java.util.function` Package](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/package-summary.html), das Interfaces für verschiedene Arten von Funktionen bietet. 

Zuerst wollen sie eine `map` Funktion schreiben, die eine Instanz des [`Function `](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Function.html) Interfaces und eine `List ` als Parameter nimmt, und eine `List ` zurückgibt.
1. [task][map]( 251354 ) Implementiere die Methode `map` in `Functions`. Die mitgegebene Funktion soll auf jedem Element der gegebenen Liste aufgerufen werden und das Ergebnis in unveränderter Reihenfolge in eine neue Liste gepeichert werden.

Nun wollen die Pinguine ihre neue Methode natürlich auch testen. Dazu wollen sie eine Methode schreiben, die jedes Element in einer `List ` quadriert. 
Die Pinguine haben von einem besonderen Syntax zum einfacheren Implementierung solcher Interfaces mit nur einer Methode namens Lambda gehört. Nutze so ein Lambda in deiner Lösung.

2. [task][square]( 251339 ) Implementiere die Methode `square` in `Functions` und nutze dafür `map`.

Als nächstes wollen sie noch eine generische Methode schreiben, die jedes Element einer beliebigen `List ` in ihre String Repräsentation umwandelt.

3. [task][toString]( 251352 ) Implementiere die Methode `toString` in `Functions` und nutze dafür `map`.

Den Pinguinen hat das bisher schon sehr gut gefallen, also wollen sie auch mal eines der anderen Interfaces dieses Packages ausprobieren: [`Predicate`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Predicate.html). Dieses Interface stellt eine Funktion bereit, die einen generischen Typen als Parameter nimmt und ein `boolean` zurückgibt.

4. [task][filter]( 251341 ) Implementiere `filter`. Dabei sollen in der Ergebnisliste nur die Elemente sein, für die das Predicate true zurückgibt.

5. [task][filterAny]( 251345 ) Implementiere `filterAny` mit `filter`. Es soll nur die Elemente behalten, bei denen eines der beiden `Predicate`s `true` zurükgibt. Nutze dafür die `default` Methoden des Predicate Interface.

6. [task][multiple2or7]( 251343 ) Implementiere `multiple2or7`. Nur `Integer`s die durch `2` oder `7` teilbar sind, sollen in der Ergebnis Liste enthalten sein. Nutze dafür `filterAny`."
404,Praktikum: Grundlagen der Programmierung WS24/25,15558,W09P02 - Iteration,"# Iteration

Die Fakultät für Pingu Algorithms and Datastructures der PUM möchte ihre bestehende Listen und Baum Implementierung je um einen [Iterator](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Iterator.html) erweitern. 

[task][List Iterator]( 251362 , 251361 )
Zuerst wird dabei ein Iterator für die einfach verkettete Liste hinzugefügt. Der Iterator soll ein Element enthalten und dieses in `next()` mit dem nächsten ersetzen.
Bei `null` ist der Iterator am Ende angekommen. Wie im Javadoc beschrieben soll `next()` auf einem leeren Iterator eine `NoSuchElementException` werfen.

1. Implementiere `List.ListIterator` mit einem public Konstructor der ein `List.Element` als Parameter erwartet. Die Klasse soll [java.util.Iterator](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Iterator.html) implementieren.
2. Implementiere [Iterable](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html) für `List`. Die hierfür benötigte Methode ist bereits mit einem Dummy-Wert vorgegeben.

[task][Tree Iterator]( 251360 , 251358 )
Nun soll noch ein Iterator für den Binärbaum implementiert werden. Der Iterator soll für jedes Element zuerst durch den linken Teilbaum (`left`) iterierieren, danach der Inhalt des entsprechenden Knotens zurückgegeben und schließlich durch den rechten Teilbaum (`right`) iterieren.

3. Implemtiere `Tree.TreeIterator` mit einem public Konstruktor der ein `Tree.Element` als Parameter erwartet. Die Klasse soll `java.util.Iterator` implementieren. Wenn als Parameter `null` übergeben wird, ist der Iterator leer.
4. Implementiere `Iterable` für `Tree`. Auch hier ist die leere Methode bereits vorgegeben."
404,Praktikum: Grundlagen der Programmierung WS24/25,15563,W09B01 - Pinguin Roboter Bonus,"# W09B01 - Pinguin Roboter Bonus

Werde kreativ und erstelle deinen eigenen Roboter mit deinen eigenen ganz besonderen Aufgaben! 
Du kannst neue Sensoren erstellen, einen komplett neuen Roboter bauen und die Welt verändern (wortwörtlich)!
Als Belohnung erhältst du von den Entdeckuinen 10 Bonuspunkte!

Denke dir irgendwas besonderes aus, was nicht schon in der Hausaufgabe gefragt war.
Ein Roboter, der einfach nur in einem Wartezimmer hin und her läuft ist nicht kreativ genug.
Du findest bspw. im `Controller`-Interface noch einige Methode, mit denen du auch Mouse-Inputs erkennen kannst.
Dein Roboter darf natürlich auch das Terrain beliebig verändern.
Tob dich aus und lass deiner Kreativität freien Lauf!

Im Template findest du dasselbe Setup wie in der Aufgabe `W09H01`.
Im Gegensatz zur Hausaufgabe darfst du diese aber beliebig verändern.
Als Voraussetzung bleibt natürlich, dass alles kompiliert.
Falls es einen Buildfail auf Artemis gibt, bekommst du leider keine Punkte!
Das bestehen der Hausaufgabe ist keine Voraussetzung für die Bonusaufgabe.
Allerdings sollst du dennoch die Steuerung wie in der Hausaufgabe über Sensoren und das `Function`-Programm umsetzen.
Falls das nicht passiert, behalten wir uns Punktabzüge vor!
Mache dafür in der Klasse `User` deutlich, wo dein Roboter zusammengebaut und programmiert wird (ein Kommentar reicht).

Nimm anschließend ein Video deines fertigen Roboters auf (nicht vom Code, sondern wenn du den Roboter in der Welt laufen lässt) und lade es im Package `pgdp.robot.video` hoch.
Es werden nur MP4-Datein akzeptiert.








 
 
  🐧  
  ❆  
  ❆  
  ❄️  
  ❆  
  ❄ 
  ❆  
  🕯️  
  ❆  
  ❄️  
  ❆  
  ❆️  
  ❆  
  ❄️  
  ❆  
  🎄  
  ❆  
  ❆️  
  ❆  
  ❄️  
  ❆️  
  ❆  
  ❄️  
  ❆  
  ❆️  
  ❆  
  ❆   
  ☃️  
  ❆  
  ❆  
  ❆️  
  ❆  
  ❆  
  ❆️  
  ❆  
  🌟  
  ❆  
  ❆  
  ❆  
  ❆️"
404,Praktikum: Grundlagen der Programmierung WS24/25,15615,W09H03 - PinguPinguLos VI - Die Rueckkehr der Suchmaschine,"# PinguPinguLos VI - Die Rückkehr der Suchmaschine 

## Ziel
Mithilfe der Links, die in der letzten Woche unserer Suchmaschine hinzugefügt wurden, können wir nun den PageRank-Wert jedes Dokumentes bestimmen. Dies ist Maß dafür, wie wichtig oder relevant ein Dokument ist. Kurz gesagt: Je mehr eingehende Links ein Dokument besitzt, desto interessanter scheint es wohl zu sein. Dementsprechend soll ein solches Dokument auch einen hohen PageRank-Wert erhalten.

Des weiteren werden wir unsere `DocumentCollection` mit einem Beispiel-Internet füllen. 
Um dieses lokal einzusehen, könnt ihr über den Befehl `docker run --rm -d -p 127.0.0.1:8000:80 -v /usr/share/man:/usr/share/man:ro gray542/man2html` einen [Docker](https://docs.docker.com/) Container starten. Unter `localhost:8000` findet ihr dann das ""Internet"".

### 1. The Page Rank
Der Page Rank ist der letzte fehlenden Teil, um eine funktionsfähige Suchmaschine zu erhalten. Je mehr eingehende Links ein Dokument besitzt, desto wichtiger ist es für uns, da viele Dokumente darauf weisen. Diese Dokumente sollen einen hohen PageRank-Wert bekommen. Den Wert selbst berechnen wir rekursiv mit folgender Formel:

$$ PR_i = \frac{1-d}{n} + d \cdot \sum_{j \in IL_i} \frac{PR_j}{|OL_j|} $$

- $$PR_i$$: PageRank-Wert des Dokumentes mit der Adresse i
- $$d$$: Dämpfungsfaktor, meist 0.85
- $$n$$: Anzahl der Dokumente in unserer Gesamtcollection
- $$IL_i$$: Menge der eingehenden Links auf das Dokument mit der Adresse i 
- $$|OL_j|$$: Anzahl der Dokumente, auf die das Dokument der Adresse j einen ausgehenden Link besitzt

Der Startwert für den PageRank-Wert jedes Dokumentes (Rekursionstiefe 0) ist $$PR_{i, 0} = \frac{1}{n}$$. Falls ein Dokument keine ausgehenden Links besitzt, behandeln wir dieses Dokument so, als hätte es zu jedem anderen Dokument einen ausgehenden Link.
Am Ende der Aufgabe befindet sich ein ausführliches Beispiel inklusive Erklärung zur Berechnung des PageRank-Wertes.

1. Ergänze die Klasse `DocumentListElement` um ein privates Attribut `double pageRank` inklusive Getter und Setter.
2. Implementiere eine Methode `double pageRankRec(DocumentListElement[] indices, int i, double d, int recDepth)` in `LinkedDocumentCollection`. Diese Methode soll für das Dokument an Index `i` von `indices` den PageRank-Wert nach der gegebenen Formel rekursiv berechnen. Der übergebene Parameter `indices` enthält alle Listenelemente unserer Collection. Der Parameter `d` entspricht dem Dämpfungsfaktor und `recDepth` bestimmt die maximale Rekursionstiefe, also wie oft `pageRankRec` rekursiv aufgerufen werden soll, bevor abgebrochen wird. Bei einer Rekursionstiefe von 0 oder kleiner soll der Startwert unseres PageRank-Wertes zurückgegeben werden. Andernfalls wird immer der neue berechnete Wert zurückgegeben. Du kannst davon ausgehen, dass die Parameter `indices`, `i` und `d` immer gültig sind. [task][ ]( 252794 , 252823 , 252788 , 252835 , 252797 , 252818 )
3. Implementiere eine Methode `double[] pageRank(double d, int recDepth)` in `LinkedDocumentCollection`. Diese Methode soll für alle Dokumente in der Collection den PageRank-Wert berechnen und die Werte als Array zurückgeben. An Index 0 soll dabei der PageRank-Wert des Dokumentes mit der niedrigsten ID stehen und am höchsten Index der Wert des Dokumentes mit der höchsten ID. Du kannst davon ausgehen, dass `d` immer gültig ist. Stelle zudem sicher, dass das `pageRank`-Attribut von jedem Listenelement korrekt aktualisiert wurde. [task][ ]( 252814 , 252833 , 252807 , 252828 , 252829 , 252793 , 252787 , 252792 )

### 2. Die `DocumentCollection` füllen

Nach der Aufgabenstellung findest du nähere informationen zu `HTTP` und `HTML`.

#### 2.1. Eine Seite aus dem Netz holen

Um die Kommunikation mit dem Server, von dem wir die Seiten holen wollen, zu implementieren, wollen wir eine Anfrage an einen fremden Host sowie dessen Antwort je als eine eigene Klasse modellieren. Implementiere also die folgenden beiden Klassen:

[task][HTTPRequest]( 252827 , 252811 , 252796 )
Diese Klasse soll eine Anfrage an einen Host repräsentieren. Da wir nur Seiten holen werden und keine Daten an Hosts verschicken wollen, wird `HTTPRequest` stets einen GET-Request darstellen.
Gib der Klasse ein Attribut `host` für die Domain sowie ein Attribut `path` für den Pfad, auf den zugegriffen werden soll. Für beide Attribute soll es Getter geben. Füge außerdem einen Konstruktor hinzu, der diese beiden Werte entgegennimmt und in die entsprechenden Attribute schreibt.

Zudem soll die Klasse `HTTPRequest` noch eine Methode `HTTPResponse send(int port)` enthalten. Diese soll den durch das Objekt `this` repräsentierten GET-Request über einen neu erstellten `Socket` absenden und aus der erhaltenen Antwort ein neues `HTTPResponse`-Objekt kreieren und dieses zurückgeben.
Achte darauf, dass Requests mit einer Leerzeile enden müssen (es sei denn, sie haben noch einen Body, was unsere Requests allerdings nicht haben).

*Hinweis:*
Beachte nochmals, dass für das Lösen dieser Aufgabe nur Klassen aus den Packages `java.lang`, `java.util`, `java.util.stream`, `java.io`, im JDK mitgelieferte Exception-Klassen und die `Socket`-Klasse aus dem Package `javax.net.Socket` verwendet werden dürfen. Insbesondere darfst du nicht die Klassen aus `java.net.http` verwenden.

[task][HTTPResponse]( 252789 , 252830 , 252803 )
Diese Klasse soll eine Antwort eines Hosts auf eine `HTTPRequest` darstellen. Dazu soll sie sich in einem Attribut `status` den Status der Response (siehe das im Template mitgelieferte Enum `HTTPStatus`) und in einem weiteren Attribut `html` den ""rohen"" HTML-Code, der mit der Response geliefert wurde, als `String` abspeichern.
Zu beiden Attributen soll es Getter geben, der Konstruktor soll direkt den Antworttext auf ein GET-Request (also mit den Headern) entgegennehmen und daraus die Werte der eigenen Attribute berechnen.

Du kannst für das HTML-Tag (und nur dieses!) davon ausgehen, dass es in der gesamten Antwort den Text ""\ "" (oder ""\ "") und den Text ""\ "" je nur einmal gibt und nie innerhalb eines Strings. Dir wird also in unseren Tests kein HTML-Code wie
```
 
 
 Link 
 
 
```
vorgesetzt, bei dem ein ""Fake-Tag"" in einem String versteckt ist.
Achte allerdings darauf, dass das Tag auch in Großbuchstaben (""\ \ "") ankommen kann und in diesem Falle genauso erkannt werden soll.

#### 2.2 Den erhaltenen HTML-Code verarbeiten

Du darfst davon ausgehen, dass sämtlicher in dieser Aufgabe übergebener HTML-Code wohlgeformt ist und keine Kommentare enthält. Genauso darfst du von den Sachen ausgehen, die dir weiter oben für unseren HTML-Code garantiert wurden. Den Methoden, die `List `-Objekte entgegennehmen (`HTMLToken` wirst du gleich selbst implementieren), werden wir in den Tests nur solche Token-Listen übergeben, die entweder wohlgeformten HTML-Code repräsentieren oder eine Teilliste einer Liste sind, die wohlgeformten HTML-Code repräsentiert.

[task][HTMLToken]( 252817 , 252790 , 252815 )

Um den vorliegenden ""rohen"" HTML-Code besser untersuchen zu können, wollen wir ihn erst einmal in logische Einheiten unterteilen. Dafür wählen wir je ein Tag (egal, ob Starttag oder Endtag) als eine logische Einheit und ein Stück Fließtext zwischen zwei (nicht notwendigerweise gleichen) Tags als eine weitere logische Einheit. Der HTML-Code
```
 
 
 Überschrift mit  Link 
        Text
         
        Mehr Text
     
 
```
würde also in dreizehn solcher logischer Einheiten unterteilt werden, nämlich
```text
Tag: html
Tag: body
Tag: h1
Text: überschrift⎵mit⎵
Tag: a⎵href=""https://www.youtube.com/watch?v=OJOV1vf1zYk""
Text: link
Tag: /a
Tag: /h1
Text: text
Tag: br
Text: mehr⎵text
Tag: /body
Tag: /html
```
Genau eine solche logische Einheit soll von der Klasse `HTMLToken` repräsentiert werden. Sie soll sich die Art des Tokens `tokenType` und dessen Inhalt `content` merken. Ersteres soll über ein (in `HTMLToken` intern definiertes) Enum `TokenType` geschehen, das die Werte `TAG` und `TEXT` annehmen kann. `tokenType` soll von diesem Enum-Typen sein. Letzteres soll durch einen `StringBuilder` dargestellt werden, sodass es leicht erweiterbar ist.

Die Klasse `HTMLToken` soll außerdem folgende fünf Methoden enthalten:
- Konstruktor: Nimmt nur den `tokenType` entgegen. Der `content` ist beim Erstellen eines `HTMLToken`-Objektes noch leer.
- Getter für `tokenType`
- `String getContentAsString()`: Gibt das Attribut `content` zurück, aber als `String`
- `void addCharacter(char c)`: Fügt den übergebenen Character hinten an den bisherigen `content` an
- `String toString()`: Gibt "" Tag:⎵ \<`content` als String>"" zurück, falls `this` einen Tag darstellt, "" Text:⎵ \<`content` als String>"", falls es einen Text darstellt.

##### HTMLProcessing

In der Klasse `HTMLProcessing` sind die Köpfe von vier statischen Methoden zum Verarbeiten des in der Response mitgesendeten HTML-Codes enthalten. Vervollständige die Rümpfe, sodass die Methoden das hier definierte Verhalten an den Tag legen.

[task][tokenize]( 252826 , 252840 )
Die Methode `List  tokenize(String)` soll den übergebenen `String` gemäß den oben beschriebenen Regeln in eine `ArrayList` von `HTMLToken`-Objekten umwandeln. Bei Tags sollen, wie oben gezeigt, die spitzen Klammern nicht mit in den `content` des Tokens aufgenommen werden, alles andere schon. Achte beim Einlesen eines Tags auf Strings, sowohl solche, die mit "" beginnen und enden, als auch solche, die mit ' beginnen und enden. Wenn man sich innerhalb eines Strings befindet und auf eine spitze Klammer zu trifft, ist das nicht das Ende des Tags.
 
Außerdem solltest du Tag-Namen wie ""A"", ""HTML"" und ""BODY"", Attribut-Bezeichner wie ""HREF"" und Text auch vollständig in Kleinbuchstaben umwandeln, sodass man später leichter danach suchen kann. Wandle allerdings nicht den gesamten HTML-String in Kleinbuchstaben um, da er auch Komponenten (für uns sind das im Speziellen Links) enthält, bei denen Groß-/Kleinschreibung wichtig ist.

*Hier noch ein Tipp zum Lösen der Aufgabe:*
Man muss den HTML-String nur einmal von vorne bis hinten durchgehen und ihn dabei Buchstabe für Buchstabe ansehen, um ihn in die Token-Liste umzuwandeln. Dabei sollte man sich immer merken, in welchem Zustand man gerade ist: Bin ich in einem Tag? Bin ich in einem String, der mit ' begonnen wurde (also auch damit aufhören muss)? usw... Abhängig von einerseits dem Zustand und andererseits dem aktuell gelesenen Zeichen ergibt sich dann, was man tun muss und ob/wie der Zustand zu ändern ist.
(Das ist nur ein Tipp! Du darfst die Aufgabe natürlich lösen, wie du willst.)

[task][filterLinks]( 252841 , 252831 )
Die Methode `String[] filterLinks(List , String)` nimmt eine Liste an `HTMLToken`s und den Namen eines Hosts entgegen. Die Liste an Tokens beschreibt dabei eine HTML-Seite, der Host ist derjenige, von dem die HTML-Seite erhalten wurde. Wenn also von ""http://man1.pgdp.sse.in.tum.de/rstart.1.html"" die Seite
```html
 
 
 Man page of RSTART 
 
 
 RSTART 
        ...
         Return to Main Contents 
        ...
           
        ...
         man2html 
        ...
     
 
```
geholt wurde, wird `filterLinks()` mit der Liste `[Tag: html, Tag: head, Tag: title, Text: man page of rstart, ..., Tag: /html]` (wobei die `HTMLToken`-Objekte hier natürlich durch den Rückgabewert ihrer `toString()`-Methode repräsentiert werden) und dem String "" man1.pgdp.sse.in.tum.de “ aufgerufen (vorausgesetzt natürlich `tokenize()` funktioniert wie zuvor beschrieben).

Die Methode soll nun ein Array mit den Adressen aller Seiten (ungleich der aktuellen Seite) erstellen, auf die die aktuelle (durch die `List ` beschriebene) Seite verlinkt (Auf Selbst-Links wie 127.0.0.1 wird nicht getestet). Die Adresse beinhaltet dabei sowohl Host als auch Pfad, nicht aber das Protokoll. 
Dabei werden dir in unseren Seiten folgende Typen von Links begegnen:

- Das href-Attribut des ersten der drei dargestellten Links verlinkt auf einen anderen Host (""pgdp.sse.in.tum.de"" statt ""man1.pgdp.sse.in.tum.de""). Die Adressen solcher Links sind stets vollständig mitsamt Protokoll (immer ""http://"") angegeben. Das Protokoll soll, wie eben gesagt, nicht mit in den Ausgabe-String, alles andere schon.
- Der zweite Link hat gar kein href-Attribut, sondern verlinkt auf einen anderen Abschnitt auf derselben Seite. Solche Links sollen ignoriert werden.
- Das href-Attribut des dritten Links verlinkt auf eine andere Seite auf demselben Host. Bei solchen Links ist nur der Pfad angegeben, nicht Host und Protokoll. Ersterer soll im Ausgabe-String ergänzt werden, das Protokoll aber nicht.

In dem obigen Beispiel sollte also das Array ["" pgdp.sse.in.tum.de/index.html “, "" man1.pgdp.sse.in.tum.de/cgi-bin/man/man2html “] zurückgegeben werden (plus eventuelle weitere Links, die in den ... stehen könnten).

Du kannst davon ausgehen, dass alle Links, mit denen wir testen, in einer dieser drei Formen ist. Mit allen anderen Links (z.B. ` `) darfst du umgehen, wie du willst/wie es dir sinnvoll erscheint.
Die Links sollen in der gleichen Reihenfolge im zurückgegebenen Array stehen, in der sie auch in der Seite auftauchen. Du musst dir keine Gedanken über mehrfach auftauchende Adressen machen. Das werden wir nicht testen.

Sowohl ""a"" als auch ""href"" können im vom Server heruntergeladenen HTML sowohl als Kleinbuchstaben als auch als Großbuchstaben auftauchen. Da du aber bei der Implementierung von `tokenize()` bereits darauf geachtet hast, kannst du jetzt davon ausgehen, dass Tag- und Attribut-Namen nur in Kleinbuchstaben vorliegen. Das Gleiche gilt auch für die nächsten beiden Methoden.

*Hinweis*:
Die Methode `filterLinks()` soll mit Streams und Lambdas implementiert werden. Insbesondere gibt es auf die Lösung dieser Aufgabe nur dann Punkte, wenn keine Kontrollstruktur verwendet wurde. Die Schlüsselwörter `if`, `else`, `for`, `do`, `while`, `switch`, `case`, `break` und `continue` sind innerhalb von `filterLinks()` verboten! Stattdessen soll die Token-Liste sofort in einen Stream umgewandelt und mit Stream-Methoden wie `map()`, `filter()` und `reduce()` weiterverarbeitet werden (es müssen nicht genau diese verwendet werden, das sollen nur Beispiele/Hinweise sein!). Des Weiteren ist auch der ternäre Operator erlaubt. Die Methode muss von folgender Form sein:
```java
public static String[] filterLinks(List  tokens, String host) {
    return tokens
            .stream()
            ./* usw. */;
}
```
Du darfst außerdem keine eigenen Hilfsmethoden aufrufen/referenzieren, sondern nur die fünf von der Aufgabenstellung für `HTMLToken` geforderten Methoden, sowie die Methoden von Klassen des Packages `java.lang`, die Methode `java.util.Arrays.stream()` und natürlich die Methoden von `java.util.stream.Stream`. Alle anderen Methoden sind verboten. Du darfst auch keine nicht-final statischen Variablen und keine Instanzvariablen (direkt - mittels einer der erlaubten Methoden geht natürlich in Ordnung) referenzieren. `static final`-Variablen, also Konstanten, dürfen referenziert werden, um Code Issues zu vermeiden. Auf die Zustände eines Enums darf auch direkt zugegriffen werden. Die zählen als `static final`.

[task][filterText]( 252825 , 252820 )
Die Methode `String filterText(List )` soll ähnlich `filterLinks()` die übergebene Token-Liste (die eine HTML-Seite darstellt) untersuchen und Informationen daraus sammeln. Nur soll diesmal der gesamte Text (also alles, was im ursprünglichen HTML-Code nicht innerhalb eines Tags stand) zu einem langen String konkateniert zurückgegeben werden. Füge zudem zwischen zwei durch Tags zuvor getrennte Textstellen stets genau ein Leerzeichen ein. Aus dem HTML
```html
 
 
        in sibirien ist es recht kühl schrank und schreibtisch stehen im zimmer
     
 
```
soll ein Dokument generiert werden, in dem man nach den Wörtern ""kühl"" und ""schrank"", nicht aber dem Wort ""kühlschrank"" suchen kann. Der Output von `filterText()` sollte hierfür also
 in⎵sibirien⎵ist⎵es⎵recht⎵kühl⎵schrank⎵und⎵schreibtisch⎵stehen⎵im⎵zimmer  generieren.

*Hinweis*:
Auch die Methode `filterText()` soll mit Streams und Lambdas implementiert werden. Insbesondere gibt es auf die Lösung dieser Aufgabe nur dann Punkte, wenn keine Kontrollstruktur verwendet wurde. Die Schlüsselwörter `if`, `else`, `for`, `do`, `while`, `switch`, `case`, `break` und `continue` sind innerhalb von `filterText()` verboten! Stattdessen soll die Token-Liste sofort in einen Stream umgewandelt und mit Stream-Methoden wie `map()`, `filter()` und `reduce()` weiterverarbeitet werden (es müssen nicht genau diese verwendet werden, das sollen nur Beispiele/Hinweise sein!). Des Weiteren ist auch der ternäre Operator erlaubt. Die Methode muss von folgender Form sein:
```java
public static String filterText(List  tokens) {
    return tokens
            .stream()
            ./* usw. */;
}
```
Du darfst außerdem keine eigenen Hilfsmethoden aufrufen/referenzieren, sondern nur die fünf von der Aufgabenstellung für `HTMLToken` geforderten Methoden, sowie die Methoden von Klassen des Packages `java.lang`, die Methode `java.util.Arrays.stream()` und natürlich die Methoden von `java.util.stream.Stream`. Alle anderen Methoden sind verboten. Du darfst auch keine nicht-final statischen Variablen und keine Instanzvariablen (direkt - mittels einer der erlaubten Methoden geht natürlich in Ordnung) referenzieren. `static final`-Variablen, also Konstanten, dürfen referenziert werden, um Code Issues zu vermeiden. Auf die Zustände eines Enums darf auch direkt zugegriffen werden. Die zählen als `static final`.

[task][filterTitle]( 252812 , 252837 )
Die Methode `String filterTitle(List )` soll aus der übergebenen Token-Liste den Titel eines Dokuments extrahieren. Dieser ist stets der Text, der sich innerhalb des \ -Elements befindet, welches Kind des \ -Elements ist, welches wiederum direktes Kind des \ -Elements (also des Elements auf oberster Ebene ist). Eine typische HTML-Seite mit Titel sieht folgendermaßen aus:
```html
 
 
 Man page of ISO_8859-1 
 
 
        ...
     
 
```
Der Text innerhalb des \ -Elements soll von der Methode extrahiert werden. Du kannst davon ausgehen, dass es immer nur ein \ -Element gibt, dieses sich immer direkt innerhalb des ebenfalls nur einmal vorkommenden \ -Elements befindet, welches wiederum direktes Kind von dem obersten Element (\ ) ist.

*Hinweis*:
`filterTitle()` muss nicht mit Streams und Lambdas implementiert werden. Hier sind wieder alle Schlüsselwörter erlaubt. Du darfst gerne auch diese Methode mit Streams implementieren, sie bietet sich aber dafür bei Weitem nicht so gut an, wie die beiden vorherigen.

#### 2.3. Die `LinkedDocumentCollection` mit Seiten aus dem Netz füllen

Nachdem wir nun Code haben, der uns Seiten als HTML aus dem Netz holt und Code, der aus dem erhaltenen HTML Links, Inhalt und Titel extrahiert, können wir uns nun daran machen, für die geholten Seiten je ein neues `LinkedDocument` zu erstellen und in unsere `LinkedDocumentCollection` einzufügen.

1. [task][addToResultCollection updaten]( 252821 , 252804 )
Gehe als erstes in die `LinkedDocumentCollection` und ändere die Methode `addToResultCollection(AbstractLinkedDocument)` so ab, dass sie zusätzlich noch die Outgoing-Links des übergebenen Dokuments als Parameter entgegennimmt. Die Signatur sollte also zu `addToResultCollection(AbstractLinkedDocument, String[])` geändert werden. Im Methodenrumpf sollen nun beim Updaten der Incoming-Links diese nicht länger aus dem `content` des übergebenen `AbstractLinkedDocument` ausgelesen werden (das war nur eine Zwischenlösung für die letzten Wochen), sondern es sollen die übergebenen Outgoing-Links verwendet werden, um zu bestimmen, für welche Dokumente das übergebene `AbstractLinkedDocument` zu den Incoming-Links hinzugefügt werden muss bzw. welche Dummies neu erstellt werden müssen.

2. [task][Eine Seite Crawlen]( 252836 , 252838 , 252834 )
In der Klasse `PageCrawling` im `networking`-Package findest du eine (noch leere) Methode `crawlPage(LinkedDocumentCollection, String)`. Diese soll die Seite an der übergebenen Adresse (im Format Host/Pfad, z.B. ""man7.pgdp.sse.in.tum.de/iso\_8859\_1.7.html"") holen, daraus mithilfe der zuvor in `HTMLProcessing` implementierten Methoden ein `LinkedDocument`-Objekt erstellen und dieses in die `LinkedDocumentCollection` einfügen. Die Konstruktorparameter `description`, `releaseDate`, `author` und `collectionSize` von `LinkedDocument` dürfen beliebig gesetzt werden, wobei letzeres logischerweise größer null sein sollte. Die Links sollen alle korrekt in die Collection übertragen werden. Achte also darauf, die richtige Methode zum Einfügen in die Collection zu verwenden und ihr die richtigen Parameter zu übergeben.
 
Beim Holen der Seite von der jeweiligen Adresse solltest du die Nachricht an Port 8000 senden.
 
Wenn der Zugriff auf die übergebene Adresse nicht möglich war (also ein Statuscode ungleich 200 zurückkam) soll nichts in die Collection eingefügt werden und `false` zurückgegeben werden. Wenn der Zugriff erfolgreich war, soll `true` zurückgegeben werden.

3. [task][Eine noch nicht gecrawlte Adresse aus der LinkedDocumentCollection holen]( 252795 )
Jetzt können wir eine einzelne Seite für eine vorgegebene Adresse holen. Wir wollen aber viele Seiten aus dem Netz holen und in unser Page Repository eintragen können. Wir könnten einfach für jede geholte Seite deren Outgoing-Links direkt verwenden, um neue Seiten zu finden. Allerdings führt das zu dem Problem, dass Seiten einander im Kreis verlinken können und man dann ewig lange die gleichen Seiten durchsucht. Um das zu verhindern, wollen wir in der `LinkedDocumentCollection` nachsehen, um nur solche Seiten zu holen, die dort noch nicht eingetragen sind. Glücklicherweise bietet uns diese dafür genau die richtige Struktur. Wir haben `LinkedDocument`s in ihr, die Seiten repräsentieren, die bereits gecrawlt wurden und `DummyLinkedDocument`s für Seiten, von deren Existenz wir wissen bzw. deren Adresse wir kennen, deren Inhalt wird aber noch nicht heruntergeladen haben.
 
Implementiere also in `LinkedDocumentCollection` eine neue Methode `String getNextUncrawledAddress()`, die die Collection nach einem `AbstractLinkedDocument` durchsucht, das noch nicht gecrawlt wurde. Welches derartige `AbstractLinkedDocument` hier genau zurückgegeben wird, spielt keine Rolle, solange es noch nicht gecrawlt wurde und in der Collection ist. Die Adresse dieses Dokuments soll zurückgegeben werden. Wenn bereits alle Dokumente in der Collection gecrawlt wurden, soll `null` zurückgegeben werden.

4. [task][Viele Seiten Crawlen]( 252838 )
Implementiere nun die Methoden `void crawlPages(LinkedDocumentCollection collection, int number, String startingAddress)` und `void crawlPages(LinkedDocumentCollection collection, int number)` in der Klasse `PageCrawling`.
Erstere soll `number` Seiten crawlen und in die `collection` einfügen. Die erste gecrawlte Seite soll dabei die in `startingAddress` sein. Alle weiteren sollen mittels `getNextUncrawledAddress()` ermittelt werden. Wenn eine der dabei gecrawlten Adressen nicht erreichbar ist (also von `crawlPage()` `false` zurückgegeben wurde), soll das entsprechende Dummy-Dokument aus der Collection entfernt werden. Diese Adresse zählt dann **nicht** zu der `number` der zu crawlenden Seiten dazu.
Zweitere Methode soll das gleiche tun, nur dass die erste gecrawlte Seite ebenfalls mittels `getNextUncrawledAddress()` ermittelt werden soll.

### Erklärungen einiger für die Aufgabe relevanter Konzepte

#### HTTP

Um mit anderen Rechnern zu kommunizieren, ist es wichtig, sich an ein bestimmtes Kommunikationsprotokoll zu halten. Sonst weiß der Rechner, mit dem man Daten austauscht, möglicherweise nicht, wie er die von einem selbst gesandten Daten zu interpretieren hat und umgekehrt. Ein gängiges solches Protokoll heißt `HTTP` (`H`yper`T`ext `T`ransfer `P`rotokoll).
Bei der Kommunikation zwischen zwei Rechnern sendet z.B. Rechner A eine Zeichenkette an Rechner B und B antwortet mit einer anderen Zeichenkette. HTTP gibt dabei Schemata vor, wie diese Zeichenketten jeweils aufgebaut sein sollen bzw. wie sie zu interpretieren/behandeln sind. Eine typische HTTP-Anfrage könnte beispielsweise folgendermaßen aussehen:
```http
GET /rstart.1.html HTTP/1.1
Host: man1.pgdp.sse.in.tum.de
User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:64.0) Gecko/20100101 Firefox/64.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: de,en;q=0.7,en-US;q=0.3
Accept-Encoding: gzip, deflate, br
DNT: 1
Connection: keep-alive
Upgrade-Insecure-Requests: 1
```
Die erste Zeile enthält die sogenannte ""Anfragemethode"" GET - dazu gleich mehr - den abgefragten Pfad ""rstart.1.html"", sowie die Version des Protokolls (hier: 1.1), jeweils mit Leerzeichen getrennt.
Die nächste Zeile enthält den Host, an den die Anfrage geschickt werden soll. Dieser ist in Version 1.1 von HTTP obligatorisch.
Die folgenden Zeilen definieren (in keiner speziellen Reihenfolge) einige andere für den Empfänger (vielleicht) interessante Information. Hier beispielsweise das Betriebssystem und den Browser des Senders, akzeptierte Formate, Sprachen und Kodierungen für die Antwortdaten und mehr.

Eine Antwort auf diese Anfrage könnte folgendermaßen aussehen:
```http
HTTP/1.1 200 OK
Date: Tue, 21 Dec 2021 18:06:31 GMT
Server: Apache/2.4.41 (Ubuntu)
Last-Modified: Tue, 21 Dec 2021 09:38:29 GMT
ETag: ""10dc-5d3a4c3154785""
Accept-Ranges: bytes
Content-Length: 4316
Vary: Accept-Encoding
Content-Type: text/html

 
 
 
 Man page of RSTART 
 
 
 RSTART 
        ...
     
 
```

In der ersten Zeile wieder die Version des Protokolls, aber diesmal mit dem sogenannten Statuscode und der zugehörigen Message der Antwort - auch hierzu gleich mehr.
Darauf folgen wieder einige Header-Daten, wie das Datum und die Uhrzeit, zu denen die Antwort verschickt wurde, der Typ des Servers, die Länge der Antwort usw.
Nach dem Header folgt dann der verschickte HTML-Code, der in obigem Request angefordert wurde.

HTTP definiert mehrere sogenannte ""Anfragemethoden"". Das sind im Prinzip nur Strings, die kennzeichnen, wie der Empfänger die Anfrage zu verstehen hat:
- `GET`: Signalisiert dem Empfänger, dass er dem Sender eine bestimmte Ressource (z.B. eine HTML-Seite) zurücksenden soll. Einen GET-Request sendet man z.B., wenn man eine Seite von einem Server laden will, um sie im lokalen Browser anzuzeigen, oder wenn man eine Datei herunterladen will.
- `POST`: Anfragen, die die POST-Anfragemethode verwenden, werden meist noch weitere Daten beigefügt. Eine POST-Anfrage signalisiert dem Empfänger, dass er die mitgesandten Daten (auf eine je nach Anwendung im Empfänger definierte Weise) weiterverarbeiten soll. Eine POST-Anfrage würde man z.B. verwenden, wenn man sich in einen Host ein- oder ausloggen will, oder man ein Webformular ausgefüllt hat (z.B. eine Umfrage) und dieses absenden will.
- `HEAD`: Signalisiert dem Empfänger, dass er den Header senden soll, den er bei einem entsprechenden GET-Request gesandt hätte, nicht aber den (i.d.R. um ein Vielfaches größeren) Rumpf. Das ist z.B. dann nützlich, wenn man einige im Header enthaltene Daten (den Status der Response, also ob die Anfrage überhaupt geglückt ist, oder die Größe der Datei, die beim entsprechenden GET-Request gesendet werden würde) abfragen möchte, ohne einen womöglich riesigen Rumpf durch die Gegend schicken zu müssen.
- `PUT`: Wird verwendet, um gezielt eine Ressource an den Empfänger hochzuladen.
- usw.

Wir wollen lediglich Seiten holen, daher werden wir in dieser Aufgabe nur `GET`-Requests verschicken. Unser Server reagiert nur auf solche (und auch auf `POST`-Requests, aber so, als wären sie `GET`-Requests). Alle weiteren Anfragemethoden werden mit dem Status ""Method Not Allowed"" abgeblockt.

HTTP definiert außerdem sogenannte Statuscodes. Dies sind dreistellige Zahlen, die Information repräsentieren, ob eine Anfrage erfolgreich war bzw. wenn nicht, warum nicht, und noch einiges mehr. Gängige Statuscodes sind unter anderem:
- **200 (OK)**: Die Antwort auf eine Anfrage enthält diesen Statuscode, wenn alles so gelaufen ist, wie erwartet und die Antwort das Ergebnis der Anfrage enthält.
- **400 (Bad Request)**: Die Antwort wird diesen Statuscode haben, wenn sie nicht korrekt formatiert war und daher nicht klar war, wie damit umzugehen ist.
- **403 (Forbidden)**: Dieser Statuscode bedeutet, dass der Host zwar existiert und ansprechbar ist, aber der angeforderte Zugriff nicht autorisiert ist.
- **404 (Not Found)**: Dieser Statuscode ist einer der am häufigsten anzutreffen. Er bedeutet, dass die angefragte Ressource (= z.B. Website) nicht existiert.
- **405 (Method Not Allowed)**: Dieser Statuscode bedeutet, dass die verwendete Anfragemethode an der angefragten Ressource nicht erlaubt ist. Er wird z.B. auftreten, wenn du versuchst, einen PUT-Request an irgendeinen Pfad in unserem Server zu senden.
- **408 (Request Timeout)**: Dieser Statuscode bedeutet, dass der Server zu lange auf das Ende der Anfrage gewartet hat (die maximal erlaubte Zeitspanne definiert der Server selbst). Er tritt unter Anderem dann auf, wenn man eine unvollständige Anfrage an einen Server schickt und dieser auf deren Rest wartet.

#### HTML

`HTML` (`H`yper`T`ext `M`arkup `L`anguage) ist eine Auszeichnungssprache (engl. Markup Language), also eine computerverständliche Sprache, die anders als Java keine Algorithmen beschreibt, sondern die Formatierung von Seiten und Texten. HTML bildet die Grundlage für so ziemlich jede Website und webbasierte Anwendung heutzutage. HTML-Dokumente können in Webbrowsern dargestellt werden. In dieser Aufgabe wollen wir Seiten von einem Server herunterladen. Diese werden wir von dem Server als HTML-Dokumente erhalten. Um aus der Antwort des Servers die für uns notwendigen Informationen herauslesen zu können, brauchen wir ein Grundverständnis dafür, wie HTML-Dokumente aufgebaut sind. Hier ist ein Beispiel für ein HTML-Dokument:
```html
 
 
 Titel der Seite 
 
 
 Eine große Überschrift 
        Etwas Text
         Eine etwas kleinere Überschrift 
        Etwas mehr Text
         
 Ein Link 
 
 
```
Du kannst [hier](https://jsfiddle.net) online eigenen HTML-Code schreiben und anzeigen lassen. Einrückungen sind - wie in Java - optional (aber sehr angeraten) und dienen nur der Leserlichkeit.

##### Tags und Elemente

HTML strukturiert eine Seite mithilfe von Elementen. Eine Überschrift ist ein Element, ein Paragraph ist ein Element, ein Link ist ein Element, ein Zeilenumbruch ist ein Element usw.
Ein Element kann auch weitere Elemente als Kinder haben. Z.B. kann ein Paragraph mehrere Links und Zeilenumbrüche (oder auch weitere Paragraphen) enthalten. Ein HTML-Dokument ist also nichts anderes als ein Baum von solchen HTML-Elementen. Im HTML-Code wird ein Element mit spitzen Klammern definiert. Diese Deklarationen von Elementen nennt man HTML-Tags. ` ` definiert eine Überschrift, ` ` einen Paragraphen, ` ` einen Link und ` ` einen Zeilenumbruch. Elemente, die Inhalt haben (also Text oder weitere Elemente, die in ihnen angezeigt werden), brauchen zudem ein zweites Tag, das ihr Ende definiert. Das geschieht durch einen `/` vor dem Tag-Namen: ` `, ` ` und ` `. Elemente, wie der durch ` ` definierte Zeilenumbruch, die keinen Inhalt haben, brauchen das nicht.

Tags können auch weitere Attribute haben. Z.B. möchte man bei einem Link in der Regel nicht nur definieren, welcher Text angezeigt werden soll, sondern auch eine Adresse angeben, wo der Link hinführt. Das wird im Falle eines Links mit dem `href`-Attribut gemacht, welches man einfach in das Start-Tag miteinfügt: ` Text, der angezeigt wird `.
Strings können in HTML - im Gegensatz zu Java - auch mit einfachen Anführungszeichen definiert werden. ` Text, der angezeigt wird ` funktioniert genauso. Innerhalb eines Strings kann natürlich auch ein ""Fake-Tag"" auftauchen, der dann ignoriert wird. Der Link in
```html
 
 
 Link-Text 
 
 
```
führt zwar nirgends hin, das HTML-Dokument kompiliert aber ganz normal. Achte bei deiner Implementierung der folgenden Aufgaben darauf.
Anführungszeichen (ob einfach oder mehrfach) haben in HTML nur innerhalb eines Tags Bedeutung.
```html
 
 
        "" Text
     
 
```
ist wohlgeformt. Du darfst davon ausgehen, dass in unseren Beispielen innerhalb eines Strings in einem Tag keine Leerzeichen vorkommen (auch wenn das normalerweise der Fall sein könnte). Das sollte später das Aufteilen eines Tags erleichtern.

Es gibt auch Kommentare in HTML. Statt mit "" \ “ markiert. Um HTML-Kommentare brauchst du dich in dieser Aufgabe nicht zu kümmern.


Herzlichen Glückwünsch! Damit hast deine eigene Suchmaschine programmiert!

# FAQ
### Q: Müssen die Methoden pageRankRec() und pageRank() auch mit ""normalen"" Dokumenten zurecht kommen?
A: Nein, ""normale"" Dokumente können sich nicht in einer LinkedDocumentCollection befinden.

## Beispiel

Man kann unsere Gesamtcollection auch als gerichteten Graphen darstellen. Dabei sind die Dokumente die Knoten und die Links die Kanten.

![pages.svg](/api/core/files/markdown/Markdown_2021-12-10T00-25-29-324_1dd6b747.svg)
 Basierend auf Folien von Julian Kranz und Gerhard Hagerer 

In diesem Beispiel sind in unserer Collection vier Dokumente vorhanden: A, B, C und D. Sämtliche Links lassen sich der Grafik entnehmen. So hat bspw. A zwei ausgehende Links, einen auf B und einen auf C, sowie einen eingehenden Link von B.

Nach Definition ergeben sich folgende PageRank-Werte für Rekursiontiefe 0:

$$PR_{A, 0} = \frac{1}{4}$$

$$PR_{B, 0} = \frac{1}{4}$$

$$PR_{C, 0} = \frac{1}{4}$$

$$PR_{D, 0} = \frac{1}{4}$$

Betrachten wir nun die Berechnung des PageRank-Wertes für C mit Rekursiontstiefe 1 und Dämpfungsfaktor d = 0.85:

Aus der Grafik lässt sich entnehmen, dass $$IL_C = \\{A, B, D\\}$$ gilt.

- $$j = A$$ mit $$|OL\_A| = 2: \frac{PR\_{A, 0}}{|OL\_A|} = \frac{0.25}{2} = \frac{1}{8}$$
- $$j = B$$ mit $$|OL\_B| = 3: \frac{PR\_{B, 0}}{|OL\_B|} = \frac{0.25}{3} = \frac{1}{12}$$
- $$j = D$$ mit $$|OL\_D| = 1: \frac{PR\_{D, 0}}{|OL\_D|} = \frac{0.25}{1} = \frac{1}{4}$$

Damit ergibt sich insgesamt:

$$PR_{C, 1} = \frac{1-d}{n} + d \cdot (\frac{PR\_{A, 0}}{|OL\_A|} + \frac{PR\_{B, 0}}{|OL\_B|} + \frac{PR\_{D, 0}}{|OL\_D|}) = \frac{1 - 0.85}{4} + 0.85 \cdot (\frac{1}{8} + \frac{1}{12} + \frac{1}{4}) \approx 0.427083$$

Dies kann man nun für A, B und D ebenso durchführen und erhält folgende Werte: 

$$PR_{A, 1} \approx 0.108333$$

$$PR_{B, 1} = 0.14375$$

$$PR_{C, 1} \approx 0.427083$$

$$PR_{D, 1} \approx 0.320833$$

Auf diese Art und Weise können für eine beliebige Rekursionstiefe die Werte berechnet werden. Ab einer gewissen Tiefe sollten sich die Werte jedoch nur noch minimal ändern und einem fixen Wert immer mehr annäheren. Deswegen erhalten wir schlussendlich als Werte:

$$PR_{A} \approx 0.054713$$

$$PR_{B} \approx 0.060753$$

$$PR_{C} \approx 0.448551$$

$$PR_{D} \approx 0.435982$$

Ab welcher Rekursionstiefe man abbrechen kann, findest du ein Stück weit durch ausprobieren selbst heraus. Ansonsten brauchst du dir darüber keine großen Gedanken machen, da die Rekursionstiefe beim Methodenaufruf immer mitübergeben wird.


### Q: Wofür ist das FAQ da?
A: Wenn es Fragen gibt, die häufiger aufkommen, werden sie hier gepostet und ebenfalls beantwortet werden. Wer sie danach noch auf Zulip postet macht Pinguine traurig!.
### Q: Wird in den Tests HTML-Code verwendet, in dem ein \ -Tag mehrere href-Attribute hat?
A: Nein. Du darfst davon ausgehen, dass es nur ein href-Attribut pro \ -Tag gibt.
### Q: Ich bekomme beim Senden eines Requests einen ""400 Bad Request"", obwohl ich meine, dass ich alles (inklusive der notwendigen Leerzeile am Ende des Requests) korrekt verschicke. Ich arbeite auf einem Mac. Was könnte das Problem sein?
A: Probiere, statt `.println(x)` `.print(x + ""\r\n"")` zu verwenden.
### Q: Wie können die Strings aufgebaut sein, bzw. was werdet ihr da testen?
A: Es kann in den Strings alles vorkommen, was nicht ausgeschlossen wurde. Zudem wird es nicht ```""\""""``` geben. ```""'""``` kann aber z.B. vorkommen (einfaches Anführungszeichen in einem String der mit doppelten Anführungszeichen markiert ist).
### Q: Muss ich in tokenize() Zeilenumbrüche, Tabs und Leerzeichen (die z.B. zur Formatierung des Codes enthalten sind, wie das in den in der Angabe aufgeführten Beispielen der Fall ist) entfernen?
Die HTML-Beispiele in der Angabe sind der Leserlichkeit halber formatiert, enthalten also zusätzliche Leerzeichen, Tabs und Zeilenumbrüche. Du musst dich **nicht** darum kümmern, diese zu entfernen. Wenn du es allerdings doch tust (wie in dem Beispiel, das die Tokens erklärt, geschehen), ist das genauso in Ordnung. Wir werden so testen, dass beim Inhalt von Text-Tokens Sequenzen von mehreren Leerzeichen, Tabs und Zeilenumbrüchen immer so wie genau ein Leerzeichen behandelt werden. Außerdem werden wir `tokenize()` auch nicht mit HTML-Code testen, in dem zwischen zwei Tags nur Leerzeichen, Tabs und Zeilenumbrüche vorkommen, sodass unklar wäre, ob dazwischen noch ein Text-Token mit besagten Leerzeichen, Tabs und Zeilenumbrüchen eingefügt werden soll.
Code wie
```html
 
 
        Some Text
     
 
```
(als String: ""\ \n⎵⎵⎵⎵\ \n⎵⎵⎵⎵⎵⎵⎵⎵Some Text\n⎵⎵⎵⎵\ \n\<\html>"") wird deiner Methode also nicht übergeben werden, sondern nur
""\ \ Some Text\ \ "", bei dem klar ist, was zu tun ist."
404,Praktikum: Grundlagen der Programmierung WS24/25,15643,W10P01 - Files,"In dieser Aufgabe wollen wir Objekte in Dateien speichern und wieder laden.

Es geht natürlich um Objekte der Klasse Penguin, genauer handelt es sich dabei um Records. Gespeichert werden sie mithilfe der Klasse PenguinRepository, die das Interface Repository  implementiert.

1. [task][Speichern]( 253337 )
  
  Implementiere die Methode save(Penguin p, String filename) in der Klasse PenguinRepository. Sie soll den Namen, Alter und Gewicht vom Penguin jeweils in einer Zeile speichern.

 
 Beispiel: 

```java 
Penguin p = new Penguin(""Tux"", 10, 20.0);
PenguinRepository pr = new PenguinRepository();
pr.save(p, ""tux.txt""); 
```

tux.txt
```text
Tux
10
20.0
```
 

2. [task][Laden]( 253338 )

  Implementiere die Methode load(String filename) in der Klasse PenguinRepository. Sie soll aus einer mit save erzeugten Datei einen Penguin laden."
404,Praktikum: Grundlagen der Programmierung WS24/25,15644,W10P02 - Streams,"## 1. Äquivalente For-Schleife

1. [task][Äquivalente For-Schleife]( 253342 )
Implementiere die Methode streamToFor. Diese soll mit einer for-Schleife dieselbe Funktionalität wie das folgende Snippet haben:

```java
Stream.of(3, 1, -4)
      .map(x -> x * x)
      .forEach(System.out::println);
```


Tipp: Gelegentlich bietet sich ein Blick in die JavaDocs zu Streams an, um praktische Funktionen zu finden.

* Hinweis 1:  Die folgenden Teilaufgaben können in den meisten Fällen in Form eines Einzeilers (nach gängigen Code-Formatierungsregeln) gelöst werden.*  
* Hinweis 2:  Alle folgenden Aufgaben sind ohne die Nutzung klassischer Kontrollstrukturen (`if/else`, `for`, `while/do-while`, etc.) lösbar und sollen auch ohne solche gelöst werden. Die Tests prüfen allerdings nicht, ob ihr euch daran haltet.*

---

## 2. Erstellung von Streams

Als kulturinteressierte Jungpinguine wollt ihr in der vorlesungsfreien Zeit die angesagteste Theateraufführung des Jahres live sehen: Harald Pingu und der eisige Wind. Da der Studienort der PUM jedoch die teuerste Stadt Deutschlands ist und die PUM zum Wintersemester die Studiengebühren auch für antarktische Erdenbewohner stark erhöht hat, müsst ihr euch für die teuren Theaterkarten zuvor in der lokalen Fischfiletfabrik etwas Geld dazuverdienen.

Als Praktikantuin seid ihr an der Warenannahme dafür verantwortlich, die gefangenen Fische der verschiedenen Lieferanten anzunehmen und in die hochmoderne Maschine zu legen, welche durch fortschrittliches Image Recognition die Spezies und mittels einer Waage das Gewicht des Fisches bestimmt (`void analyze(Stream )`). Vor wenigen Wochen wurde das Fließband der Maschine dabei auf den Rund-um-die-Uhr-Betrieb umgestellt, weshalb das Fließband für die Fischannahme nun praktische Streams zur Verarbeitung erwartet.

Eure Aufgabe ist es nun, aus den unterschiedlichen Anlieferungen der Kooperationspartner der Fischfiletfabrik `Stream`s zu erstellen, damit diese einheitlich von der Maschine verarbeitet werden können. Schreibt euren Code dafür in `StreamCreation`.

1. [task][Handfang]( 253349 )
Implementiere die Methode `Stream  caughtWithHand(Fish, Fish, Fish)`, welche die Lieferungen der lokalen Fischfänger vor Ort entgegennimmt. Diese besuchen euch immer dann, wenn sie exakt drei Fische gefangen haben und diese abgeben möchten.

2. [task][Anglerverein]( 253356 )
Implementiere als nächstes die Methode `Stream  caughtWithFishingRod(Fish[])`, welche die Abgaben des Anglervereins verarbeitet. Durch seine vielen fleißigen Vereinsmitglieder kann der Vorstand immer ein ganzes Array an Fischen abliefern.

3. [task][Hochseefischer]( 253351 )
Da die Fänge einiger Hobby-Fischer nicht ausreichen um die hohe Nachfrage nach Fischfilet zu decken, hat die Firma nun auch Verträge mit Hochseefischereien abgeschlossen. Implementiere die Methode `Stream  caughtWithFishNet(Collection )`, welche Collections an Fischen zu einem Stream umwandelt.

4. [task][Fischfarm]( 253350 , 253357 )
Um Lieferschwierigkeiten für die Zukunft definitiv ausschließen zu können hat der Firmenchef eine eigene Fischfarm erbauen lassen, welche direkt mit der Maschine verbunden ist. Implementiere zuletzt `Stream  caughtInFishFarm(Supplier )`, welche konstant Fisch produziert und die endlose Menge an Fischen ebenso in einen Stream verwandelt.

---

## 3. Bearbeitung von Streams

Als nächstes wollen wir uns ansehen, welche Operationen auf Streams ausgeführt werden können. Nutze dafür die Klasse `StreamModification`.

1. [task][Begrenzte Fischannahme]( 253340 )
Nachdem der Fabrikchef all die verschiedenen Händler mit dem Fischfang beauftragt hatte, flachte das Geschäft unerwarteterweise wieder ab. Nun muss er die Menge an angenommenem Fisch beschränken, damit dieser nicht in seinem Lager schlecht wird. Implementiere dafür `Stream  limitIncomingFish(Stream , int)`. Der zurückgegebene Stream soll dabei maximal so viele Fische enthalten, wie der zweite Parameter spezifiziert, allerdings auch nur aus solchen Fischen bestehen, die mindestens 0.8 kg wiegen. Da der Firmenchef keinerlei Risiken eingehen will, soll die Maschine die Fischentnahme aus der Lieferung beenden, sobald ein Fisch das Mindestgewicht nicht erfüllt - ""Alle weiteren Fische sind vermutlich ebenfalls klein"", denkt der Chef.

2. [task][Bestimmte Spezies]( 253353 )
Manche Großkunden der Gastronomie möchten nur bestimmte Fischspezies erhalten. Die Maschine soll also nun in `Stream  filterSpecies(Stream , Fish.FishSpecies)` nur solche Fische behalten, die von der entsprechenden Spezies sind. Der Rest wird aussortiert.

3. [task][Lieferung inspizieren]( 253359 )
Mit `Stream  printAllFish(Stream )` möchte der Chef in die ankommenden Lieferungen je einen Blick werfen, um deren Qualität zunächst grob begutachten zu können.
**Wichtig:** Die Lieferung soll danach weiter verarbeitbar sein und nicht durch die Kontrolle des Chefs zerstört werden! Zudem soll der Stream lazy evaluiert werden, d.h. die `print`s erst ausgeführt werden, wenn der Stream weiter verarbeitet wird.

4. [task][Enthaltene Spezies]( 253347 , 253363 )
Ab und an prüft die Fischfiletfabrik vereinzelte Lieferungen auf ihre Speziesvielfalt (`void printAvailableSpecies(Stream )`). Dabei soll aus der Lieferung jede enthaltene Fischspezies ausgegeben werden - jedoch jede nur einmal (wenn sie mindestens einmal vorkommt).

5. [task][Babyfische]( 253344 )
In der Fischfarm kommen regelmäßig neue Fische auf die Welt - da jedoch nur die Fische mit der besten Form den höchsten Gewinn erzielen, soll die Maschine nun auch den gebärenden Fischen dabei helfen, ihre Babies möglichst unbeschadet auf die Welt zu bringen. `Stream  getBabyFish(Stream )` soll aus einem Stream an Fischen ebendiese zusammen mit ihren Kindern in einen neuen Stream verbinden. Die Babyfische schwimmen aus dem bereits implementierten Teil `Fish[] birthHelper(Fish mother)` der Maschine in Form eines Arrays heraus, wenn diesem ein Fisch übergeben wird. Beachte, dass auch die Elternfische im resultierenden Stream enthalten sein sollen!
Hinweis: Um zwei Streams in einen zu verbinden kannst du die Methode `Stream .concat(Stream , Stream )` verwenden.

6. [task][Gewichtsortierung]( 253345 )
`Stream  sortByWeight(Stream )` soll den übergebenen Stream aufsteigend nach dem Gewicht der enthaltenen Fische sortieren und zurückgeben. Wenn zwei Fische dasselbe Gewicht haben, soll ihre Reihenfolge im ursprünglichen Stream beibehalten werden.

---

## 4. Aggregation und Endverarbeitung von Streams

*Aggregationsfunktionen sind solche, die mehrere Elemente auf eines abbilden (z.B. indem die Anzahl an Elementen gezählt, das Maximum bestimmt oder Werte summiert werden). Sie werden häufig zum Abschluss der Stream-Verarbeitung eingesetzt.*

Implementiere die folgenden Aufgaben in der Klasse `StreamTermination`.

1. [task][Fische verkaufen]( 253362 , 253360 )
Der Firmenchef ist sehr stolz auf euch, dass die Warenannahme und -verarbeitung inzwischen reibungslos funktioniert. Nun möchte er auch das Verpacken und Verkaufen der Fischfilets an die Wünsche seiner Kunden anpassen - bei diesen sind Listen aktuell die Trendverpackung. Implementiere die Methode `List  sellFish(Stream )`, welche die Elemente eines gegebenen Fisch-Streams als Liste zurückgibt.

2. [task][Fische verkaufen II]( 253346 , 253352 )
Trotz der großen Beliebtheit der Listen-Verpackungen gefällt diese nicht allen Kunden. Herr und Frau Kaiser(pinguin) bestehen darauf, ihren Fisch in Form eines Arrays zu erhalten, weil ""Das haben wir schon immer so gegessen!"". Da die beiden fast täglich mehrere Kilo Fisch kaufen, kann die Fischfiletfabrik es sich nicht leisten, die beiden als Stammkunden zu verlieren. Implementiere nun also auch noch `Fish[] sellFishArray(Stream )`, welche einen Stream als Array zurückgibt.

3. [task][Küchenvorbereitung]( 253358 )
Knuth Koch ist in der gesamten Antarktis für seine exzellenten Fischfilets mit Spekulatiuskruste bekannt und arbeitet - wie könnte es anders sein - in der kleinen Suppenküche gleich neben der Fischfiletfabrik. Um die Vielzahl an täglichen Kunden mit seinen Gerichten zufriedenstellen zu können, muss er gleich morgens mit der Vorbereitung der Kochtöpfe beginnen. Dafür ist es wichtig, die Anzahl verschiedener Fisch-Spezies zu kennen, um entsprechend viele Brühen aufzusetzen. Implementiere die Methode long `numberOfDifferentSpecies(Stream )`, welche die Anzahl verschiedener Fischarten im Lager zählt und zurückgibt.

4. [task][Allergikuin]( 253348 )
Sofia Schnief ist eine liebenswürdige Pingudame, leider jedoch auch auf sehr viele Lebensmittel allergisch - so auch auf sämtliche Fischarten außer Forellen (Trouts). Daher inspiziert sie ihr Mittagessen (einen `Stream `) in `void consumeTrouts(Stream )` darauf, dass nur `TROUT`s enthalten sind (die anderen Fische nimmt sie nicht mit) und verzehrt die Forellen anschließend, wobei sie deren köstlichen Geschmack stets mit den Worten: `""Sofia fand TROUT mit Gewicht  kg sehr lecker!""` lobt.

5. [task][Schwersten Fisch finden]( 253354 , 253355 )
Für das Schaufenster möchte Knuth Koch jeden Tag den dicksten Fang aus der gekauften Lieferung vollautomatisiert zur Schau stellen. Bestimme mit `Optional  heaviestFish(Stream )` den schwersten Fisch im Stream.
Achtung: Sollte Knuth einmal keine Fische ankaufen (z.B. an einem Feiertag), so soll die Maschine dies durch die Rückgabe eines `Optional .empty()` bemerken, um nichts auf den Teller zu legen. Wenn du in dieser Teilaufgabe die richtige Stream-Funktion verwendest, geschieht das automatisch.

6. [task][Bodybuilduin]( 253361 )
Markus Muskel ist ein Bodybuilduin, der aufgrund seines strikten Ernährungsplans jeden Tag mindestens einen Thunfische (Tuna) essen muss. Um richtig Muskeln aufbauen zu können, muss zudem mindestens einer der Thunfische im Stream mindestens 2.0kg wiegen. Hilf ihm, seinen Einkauf darauf zu prüfen, ob ein solcher Thunfisch mindestens einmal enthalten ist. Nutze dafür `boolean hasHeavyTuna(Stream )`.

7. [task][Gesamtgewicht]( 253364 )
Da Markus Muskel als guttrainierter Pinguin durch sein hohes Muskelgewicht bereits einige Kilo auf die Waage bringt, möchte er vermeiden, dass sein beschauliches Iglu, das auf einer Eisscholle gebaut ist, durch das zusätzliche Gewicht seiner Fischeinkäufe einbricht. Implementiere `double totalFishWeight(Stream )`, womit Markus das Gesamtgewicht der Fische in seinem Iglu berechnen kann.

---

## 5. Parallelisierung von Streams

Streams können auch parallel verarbeitet werden, was bei großen Datenmengen für kürzere Laufzeiten sorgen kann (mehr dazu in den nächsten beiden Wochen). Sieh dir nun die Klasse StreamParallelizationExample an.

Bei den folgenden 3 Aufgaben müsst ihr keinen Code schreiben, sondern sollt stattdessen lokal mit den vorgegebenen Streams experimentieren und Unterschiede ermitteln. Es gibt auch keine Tests, da der Code bereits vorgegeben ist.

0. [task][Komplexe Berechnungen]()
Sieh dir in `StreamParallelizationExample` die Methode `int complexCalculation(int)` an. Diese wartet bei einem Aufruf zunächst 300ms und gibt anschließend das Doppelte der übergebenen Zahl zurück.

1. [task][Sequentielle Stream-Bearbeitung]()
Schau dir zunächst die Implementierung der Methode `streamExecutionSequential(Integer[])` an. Kommentiere in der `main`-Methode nun alle Methodenaufrufe außer `streamExecutionSequential(numbers);` aus und führe den Code aus. Was beobachtest du?

 
 Lösung 
  Die Ausführung dauert, verglichen mit den vorigen Teilaufgaben, erwartbar relativ lang. $$10$$ Elemente in  numbers  $$\times 300ms = 3000ms$$, d.h. etwas mehr als 3 Sekunden. 
 

2. [task][Parallele Stream-Bearbeitung I]()
Schau dir nun die Implementierung der Methode `streamExecutionParallel(Integer[])` an. Kommentiere anschließend in der `main`-Methode alle Methodenaufrufe außer `streamExecutionParallel(numbers)`; aus und führe den Code mehrmals aus. Was beobachtest du jetzt? Woran kann das liegen?

 
 Lösung 
  Die Ausführung geht nun deutlich schneller (circa 700ms - je nach Computer, definitiv aber unter 3 Sekunden). Allerdings sind die ausgegebenen Elemente nun nicht mehr in der gleichen Reihenfolge, wie sie in  numbers  in  main  vorgegeben werden. Die Reihenfolge unterscheidet sich zudem zwischen den Ausführungen.
  Das liegt daran, dass Java die einzelnen Elemente des Streams dank  .parallel()  nun parallel, also gleichzeitig verarbeiten kann. Je nachdem, wie die Elemente aufgeteilt werden und wie schnell die verschiedenen Prozesse sind, kann dabei die Ausgabereihenfolge variieren. 
 

3. [task][Parallele Stream-Bearbeitung II]()
Schau dir zuletzt die Implementierung der Methode `streamExecutionParallelKeepOrder(Integer[])` an. Kommentiere anschließend in der `main`-Methode alle Methodenaufrufe außer `streamExecutionParallelKeepOrder(numbers)`; aus und führe den Code mehrmals aus. Was beobachtest du? Woran kann das liegen?

 
 Lösung 
  Die Ausführungsdauer ist ähnlich schnell wie bei  streamExecutionParallel(Integer[]) , jedoch bleibt die Reihenfolge bei jeder Ausführung gleich. Dafür sorgt  .forEachOrdered() , was im Gegensatz zu  .forEach()  die ursprüngliche Reihenfolge der Elemente im Stream behält und nach der parallelen Ausführung von  complexCalculation()  wartet, bis dieselbe Reihenfolge wiederhergestellt werden kann. 
 

Öffne nun die Klasse `StreamParallelization`.

4. [task][Parallele Berechnungen]( 253341 )
Der mathematikinteressierte Sohn des Firmenchefs hat eine geniale Formel entwickelt, mit welcher er glaubt, die Haltbarkeit der Fische besser vorhersagen zu können. Er bittet dich, die rechenintensiven Operationen effizient in der Maschine zu implementieren. `double calculationOfWeights(Stream  fishStream, int limit)` soll aus dem gegebenen, unendlichen Stream die ersten limit Fische entnehmen und deren Gewichte nach folgender hoch wissenschaftlicher Formel verrechnen: $$\sum{(3 * (weight^4 + 1.5)^{0.7})}$$
Beachte, dass der Test zu dieser Aufgabe Limits bis zu $$5~000~000$$ überprüft.

---

Geschafft! Der Firmenchef ist mit deiner Arbeit vollstens zufrieden und zahlt dir deinen Lohn aus, mit welchem du dir gleich zwei Logenplätze für Harald Pingu und der eisige Wind leisten kannst. Jetzt musst du nur noch überlegen, welcher deiner Freunde dich in die Aufführung begleiten darf..."
404,Praktikum: Grundlagen der Programmierung WS24/25,15645,W10P03 - Chat,"# Chat

In dieser Aufgabe sollst du ein einfaches Chatprogramm mittels Sockets implementieren. Ergänze die Klasse Chat an den Stellen, die mit TODOs gekennzeichnet sind.

Die Kommunikation hat folgenden Ablauf:

1. Das Programm fragt den Nutzer nach einer Eingabe (bereits im Template). Diese Abfrage wird so lange wiederholt, bis eine Verbindung zustandekommt oder der Nutzer ""exit"" eingibt.
  1. Gibt der Nutzer etwas ein, was keinen "":"" enthält, wird die Eingabe als Port interpretiert und das Programm versucht, auf diesem Port einen ServerSocket zu starten und auf Verbindungen zu warten. Der Server erwartet genau eine Verbindung.
  2. Gibt der Nutzer etwas mit `:` ein, wird die Eingabe als "" : "" interpretiert und das Programm versucht, sich mit dem gegebenen Host am gegebenen Port zu verbinden.
2. Beide Teilnehmer tauschen Nachrichten aus. Der Server beginnt mit dem Senden. Das Programm wartet also abwechselnd auf Nachrichten vom Nutzer und vom Socket.
3. Einer der Teilnehmer gibt ""exit"" ein. Beide Programme beenden sich dadurch.

Behandle alle Exceptions geeignet. Gib möglichst genaue Meldungen aus und entscheide, ob du die Programmausführung trotz des Fehlers fortsetzen kannst oder nicht. Stelle sicher, dass beim Beenden des Programms alle Sockets, Writer und Reader ordnungsgemäß geschlossen wurden. Nutze dazu entweder `finally`-Blöcke oder [try-with-resource-statements](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html).

Teste dein Programm, indem du entweder mit dir selbst oder einem Kommilitonen chattest! Beachte, dass du nur Portnummern >1024 verwenden kannst. Beachte außerdem, dass du dein Programm häufig erst durch die Firewall freigeben musst. Falls deine Firewall auf Windows dich nicht automatisch beim Start des Programms fragt, ob es freigegeben werden soll, kannst du alternativ auch den Port deiner Wahl freigeben. [Hier](https://www.netzwelt.de/anleitung/181406-windows-10-firewall-so-oeffnet-ports.html) ist beschrieben, wie. Beachte, dass solche Portfreigaben am besten nach Abschluss der Nutzung wieder gelöscht werden sollten, andernfalls kann es zu unerwünschten Effekten kommen, solltest du je ein Programm starten, dass zufälligerweise den gleichen Port nutzt (das ist dann nämlich plötzlich unerwarteterweise vom Netzwerk aus zugreifbar).

- Um mit sich selbst zu chatten, starte erst ein Programm als Server und verbinde dich dann mit einem zweiten Programm damit. Dein lokaler Host heißt `localhost`. (z.B. `localhost:5000` wenn der Server auf dem Port `5000` läuft.
- Um mit deinen Kommilitonen zu chatten ist es nötig, dass sich beide Rechner im gleichen Netz befinden. Statt das gleiche WLAN zu verwenden, kannst du dies erreichen, indem du das VPN des lrz verwendest. Dieses wird typischerweise im Vorkurs installiert, falls du es noch nicht hast ist die Installation [hier](https://doku.lrz.de/vpn-10333177.html) beschrieben. Sobald beide Chatpartner mit dem VPN verbunden sind, muss einer von beiden die eigene IP-Adresse herausfinden (z.B. durch den Befehl `ipconfig` (oder `ifconfig`, je nach Betriebssystem) im Terminal) und den Server auf einem beliebigen Port starten. Der/Die andere kann sich dann mit dieser IP als Host verbinden."
404,Praktikum: Grundlagen der Programmierung WS24/25,15646,W10H01 - Pinguin Ausflug,"# W10H01 - Pinguin Ausflug

Es wird endlich wieder Sommer in der Antarktis und die Pinguine der Familie Fluss können ihren ersten Ausflug nach dem langen Winter kaum noch erwarten. Damit auch alles glattgeht und der Ausflug zu einem vollen Erfolg wird, brauchen sie aber Deine Hilfe! Sie würden ihren Ausflug nämlich gerne analysieren, bevor sie aufbrechen. Da sie gelesen haben, dass sich Streams dafür sehr gut eignen, würden sie diese These gerne von Dir testen lassen.

## Streams

Diese Aufgabe dient dazu Javas Streams kennenzulernen, daher sind alle konventionellen Kontrollstrukturen verboten, dazu gehören: `for (;;)`-, `for (:)`- und (`do`-)`while` Schleifen, `if-else`-Statements, der Ternary Operator, die Methode `.forEach()` auf `Stream` und `List` sowie Rekursion. Diese Einschränkungen werden in einem public Test automatisch überprüft. Sollte es Probleme damit geben, würden wir uns auf Zulip über Feedback freuen.

Hinweise/Tipps:

Wenn Ihr bei einer Teilaufgabe nicht weiter kommt, hilft oft ein Blick in die [Stream API](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html). Alle Aufgaben lassen sich in wenigen Zeilen Code (bzw. mit wenigen Methodenaufrufen auf einem Stream) lösen. Oft reduziert sich die Schwierigkeit nur darauf, die richtige Stream-Methode zu finden. Beachtet auch, dass es neben generischen Streams auch spezielle Implementationen, u. a. [IntStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/IntStream.html), [LongStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/LongStream.html) und [DoubleStream](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/DoubleStream.html) gibt, welche besondere Funktionen (wie z.B. `sum()` oder `average()`) bereitstellen.

[task][Keine verbotenen Konstrukte verwendet]( 253421 )

## Gegebene Klassen

Euch sind bereits die Klassen `WayPoint` und `OneWay` gegeben. Diese enthalten einige Methoden für geometrische Berechnungen, Umwandlung von Strings zu Objekten und Ausgabe. Schaut euch die Klassen gut an und verwendet die gegebenen Methoden nach Möglichkeit.

## Aufgabe

Vervollständige nun die Methoden in der Klasse `PinguTrip` wie im Folgenden beschrieben!

### 1. Route einlesen

Die Pinguine haben sich schon den ganzen Winter lang Gedanken gemacht, wo sie denn bei ihrem ersten Ausflug überall hin möchten. Da sie aber erst im Oktober angefangen haben zu programmieren, stehen ihre ganzen Notizen noch in einer .txt Datei und sie hätten gerne eine Methode `readWayPoints`, welche ihre Wegpunkte einliest und in `WayPoint` Objekte umwandelt, damit sie die Notizen besser analysieren können.

Die Methode soll den Pfad zu den Notizen als String bekommen und einen Stream, welcher die `WayPoint` Objekte beinhaltet, zurückgeben. Jede Zeile in der Notiz ist dabei genau in einem von drei Formaten:

1. Eine Koordinate `x;y`. Diese soll in einen `WayPoint` umgewandelt werden. x und y stehen hierbei für beliebige doubles als String.
2. Ein Kommentar `// …`. Startend mit zwei Schrägstrichen und gefolgt von einer beliebigen Zeichenfolge. Kommentare sollen ignoriert werden.
3. Ein Schlussstrich `---`. Als die Pinguine gemerkt haben, dass ihre Route schon viel zu lang ist haben sie einen Schlussstrich gezogen. Alles, was danach kommt, soll nicht mehr behandelt werden.

Alle anderen Fälle, wie etwa eine Zeile die nicht in einem der drei Formate ist, werden nicht getestet und müssen nicht behandelt werden.

Sollte beim Einlesen ein Fehler auftreten, soll ein leerer Stream zurückgegeben werden.

 
 Beispiel 
  Eine Datei mit folgendem Inhalt: 
  
```text 
4.0;11.5
// comment 
19.1;3.2
---
9.11;1.1
```

soll umgewandelt werden in:

```java
Stream.of(new WayPoint(4.0, 11.5), new WayPoint(19.1, 3.2));
```

 

[task][Public Tests]( 253420 , 253412 )
[task][Hidden Tests]( 253394 , 253392 )

### 2. Wegpunkte zu Wegen wandeln

Da nur die Wegpunkte zu haben manchmal sehr umständlich sein kann, wollen die Pinguine ihre Wegpunkte nun in Wege - repäsentiert duch `OneWay` Objekte - umwandeln. Dafür sollen in der Methode `transformToWays` die Elemente einer Liste von Wegpunkten verbunden werden und zwar so, dass immer der i-te mit dem i+1-ten Wegpunkt zu einem Weg wird. Die Methode wird nur mit Streams, welche mindestens zwei Wegpunkte enthalten, getestet. Leere Streams oder Streams mit nur einem Element müssen nicht behandelt werden.

*Tipp:* Der Weg wird hier aus einem Grund als eine Liste und nicht wie in den anderen Methoden als ein Stream übergeben. Mit `waysPoints.stream()` zu beginnen, ist also vermutlich nicht der richtige Weg. Überlege dir stattdessen, mit was für einem Stream du deine Berechnungen beginnen willst. Die Methode `IntStream.range()` könnte hilfreich sein.

 
 Beispiel 

```java
List.of(new WayPoint(4.0, 11.5), new WayPoint(19.1, 3.2), new WayPoint(2.1, 7.4));
```

Soll umgewandelt werden in:

```java
Stream.of(new OneWay(new WayPoint(4.0, 11.5), new WayPoint(19.1, 3.2)), new OneWay(new WayPoint(19.1, 3.2), new WayPoint(2.1, 7.4)))
```
 

[task][Public Tests]( 253418 )
[task][Hidden Tests]( 253391 )

### 3. Länge des Weges

Die Pinguine wollen wissen, wie lang ihr Weg überhaupt ist. Dafür soll die Länge der gesamte Strecke in der Methode pathLength berechnet werden.

 
 Beispiel 

```java 
Stream.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0))); 
``` 
Sollte dementsprechend `1.0` zurück geben. 
 

[task][Public Tests]( 253393 )
[task][Hidden Tests]( 253419 )

### 4. Kinderausflug

In der großen Pinguin-Familie sind auch Küken, welche nicht so weite Strecken laufen können. Daher sollen in der Methode `kidFriendlyTrip` ein Ausflug erstellt werden, der auch für die kleinen Pinguine geeignet ist. Dafür sollen vom Start aus die Wege genommen werden, welche nicht länger als die durchschnittliche Weglänge in der gesamten Route sind. Sobald der erste Weg länger ist, soll der Kinderausflug beendet werden und keine weiteren Wege mehr enthalten (exklusive dem Weg, welcher länger als der Durchschnitt war).

*Hinweis:* Dass hier wieder Listen statt Streams übergeben und zurückgegeben werden, hat ebenfalls seine Gründe. Hier musst du dir darüber allerdings nicht allzu viele Gedanken machen. `oneWays.stream()` zu verwenden ist hier eine gute Idee.

 
 Beispiel 

```java 
List.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0)), new OneWay(new WayPoint(1.0, 0.0), new WayPoint(3.0, 0.0)), new OneWay(new WayPoint(3.0, 0.0), new WayPoint(4.0, 0.0))); 
``` 

soll zu folgender Liste umgewandelt werden, da die durchschnittliche Länge $$(1 + 2 + 1) / 3 = 1.33..$$ ist, und der zweite Weg mit $$2 > 1.33$$ länger als der Durschnitt ist und somit ab diesem Punkt keine weiteren Wege mehr mit aufgenommen werden. 

```java 
List.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0))); 
```

 

[task][Public Tests]( 253410 )
[task][Hidden Tests]( 253414 )

### 5. Maximale Entfernung nach Hause

Damit sie ihren Ausflug auch gut spontan abbrechen können, wollen die Pinguine in der Methode `furthestAwayFromHome` gerne berechnet haben bei welchem Wegpunkt sie sich am weitesten von Zuhause entfernen. Wenn es keinen Wegpunkt gibt, soll der Wegpunkt ihres Zuhauses zurückgegeben werden. Sollten mehrere Wegpunkte gleich weit entfernt sein, kann von diesen ein Beliebiger zurückgegeben werden.

 
 Beispiel 

```java 
Stream path = Stream.of(new WayPoint(1.0, 0.0), new WayPoint(2.0, 0.0)); 
WayPoint home = new WayPoint(0.0, 0.0);
``` 
soll folgenden Wegpunkt wieder geben: 
```java 
new WayPoint(2.0, 0.0);
```

 

[task][Public Tests]( 253411 )
[task][Hidden Tests]( 253416 )

### 6. Freunde besuchen

Die Pinguine haben im Winter viele ihrer Freunde nicht gesehen und würden diese gerne besuchen. Dies ist aber nur sinnvoll, wenn ihre Freunde auf dem Weg ihrer Route leben. Gegeben ist eine Route und der Wegpunkt eines Freundes, die Methode `onTheWay` soll berechnen, ob ihr Freund auf dem geplanten Weg liegt.

 
 Beispiel 

```java 
Stream.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0))); 
WayPoint visit = new WayPoint(0.5, 0.0); 
``` 
Soll `true` wieder geben.

 

[task][Public Tests]( 253417 )
[task][Hidden Tests]( 253395 )

### 7. Schöne Richtungsangaben

Nachdem ihr Ausflug nun hinreichend analysiert wurde, wollen sich die Pinguine auf den Weg machen. Da der Mobilfunk-Ausbau in der Antarktis aber leider genau so schleppend voran geht wie in Deutschland, wollen sie sich ihre Wegbeschreibung ausdrucken. Dafür muss sie aber erstmal in der Methode `prettyDirections` in ein hübsches und lesbares Format umgewandelt werden. **Jeder** Weg soll in eine Zeile in folgendem Format gewandelt werden:  ⎵Schritte⎵Richtung⎵ ⎵Grad., (die Methode `prettyPrint` übernimmt diese Umwandlung bereits für euch).

 
 Beispiel 

```java 
Stream.of(new OneWay(new WayPoint(0.0, 0.0), new WayPoint(1.0, 0.0)), new OneWay(new WayPoint(1.0, 0.0), new WayPoint(3.0, 0.0)), new OneWay(new WayPoint(3.0, 0.0), new WayPoint(4.0, 1.0))); 
``` 
Soll folgenden String zurück geben. 
```text 
1 Schritte Richtung 0 Grad.
3 Schritte Richtung 0 Grad. 
2 Schritte Richtung 45 Grad. 
``` 

 

[task][Public Tests]( 253396 )
[task][Hidden Tests]( 253415 )

## FAQ

**Null Elemente:** Ihr könnt davon ausgehen, dass alle Attribute von WayPoint und OneWay sowie die Parameter der Methoden immer ungleich `null` sind."
404,Praktikum: Grundlagen der Programmierung WS24/25,15657,W10H02 - Pingu Indexing,"# Pingu Indexing Tool (PIT)

## Overview

Ziel der Aufgabe ist es, die verschiedenen Interaktionen mit dem Dateisystem kennen zu lernen. 

## Story

Die Pinguine der PUM haben festgestellt, dass es sehr schwierig ist, verschiedene Versionen ihrer Programme zu speichern. 
Sie möchten, dass du ihnen hilfst, ein System zu entwickeln, um mehrere Versionen einer Datei zu speichern.

### [task][HistoryEntry]( 253718 )

Die Klasse `HistoryEntry` enthält Felder für Hashes von vorhergegangenen (`prevHash`) und nachfolgenden (`nextHash`) `HistoryEntries`. 
Diese können `null` sein, falls keine solche Dokumente existieren.

Das Feld `content` enthält den Dateiinhalt der Version, die der `HistoryEntry` beschreiben soll.
Das `pitDirectory` ist das Verzeichnis in welchem sich alle PIT Dokumente (also nicht die des Nutzers) befinden.

Implementiere Getter und Setter für alle gegebenen Felder. Implementiere zudem Getter für einen nächsten (`getNext()`) bzw. vorhergegangenen (`getPrev()`) `HistoryEntry` (s. `HistoryEntryRepository`).
Hint: Wenn der Test mit ""not yet implemented"" failen sollte - schaut euch load an

## Das Interface

Wir werden nun einen Blick auf das Interface werfen, über welches wir mit dem PIT interagieren.
Um die verschieden Versionen persistent speichern zu können, müssen wir sie selbst in irgendeiner Form im Dateisystem speichern.
Wir verwenden dafür folgende Dateistruktur:
```text
rootDir
|-.pit
 |-pit_index.json
```

Das Verzeichnis `rootDir` ist das Verzeichnis, dessen Inhalt wir überwachen wollen. 
`.pit` ist das Verzeichnis in dem wir alle für uns relevanten Daten speichern.
In der `pit_index.json` speichern wir eine Referenz auf die neuste uns bekannte Version eines Dokumentes.

Da wir hier mit einer JSON Datei arbeiten werden, empfiehlt sich ein Blick auf die [Dokumentation von org.json](http://stleary.github.io/JSON-java/index.html).

[task][Initialisieren]( 253716 )

Wenn ein Nutzer die Änderungen in einem Verzeichnis überwachen möchte, ruft er die Funktion `init(Path)` mit dem entsprechenden Verzeichnis als Parameter auf. 

Ergänze die Funktion, sodass die oben beschriebene Verzeichnisstruktur erstellt wird. 
Bedenke, dass `pit_index.json` immer eine valide JSON Datei sein sollte.

[task][Neue Dateien]( 253713 , 253710 , 253717 )

Da man nicht immer einen Überblick hat, welche Dateien schon dem PIT hinzugefügt wurden, oder aktuell sind, möchten wir dem Nutzer dabei helfen.

Die Funktion `listNewFiles(Path)` bekommt das oberste Verzeichnis übergeben und gibt einen Stream an `Path`s zurück.
Eine Datei ist neu, wenn sie nicht in der `pit_index.json` als Schlüssel vorkommt. 
Die Dateien des `.pit` Verzeichnisses und die Verzeichnisse im Allgemeinen sollen in diesem Stream nicht vorkommen.

Um die so gefundenen Dateien hinzuzufügen,stellen wir die Methode `addFile(Path, Path)` zur Verfügung. 
Diese nimmt das oberste Verzeichnis, sowie einen Pfad zur entsprechenden Datei entgegen.
Für die Datei wird ein neuer `HistoryEntry` mit entsprechendem Inhalt erstellt und abgespeichert (s. `HistoryEntryRepository`). 
Der `pit_index.json` Datei wird ein neuer Eintrag hinzugefügt. Dieser enthält den Dateipfad der Datei relativ zum obersten Verzeichnis, wir betrachten den Pfad als Schlüssel und den `hashCode()` des Dateiinhalts als Hexstring als Wert.

[task][Geänderte Dateien]( 253714 , 253709 , 253715 )

Die Funktion `listChangedFiles(Path)` funktioniert analog zur Funktion `listNewFiles(Path)`. 
Hier sollen jedoch nur Dateien zurückgegeben werden, welche bekannt sind aber verändert wurden. 
Eine Datei gilt als verändert, wenn der `hashCode()` des Inhalts nicht mit dem gespeicherten übereinstimmt.

Um die Änderungen einer Datei auch in das PIT zu übernehmen, gibt es die Funktion `commitFile(Path, Path)`. 
Diese nimmt wie auch `addFile` das oberste Verzeichnis und den Pfad zur Datei als Paramteter entgegen. 
Es soll ein neuer `HistoryEntry` für die aktuelle Version der Datei erstellt werden. 
Sowohl der neue Eintrag, als auch der Eintrag der zuletzt bekannten Version werden um Referenzen aufeinander ergänzt und abgespeichert.
Zu guter Letzt, wird der Hash in `pit_index.json` auf den des neuen Eintrags aktualisiert.

## Einträge persistent machen

Da die Versionierung des PIT System Neustarts überstehen können soll, müssen alle Daten im Dateisystem abgespeichert werden.
Dafür haben wir mit der `init` Funktion bereits die Grundlagen gelegt. 
Nun benötigen wir einen Weg `HistoryEntry`s systematisch im Dateisystem abzulegen.

[task][Einträge speichern]( 253711 )

Die Funktion `store(Path, HistoryEntry)` nimmt den Pfad des `.pit` Verzeichnises und den zu speichernden `HistoryEntry` entgegen, um ihn zu speichern.
Dazu wandeln wir zu allererst den `hashCode()` des`content`s in einen Hexstring um. 
Nun wird der Hexstring um eine führende Null erweitert, falls er eine ungerade Länge hat, und in 2er Blocks aufgeteilt.
Der Pfad zu unserer Datei wird nun aus den Blöcken konstruiert, in dem man sie als Verzeichnisse rückwärts aneinanderhängt.
Dabei ist der jetzt letzte Block der Dateiname.

 
 Beispiel 

Der Hash `81985529216486895` wird zum Hexstring `123456789abcdef`

Dieser wird aufgeteilt zu: `01`,`23`,`45`,`67`,`89`,`ab`,`cd`,`ef`.

Diese Blöcke setzen sich zu dem Pfad `ef/cd/ab/89/67/45/23/01` zusammen.
Hier sind `ef/cd/ab/89/67/45/23` Verzeichnisse und `01` ist die Datei in der der `HistoryEntry` gespeichert wird.
 

Das Dateiformat ist recht einfach. In der ersten Zeile sollen die Hashes vorhergehender oder nachfolgender Einträge stehen. 
Dabei steht der Hash eines Vorgängers, wenn es keinen Nachfolger gibt als Hexstring in der ersten Zeile.
Falls es einen Nachfolger gibt, wird dieser(auch als Hexstring) mittels eines Doppelpunktes `:` vom Vorgänger getrennt. 
Sollte es einen Nachfolger aber keinen Vorgänger geben, ist der Hexstring des Vorgängers """".

Anschließend kommt der Inhalt des Eintrags ohne weitere Zeichen.

```text
prevHash:nextHash
content
```

[task][Einträge lesen]( 253712 )

Die Funktion `load(Path, int)` lädt die wie oben gespeicherten Einträge wieder aus dem Dateisystem.
Dafür bekommt sie den Pfad zum `.pit` Verzeichnis und den Hash des zu ladenden `HistoryEntry`s. 
Entsprechend der oben beschrieben Methode wird zuerst der Dateipfad des Eintrags aus dem Hash konstruiert.
Anschließend kann der Eintrag entsprechend des beschriebenen Dateiformats rekonstruiert werden."
404,Praktikum: Grundlagen der Programmierung WS24/25,15739,W11H01 - Work Life Balance of Threaduins,"# Work Life Balance of Threaduins

Die Studenten der PUM sind bunt gemischt: Von überengagierten Pinguinen bishin zu Schlafmützen findet man alles. Als ausgewogener Pinguin-Freund machst du dir natürlich Sorgen um deine Kommilitonen. Nutze deine Thread-Kenntnisse, um Balance in ihren Alltag in zu bringen!


## Aufgabe
- *Hinweis 1:* Alle benötigten Ausgabe-Texte sind als Strings in der Threaduins-Klasse definiert. Beispiel: `Threaduins.STOP_MSG`  
- *Hinweis 2:* Du kannst bei allen Methoden davon ausgehen, dass dir keine `null`-Values übergeben werden. Du erhältst also nur echte `Thread`s oder `PrintStream`s, die voll funktional sind. In anderen Worten: Mach dir keine Gedanken über Edge Cases. 🐧  
- *Hinweis 3:* Zum Testen eignet sich das vorgegebene `ConsoleSignal` nicht. Daher enthält das Template die Methode `setSignal`, mit der du eigene Implementierungen verwenden kannst. Achte darauf, dass die Methode wirklich nur zum Testen verwendet wird.  

1. [task][Workaholic Penguin]( 256067 )
Ein Workaholic Pinguin ist ein `Thread`, der kontinuierlich Arbeitsnachrichten ausgibt, bis er durch einen Interrupt gestoppt wird.  
Implementiere die Methode `getWorkaholic(PrintStream)`, deren Thread beim Start die Aufgaben des Workaholics durchführt: Dieser soll ständig die Nachricht `WORKAHOLIC_WORKING_MSG` an den spezifizierten PrintStream senden. Jede Nachricht soll dabei in einer neuen Zeile stehen, benutze also am besten `PrintStream#println(String)`.  
Wird der Pinguin bei seiner Arbeit gestört, soll er einmalig die Nachricht `WORKAHOLIC_STOP_MSG` an den PrintStream senden und anschließend seine Arbeit niederlegen.


2. [task][Save a Workaholic]( 256065 )
Implementiere die Methode `stopWorkaholic(Thread)`, die einen Workaholic-Pinguin kontrolliert beendet. Die Methode soll den gegebenen Thread zunächst starten und `STOP_MSG` ausgegeben. Anschließend wartet die Methode mittels der vorgegebenen statischen Variable signal und deren await()-Methode auf eine Eingabe. Sobald diese erfolgt ist, soll der Workaholic-Thread durch interrupt() unterbrochen werden. Achte darauf, dass der Thread seine Arbeit beendet hat, bevor du die Nachricht `STOPPED_MSG` in der Konsole ausgibst.    
Zum Testen der Implementierung kannst du die vorbereitete main-Methode verwenden, bei der eine beliebige Konsoleneingabe als Signal dient.

3. [task][Procrastinating Penguin]( 256058 )
Ein prokrastinierender Pinguin ist ein Thread, der die Kunst des Aufschiebens perfektioniert hat! Erst wenn seine Freunde ihn an die Deadline erinnern, rafft er sich zur Arbeit auf.   Implementiere die Methode `getLuckyProcrastinator(PrintStream)`, die einen prokrastinierenden Pinguin zurückgibt. Dieser sendet an den spezifizierten PrintStream einmalig die Nachricht `PROCRASTINATOR_PROCRASTINATING_MSG`, sobald er mit dem Prokrastinieren beginnt. Ab dann wartet er unbegrenzt, bis ein lieber Freund ihn mit `notify` an die Deadline der PGdP-Hausaufgaben erinnert. Obwohl er es eigentlich besser wissen sollte, ist er natürlich über die Deadline überrascht und sendet, nachdem sein Warten durch die Benachrichtigung beendet wurde, die Nachricht `LUCKY_PROCRASTINATOR_WORKING_MSG` über `PrintStream#println(String)`.

4. [task][Friend of a Procrastinator]( 256070 )
Implementiere die Methode `stopProcrastinator(Thread)`. Die Methode soll den gegebenen Thread zunächst starten. In der Konsole soll nun die Nachricht `STOP_MSG` ausgegeben und, wie beim Workaholic mit `Signal#await` gewartet werden. Sobald du das Signal erhalten hast, soll der Pinguin durch `notify()` an die nahende Deadline erinnert werden. Achte darauf, dass der Pinguin seine Reaktion auf die Erinnerung (`LUCKY_PROCRASTINATOR_WORKING_MSG`) ausgeben konnte, bevor du die Nachricht `STOPPED_MSG` in der Konsole ausgibst. Hinweis: Im Gegensatz zum Workaholic soll der Pinguin nicht durch `interrupt()` gestoppt, sondern nur durch `notify()` benachrichtigt werden.


## Tests

[task][Tests]( 256071 , 256064 , 256061 , 256072 , 256069 , 256060 , 256050 , 256074 , 256056 , 256062 , 256068 , 256066 , 256046 , 256073 ) Testet deine Abgabe.

Viel Erfolg!"
404,Praktikum: Grundlagen der Programmierung WS24/25,15740,W11P01 - Parallele Summierung,"# Parallele Summierung

In dieser Aufgabe sollst du ein gegebenes Integer-Array summieren. Easy, das ist ja Stoff von Woche 05! Nicht so schnell. Diesmal wird der entsprechenden Methode noch ein zweiter Parameter `threadCount` übergeben. Die Summierung soll dann in genau so viele Threads parallel ausgeführt werden, um die vorhandene Rechenpower besser auszunutzen.

## Aufgaben

### 1. Die Klasse `ParallelSummer`
Vervollständige zuerst die Klasse `ParallelSummer`. Diese soll einen Thread repräsentieren, der das als Attribut gespeicherte `array` von Index `lowerBound` (inklusive) zu Index `upperBound` (exklusive) summiert und das Ergebnis in seinem Attribut `result` speichert, sobald er ausgeführt wird (keine Prüfung, ob die Bounds auch innerhalb der Array-Grenzen liegen, nötig!).

### 2. Die Methode `sumParallel`
Vervollständige nun im Template noch die Methode `sumParallel`. Diese soll die Summation des übergebenen Arrays auf `threadCount` Threads (genauer: `ParallelSummer`s) verteilen, die alle einen (etwa) gleichgroßen Teil des Arrays summieren sollen. Danach soll die Methode die einzelnen Zwischenergebnisse alle zu einem Endergebnis aufsummieren und dieses zurückgeben.

### 3. Den Code Ausführen
Teste nun mithilfe des Codes in der im Template vorgegebenen `main()`-Methode deine Implementierung. Die `main()`-Methode summiert mittels `sumParallel` ein Array mit einer Milliarde einträgen und misst die dabei verstrichene Zeit (mithilfe der Methode [`System.currentTimeMillis()`](https://currentmillis.com/tutorials/system-currentTimeMillis.html)). Verändere nun die Anzahl an verwendeten Threads und beobachte, wie sich die Rechenzeit dabei verändert. Versuche dabei herauszufinden

1. ob du ""korrekt"" parallelisierst, also ob mit mehreren Threads die Berechnung tatsächlich schneller ist, als mit nur einem (wenn du z.B. die Threads nacheinander laufen lässt, also wartest, bis ein Thread zu Ende gelaufen ist, ehe du den nächsten startest, wird es logischerweise keinerlei Zeitersparnis geben) und
2. mit wie vielen Threads die Berechnung am schnellsten ist. 

Stelle den `threadCount` auch auf `10_000` und beobachte nun die benötigte Rechenzeit. Wie erklärst du dir das?

[task][Test, ob Summierung korrekt funktioniert]( 256083 )
Dieser Test prüft nur, ob die Summe korrekt berechnet wird und zwar unabhängig vom `threadCount`. Ob auch ""sinnvoll"" parallelisiert wurde (als z.B. nicht einfach alle Threads hintereinander ausgeführt werden, ohne dass je Berechnungen parallel stattfinden) musst du selbst überprüfen, indem du die Zeit misst, die deine Implementierung mit einem vs. mit mehreren Threads für die Berechnung der Summe benötigt."
404,Praktikum: Grundlagen der Programmierung WS24/25,15741,W11P02 - Geschaeftspartner,"# Geschäftspartner

Das Geschäft mit Essen für Pinguine brummt. Die beiden `BusinessPenguins` Peter und Paul haben schon bemerkt, dass sie alleine keine Chance haben werden, sich in diesem stark umkämpften Markt zu behaupten. Daher haben sie beschlossen, im Fischhandel zusammenzuarbeiten, indem jeder die Hälfte seines Einkommens durch Fischverkäufe dem anderen gibt. Da die beiden aber keine Ahnung von Informatik haben brauchen sie deine Hilfe bei der Umsetzung.

## Aufgaben

Das Template dieser Aufgabe enthält drei Packages

- `pgdp.threads.start`,
- `pgdp.threads.race` und
- `pgdp.threads.dead`.

Das zweite Package enthält dabei die Lösung der ersten Aufgabe und das dritte die der zweiten. Sieh dir die unteren beiden Packages also jeweils erst dann an, wenn du in der Aufgabe weit genug bist.


### Aufgabe 1: Parallelly Purchasing Penguins

**Package:** `pgdp.threads.start`

Ergänze die Methode `sellFish` in `BusinessPenguin`, die jeweils dem Pinguin selbst und seinem Partner den halben Preis auf seine `balance` gutschreibt (`+=`). Du kannst davon ausgehen, dass der Preis gerade ist.

Jeder der beiden Pinguine hat nun einen Stammkunden, der bei ihm einkauft. Beide Kunden kaufen parallel ein. Ergänze die Klasse `Customer` so, dass jede `Customer`-Instanz nebenläufig arbeitet. Die Kunden kaufen jeweils 5000 Fische für je 2PD (Pingu-Dollar) ein. Füge `Customer` eine entsprechende `run`-Methode hinzu.

Vervollständige zuletzt die `main`-Methode in `Main`, sodass sie den Pinguinen jeweils einen Stammkunden zuordnet, diese einkaufen lässt und, sobald beide Kunden fertig sind, ausgibt, wie viel Geld die beiden Pinguine jeweils besitzen.

Führe das Programm mehrmals aus und überlege, wie es zu diesem Ergebnis kommen konnte.

Der (noch problematische) Lösungsvorschlag zu diesem Teil ist im Package `pgdp.threads.race` zu finden.

[task][Tests]( 256109 , 256104 )
*Hinweis:* Die Tests testen nur, ob die `sellFish`- und die `run`-Methode in einem nicht-parallelen Setting korrekt funktionieren. Daher passen sie im Falle von Aufgaben 2 und 3 auch direkt und stellen nur einen Indikator dafür, dass du nichts an der Funktionalität beim Synchronisieren/Probleme Beheben kaputt gemacht hast. Diskutiere, warum Testen auf Synchronisation nie perfekt möglich sein wird.

### Aufgabe 2: Racing to the Banks

**Package:** `pgdp.threads.race`

Überlege, wie du die in Aufgabe 1 entstandenen Probleme lösen kannst. Passe dazu die Beispiellösung von Aufgabe 1 im Package `pgdp.threads.race` entsprechend an.

*Hinweis:* Nutze das Schlüsselwort `synchronized`.

Je nachdem, wie genau du die Aufgabe gelöst hast, kann nun entweder alles so funktionieren, wie gewünscht, oder es ist ein neues Problem aufgetreten.

[task][Tests]( 256090 , 256094 )
*Hinweis:* Die Tests testen nur, ob die `sellFish`- und die `run`-Methode in einem nicht-parallelen Setting korrekt funktionieren. Daher passen sie im Falle von Aufgaben 2 und 3 auch direkt und stellen nur einen Indikator dafür, dass du nichts an der Funktionalität beim Synchronisieren/Probleme Beheben kaputt gemacht hast. Diskutiere, warum Testen auf Synchronisation nie perfekt möglich sein wird.

### Aufgabe 3: Waiting for the Other's Play

**Package:** `pgdp.threads.dead`

In `pgdp.threads.dead` findest du eine Implementierung, die versucht, das Problem aus Aufgabe 1 durch Synchronisation zu lösen. Betrachte den Code und bestimme erstmal nach Augenmaß, ob du denkst, dass die Implementierung korrekt ist.

Führe anschließend das Programm mehrfach aus, um deine These zu prüfen. Falls das Programm fehlerhaft ist, korrigiere es. Der Lösungsvorschlag zu diesem Teil ist in der Musterlösung dann im dortigen Package `pgdp.threads.dead` zu finden.

[task][Tests]( 256100 , 256093 )
*Hinweis:* Die Tests testen nur, ob die `sellFish`- und die `run`-Methode in einem nicht-parallelen Setting korrekt funktionieren. Daher passen sie im Falle von Aufgaben 2 und 3 auch direkt und stellen nur einen Indikator dafür, dass du nichts an der Funktionalität beim Synchronisieren/Probleme Beheben kaputt gemacht hast. Diskutiere, warum Testen auf Synchronisation nie perfekt möglich sein wird.



## Freiwillige Übung

**Freiwillig**: Zur weiteren Übung zum Thema Race-Conditions und Deadlocks gibt es z.B. folgendes [Spiel](https://deadlockempire.github.io/), in dem es deine Aufgabe ist, derartige Schwächen in Programmen zu finden und auszunutzen. Beachte, dass dort nicht Java verwendet wird und sich die Syntax daher ein bisschen unterscheidet."
404,Praktikum: Grundlagen der Programmierung WS24/25,15742,W11P03 - Klausurkorrektur,"# Klausurkorrektur

Um eine möglichst gerechte und schnelle Korrektur der anstehenden Klausur zu gewährleisten, werden wir dies hier simulieren. Dafür wurden bereits die Klassen `Exam` und `CorrectionScheme` sowie diverse Hilfsmethoden fertig implementiert.

Der Ablauf der Korrektur ist wie folgt:

@startuml

hide circle
hide members

package InitialerBuffer < > {
}
class ""Korrektur Aufg. 1"" as k1
package Buffer1 < > {
}
class ""Korrektur Aufg. 2"" as k2
package Buffer2 < > {
}
class ""  ...  "" as k3
package Buffer7 < > {
}
class ""Korrektur Aufg. 8"" as k8
package FinalerBuffer < > {
}
class ""Zusammenrechnen und Eintragen"" as k9

InitialerBuffer --> k1
k1 --> Buffer1
Buffer1 --> k2
k2 --> Buffer2
Buffer2 --> k3
k3 --> Buffer7
Buffer7 --> k8
k8 --> InitialerBuffer : Zweitkorrektur
k8 --> FinalerBuffer : Korrektur abgeschlossen
FinalerBuffer --> k9

@enduml

Insgesamt sollen 1900 Klausuren korrigiert werden. Dabei haben der initiale und finale Buffer Größe 1900 und alle dazwischenliegenden je Größe 50. Jedem der 32 Tutoren wird nun eine Aufgabe zugewiesen. Danach beginnen sie nebenläufig, Klausuren aus dem Buffer vor der jeweiligen Korrektur zu entnehmen, die jeweilige Aufgabe zu bewerten und die Klausur danach im dahinterliegenden Buffer abzulegen. Dazu gibt es bereits die Methode `correctExam` im Template, die die Punkte entsprechend einträgt und zurückgibt, ob die Klausur vollständig korrigiert wurde. Eine fertig korrigierte Klausur wird dann in den finalen Buffer abgelegt. Das Zusammenrechnen und Eintragen wird vom main-Thread übernommen.

Erledige nun folgende Teilaufgaben:
- Beginne damit, die Klasse `Buffer` zu vervollständigen, sodass diese Thread-safe arbeiten, also weder zu Deadlocks noch Race Conditions führen. Die Größe des Buffers wird im Konstruktor übergeben.
Dabei soll der `Buffer` wie eine Queue funktionieren, also die erste Klausur, die von einem Tutor des vorigen Teams in den Buffer gelegt wurde, soll auch die erste sein, die der Tutor aus hiesigem Team dann entnimmt und weiterkorrigiert. Essentiell ist `Buffer` nichts anderes, als ein Ring-Buffer (siehe W06H03) mit Synchronisation (du kannst ihn auch anders implementieren, aber ein RingBuffer bietet sich an).
Zur  Synchronisation könnte die Klasse [Semaphore](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/Semaphore.html) hilfreich sein.  
*Falls du unsicher bist, wie du dies lösen kannst, schaue nochmal in die Vorlesungsfolien.*
- Ergänze anschließend die Klasse `Tutor`. Tutoren nehmen eine Klausur aus ihrem `in`-Buffer, führen ihre wie oben beschriebene Aufgabe aus und legen sie dann in ihren `out`- oder den `finished`-Buffer. Sollte `in` leer oder `out`/`finished` voll sein, wartet der Tutor, bis der Engpass behoben ist. Die Methode `correctExam()` in `Tutor` gibt dabei genau dann `true` zurück, wenn die übergebene `Exam` mit diesem Aufruf fertig korrigiert wird, d.h. wenn dies eine Zweitkorrektur der Aufgabe 8 ist. In dem Fall sollte die Klausur dann natürlich nicht auf den `out`-Stapel, sondern den `finished`-Stapel gelegt werden.
- Vervollständige die `main`-Methode in `ExamCorrection`. Die Methode erstellt bereits alle Buffer und die zugehörigen Tasks. Deine Aufgabe ist nun, 32 Tutor-Threads mit den gegebenen Tasks zu starten (je 4 pro Aufgabe) und anschließend mit dem main-Thread Klausuren aus dem finalen Buffer zu entnehmen und zu bearbeiten (dazu gibt es die Hilfsmethode `finalizeExam`). Sobald alle Klausuren abgeschlossen wurden, sollen alle Threads beendet werden und `""Korrektur der EIDI Klausur beendet :)""` ausgegeben werden.

[task][Tests]( 256112 , 256129 , 256126 , 256125 , 256113 )
Tests: Die Tests testen wieder nur die Funktionalität des Buffers. Ob deine Vervollständigungen der Klassen `ExamCorrection` und `Tutor` korrekt funktionieren, musst du durch Ausführen der `main`-Methode in `ExamCorrection` selbst testen."
404,Praktikum: Grundlagen der Programmierung WS24/25,15743,W11H02 - Parallele Baumsumme,"# Parallele Baumsumme 

### Hinweis

Bei dieser Aufgabe sind die Fehlermeldungen etwas detaillierter und es gibt mehr Hinweise als sonst. Das soll dir den Einstieg erleichtern.
Versuche aber die Aufgabe möglichst ohne die Hinweise zu bearbeiten. Durch Ausprobieren lernst du viel besser! 
Erst wenn du dir sicher bist, dass du nicht mehr vorankommst, sollst du die Hilfestellungen nutzen.

### Das Ziel 

In dieser Aufgabe wollen wir die Summe über einen Binärbaum parallelisiert berechnen. Zur Vereinfachung lassen wir die Wrapper-Klasse weg und arbeiten direkt mit den Knoten, wie sie in der `Node` Klasse definiert sind.

In der Klasse `Main` ist bereits Code vorgegeben mit dem du deine Implementierung testen kannst. Diesen musst du natürlich für unterschiedliche Fälle anpassen z.B. um mit einer
anderen Anzahl an Threads zu arbeiten. Überlege dir außerdem, welche Edgecases bei einer Multithreaded-Applikation interessant sein könnten.

## Aufsummieren ohne Parallelisierung


1.  [task][Implementiere die Methode sum in der Klasse Node]( 256136 )
    Zuerst berechnen wir die Summe ohne Threads. Diesmal verwenden wir für die Kinderknoten [Optionals](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html). `Optional` ist ein Container-Type, der es uns erlaubt, die Abwesenheit eines Wertes darzustellen, ohne null nutzen zu müssen. Du solltest ihn noch aus der letzten Woche kennen. `Optional` können wir also verwenden, um die Kinderknoten darzustellen; es müssen ja nicht alle Knoten links und rechts einen Kinderknoten haben.  Ansonsten ändert sich nichts. 

    Hinweis: Es ist umstritten, ob diese Art von Verwendung der `Optional`s zu den Best-Practices gehört. Du kannst dich [hier](https://medium.com/javarevisited/4-reasons-why-you-should-use-java-optional-or-not-4e44d51a9645) weiterinformieren.

     
 Hinweise: Falsches Ergebnis 
        Stelle sicher, dass du den eigenen Wert von einem Knoten zu der Summe hinzufügst.
     
 
 Hinweise: NoSuchElementException 
        Die Kinderknoten sind vom Typ  Optional . Diese können auch  empty  sein.
     

## Parallelisierung

In diesem Schritt wollen wir die Berechnung mithilfe der Klasse `SumThread` parallelisieren, indem wir die Summe von jedem Teilbaum in einem neuen Thread berechnen bis wir die erwünschte Anzahl der Threads erreichen. Das Ergebnis jeder Berechnung wird im Feld `sum` gespeichert, das zu Beginn des Threads noch keinen Wert enthält. Aus diesem Grund ist auch dieses Feld vom Typ `Optional`. 

Zur Begrenzung der Gesamtanzahl der Threads wird jeder SumThread mit der Variable `remainingThreads` initialisiert. Diese gibt die maximale Anzahl an Threads an, die in dieser Teilberechnung inklusive des aktuellen Threads verwendet werden dürfen.

2.  [task][Implementiere den Konstruktor]( 256144 )
    Implementiere den Konstruktor `public SumThread(Node node, int remainingThreads)` in der Klasse `SumThread`. Initialisiere die Attribute `sum`, `node` und `remainingThreads` mit sinnvollen Werten. Mit den Threads soll in diesem Schritt noch nichts passieren. 


3. [task][Implementiere leftThreadCount()]( 256141 )
    Implementiere die Methode `protected int leftThreadCount()` in der Klasse `SumThread`. Sie soll die Anzahl der verbleibenden Threads für den **linken** Teilbaum berechnen. Die Threads werden noch nicht gestartet. Falls es einen rechten und linken Teilbaum gibt, soll die Anzahl an Threads möglichst gleichmäßig auf beide Teilbäume aufgeteilt werden. Wenn beide Teilbäume existieren und die Threads nicht gleichmäßig aufgeteilt werden können, soll die rechte Seite einen Thread mehr zugeteilt bekommen als die linke Seite. Wenn ein Teilbaum leer ist, werden für diesen keine Threads reserviert. 


     
 Hinweise: Falsches Ergebnis 
        Denke an den aufrufenden Thread im aktuellen Schritt. Diesen kannst du nicht in die Aufteilung miteinrechnen.
     

4.  [task][Implementiere startChildThreads()]( 256147 )
    Implementiere die Methode `protected void startChildThreads()` in der Klasse `SumThread`. Berechne dafür zuerst die Anzahl der Threads für den rechten Teilbaum und erzeuge neue `SumThread`s für die Teilbäume. Achte auf die Mitgabe des richtigen `Node`s und der richtigen Anzahl an Threads für den jeweiligen Teilbaum. Rufe auf den neu erzeugten `SumThread`s die Methode `start()` auf. Die Methode soll auch funktionieren, wenn einer der zwei Teilbäume leer ist. 
     
 Hinweis 
        Könnte dein rechter Teilbaum leer sein? 
     


5.  [task][Implementiere run()]( 256134 )
    Implementiere die Methode `public void run()` in der Klasse `SumThread`. Falls es keinen Thread für den Teilbaum gibt, der Teilbaum aber existiert, soll die Summe von diesem Teilbaum ohne Threads berechnet werden. Ansonsten erhälst du den Wert aus dem zugehörigen Thread. Speichere dein Endergebnis wieder in dem Attribut `sum` des aktuellen Nodes. 

     
 Hinweise zur Implementierung 
 
  Vergess nicht, die Threads erst zu starten! 
  Um ohne Threads zu summieren, steht `Node.sum` bereits zur Verfügug.  
  Denk daran, dass du warten musst, bis die Kinderthreads fertig sind.  
  Beachte, dass `SumThread.sum` vom Typ `Optional ` ist.  
 
 



## Freies Spiel
Glückwunsch, dass du es so weit geschafft hast. Der Rest dieser Aufgabe ist zum freien
Experimentieren da, und es gibt keine automatisierte Tests dazu. 

Jetzt kannst du dir wieder die `Main`-Klasse 
anschauen und die Laufzeiten vergleichen. Experimentiere mit unterschiedlichen Baumgrößen.
Ab wann lohnt sich der Verwaltungsaufwand für die Parallelisierung? 

Um dir einen besseren Überblick zu schaffen, kannst du die `Main`-Klasse mit einer Methode ergänzen,
die als Parameter die Anzahl der Threads und die Baumgröße entgegennimmt und die Bearbeitungsdauer 
zurückgibt. 

Überlege dir als letztes, ob die gegebene Anzahl an Threads immer erzeugt wird. Kannst du einen Baum konstruieren, in dem 
es möglichst ineffizient läuft? Wie vergleichen sich die Zeiten jetzt?"
404,Praktikum: Grundlagen der Programmierung WS24/25,15744,W11H03 - Pingunetze,"# PinguNetze

Die Pinguine der PUM haben kürzlich Threads kennengelernt. Begeistert von der neuen Fähigkeit, parallel arbeitende Prozesse zu modellieren, haben sie sich ein eigenes System ausgedacht, um größere Systeme zu simulieren: **Pingunetze**.

Ein Pingunetz ist ein abstraktes Modell zur Beschreibung und Simulation von Systemen, die aus parallelen Prozessen bestehen. Es ist ein Netz (ähnlich wie ein Graph) auf dem Tokens sich von einer Stelle zur nächsten bewegen. Die Stellen sind durch Transitionen verbunden, die bestimmen wann und wie sich die Tokens bewegen können. Da die Transitionen unabhängig voneinander aktiviert werden können, ist ein Pingunetz ein paralleles System.

Ein Pingunetz besteht aus also drei zentralen Komponenten:

- **Stellen** (*Places*): Diese sind Puffer, die Tokens (repräsentiert durch Zahlen) enthalten. Sie kontrollieren den Fluss im System.
- **Transitionen** (*Transitions*): Das sind die aktiven Elemente, die Tokens aus den Stellen konsumieren und diese weiterverarbeiten.
- **Kanten** (*Edges*): Diese verbinden Stellen mit Transitionen und haben ein Gewicht, das angibt, wie viele Tokens durch sie fließen können.

## Funktionsweise eines Pingunetzes

1. **Stellen (Places):** 
   Stellen können eine Anzahl von Tokens enthalten, die von Transitionen verwendet werden. Eine Transition kann nur ""schalten"" (aktiviert werden), wenn alle Stellen, die mit ihr verbunden sind, genügend Tokens bereitstellen.

2. **Transitionen (Transitions):**
   Transitionen verbrauchen Tokens aus eingehenden Stellen entsprechend den Gewichten der eingehenden Kanten und fügen den ausgehenden Stellen Tokens hinzu. Eine Transition wird nur aktiviert, wenn alle ihre eingehenden Stellen die erforderliche Anzahl an Tokens bereitstellen können.

3. **Kanten (Edges):**
   Die Kanten legen fest, wie viele Tokens zwischen einer Stelle und einer Transition fließen. Es gibt zwei Arten von Kanten:
   - **Von einer Stelle zu einer Transition.**
   - **Von einer Transition zu einer Stelle.**

(Hätten die Pinguine, aber anstatt rumzudödeln fleißig ihre Vorlesungen geschaut wüssten sie, dass diese PinguNetze eigentlich nur vereinfachte Petrinetze sind.)


## Beispiele:
In den folgenden Beispielen repräsentieren die Kreise die Stellen und die Boxen die Transitionen.

Hier seht ihr ein simples PinguNet, bestehend aus zwei Stellen und einer Transition. Wie ihr sehen könnt, ist dieses deterministisch, da die Token alle nur von `P1` zu `P2` ""fließen"" können. 

![image.png](/api/core/files/markdown/Markdown_2025-01-09T13-38-45-911_5f89d6c6.png)


Jetzt wird es schon etwas spannender. Hier seht ihr ein simples nicht deterministisches PinguNet. Wir haben am Anfang zwei Token in `P1`. Diese können entweder zu `P2` oder `P3`. Wo die Token landen, hängt davon ab, welcher der Transitionen `T1` und `T2` als erstes aktiviert, eine feste Reihenfolge ist nicht gegeben. Das sind alle möglichen Endzustände des `PinguNets`. 


![image.png](/api/core/files/markdown/Markdown_2025-01-09T13-44-30-986_a9065c09.png)

![image.png](/api/core/files/markdown/Markdown_2025-01-09T13-45-46-771_979137be.png)



Durch diese Modellierung können die Pinguine komplexe Systeme mit parallelen Prozessen und kontrolliertem Ressourcenfluss abbilden. Die grundlegende Implementierung haben die Pinguine dir schon bereits vorgegeben, aber die Implementierung ist noch nicht sicher vor Race Conditions und Deadlocks! Es ist nun deine Aufgabe, deinen Pinguin-Freunden unter die Flossen zu greifen.

Bevor du mit der Implementierung beginnst, solltest du dir unbedingt alle gegebenen Klassen einmal anschauen. Die Stellen für deinen Code sind auch nochmal extra mit einem ""TODO"" markiert.

## Hinweise und Tipps
- Wenn eine `Exception` geworfen werde soll, ist die mitgegebene Nachricht für die Tests irrelevant, könnten aber euch beim Debuggen helfen. Insbesondere könnte auch die Methode `Thread::setUncaughtExceptionHandler` helfen.
- Methode, Felder und Klassen die keine ""TODOs"" enthalten dürfen auf keinen Fall verändert werden!
- Nur die ""Concurrent"" Tests geben Punkte! Damit ihr aber seht, ob eure Klassen sequentiell funktionieren, haben wir euch ein paar Tests gegeben als Hilfestellung.
- Ein Timeout in den Tests bedeutet in den meisten Fällen, dass eure Implementierung einen Deadlock produziert.

## Die Klasse `Place`

Die Klasse Place ist das Herzstück unseres Programmes. Dort passiert auch der Hauptteil der Synchronisierung. In der Vorgabe bekommt ihr bereits die Mindestanforderung an die Struktur der Klasse gegeben. Ihr dürft die in der Vorgabe gegebenen Signaturen, Felder und den Konstruktor auf keinen Fall verändern! Ansonsten werden die Tests fehlschlagen.


1. Die Methode `lockPlace()`:  
   Diese Methode ist der Synchronisationsmechanismus der Klasse Place. Durch das Aufrufen dieser Methode soll es möglich sein das Schloss (Lock) auf die Instanz zu bekommen auf der es aufgerufen wird. Sollte ein weiterer Thread diese Methode aufrufen nachdem ein anderer Thread bereits das Schloss bekommen hat, so soll es warten bis das Schloss frei ist und erst weitermachen, wenn es auch Zugang zum Schloss bekommt. Ein Blick in die Folien dieser Woche könnte sehr hilfreich sein...


2. Die Methode `unlockPlace`:  
   Analog zu der Methode `lockPlace` soll diese Methode einem Thread die Möglichkeit geben das Schloss wieder abzugeben. Sollte diese Methode von einem Thread aufgerufen werden, der nicht das Schloss hält, so soll eine `IllegalStateException` geworfen werden.

3. Die Methode `hasEnoughTokens(int)`:  
   Diese Methode soll überprüfen und zurückgeben, ob genug `tokens` vorhanden sind. Sollte diese Methode von einem Thread aufgerufen werden, der nicht das Schloss hält, so soll eine `IllegalStateException` geworfen werden. Die Nachricht in der Exception ist dabei egal. 

4. Die Methode `consumeToken(int)`:  
   Diese Methode soll die übergeben Menge an `tokens` konsumieren, falls genug tokens da sind. Sollten nicht genug `tokens` vorhanden sein, so soll hier eine `IllegalArgumentException` geworfen werden. Sollte diese Methode von einem Thread aufgerufen werden, der nicht das Schloss hält, so soll eine `IllegalStateException` geworfen werden. Die Nachricht in der Exception ist dabei egal. 

5. Die Methode `addTokens(int)`:  
   Diese Methode soll die übergebene Menge an `tokens` hinzufügen. `Place` hat dabei aber kein oberes Limit und du musst Overflows nicht beachten. Sollte diese Methode von einem Thread aufgerufen werden, der nicht das Schloss hält, so soll eine `IllegalStateException` geworfen werden. Die Nachricht in der Exception ist dabei egal. 

[task][Place Helper-Tests]( 256174 , 256175 , 256159 , 256168 , 256171 , 256160 , 256163 , 256165 )

[task][Place Grading-Tests]( 256169 , 256167 , 256173 , 256177 )

## Die Klasse `ProducerTransition`

Diese Klasse soll eine primitive Transition modellieren. Wie der Name schon verrät soll diese Transition keinerlei Token konsumieren, sondern nur welche produzieren. In der Vorgabe bekommt ihr bereits die Mindestanforderung an die Struktur der Klasse gegeben. Ihr dürft die in der Vorgabe gegebenen Signaturen, Felder und den Konstruktor auf keinen Fall verändern! Ansonsten werden die Tests fehlschlagen.

Der Klasse fehlt nurnoch die Implementierung der `tryFire()`-Methode. Diese Methode soll bei allen `Place`s die man über die ausgehenden Kanten (`Edge`) erreichen kann `tokens` hinzufügen. Die Menge entspricht dabei dem Gewicht (`weight`) der Kante. Der Rückgabewert der `tryFire()` Methode soll dabei singalisieren, ob die Methode erfolgreich war. Achte darauf, dass die Implementierung thread-safe ist und nicht zu Race-Conditions oder Deadlocks führt!

[task][ProducerTransition Grading-Tests]( 256181 )

## Die Klasse `BasicTransition`

Diese Klasse soll eine komplexere Transition mit beliebigen Aus- und Eingangskanten modellieren. Auch hier fehlt nur noch die `tryFire()`-Methode. Diese Methode soll erst alle `Place`s von den eingehenden Kanten abschließen (locken), dann überprüfen ob genug `tokens` enthalten sind. Sollte ein `Place` nicht genug `tokens` haben, sollen alle `Place`s wieder aufgeschlossen werden (unlocked) und ein entsprechender Rückgabewert zurückgegeben werden. Sollten alle `Place`s genug token haben, sollen von allen eingehenden Kanten, entsprechend dem Gewicht der Kante die Tokens eingesammelt werden. Danach müssen noch die `Place`s der ausgehenden Kanten entsprechend dem Gewicht der Kanten gefüllt werden. Anschließend müssen natürlich alle `Place`s wieder aufgeschlossen (unlocked) werden. Achte darauf, dass die Implementierung thread-safe ist und nicht zu Race-Conditions oder Deadlocks führt! 

[task][BasicTransition Helper-Tests]( 256180 )

[task][BasicTransition Grading-Tests]( 256178 , 256170 )

## Die Klasse `PinguNet`

Hier kommt nun alles zusammen. Vieles in der Klasse ist schon vorgegeben, aber du musst den Konstruktor noch vervollständigen. Das Feld `transitionThreads` soll im Konstruktor mit Threads initialisiert werden die jeweils eine Transition darstellen. 

1. Die Methode `start()`:   
Diese Methode soll alle `transitionThreads` starten.

2. Die Methode `stop()`:   
Diese Methode soll das `PinguNet` stoppen indem es alle `transitionThreads` stoppt. Ein Blick in die Klasse `Transition` könnte hilfreich sein.

[task][PinguNet Grading-Tests]( 256172 , 256162 )

## Graphviz
In der Graphviz Klasse findet ihr bereits implementierte Methoden, um die PinguNets als Graph zu repräsentieren. Wie der Graph aussiehen soll, der in der main Methode steht, seht ihr in `pingunetz.txt`. Das kann man in Online Viewern wie https://dreampuf.github.io/GraphvizOnline/ einfügen und sehen, wie die Pingunetze aussehen.

Viel Erfolg beim Implementieren! Die Pinguine freuen sich darauf, ihre Pingunetze in Aktion zu sehen! 🐧"
404,Praktikum: Grundlagen der Programmierung WS24/25,15745,W11P00 - Threads Playground,"# Threads Playground


Da in dieser Woche eine Menge Methoden und Klassen der Standardbibliothek vorgestellt werden und viele Code-Schnippsel in den Folien vorkommen, wollen wir euch die Code-Schnippsel in Form dieser Aufgabe zur Verfügung stellen.



Der einzige Test hier ist ob eure Aufgabe auf Artemis kompiliert. Das gibt euch auch die Möglichkeit mit Threads auf Artemis rumzuspielen."
404,Praktikum: Grundlagen der Programmierung WS24/25,15789,W12P01 - Memory Visibility,"# Memory Visibility zwischen Threads
In Java ist die Sichtbarkeit von Variablenänderungen zwischen verschiedenen Threads nicht automatisch garantiert. Ohne spezielle Maßnahmen kann es passieren, dass Änderungen, die ein Thread an einer Variable vornimmt, für andere Threads nicht oder nicht sofort sichtbar sind. Dies liegt am *Java Memory Model* und der Tatsache, dass moderne CPUs Caches verwenden, um die Performance zu optimieren. In dieser Aufgabe werden wir drei verschiedene Ansätze in diesem Kontext vergleichen:

1. Eine Implementierung ohne Memory Visibility Garantien
2. Eine Lösung mit dem `volatile` Keyword
3. Eine Version mit `synchronized` Blöcken

### 1. Das Memory Visibility Problem
Im Template findest du eine erste Implementierung der BusinessPenguin Klasse ohne jegliche Memory Visibility Garantien. Die main-Methode demonstriert das grundlegende Problem:
Ein wartender Thread prüft kontinuierlich den Shop-Status mit `waitForShopToOpen()`, während der Hauptthread nach einer kurzen Pause mit `openShop()` den Shop öffnet. Führe diese Version mehrfach aus und beobachte das Verhalten:

- Warum erkennt der wartende Thread manchmal nicht, dass der Shop geöffnet wurde?
- Welche Rolle spielen dabei CPU-Caches und Thread-lokale Sichtbarkeiten?

### 2. Volatile Variablen
Das volatile Keyword in Java stellt sicher, dass Lese- und Schreibzugriffe direkt im Hauptspeicher erfolgen, statt in CPU-Caches zwischengespeichert zu werden. Markiere nun die `isShopOpen` Variable als `volatile` und führe das Programm erneut aus. Analysiere die Unterschiede:

- Wie verändert sich das Verhalten des Programms?
- Welche Garantien bietet `volatile` bezüglich der Sichtbarkeit von Änderungen?

### 3. Synchronisierte Koordination
In dieser Version wollen wir statt einer einzelnen `volatile` Variable die Objekt-Synchronisation nutzen. Verwende in BusinessPenguinSynchronized anstelle von *busy waiting* eine Lösung, die `wait()` und `notifyAll()` verwendet.

Nachdem du deine Implementierung getestet hast, überlege:
- Was ist der Unterschied zwischen dieser Lösung und dem *busy waiting* zuvor?
- Warum sind beide Methoden synchronisiert?
- Welche Auswirkunge hat `synchronized` auf memory visibility?"
404,Praktikum: Grundlagen der Programmierung WS24/25,15790,W12P02 - Interrupts,"# Interrupts
In dieser Aufgabe veränderst du ein System für Banküberweisungen, sodass es korrekt mit Thread-Unterbrechungen umgeht. Das zentrale Ziel ist es, die Kontostände auch dann konsistent zu halten, wenn eine Überweisung mittendrin abgebrochen wird.

### 1. Die TransferJob-Klasse
Ein TransferJob repräsentiert eine einzelne Überweisung und führt diese in drei Schritten durch:
- Abheben vom Senderkonto
- Betrugsprüfung durchführen (simuliert durch eine 2-Sekunden-Verzögerung)
- Einzahlung auf das Empfängerkonto

Deine Hauptaufgabe ist es, die `run()`-Methode so zu implementieren, dass sie unterbrechbar ist und dabei keine Inkonsistenzen entstehen. Überlege dir dazu, was mit bereits abgehobenem Geld passiert, wenn die Überweisung während der Prüfung unterbrochen wird. Überlege dir auch, wie du mit InterruptedExceptions an verschiedenen Stellen umgehst.

### 2. Die Bank-Klasse
Die Bank-Klasse verwaltet die laufenden Überweisungen und stellt sicher, dass diese bei Bedarf sicher unterbrochen werden können.
Im Template findest du dazu bereits zwei Komponenten: Das Set `activeTransfers` verfolgt alle momentan laufenden Überweisungen. Du musst dann als Teil deiner Implementierung die Überweisungen dort korrekt registrieren und löschen. Zudem ist hier die Methode `performFraudCheck()` implementiert, die für `TransferJob`s eine unterbrechbare, zeitaufwändige Betrugsprüfung simuliert. 

Deine Aufgabe ist es, die folgenden zwei Methoden zu implementieren:
Die erste Methode `startTransfer()` initiiert eine neue Überweisung. Sie erhält als Parameter die beiden beteiligten Konten sowie den zu überweisenden Betrag. Die Methode muss einen neuen `TransferJob` erstellen und als Thread starten.

Die zweite Methode `stopAllTransfers()` beendet alle laufenden Überweisungen kontrolliert. Sie muss alle aktiven Transfers mit `interrupt()` unterbrechen, und nach deren Beendigung das Set der aktiven Transfers löschen.

[task][TransferJob]( 257814 , 257815 , 257816 )
[task][Bank]( 257817 , 257818 )"
404,Praktikum: Grundlagen der Programmierung WS24/25,15791,W12P03 - Synchrone Listen,"# Synchrone Listen

Wie der [Java-Dokumentation](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/LinkedList.html)
zu entnehmen ist, sind `LinkedList`s nicht thread-safe:
> “If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.)”

 In dieser Aufgabe sollst du eine Klasse
`SynchronizedList` erstellen, die es mehreren Threads ermöglicht, zugleich auf die Liste zuzugreifen.

### 1. Welche Probleme können bei fehlender Synchronisation auftreten? Warum?
Die bereitgestellte Main-Methode testet die Laufzeit deiner Implementierungen mit 5 lesenden und einem schreibenden Thread. Die lesenden Threads rufen jeweils 10.000 mal get() auf, während der schreibende Thread 10.000 mal ein Element einfügt und wieder entfernt. Führe die Methode zunächst mehrfach aus, und diskutiere das Ergebnis.

### 2. ‘Naive’ Synchronisation
Synchronisiere nun alle Zugriffe mittels `synchronized`. Führe erneut die main-Methode aus.
Diskutiere, warum das Programm deutlich langsamer geworden ist.

### 3. Synchronisation mit einem ReadWriteLock
Synchronisiere zuletzt mit einem ReadWriteLock. Verwende dazu die Klasse `RW` mit den
Methoden `startRead()`, `stopRead()`, `startWrite()` und `stopWrite()`, die du analog zur Vorlesung implementieren sollst.
Das Lock soll sicherstellen, dass mehrere lesende Prozesse gleichzeitig zugreifen können,
aber nur ein schreibender Zugriff zugleich erlaubt ist. Sorge dafür, dass deine Implementierung frei
von Race-Conditions oder Deadlocks ist. Vergleiche abschließend die Performance und überlege, warum das Programm schneller geworden ist.

[task][Test]( 256735 )
Test der Implementierung."
404,Praktikum: Grundlagen der Programmierung WS24/25,15795,W12H02 - PUM Server Synchronisierung,"# PUM Server Synchronisierung

In [Woche 06](https://artemis.ase.in.tum.de/courses/404/exercises/15238) hast du den Softwareuinen der PUM bereits geholfen, einen `RingBuffer` und einen `MultiStack` zu implementieren. In der Zwischenzeit haben sie ein wenig weiter an den Klassen gearbeitet, doch jetzt brauchen sie wieder die Hilfe ihres exzellenten Freundes: Deine! Da der Hochleistungsrechner natürlich stark parallelisiert arbeitet, müssen die Datenstrukturen auch für diesen Einsatz geeignet sein.

## MultiStack

Der `MultiStack` wurde um zwei neue Methoden erweitert, die es auch in der [Stack-Implementierung der Standardbibliothek](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Stack.html#search(java.lang.Object)) gibt.

- `size()`: Gibt die Anzahl der Elemente im Stack zurück  
- `search(int value)`: Sucht nach einem Element und gibt dessen Position relativ zum obersten Element zurück. Das oberste Element hat Position 1, das zweite Position 2, usw. Falls das Element nicht gefunden wird, wird -1 zurückgegeben.

Deine Aufgabe ist es jetzt, die Methoden des `MultiStack` so zu synchronisieren, dass mehrere lesende Threads gleichzeitig auf den MultiStack zugreifen können, während aber nur ein schreibender Thread diesen zu einem bestimmten Zeitpunkt verändern darf. Während eines schreibenden Zugriffs sind auch keine Lesenden erlaubt. Dabei gilt es Folgendes zu beachten:
- Die Signaturen der vorgegebenen Methoden müssen gleich bleiben.
- Die Konstruktorsignatur von `MultiStack` muss gleich bleiben (die von `Stack` darf allerdings verändert werden).
- Vorhandene Attribute müssen gleich bleiben.
- Hilfsmethoden und -Attribute sind erlaubt.
- Die bisherige Funktionalität der Methoden muss natürlich weiterhin bestehen.
- Klassen aus `java.util.concurrent.locks` und `Semaphore` dürfen verwendet werden.

[task][MultiStack Original Implementation]( 256779 )
Hier siehst du, ob deine Änderungen die ursprüngliche Funktionalität der Methoden beeinflusst.
 
[task][MultiStack Concurrency]( 256784 , 256798 , 256800 , 257264 )

[task][MultiStack Concurrency Teilergebnisse]( 257260 , 257261 , 257262 , 257263 )
Wenn du alle diese Tests bestehst, bekommst du die Punkte für MultiStack - All Synchronized

## RingBuffer

Der `RingBuffer` soll in einen ""BlockingRingBuffer"" umgewandelt werden (die Klasse soll aber nicht umbenannt werden!). Das heißt, dass `put(val)` das übergebene `val` immer in den Buffer einfügt. Falls der Buffer voll ist, soll der einfügende Thread warten, bis wieder Kapazität vorhanden ist. Deshalb wurde der Rückgabetyp auch auf `void` geändert (es wird ja immer eingefügt). Ebenso soll `get` immer ein Element zurückgeben. Falls der Buffer leer ist, wartet der Thread, bis wieder ein Element vorhanden ist. Sollte ein wartender Thread interrupted werden, soll in beiden Methoden eine `InterruptedException` geworfen werden. Während eines `toString`-Aufrufs darf nichts am Buffer geändert werden. Für diese Teilaufgabe gilt Folgendes:
- Die Signaturen der vorgegebenen Methoden und des Konstruktors müssen gleich bleiben. `put` und `get` wurden bereits um ein `throws InterruptedException` erweitert.
- Alle Attribute außer `mem` dürfen beliebig geändert werden und Neue dürfen hinzugefügt werden. Hilfsmethoden sind erlaubt.
- Die bisherige Funktionalität der Methoden muss natürlich weiterhin bestehen.
- Klassen aus `java.util.concurrent.locks` und `Semaphore` dürfen verwendet werden.

[task][RingBuffer Original Implementation]( 256774 )
Hier siehst du, ob deine Änderungen die ursprüngliche Funktionalität der Methoden beeinflusst.
 
[task][RingBuffer Concurrency]( 256787 , 256776 , 256783 , 257259 )"
404,Praktikum: Grundlagen der Programmierung WS24/25,15796,W12H03 - PSA Shuttle Computer,"# PSA Shuttle Computer

Die PSA (Pingu Space Agency) entwickelt derzeit ein neues Spaceshuttle und steht vor einer besonderen Herausforderung: Der Bordcomputer muss nicht nur leistungsstark sein, sondern auch absolut zuverlässig arbeiten. Um dies zu gewährleisten, setzt die PSA auf ein innovatives Multithreading-Konzept, bei dem mehrere Prozessoren parallel die gleichen Berechnungen durchführen. Deine Aufgabe wird es sein, die verschiedenen Thread-Komponenten zu implementieren und dabei besonders auf korrekte Synchronisation zu achten. Die redundante Berechnung ist zwingend erforderlich, da die intensive Strahlung im All zu sogenannten Bitflips führen kann. Das sind zufällige Änderungen einzelner Bits im Speicher, die falsche Berechnungsergebnisse verursachen können (siehe hierzu dieses sehr [empfehlenswerte Video](https://youtu.be/AaZ_RSt0KP8), kein Muss für diese Aufgabe!).


## Struktur und allgemeine Funktionsweise
Der `ShuttleComputer`, den du implementieren sollst, basiert auf einem verteilten System von Threads, die das `ShuttleComputerComponent`-Interface implementieren. Im Zentrum steht der `TaskDistributer`-Thread, der mithilfe eines `TaskGenerators` eine Anzahl von Berechnungsaufgaben (`ShuttleTask`s) erzeugt. Diese Aufgaben werden an vier `ShuttleProcessor`-Threads weitergeleitet (die Anzahl ist konfigurierbar), die jeweils unabhängig voneinander die gleiche Berechnung durchführen. Ein `TaskChecker`-Thread vergleicht die Ergebnisse der verschiedenen Prozessoren und akzeptiert ein Resultat nur dann, wenn mindestens drei identische Ergebnisse vorliegen. Der `ShuttleOutput`-Thread gibt dann die Ergebnisse aus.

Die folgende Abbildung zeigt den Datenfluss zwischen den Komponenten. 

![ShuttleComputer Aufbau](/api/core/files/markdown/Markdown_2022-11-21T14-24-17-192_5058a7d8.svg)

Der Shuttle Computer produziert also Aufgaben, die dann parallel gelöst werden. Anschließend werden die Ergebnisse überprüft und ggf. eine erneute Lösung in die Wege geleitet. Korrekt gelöste und überprüfte Aufgaben werden schließlich auf der Konsole ausgegeben.

## Template
Im Template findest du bereits eine vollständige Implementierung von `ShuttleTask`, das Interface `TaskGenerator`, sowie zwei Implementierungen davon: `ErrorlessTaskGenerator`, dessen `ShuttleTask`s immer das richtige Ergebnis berechnen; und `ErrorProneTaskGenerator`, dessen `ShuttleTasks` mit einer übergebenen Wahrscheinlichkeit ein falsches Ergebnis zurückgeben (um die Bitflips zu simulieren). Solltest du eine eigene lustige oder interessante Idee für einen `TaskGenerator` haben, darfst du diesen gerne auch schon vor der Deadline der Aufgabe öffentlich teilen, solange (wie immer) nichts von der Implementierung der eigentlichen Aufgabe verraten wird.  
Weiterhin enthält das Template bereits Implemenierungen der übrigen bisher beschriebenen Klassen, die du beliebig erweitern darfst (die Konstruktor und Methoden-Signaturen, die bereits vorgegeben sind, müssen aber gleich bleiben!). Deine Aufgabe ist es, die Methoden `shutDown` und `run` in diesen Klassen zu implementieren. Weitere Informationen findest du im Punkt ""Aufgaben"".
In der Klasse `ShuttleComputer` findest du außerdem eine `main`-Methode, mit der du deine Implementierung ausprobieren kannst.

## Allgemeine Hinweise
- Am besten liest du dir die ganze Aufgabenstellung einmal durch, bevor du mit der Implementierung der einzelnen Teilaufgaben beginnst
- "" ⎵ "" dient wie immer nur der besseren Lesbarkeit und soll in der tatsächlichen Ausgabe durch ein Leerzeichen ersetzt werden.
- `shutDown` muss für jede Objekt-Instanz nur einmal funktionieren
- `run` muss für jede Objekt-Instanz nur einmal funktionieren
- Die Klassen (außer `ShuttleComputer` !!) werden unabhängig voneinander getestet
- Deine Implementierung darf bei der Interaktion mit Objekten aus dem Package `pgdp.shuttle.tasks` nur die vorgegebenen Methoden verwenden und diese dürfen nicht verändert werden.
- Sollte ein Test fehlschlagen und ""This could be an Artemis issue."" beinhalten, ist es **möglich**, dass das Problem an Artemis und nicht an deiner Implementierung liegt. In solch einem Fall solltest du 1.) deinen Code nochmal genau überprüfen, ob du nicht doch einen Fehler findest, und 2.) etwas abwarten und nochmal pushen (möglicherweise löst sich dadurch der Fehler von selbst)
- Falls ein Thread gerade nichts zu tun hat, soll er warten. Ebenso soll ein Thread informiert werden, falls er wieder etwas zu tun bekommt. (Stichwort `wait` und `notify`)
- Falls andere Exceptions auftreten als `InterruptedExceptions` wird kein spezielles Verhalten erwartet.
- Du musst dir keine Gedanken machen, ob im Konstruktor initialisierte Variablen `null` sein könnten.

## Aufgaben
Wie bereits oben beschrieben musst du die Methoden `shutDown` und `run` implementieren. Allgemein gilt für die Methoden: 
- `shutDown`: beendet den Thread. Das Beenden soll ""auf natürliche Weise"", d.h. ohne Exceptions, etc., sondern durch verlassen der `run`-Methode erreicht werden. Dies muss nur einmal pro Objekt-Instanz funktionieren.
- `run`: übernimmt die im folgenden definierten Aufgaben je Klasse. Muss nur einmal pro Objekt-Instanz funktionieren. Wenn nicht anders definiert, wartet diese Methode auch immer, wenn sie gerade nichts zu tun hat.

[task][TaskDistributer Console-Output]( 256820 , 256805 )
[task][TaskDistributer Distribution]( 256802 )
Diese Klasse übernimmt im Konstruktor die Anzahl der zu generierenden Aufgaben (`tasksToGenerate`), eine Liste von `ShuttleProcessor`en (`processors`) und einen TaskGenerator (`generator`). In der `run`-Methode sollen solange `ShuttleTasks` mit dem Generator erstellt und an alle Prozessoren mit normaler Priorität verteilt werden (jeder Prozessor erhält jede Task, zum Verteilen existiert die Methode `addTask`), bis entweder `tasksToGenerate` Aufgaben erstellt und verteilt wurden, oder der `TaskDistributer` mittels `shutDown` beendet wird. In letzterem Fall soll aber immer eine schon generierte Task auf alle Prozessoren fertig verteilt werden. Weiterhin sollen folgende Ausgaben auf der Konsole getätig werden:
- Direkt beim Starten: "" TaskDistributer⎵starting⎵to⎵generate⎵tasks. ""
- Bei normalem Beenden (sobald die maximale Anzahl and Tasks generiert wurde oder `shutDown` aufgerufen wurde): "" TaskDistributer⎵finished⎵generating⎵ \ / \ ⎵tasks.⎵Shutting⎵down. ""
- Beim Auftreten einer `InterruptedException` statt der Nachricht zum normalen Beenden: "" TaskDistributer⎵was⎵interrupted⎵after⎵ \ ⎵tasks! ""

[task][ShuttleProcessor Console-Output]( 256828 )
[task][ShuttleProcessor Runbehavior]( 256803 )
Diese Klasse verwaltet `ShuttleTask`s in zwei Warteschlagen, einer mit normaler (`taskQueue`) und einer mit hoher Priorität (`priorityTaskQueue`). In der `run` Methode sollen `ShuttleTask`s evaluiert (`evaluate()`) und an den TaskChecker weitergegeben werden (`checker.addTask()`). Dabei sollen `ShuttleTask`s aus der priorisierten Warteschlange bevorzugt werden. Ein `ShuttleProcessor` soll nur durch einen Aufruf von `shutDown` oder eine `InterruptedException` beendet werden. Sollte bei einem Aufruf von `shutDown` bereits eine `ShuttleTask` evaluiert worden sein, soll diese noch and den `TaskChecker` weitergegeben werden. Außerdem sollen noch folgende Ausgaben auf der Konsole getätigt werden:
- Bei normalem Beenden (durch `shutDown`): "" ShuttleProcessor⎵shutting⎵down. ""
- Beim Auftreten einer `InterruptedException` statt der Nachricht zum normalen Beenden: "" ShuttleProcessor⎵was⎵interrupted.⎵Shutting⎵down. ""

[task][TaskChecker Console-Output]( 256806 )
[task][TaskChecker Runbehavior]( 256804 )
Diese Klasse überprüft in der `run`-Methode, ob sich die verschiedenen `ShuttleProcessor`en auf ein Ergebnis für die `ShuttleTask` ""einigen"" konnten. Voraussetzung dafür ist, dass mindestens vier Prozessoren die Task evaluiert haben. Falls dies nicht der Fall ist, kann die `ShuttleTask` erstmal ignoriert werden, bis sie wieder in der `taskQueue` landet. Die `ShuttleProcessor`en ""einigen"" sich auf ein Ergebnis, wenn mindestens dreimal dasselbe Ergebnis berechnet wurde. In diesem Fall wird `result` der `ShuttleTask` auf den ensprechenden Wert gesetzt und die Task an den `ShuttleOutput` weitergegeben (Hinweis: jede `ShuttleTask` soll nur genau einmal an den `ShuttleOutput` weitergegeben werden). Andernfalls wird die `ShuttleTask` zurückgesetzt und wieder auf die Prozessoren verteilt, um neu berechnet zu werden. Die Neuberechnung hat dabei hohe Priorität. `ShuttleTask` bietet bereits alle nötigen Methoden, um dieses Verhalten umzusetzen. Ein `TaskChecker` soll nur durch einen Aufruf von `shutDown` oder eine `InterruptedException` beendet werden. Angefangene Überprüfungen werden vor dem Beenden mit `shutDown` noch zu Ende geführt. Außerdem sollen noch folgende Ausgaben auf der Konsole getätigt werden:
- Bei normalem Beenden (durch `shutDown`): "" TaskChecker⎵shutting⎵down. ""
- Beim Auftreten einer `InterruptedException` statt der Nachricht zum normalen Beenden: "" TaskChecker⎵was⎵interrupted.⎵Shutting⎵down. ""

[task][ShuttleOutput Console-Output]( 256801 )
[task][ShuttleOutput Runbehavior]( 256807 )
Diese Klasse ist letztlich dafür verantwortlich die Ergebnisse fertiger `ShuttleTask`s auf der Konsole auszugeben. Dies soll natürlich in der `run`-Methode geschehen. Außerdem soll auch `ShuttleOutput` nur durch einen Aufruf von `shutDown` oder eine `InterruptedException` beendet werden. Angefangene Ergebnis-Ausgaben werden vor dem Beenden mit `shutDown` noch vollendet. Diese Klasse tätigt folgende Konsolenausgaben:
- Beim Output eines Ergebnisses: "" Result:⎵ \ ""
- Bei normalem Beenden (durch `shutDown`): "" ShuttleOutput⎵shutting⎵down. ""
- Beim Auftreten einer `InterruptedException` statt der Nachricht zum normalen Beenden: "" ShuttleOutput⎵was⎵interrupted.⎵Shutting⎵down. ""

[task][ShuttleComputer Console-Output]( 256827 )
[task][ShuttleComputer Runbehavior]( 256822 )
Schließlich fehlt noch die Klasse `ShuttleComputer`. Diese soll in der `run`-Methode einen `TaskDistributer`, vier `ShuttleProcessor`, einen `TaskChecker` und einen `ShouttleOutput` initialisieren (`tasksToGenerate` und der benötigte `TaskGenerator` werden im Konstruktor initialisiert). Diese Komponenten sollen dann parallel ausgeführt werden. Nach `sleeptime` Millisekunden soll der `TaskDistributer` wieder heruntergefahren werden (falls er nicht schon fertig und damit heruntergefahren ist; trotzdem soll immer die volle  `sleeptime` gewartet werden) und anschließend auch alle anderen `ShuttleComputerComponent`en. Nachdem alle Threads beendet sind, soll sich auch der `ShuttleComputer` beenden. Während der Ausführung tätigt `ShuttleComputer` folgende Ausgaben auf der Konsole:
- Zu Beginn: "" ShuttleComputer⎵booting⎵up. ""
- Bei normalem Beenden ganz zum Schluss: "" ShuttleComputer⎵shutting⎵down. ""
- Falls eine `InterruptedException` auftritt, während auf den `TaskDistributer` gewartet wird, anstatt der normalen Schluss-Nachricht: "" ShuttleComputer⎵crashed⎵(interrupted⎵while⎵waiting⎵for⎵TaskDistributer)! ""
- Falls eine `InterruptedException` auftritt, während auf das Beenden der übrigen `ShuttleComputerComponent`en gewartet wird, anstatt der normalen Schluss-Nachricht: "" ShuttleComputer⎵crashed⎵(interrupted⎵while⎵waiting⎵for⎵ShuttleComputerComponent)! ""

## FAQ
- **Frage:** Der ""shutDown""-Test zu Klasse XY failt mit einem Timeout. Woran könnte das liegen? 
Wahrscheinlich beachtest du noch nicht alle Hinweise. Lies dir am besten nochmal den Abschnitt ""Allgemeine Hinweise"" durch."
404,Praktikum: Grundlagen der Programmierung WS24/25,15801,W12H01 - Penguin Kitchen,"# Penguin Kitchen

Die Pinguine der PUM haben ein Problem: Die Vorlesungen haben wieder angefangen und tausende hungrige Pinguine stürmen täglich die Kantine. Das bisherige System zur Bestellungsverarbeitung ist aber hoffnungslos überfordert, da es Bestellungen nur sequentiell abarbeiten kann. Die exzellenten Entwickler der PUM haben bereits ein neues System designed, das Bestellungen parallel verarbeiten soll. Leider sind sie mit den Vorbereitungen für die Prüfungen beschäftigt - für die Entwicklung kommst deshalb du ins Spiel.

### Das System im Überblick

Eine Bestellung in unserem System wird durch die `Order`-Klasse repräsentiert. Sie enthält eine eindeutige ID, eine maximale Zubereitungszeit und die Liste der Stationen, die durchlaufen werden müssen. Die `Order`-Klasse ist bereits vollständig implementiert und simuliert die Verarbeitungszeit an den Stationen durch ihre `cook()`-Methode.

Die parallele Verarbeitung stellt besondere Anforderungen an die Koordination. Jede Station (`KitchenStation`) hat nur begrenzt viel Platz - dies wird durch einen Semaphor kontrolliert. Die Köche (`Chef`) arbeiten als eigenständige Threads und teilen sich eine Warteschlange für neue Bestellungen. Der `KitchenManager` startet und beendet den Prozess und verwaltet einkommende Bestellungen.

Eine Bestellung muss innerhalb ihrer Zeitvorgabe alle benötigten Stationen durchlaufen. Ist diese Zeit beim Erreichen einer Station überschritten, muss die Bestellung aus dem System entfernt werden. Achte auf eine korrekte Synchronisation zwischen allen Komponenten.

#### 1. KitchenStation
Gegeben ist bereits eine Methode `validateOrder()`, mit der ein Chef prüft, ob eine Bestellung noch innerhalb ihrer Zeitvorgabe liegt. Du implementierst nun `processOrder()`, die den eigentlichen Verarbeitungsprozess einer Bestellung an der Station steuert: Die Methode muss berücksichtigen, dass jede Station nur begrenzt viel Platz hat, bevor sie eine Order kocht.

#### 2. Chef
Das Verhalten der Köche wird in der `Chef`-Klasse modelliert. Jeder Koch arbeitet als eigenständiger Thread und ist für die vollständige Verarbeitung von Bestellungen zuständig. In der `run()`-Methode implementierst du den Arbeitszyklus: Der Koch entnimmt kontinuierlich neue Bestellungen aus der geteilten Queue und verarbeitet diese an den erforderlichen Stationen. Dabei muss er sowohl auf abgelaufene Orders als auch auf mögliche Unterbrechungen reagieren. Ein Koch arbeitet so lange, bis er explizit gestoppt wird. 


#### 3. KitchenManager
Der `KitchenManager` koordiniert das Gesamtsystem über seine synchronisierten Methoden. Die `start()`-Methode initialisiert das System und lässt die Köche starten. In `stop()` werden die Prozesse geordnet heruntergefahren und der `KitchenManager` zurückgesetzt. Wenn das System bereits im entsprechend korrekten Zustand ist, sollen die Methoden nichts machen. `submitOrder()` nimmt neue Bestellungen entgegen solange die Küche läuft und fügt sie in die priorisierte Warteschlange ein.
 
Achte darauf, dass der `activeOrders`-Zähler, der zu jedem Zeitpunkt angibt, wie viele Bestellungen sich im System befinden - sowohl wartende als auch solche, die von Kochthreads bearbeitet werden. Eine Bestellung, die abgearbeitet oder abgelaufen ist, befindet sich nicht im System. Das Ablaufdatum muss nur für die Übergabe an `processOrder()` geprüft werden, während der Verarbeitung können Bestellungen ablaufen.

[task][KitchenStation]( 256998 )
[task][KitchenManager]( 256989 , 256995 , 256993 , 256987 , 256991 , 256997 , 256999 ) 
[task][Chef]( 257765 )"
404,Praktikum: Grundlagen der Programmierung WS24/25,15896,W13H01 - Mini JVM,"Das ist eine freiwillige Aufgabe und hat keinen Einfluß auf den Notenbonus!

# MiniJVM Simulator

Wir wollen einen Simulator für ein Subset des MiniJVM-Codes entwickeln. 
Folgende Befehle sollen umgesetzt werden:

- arithmetische Operationen:  `ADD`, `SUB`
- Laden von Konstanten: `CONST i`
- Allozieren von Speicherplatz `ALLOC i` 
- Load/Store: `LOAD i`, `STORE i`
- Vergleichsoperatoren: `LESS`
- Logische Operatorn: `AND`, `NOT`
- Sprunganweisungen: `JUMP i`, `FJUMP i`
- Funktionsaufrufe: `CALL i`, `RET`
- Programmende: `HALT`


Jede Operation soll dabei in einer eigene Klasse umgesetzt werden, die von der abstrakten Klasse `Instruction` erbt.
Ein `Simulator` besitzt ein Array von Instructions `code` und einen Stapel `stack`.
Der Stack speichert dabei `int`-Werte. 
Der Einfachheit halber wird in dieser Aufgabe als interne Darstellung von Wahrheitswerte `int`s verwendet.
Der Stack der Simulators besitzt eine feste Kapazität, die bei der Instanziierung festgelegt wird. 
Der `stackPointer` des Stacks zeigt dabei auf die oberste belegte Zelle.
Zudem verfügt eine Instanz von `Simulator` über einen Programmzähler `programCounter`,
der den Index des am nächsten auszuführenden Befehls speichert und ein Attribut `halted`, das speichert, ob ein `HALT` ausgeführt wurde.
Der Simulator nimmt bei Aufruf der Funktion `executeInstructions` dei bei der Instanziierung übergebenen Instruktionen und führt diese aus.
Zudem gibt es einen `Parser`, welcher eine Textdatei in ein `Instruction` Array umwandelt.

## Stackframes

Unsere MiniJVM soll auch in der Lage sein Funktionen aufzurufen.  
Unsere Funktionen benötigen unter Umständen Variablen, und sollen auf diese zugreifen können. Wenn die `CALL` instruktion wie ein `JUMP` funktionieren würde, würde `LOAD 0` auf die gleiche Variable zugreifen wie vor dem `CALL`. Das wäre an sich nicht sonderlich schlimm. Da aber der Wert des Stackpointers unbekannt ist, kann, selbst wenn man mit `ALLOC` Platz dafür erstellt, nicht auf eigene Variablen zugegriffen werden. Aus diesem Grund, gibt es das Konzept des Stackframes.  
Stackpointer ermöglichen 2 Dinge:
* Das Rückspringen aus einer Funktion ohne explizit die Rücksprungadresse zu Programmieren.
* Das nutzen von Lokalen Variablen.

Stackframes sind wie folgt aufgebaut:

Um wieder an die Stelle zurück zu springen, von der aus die Funktion aufgerufen wurde, wird zuerst der aktuelle `programCounter` auf den Stack gepushed.
Anschließend wird, um ihn ebenso zu sichern, der `stackOffset`des alten Frames gepushed.
Nun muss der `stackOffset` noch aktualisiert werden. Der stackOffset soll so gewählt werden, dass man mit `LOAD 0` auf das erste Element am Stack, nach dem gesicherten `stackOffset` zugreifen kann.

Die Dateien sind im Template bereits vorhanden. Die abstrakte Klasse `Instruction` ist wie die Klasse `Stack` bereits definiert.

# Aufgaben

## Der Simulator
[task][Implement simExProg]( 259185 )
[task][Extra tests]( 259197 )
[task][Extra tests]( 259192 )

- Implementiert einen `Simulator`, welcher miniJVM Instruktionenen Ausführen kann. Im Konstruktor soll eine `stackSize` und eine `Instruction` Array übergeben werden. Die `Instructions` werden gespeichert, und ein Stack entsprechender größe wird erstellt.
- Die `executeInstructions` Methode soll kontinuierlich die Instruktionen aus dem im Konstruktor übergebenen Array ausführen. Begonnen wird an Index 0. Die Instruktionen werden, sollange nicht gesprungen wird, nach einander ausgeführt. Ist das `halted` Attribut gesetzt, wird das Ausführen beendet.
- Es kann davon ausgegangen werden, dass alle übergebenen Programme dafür sorgen, dass der `programCounter` innherhalb des Programms bleibt. Es soll dementsprechend nichts abgefangen werden.

## Die Instruktionen
[task][Tests]( 259211 , 259196 , 259208 , 259187 , 259205 , 259203 , 259195 , 259213 , 259189 , 259191 , 259207 , 259212 , 259217 , 259219 , 259180 , 259209 , 259179 , 259218 , 259183 , 259199 , 259202 , 259214 , 259206 , 259220 , 259216 , 259190 , 259210 )

- Die Objekte der Klassen, die die Instruktionen für `CONST i`, `ALLOC i`, `LOAD i`, `STORE i`, `JUMP i`, `FJUMP i`, `CALL i` darstellen,
sollen jeweils einen `int`-Attribut besitzen, welches den Parameter `i` des Befehls abspeichert.
Erstellt in den Klassen für diese Befehle jeweils einen öffentlichen Konstruktor, 
der einen `int`-Parameter erwartet, und das jeweilige Attribut damit initialisiert.
- Implementiert für jede konkrete Klasse von Instruktionen die Methode `public void execute(Simulator simulator)`, welche den Stack je nach Befehl passend verändert.
Das Verhalten von `execute(...)` bei den unterschiedlichen Instruktionen ist dabei wie folgt:
    - `ADD`: Nimmt die beiden obersten Elemente vom Stack und setzt das Ergebnis der Addition auf dem Stack.
    - `SUB`: Nimmt die beiden obersten Elemente `a`, `b` vom Stack und setzt das Ergebnis von `b - a` auf den Stack.
    - `CONST i`: Lädt die Konstante `i` auf den Stack
    - `ALLOC i`: Erhöht den Stackpointer um `i`. Ihr könnt dazu die Methode `alloc` von Stack verwenden.
    - `LOAD i`: Liest den Wert am Index `i` des Stackframes ein und legt ihn auf den Stack.
    - `STORE i`: Nimmt den obersten Wert vom Stack und speichert ihn am Index `i` des Stackframes.
    - `LESS`: Nimmt die beiden obersten Elemente `a`, `b` vom Stack und legt das Ergebnis des Vergleichs `b < a` als `int` codiert auf den Stack.
       dabei soll der Wahrheitswert `true` durch eine `1` codiert werden, der Wahrheitswert `false` durch eine `0`.
    - `JUMP i` soll einen Sprung zum Befehl am Index `i` umsetzen.
    - `AND` nimmt die beiden oberen Elemente vom Stack und setzt das Ergebnis eines logischen Undes wieder auf den Stack. Als wahr zählen alle Werte, welche nicht 0 sind.
    - `NOT` Invertiert den Wahrheitswert des obersten Elementes auf dem Stack.
    - `FJUMP i` Nimmt das oberste Element vom Stack. Falls der Wert dieses Elements `0` ist, soll
       ein Sprung zum Befehl am Index `i` durchgeführt werden. Andernfalls wird kein Sprung durchgeführt und der Programmfluss geht normal weiter.
    - `CALL i` soll den aktuellen Stackframe wie beschrieben sichern, den `stackOffset` anpassen und die Ausführung an der übergebenen Adresse fortsetzen.
    - `RET` verlässt den aktuellen Stackframe und setzt den Simulator auf den zuvor gespeicherten Zustand zurück.
    - `HALT` soll das Programm beenden. Dazu soll das `halted`-Attribut des Simulators auf `true` gesetzt werden.
- Alle Instruktionen mit Parameter sollen zudem eine `getParameter` Methode haben, mit welcher man diesen abrufen kann.

## Der Parser
[task][Parser Tests]( 259198 , 259188 , 259200 , 259184 , 259201 )
- Damit das schreiben von Programmen möglichst einfach wird, soll ein Parser implementiert werden, welcher einen String in ein MiniJVM Programm übersetzt.
- Implementiert die statische Methode `instructionsFromString` welche diese Aufgabe übernimmt.
- Die der `instructionsFromString` Methode übergebenen Strings sind wie folgt aufgebaut:
    - `;` Am Anfang einer Zeile definiert einen Kommentar welcher ignoriert wird.
    - `:` Am Ende einer Zeile definiert ein Label (Label beinhalten keine weiteren Doppelpunkte)
    - Sämtliche anderen zeilen sind valide Instruktionen
        - Instruktionen welche den `programCounter` verändern können als Parameter sowohl ein Label als auch eine Adresse haben.
        - Label können sowohl bereits über der Instruktion definiert worden sein, als auch erst nach der Instruktion folgen.
        - Direkte Sprungadressen beziehen sich auf den n-ten Befehl im Programm und nicht auf die n-te Zeile
- Auf jeder Zeile des Eingabe Strings befindet sich nur ein Befehl.
- Man kann davon Ausgehen, dass nur Valide Zeilen enthalten sind.
- Es gibt keinen Whitespace am Anfang der Zeile.
 
## Testen 

Schreibt für 5 Beliebige Instruktionen je mindestens 2 Tests, welche deren jeweilige `execute()`-Methode testen.
Hierfür gibt es 2 Punkte welche erst mit der manuellen Bewertung vergeben werden. Wie gewohnt sollt ihr auch eure Tests wieder mit Kommentaren erklären.

## Ein Besipiel
[task][Sample Program Test]( 259186 )
Gegeben ist folgendes Programm:
```
 1 |; Dieses Programm berrechnet 6(Zeile 7) * 6 (Zeile 9)
 2 |; Initialisierung von Variablen
 3 |Start:
 4 |ALLOC 3
 5 |CONST 0
 6 |STORE 0
 7 |CONST 6
 8 |STORE 1
 9 |CONST 6
10 |STORE 2
11 |; Hier fängt der Loop an
12 |Loop:
13 |LOAD 0
14 |LOAD 1
15 |ADD
16 |STORE 0
17 |LOAD 2
18 |CONST 1
19 |SUB
20 |; Wenn der Multiplikand 0 ist, ist das Programm beendet
21 |FJUMP End
22 |ALLOC 1
23 |STORE 2
24 |JUMP Loop
25 |End:
26 |LOAD 0
27 |HALT
```

welches nach der Ausführung 36 als oberstes Element auf dem Stack haben sollte.

[task][CALL Beispielprogramm]( 259204 )

```  
  1 |; -- Start --
  2 |CONST 4
  3 |CALL Square
  4 |HALT
  5 |;
  6 |; This function squares the preceding value
  7 |Square:
  8 |LOAD -3
  9 |LOAD -3
 10 |CALL Mul
 11 |STORE -3
 12 |RET
 13 |;
 14 |; This function multiplies the preceding two values
 15 |Mul:
 16 |ALLOC 3
 17 |CONST 0
 18 |STORE 0
 19 |LOAD -3
 20 |STORE 1
 21 |LOAD -4
 22 |STORE 2
 23 |Loop:
 24 |LOAD 0
 25 |LOAD 1
 26 |ADD
 27 |STORE 0
 28 |LOAD 2
 29 |CONST 1
 30 |SUB
 31 |FJUMP End
 32 |ALLOC 1
 33 |STORE 2
 34 |JUMP Loop
 35 |End:
 36 |LOAD 0
 37 |STORE -3
 38 |RET
 ```
 
 Das Oberste Element auf dem Stack sollte nach Ausführen des Programmes 16 sein.
 
 Die Zeilennummern welche in den beiden Beispielprogrammen hinzugefügt wurden, werden natürlich nicht dem Parser übergeben.
[task][Extra Tests]( 259194 )

# Hinweise:
- Bei Instruktionen welche mehrere Werte vom Stack verwenden, ist der untere Wert links des Operanden
- Eine Stack-Instanz verfügt insbesondere über folgende Methoden, die ihr bei der Implementierung verwenden könnt:
    - `pop()` : Liefert das Element am Stackpointer zurück und dekrementiert den Stackpointer
    - `push(int value)`: Inkrementiert den Stackpointer um eins und speichert `value` am neuen Index des Stackpointers.
    - `alloc(int count)`: Erhöht den Stackpointer um `count`.
    - `setValueAtIndex(int index, int value)`: Setzt den Wert bei `index` auf `value`
- Der Programmzähler des Simulators kann mit `setProgrammCounter(...)` gesetzt werden.
- Ihr könnt davon ausgehen, dass die Stackgrößen und Instruktionsfolgen des MiniJVM-Codes mit denen getestet wird, bei korrekter Umsetzung keinen Stackoverflow oder Stackunderflow produzieren.
- Verändern Sie den Code von `Instruction` und `Stack` nicht."
443,Funktionale Programmierung und Verifikation SS25,16636,Week 00 Tutorial 01 — Truth Tables and Equivalence,"## Recap: Truth Tables and Equivalence

Verify the following equivalences using truth tables.

1. Prove **De Morgan’s Law**:  
   $$ \neg (P \land Q) \equiv \neg P \lor \neg Q $$.  
2. Show:  
   $$ P \implies Q \equiv \neg P \lor Q $$.  

Do you think truth tables are always a good way to prove logical equivalences? What other methods could be used?

**Hint**: Introduce new columns for sub-expressions and build the truth table step by step."
443,Funktionale Programmierung und Verifikation SS25,16637,"Week 00 Tutorial 02 — Equivalence, Tautologies and Contradictions","# Recap: Logic
Logical expressions can often be rewritten in simpler or more useful forms by applying certain equivalence laws. 

## Equivalence Logic Laws
- Double Negation:
 $$\lnot \lnot A \equiv A$$

- Idempotence:
    - $$A \land A \equiv A$$
    - $$A \lor A \equiv A$$
   
- De Morgan:
    - $$\lnot(A \lor B) \equiv \lnot A \land \lnot B$$
    - $$\lnot(A \land B) \equiv \lnot A \lor \lnot B$$

- Distributivity:
    - $$ A \land (B \lor C) \equiv (A \land B) \lor (A \land C)$$
    - $$ A \lor (B \land C) \equiv (A \lor B) \land (A \lor C)$$

- Absorption:
    - $$ A \lor (B \land A) \equiv A$$
    - $$ A \land (B \lor A) \equiv A$$


## Recap: Tautologies and Contradictions
Tautologies are logical statements that are always true and contradictions are logical statements that are always false.
- $$A \lor \lnot A \equiv true$$
- $$A \land \lnot A \equiv false$$

## Tautology and Contradiction Rules
- $$ A \land false \equiv false$$
- $$ A \lor false  \equiv A$$
- $$ A \land true \equiv A$$
- $$ A \lor true \equiv true$$


### Exercise 1: Simplifying the Expression
Simplify the following and state the equivalence law used in each step. 

1. $$\lnot(A \land \lnot B) \lor \lnot A$$
2. $$\lnot(\lnot A \lor \lnot B) \lor (A \land C)$$
3. $$\lnot(\lnot A \land (\lnot B \lor \lnot A))$$
4. $$ (A \land (B \lor \lnot D)) \lor (A \land D) $$ 
5. $$ (A \lor (B \land (C \lor B))) \land \lnot B $$"
443,Funktionale Programmierung und Verifikation SS25,16638,Week 00 Tutorial 03 — Quantifiers,"# First-order logic: Quantifiers
Beyond basic logic operators, first-oder logic introduces quantifiers which allow us to specify whether a formula holds for all instances of a variable or at least one.

We will primarily use the following two:
- The Universal quantifier: $$\forall$$
    - $$\forall x.\; P\: x$$ holds iff¹ $$P\: x$$ holds for every $$x$$
- The Existential quantifier: $$\exists$$
    - $$\exists x.\; P\: x$$ holds iff there exists at least one $$x$$ for that $$P\: x$$ holds

## Exercise 1: Formulas
Decide if the following formulas hold. If they don't, provide a counter-example.
1. $$(\forall x.\; P\: x\; \lor\; Q\: x)\; \stackrel{?}{\equiv}\; (\forall x.\; Q\: x\; \lor\; P\: x)$$
1. $$(\forall x.\; P\: x\; \lor\; Q\: x)\; \stackrel{?}{\equiv}\; (\forall x.\; P\: x)\; \lor\; (\forall x.\; Q\: x)$$
1. $$(\forall x.\; P\: x\; \land\; Q\: x)\; \stackrel{?}{\equiv}\; (\forall x.\; P\: x)\; \land\; (\forall x.\; Q\: x)$$
1. $$\lnot(\forall x.\; P\: x)\; \stackrel{?}{\equiv}\; (\exists x.\; P\: x)$$
1. $$(\forall x.\; \exists y.\; P\: x\: y)\; \stackrel{?}{\implies}\; (\exists y.\; \forall x.\; P\: x\: y)$$
1. $$(\exists x.\; \forall y.\; P\: x\: y)\; \stackrel{?}{\implies}\; (\forall y.\; \exists x.\; P\: x\: y)$$


## Exercise 2: One-Point Rule
Decide for each quantifier which formula holds. For the incorrect formula show why it doesn't hold.

- Universal quantifier:
    1. $$(\forall x.\; x\; =\; t\; \land\; P\: x)\; \iff\; P\: t$$
    1. $$(\forall x.\; x\; =\; t\; \implies\; P\: x)\; \iff\; P\: t$$
- Existential quantifier:
    1. $$(\exists x.\; x\; =\; t\; \land\; P\: x)\; \iff\; P\: t$$
    1. $$(\exists x.\; x\; =\; t\; \implies\; P\: x)\; \iff\; P\: t$$

---
[1]: ""if and only if"""
443,Funktionale Programmierung und Verifikation SS25,16639,Week 01 Tutorial 01 — Recap: Implications,"# Recap: Implications

Remember that an implication $$A \implies B$$ states an *if-then* relation: If $$A$$ is satisfied, then $$B$$ is satisfied as well. Let $$x,y \in \Z$$ and let $$A,B$$ be arbitrary formula. Decide, which of the following implications hold:

1. $$x = 1 \implies 0 < x$$
1. $$x < 6 \implies x = 3$$
1. $$x > 0 \implies x \geq 0$$
1. $$x = -2 \implies x < -1 \lor x > 1$$
1. $$x = 0 \lor x = 7 \implies 4 \;\mathrlap{\,/}{=}\; x$$
1. $$x = 1 \implies x \leq 3 \land y > 0$$
1. $$x < 8 \land y = x \implies y \;\mathrlap{\,/}{=}\; 12$$
1. $$x = 1 \lor y = 1 \implies x > 0$$
1. $$x \;\mathrlap{\,/}{=}\; 5 \implies false$$
1. $$true \implies x \;\mathrlap{\,/}{=}\; y$$
1. $$false \implies x = 1$$
1. $$x \geq 1 \implies 2x + 3 = 5$$
1. $$A \land x = y \implies A$$
1. $$B \implies A \lor B$$
1. $$A \implies (B \implies A)$$
1. $$(A \implies B) \implies A$$

*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16640,Week 01 Tutorial 02 — Assertions,"# Assertions

Consider the following control flow graph:

![blatt0102.svg](/api/core/files/markdown/Markdown_2021-10-05T21-17-48-171_37998e81.svg)

1. Which of the following assertions hold at point $$A$$?
	- a) $$i \geq 0$$
	- b) $$x = 0$$
	- c) $$i \leq 10  \land x \;\mathrlap{\,/}{=}\; 0$$
	- d) $$true$$
	- e) $$i = 0$$
	- f) $$x = i$$
1. Which of the following assertions hold at point $$B$$?
	- a) $$x = 0 \land i = 0$$
	- b) $$x = i$$
	- c) $$i < x$$
	- d) $$0 \leq i \leq 10$$
	- e) $$i \geq 0 \land x \geq 0$$
	- f) $$n = 1 \implies x = i$$
1. Which of the following assertions hold at point $$C$$?
	- a) $$i \geq 0$$
	- b) $$i = 10$$
	- c) $$i > 0$$
	- d) $$x \;\mathrlap{\,/}{=}\; n$$
	- e) $$x = 10n$$
	- f) $$x = i * n \land i = 10$$



*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16642,Week 01 Tutorial 04 — Strongest Postconditions,"# Strongest Postconditions

Using our understanding of strong and weak assertions, it is now possible to look at statements individually and, given an assertion $$A$$ that holds before a statement $$s$$, find the strongest assertion $$B$$ that holds after the statement. We call $$B$$ the *strongest postcondition* (of $$A$$ at statement $$s$$).
	
For each of the following statements, find the *strongest postcondition* $$B$$:

![blatt0104.svg](/api/core/files/markdown/Markdown_2021-10-05T21-19-04-014_cbb96167.svg)

 

*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16643,Week 01 Tutorial 03 — The Strong and the Weak,"# The Strong and the Weak

Again consider the assertions that hold at point $$C$$ of assignment 2. Discuss the following questions:
1. When annotating the control flow graph, can you say that one of the given assertions is ""better"" than the others?
1. Can you arrange the given assertions in a meaningful order?
1. How can you define a *stronger than* relation formally?
1. How do $$true$$ and $$false$$ fit in and what is their meaning as an assertion?
1. What are the strongest assertions that still hold at $$A$$, $$B$$ and $$C$$?



*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16644,Week 01 Quiz,
443,Funktionale Programmierung und Verifikation SS25,16742,Week 02 Tutorial 01 — From Post- to Preconditions,"# From Post- to Preconditions
Consider these control flow graphs:

1.     
    ![blatt0201-1.svg](/api/core/files/markdown/Markdown_2021-10-05T21-00-25-984_030f7cb5.svg)
2.     
    ![blatt0201-2.svg](/api/core/files/markdown/Markdown_2023-04-17T19-21-59-447_18651151.svg)
3.     
    ![blatt0201-3.svg](/api/core/files/markdown/Markdown_2021-10-05T21-00-58-733_7a140b52.svg)

 

1. For each of these graphs show whether the assertion $$Z$$ holds... 
    (a) ...using strongest postconditions and 
    (b) ...using weakest preconditions.
2. Discuss advantages and disadvantages of either approach.




*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16743,Week 02 Tutorial 02 — Local Consistency,"# Local Consistency

In the following control flow graph assertions are annotated to all the edges.  

![blatt0202.svg](/api/core/files/markdown/Markdown_2021-10-06T12-16-36-844_514693d9.svg)

Check whether the annotated assertions prove that the program computes an $$x \;\mathrlap{\,/}{=}\; 0$$ and discuss why this is the case.


 
*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16744,Week 02 Tutorial 03 — Trouble Sort,"# Trouble Sort

1. Annotate each program point in the following control flow diagram with a suitable assertion, then show that your annotations are locally consistent and prove that $$Z$$ holds at the given program point.
2. Discuss the drawbacks of annotating each program point with an assertion before applying weakest preconditions, and discuss how you could optimize the approach to proving that $$Z$$ holds.

![blatt0204.svg](/api/core/files/markdown/Markdown_2021-10-05T21-25-35-975_9fd1c152.svg)



*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16745,Week 02 Quiz,
443,Funktionale Programmierung und Verifikation SS25,16844,Week 03 Tutorial 02 — Loop Invariants,"# Loop Invariants

A program computes the factorial of its input:  
![W03T02.svg](/api/core/files/markdown/Markdown_2022-05-19T15-19-22-418_39511dfe.svg)  
Perform the following tasks:  
1. Discuss the problem that arises when computing weakest preconditions to prove $$Z$$.
2. How can you use weakest preconditions to prove $$Z$$ anyway?
3. Try proving $$Z$$ using the the loop invariants $$x \geq 0$$ and $$i = 0 \land x = 1 \land n = 0$$ **at the end of the loop body** and in particular discuss these questions:
    - a) How has a useful loop invariant be related to $$Z$$?
    - b) What happens if the loop invariant is chosen too strong?
    - c) What happens if the loop invariant is chosen too weak?
    - d) Can you give a meaningful lower and upper bound for useful loop invariants?
4. Retry proving $$Z$$ using the loop invariant $$x = i!$$ (again at the end of the loop body) and improve this invariant until the proof succeeds.



*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16845,Week 03 Tutorial 01 — MiniJava 2.0,"# MiniJava 2.0

In the lecture, the weakest precondition operator has been defined for all statements of
MiniJava. In this assignment, we consider an extension of the MiniJava language, which
provides four new statements:

1. `rand x`:  
Assigns a random value to variable $$x$$,
2. `x = either e0, e1, ..., ek`:  
Assigns one of the values of the expressions $$e_0,\dotsc,e_k$$ to variable `x` non-deterministically,
3. `x = e in a, b`:  
Assigns the value $$1$$ to variable `x`, if the value of expression `e` is in
the range $$[a, b]$$ and $$0$$ if `e` is not in the range or the range is empty $$(a > b)$$,
4. `stop`:  
Immediately stops the program.

Define the weakest precondition operator $$ {\bf WP} ⟦ \dots ⟧(B) $$ for each of these statements.

*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16846,"Week 03 Tutorial 03 — Two b, or Not Two b","# Two b, or Not Two b

Prove $$Z$$ using weakest preconditions.

![blatt0303.svg](/api/core/files/markdown/Markdown_2021-10-19T22-18-06-386_21298478.svg)



*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16848,Week 03 Quiz,
443,Funktionale Programmierung und Verifikation SS25,16920,Week 04 Tutorial 01 — Y?,"# Y?

Consider this control flow graph fragment (assume $$x$$ and $$y$$ to be $$0$$ initially):

 
 
 

Find a suitable loop invariant and prove it locally consistent.

*Note: We follow the standard practice that the empty sum, where the number of terms is zero, is $$0$$, e.g.: $$\sum_{k = 0}^{-1} \left( \dots \right) = 0$$.*

*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16921,Week 04 Tutorial 02 — Termination,"# Termination

In the lecture, you have learned how to prove termination of a MiniJava program. Discuss these questions:
1. How can you decide whether a termination proof is required at all?
2. What is the basic idea of the termination proof?
3. How is the program to be modified?
4. What has to be proven?
5. How is the loop invariant influenced?


*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16922,Week 04 Tutorial 03 — A Wavy Approach,"# A Wavy Approach

Prove termination of the following program:

 
 
 


*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16923,Week 04 Supplemental 01 — Loloopop,"# Loloopop

Prove $$Z$$ using weakest preconditions.


 
 
 


*__Hint:__ If you have to find invariants for nested loops, it is usually easiest to work from outermost loop to innermost loop.*

*Note: This is a supplemental exercise, it will neither be discussed in the tutorials nor is a submission needed for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16924,Week 04 Supplemental 02 — Counter Time,"# Counter Time

Prove that the following program does indeed terminate for all inputs.


 
 
 


*Note: This is a supplemental exercise, it will neither be discussed in the tutorials nor is a submission needed for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16925,Week 04 Supplemental 03 — A Neverending Story,"# A Neverending Story

Prove that the following program cannot terminate using weakest preconditions.

 
 
 


*Note: This is a supplemental exercise, it will neither be discussed in the tutorials nor is a submission needed for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16926,Week 04 Quiz,
443,Funktionale Programmierung und Verifikation SS25,16956,Week 05 Tutorial 01 — Expressions,"# Expressions

So far, you learned about the following types of expressions:
* Constants
* Variables
* Unary operators
* Binary operators
* Tuples
* Records
* Lists
* If-then-else
* Pattern matching
* Function definition
* Function application
* Variable binding

Perform the following tasks:
1. For each of the aforementioned types of expressions, give the general structure and two concrete examples with different subexpressions.
2. For the following expressions, list all contained subexpressions and give their corresponding types. Then evaluate the expressions:

```ocaml
(* a *) let a = fun x y -> x + 2 in a 3 8 :: []
```

```ocaml
(* b *) ((fun x -> x::[]) (9 - 5), true, ('a', 7))
```


*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16957,Week 05 Tutorial 02 - What is the Point,"# What's the point?

Using what you learned about tuple types in the lecture, implement functionality for computing with three-dimensional vectors. 

1. [task][Define a suitable data type for your point.]( 289361 )
    The type `vector3` should be a tuple of 3 float values.
1. [task][Define three points]( 289364 )
    The points `p1`, `p2` and `p3` should all be different, but their exact values don't matter.
    Use them, along with other points, to test your functions.
1. [task][string_of_vector3]( 289363 )
    Implement a function `string_of_vector3 : vector3 -> string` to convert a vector into a human-readable representation.  
    For example, the string for the zero vector should be: `(0.,0.,0.)`.  
    **Hint**: use `string_of_float` to convert components.
1. [task][vector3_add]( 289368 )
    Write a function `vector3_add : vector3 -> vector3 -> vector3` that adds two vectors component-wise.
1. [task][vector3_max]( 289367 )
    Write a function `vector3_max : vector3 -> vector3 -> vector3` that returns the larger argument vector (the vector with the greater magnitude).
1. [task][combine]( 289366 )
    Write a function `combine : vector3 -> vector3 -> vector3 -> string` that adds its first argument to the larger of the other two arguments and returns the result as a string.

*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16958,Week 05 Tutorial 03 - Student Database,"# Student Database

In this assignment, you have to manage the students of a university.

1. [task][Type declarations]( 289371 )
    First you need to define some types.
    - Define a data type for a `student`.

        A student should be represented as a record of the student's:
        - `first_name`, a string
        - `last_name`, a string
        - identification number `id`, an `int`
        - number of the current `semester`, as well as
        - the list of `grades` received in different courses

         
        Each grade should be a pair of the course number and the grade value, as a floating point number.

    - To actually manage students, you need a `database`, which shall be represented as a list of students.
3. [task][insert]( 289375 )
    Write a function `insert : student -> database -> database` that inserts a student into the database.
4. [task][find_by_id]( 289374 )
    Write a function `find_by_id : int -> database -> student list` that returns a list with the (first) student with the given id (either a single student or an empty list, if no such student exists).
5. [task][find_by_last_name]( 289373 )
    Implement a function `find_by_last_name : string -> database -> student list` to find all students with a given last name.

*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16959,Week 05 Homework 01 - More Students,"# More Students!
In this assignment you will extend the student database introduced in [W05T03](https://artemis.tum.de/courses/443/exercises/16958). All type definitions and functions developed in W05T03 are already in the template.

Implement these new functions:
1. [task][remove_by_id]( 289388 , 289381 , 289380 )
    `remove_by_id : int -> database -> database` removes the student with the given id from the database.
2. [task][count_in_semester]( 289387 , 289386 , 289384 )
    `count_in_semester : int -> database -> int` counts the number of students in the given semester.
3. [task][student_avg_grade]( 289383 , 289382 , 289379 )
    `student_avg_grade : int -> database -> float` computes the average grade of the student with the given id. If no student with the given id exists or the student does not have any grades, the function shall return `0.0`.
4. [task][course_avg_grade]( 289378 , 289377 , 289376 )
    `course_avg_grade : int -> database -> float` computes the average grade achieved in the given course. If no grades in the given course exist, the function shall return `0.0`.

*Note: This is a homework exercise; you must submit your own individual solution and the points count towards the grade bonus. This exercise is graded automatically; use the tests on Artemis to check your score.*"
443,Funktionale Programmierung und Verifikation SS25,16960,Week 05 Homework 02 - List Mishmash,"# List Mishmash

[task][interleave3]( 289392 , 289391 , 289390 , 289389 , 289393 )

Implement a function `interleave3 : 'a list -> 'a list -> 'a list -> 'a list`
that interleaves three lists. So for input lists `[0; 1; 2]`, `[10; 11; 12]` and `[20; 21; 22]` the function must return the list `[0; 10; 20; 1; 11; 21; 2; 12; 22]`.

If a list is out of elements (e.g. for inputs of different lengths), the function continues interleaving the remaining lists, such that for inputs `['a'; 'b']`, `['A'; 'B'; 'C'; 'D']` and `['!']` the output `['a'; 'A'; '!'; 'b'; 'B'; 'C'; 'D']` is produced.

*Note: This is a homework exercise; you must submit your own individual solution and the points count towards the grade bonus. This exercise is graded automatically; use the tests on Artemis to check your score.*"
443,Funktionale Programmierung und Verifikation SS25,16961,Week 05 Homework 03 - OCamlfication,"# OCamlfication

[task][foo]( 289399 , 289397 , 289396 )

Consider the following function foo implemented in an imperative programming language:
```java
int foo(int x, int y, bool b) {
    if(x > y) {
        int t = x;
        x = y;
        y = t;
    }
    while(x < y) {
        if(b) {
            ++x;
        } else {
            --y;
        }
        b = !b;
    }
    return x;
}
```
Implement a semantically equivalent function `foo : int -> int -> bool -> int` in OCaml.

*Note: This is a homework exercise; you must submit your own individual solution and the points count towards the grade bonus. This exercise is graded automatically; use the tests on Artemis to check your score.*"
443,Funktionale Programmierung und Verifikation SS25,16962,Week 05 Homework 04 - Polynomial Party,"# Polynomial Party

A polynomial
$$
c_nx^n + c_{n-1}x^{n-1} + \dotsc + c_2x^2 + c_1x + c_0
$$
is represented by the list $$[c_n;c_{n-1};\dotsc;c_2;c_1;c_0]$$ of its coefficients.

1. [task][eval_poly]( 289409 , 289413 , 289412 )
    Implement `eval_poly : float -> float list -> float` that evaluates the polynomial (second argument) for a given $$x$$ (first argument).
2. [task][derive_poly]( 289411 , 289418 , 289414 )
    Implement `derive_poly : float list -> float list` that returns the first derivative of the given polynomial.

*Note: This is a homework exercise; you must submit your own individual solution and the points count towards the grade bonus. This exercise is graded automatically; use the tests on Artemis to check your score.*"
443,Funktionale Programmierung und Verifikation SS25,16995,Week 06 Tutorial 02 - The List Module,"# The List Module

Check the documentation of the OCaml `List` module [here](https://ocaml.org/api/List.html) and find out what the following functions do. Then implement them yourself. Make sure your implementations have the same type. In cases where the standard functions throw exceptions, you may just `failwith ""invalid""`.

1. [task][hd]( 289653 )
Implement the function `hd`

2. [task][tl]( 289659 )
Implement the function `tl`

3. [task][length]( 289655 )
Implement the function `length`

4. [task][append]( 289660 )
Implement the function `append`

5. [task][rev]( 289651 )
Implement the function `rev`

6. [task][nth]( 289647 )
Implement the function `nth`

**Restriction:** You may not use any operations from the List module (e.g., `List.append / (@)`, `List.length`, `List.map`, etc.). Implement the required functionality manually instead.

*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16996,Week 06 Tutorial 03 - Binary Search Trees,"# Binary Search Trees

In this assignment, a collection to organize integers shall be implemented via binary search trees.

1. Define a suitable data type `tree` for binary trees that store integers. Each node in the binary tree should either be
    - an inner node which stores a value of type `int` and has a left and a right child of type `tree`, or
    - a leaf node and contain no value.

Since you are free to define your `tree` type however you wish (the type `tree` is said to be *abstract*), we need to define functions for creating trees.
2. Define functions `node` and `leaf`, which should create inner nodes and leaves, respectively:
    - `node v l r` should create an inner node with the value `v`, left child `l` and right child `r`,
    - `leaf ()` should create an leaf node of your `tree` type.

Similarly, we need a function that allows us to inspect the structure of your tree, specifically to access the children of a node.
The OCaml `Option` type ([API documentation for Option](https://ocaml.org/api/Option.html)) allows us to cleanly distinguish between the presence of absence of a value.
Here, we will use it to distinguish between inner nodes, which have children, and leaf nodes, which do not.
Using the `Option` type and returning `None` instead of raising an exception is (often) good functional programming style!
3. Define the function `inspect`, which allows us to access the children of a node:
    - `inspect n`, where `n` is an inner node of your `tree` type with the value `v` and children `l` and `r`, should return `Some (v, l, r)`. Here, `Some` is used to indicate the *presence* of a value and children.
    - `inspect l`, where `l` is a leaf of your `tree` type (with no children), should return `None`. Here, `None` is used to indicate the *absence* of a value and children.

 
 *Note: if you are having difficulty with the above tasks, you may use the following template* (click to expand) 

```ocaml
type tree = Node of int * tree * tree | Empty

let leaf _ = Empty

let node v l r = Node (v, l, r)

let inspect = function
  | Node (v, l, r) -> Some (v, l, r)
  | Empty -> None
```

 

Now, implement the following functions on your `tree` type:

4. Define a binary tree `t1` which contains the values $$8$$, $$12$$, $$42$$, $$1$$, $$6$$, $$9$$, $$8$$. To construct the tree, start with an empty tree, then insert the given values in order.
5. Implement a function `to_list : tree -> int list` that returns an ordered list of all values in the tree.
6. Implement a function `insert : int -> tree -> tree` which inserts a value into the tree. If the value exists already, the tree is not modified.
7. Implement a function `remove : int -> tree -> tree` to remove a value (if it exists) from the tree. Upon removing a value from an inner node:
    - if either child of the inner node is empty, replace the entire inner node with the other child, otherwise
    - if neither child of the inner node is empty, the value should be replaced with the largest value from the *left* subtree.

    Examples. To make the following examples simpler, we define `inode v = node v (leaf ()) (leaf ())` for an inner node with the given value and two empty children:
    - `remove 0 (leaf ()) = leaf ()`
    - `remove 0 (inode 0) = leaf ()`
    - `remove 1 (node 1 (inode 0) (leaf ())) = inode 0`
    - `remove 0 (node 0 (leaf ()) (inode 1)) = inode 1`
    - `remove 1 (node 1 (inode 0) (inode 2)) = node 0 (leaf ()) (inode 2)`

*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,16997,Week 06 Homework 01 - Peano Arithmetic,"# Peano Arithmetic

The natural numbers can be defined recursively as follows:
- 0 is a natural number.
- if $$n$$ is a natural number, then so is the successor of $$n$$

We can easily represent this in OCaml using corresponding constructors:

```ocaml
type nat = Zero | Succ of nat
```

Implement the following functions for natural numbers:

First convert between integers and naturals in the file `conv.ml`
1. [task][int_to_nat]( 289700 )
    `int_to_nat : int -> nat` converts an integer to natural.
1. [task][nat_to_int]( 289680 )
    `nat_to_int : nat -> int` converts a natural to integer.

Then implement some operations on naturals in the file `ops.ml`:
1. [task][add]( 289685 )
    `add : nat -> nat -> nat` adds two natural numbers.
1. [task][mul]( 289691 )
    `mul : nat -> nat -> nat` multiplies two natural numbers.
1. [task][pow]( 289684 )
    `pow : nat -> nat -> nat` a call `pow a b` computes $$a^b$$.
1. [task][leq]( 289694 )
    `leq : nat -> nat -> bool` a call `leq a b` computes $$a \leq b$$.

You are not allowed to use integers to implement the operations on naturals! That includes arithmetic operations like `+`, `-`, and `*`, as well as comparisons like `=` and `<=`. Artemis will tell you if you use a value you're aren't allowed to.

 Click here to see exactly which functions are not allowed in this exercise 

The following functions and modules can't be used for your implementation in `ops.ml`:

- Comparison operators: `( = )`, `( <> )`, `( < )`, `( > )`, `( <= )`, `( >= )`, `compare`, `min`, `max`
- Integer operations: `( ~- )`, `( ~+ )`, `succ`, `pred`, `( + )`, `( - )`, `( * )`, `( / )`, `( mod )`, `abs`, `( land )`, `( lor )`, `( lxor )`, `lnot`, `( lsl )`, `( lsr )`, `( asr )`, `max_int`, `min_int`
- Float operations: `( ~-. )`, `( ~+. )`, `( +. )`, `( -. )`, `( *. )`, `( /. )`, `( ** )`, `exp`, `expm1`, `acos`, `asin`, `atan`, `atan2`, `hypot`, `cos`, `cosh`, `acosh`, `log`, `log10`, `log1p`, `sin`, `sinh`, `asinh`, `sqrt`, `tan`, `tanh`, `atanh`, `ceil`, `floor`, `abs_float`, `copysign`, `mod_float`, `frexp`, `ldexp`, `modf`, `float`, `float_of_int`, `truncate`, `int_of_float`, `infinity`, `neg_infinity`, `nan`, `max_float`, `min_float`, `epsilon_float`, `fpclass`, `classify_float`
- The following modules: `Int`, `Int32`, `Int64`, `Nativeint`, `Float`

 


*Note: This is a homework exercise; you must submit your own individual solution and the points count towards the grade bonus. This exercise is graded automatically; use the tests on Artemis to check your score.*"
443,Funktionale Programmierung und Verifikation SS25,16998,Week 06 Homework 02 - Expression Evaluation,"# Expression Evaluation

We define expressions over rationals using these OCaml types:

```ocaml
type rat = int * int (* num, denom *)
type unary_op = Neg
type binary_op = Add | Sub | Mul | Div
type expr = Const of rat
          | UnOp of unary_op * expr
          | BinOp of binary_op * expr * expr
```

*****
[task][eval_expr]( 289711 )

Implement a function
```ocaml
eval_expr : expr -> rat
```
that evaluates the given expression. The resulting fraction **must** be irreducible (i.e. simplified or in lowest terms), so for example `(-3,2)` and `(3,-2)` are accepted, but `(-6,4)` and `(12,-8)` are **not**. Be careful to avoid integer overflow **during** evaluation.

You **may** assume that all expressions passed to `eval_expr` will not cause division by zero to occur.

You may **not** assume that all `rat`s passed to `eval_expr` will be irreducible.

*****

Example:
```ocaml
eval_expr (BinOp (Mul, BinOp (Sub, Const (3,8), Const (2,4)), Const (6,-3)))
```
evaluates to `(1,4)` (or `(-1,-4)`, but not `(2,8)`, `(-2,-8)`, ...)

*****

*Note: For this exercise, there are various different secret tests: the tests `3:private_tests_1 [hidden]` and `4:private_tests_2 [hidden]` are easier, as some edge cases are not tested. The tests `1:arbitrary_tests_small [hidden]` and `2:arbitrary_tests_large [hidden]`, on the other hand, contain all kinds of expressions and therefore also test your implementation on edge cases. If you pass only some of the tests, think about what edge cases may occur and how you can handle them. Click on your score at the top right of the page to see which tests are failing.*  
*Note: This is a homework exercise; you must submit your own individual solution and the points count towards the grade bonus. This exercise is graded automatically; use the tests on Artemis to check your score.*"
443,Funktionale Programmierung und Verifikation SS25,16999,Week 06 Homework 03 - Crawling on Trees,"# Crawling on Trees

Once again, consider binary trees, which we define as:

```ocaml
type tree = Empty | Node of int * tree * tree
```

In this assignment you will implement a crawler that walks along binary trees
and performs different operations. At any time, the crawler ""sits"" on a particular node
of the tree (this includes the `Empty`-leaf). In the following we refer to this node as the
current node. Furthermore, the crawler uses a stack to store trees.

*Hint: Recall that only the functional subset of OCaml is allowed in exercises, unless stated otherwise. The `Stack` module from the standard library uses imperative updates and is thus is not permitted. Instead, you have already seen a simple data structure for representing stacks functionally. For the full set of prohibited modules please refer to Moodle.*

Initially, the crawler is
positioned at the input tree’s root and is then instructed using the commands

```ocaml
type command = Left | Right | Up | New of int | Delete | Push | Pop
```
with the following meaning:
- `Left` moves the crawler to the current node's left child.
- `Right` moves the crawler to the current node's right child.
- `Up` moves the crawler up to the current node's parent node.
- `New x` replaces the current node (including all children) with a new node with value `x`.
- `Delete` removes the current node (including all children) leaving behind an `Empty`-leaf.
- `Push` pushes the subtree rooted at the current node onto the stack. The tree stays
unchanged.
- `Pop` replaces the subtree rooted at the current node with the topmost tree of the
stack. The tree is then popped from the stack.


1. [task][crawl]( 289726 , 289731 , 289729 )
Implement a function `crawl : command list -> tree -> tree` that executes a list of
crawler commands on the given tree.

You may assume that the list of commands is always valid, so there is no `Left` or `Right` when the crawler is already at a leaf, no `Up` when it is on the root and no `Pop` when the stack is empty.

*Note: The tricky part is to get the `Up` command right. If you do not manage to implement this correctly, leave it out and you will still get some points if the rest is correct.*

*Hint: The function `print_tree` is provided, that can be used to export your tree to the [dot-format](https://en.wikipedia.org/wiki/DOT_(graph_description_language)). You could use https://edotor.net/ to visualize the output.*

---

*Note: This is a homework exercise; you must submit your own individual solution and the points count towards the grade bonus. This exercise is graded automatically; use the tests on Artemis to check your score.*"
443,Funktionale Programmierung und Verifikation SS25,17000,Week 06 Tutorial 01 — Explicit Type Annotation,"# Explicit Type Annotation

In OCaml, types are inferred automatically, so there is no need to write them down explicitly. However, types can be annotated by the programmer. Discuss:

1. In the following `let`-binding, annotate the types of all subexpressions:

    ```ocaml
    let f = fun x y -> x, [y]
    ```
    
    Also annotate the type of `f`, and the type of the parameters `x` and `y` of the anonymous function.
    
2. When can explicitly annotated types be helpful?


*Note: This is a tutorial exercise, you do not need to submit anything for this exercise.*"
443,Funktionale Programmierung und Verifikation SS25,17001,Week 06 Supplemental 01 — Local Binding,"# Local Binding

Local (variable) bindings can be used to give names to intermediate results or helper functions inside other expressions (e.g. functions) such that they can be reused. Furthermore, they allow you to split your computation into smaller steps.

In the following expression, mark all subexpressions and for each use of a variable, decide where this variable is defined and what its value is during the evaluation of this expression.

```ocaml
let x =
    let f x y =
        let x = 2 * x in
        let y = y::[x] in
        let y x =
            let y = x::y in
            y @ y
        in
        let x = y 3 in
        1::x
    in 
    f 1 2
```

*Note: This is a supplemental exercise, it will neither be discussed in the tutorials nor is a submission needed for this exercise.*"
453,Grundlagenpraktikum Rechnerarchitektur,16481,Abschlussprojekt,"# Abschlussprojekt

Die Aufgabenstellung für das Abschlussprojekt sind im Repository ""Projektgruppen - Organisatorisches"" zu finden. 

Die Testumgebung versucht bei jedem push auf das Git-Repository das Skript build.sh auszuführen. Die Ausgabe des Skripts wird im Resultat des Testcases Build angezeigt. Dieser Test schlägt immer fehl, damit ihr die Ausgabe des Skripts sehen könnt.

Viel Erfolg bei Ihren Abschlussprojekten!"
453,Grundlagenpraktikum Rechnerarchitektur,16482,Wahl der Vortragstermine,"# Wahl der Vortragstermine

In dieser Aufgabe geben Sie Ihre Präferenzen für Ihren bevorzugten Zeitslot für die Abschlusspräsentation Ihrer Gruppe an. Wir weisen Sie darauf hin, dass die Abschlusspräsentationen eine bewertete Prüfungsleistung und für das Bestehen des Kurses notwendig ist.

Bitte achten Sie darauf, dass Sie durch diese Abgabe Ihre Präferenzen angeben können, wir allerdings nicht garantieren können, dass Sie einen Ihrer bevorzugten Zeitslots erhalten.

Nach Abgabe Ihrer Auswahl wird automatisch überprüft, ob die Abgabe dem vorgegebenen Format entspricht. Bitte bessern Sie die Abgabe im Fall von Fehlern aus.

Wenn Sie Ihre Präferenzen nicht abgeben, oder ein ungültiges Format verwenden, werden Sie automatisch einem noch freien Termin zugeteilt.

Die Zeitslots für Termine sind absichtlich größer als nötig. Wenn Sie beispielsweise dem Termin 09:00-12:00 zugeteilt werden, kann es sein, dass Sie für die Präsentation erst um 10:00 Uhr antreten müssen. Wir empfehlen Ihnen aber trotzdem, den gesamten Zeitslot frei zu halten.

## Abgabeformat

Die Vorlage beinhaltet eine Auflistung von verschiedenen Terminen im Format

```
[ ] Datum, Uhrzeit
```

Jede Zeile beinhaltet einen möglichen Termin. Sie dürfen bis zu drei Termine Ihrer Wahl als Präferenz markieren. Zur Markierung Ihrer Präferenzen, geben Sie die Zahlen `1` bis `2` innerhalb der `[ ]` Ihrer bevorzugten Termine an, wobei `1` Ihrer ersten Wahl und `2` Ihrer zweiten Wahl entspricht.

Bitte löschen Sie keine der Termine aus der Liste, und ändern Sie keine der Daten und Uhrzeiten.

Eine korrekte Abgabe könnte beispielsweise so aussehen:

```
[1] 18.03.2024, 09:00-12:00
[ ] 19.03.2024, 13:00-16:00
[ ] 20.03.2024, 13:00-16:00
[2] 26.03.2024, 13:00-16:00
[ ] 27.03.2024, 13:00-16:00
[ ] 28.03.2024, 09:00-12:00
```"
453,Grundlagenpraktikum Rechnerarchitektur,16483,C Basics,
453,Grundlagenpraktikum Rechnerarchitektur,16484,Speicherbereiche und Optimierungen,
453,Grundlagenpraktikum Rechnerarchitektur,16485,Sichere Programmierung und Systemaufrufe,
453,Grundlagenpraktikum Rechnerarchitektur,16486,"Einführung in C++ & ""Hello SystemC""",
453,Grundlagenpraktikum Rechnerarchitektur,16487,SystemC & Kombinatorische Schaltungen,
453,Grundlagenpraktikum Rechnerarchitektur,16488,Sequentielle Schaltungen,
453,Grundlagenpraktikum Rechnerarchitektur,16489,Schaltkreisanalyse,
453,Grundlagenpraktikum Rechnerarchitektur,16492,P1-1 Collatz Orbit,"# Collatz-Orbit

Die Collatz-Vermutung besagt, dass für eine beliebige natürlich Zahl $$ n $$
folgende Transformation nach einer unbestimmten Anzahl von Iterationen immer bei
der Zahl $$ 1 $$ endet: wenn $$ n $$ gerade ist, wird $$ n\gets\frac n2 $$ ausgeführt,
andernfalls $$ n\gets 3\cdot n+1 $$.

Ein Collatz-Orbit für eine gegebene Zahl $$ n $$ enthält alle Zahlen, die nach
beliebig vielen Iterationsschritten besucht werden. Es soll nun berechnet
werden, welche Zahl des Orbits nach der $$ k $$-ten Iteration erreicht wurde.

---

Schreiben Sie in C die Funktion `collatz_orbit` mit folgender Signatur,
welche die Zahl des Collatz-Orbits nach der $$ k $$-ten Iteration bestimmt. Falls
irgendein $$ n $$ im Verlauf der Berechnung die Größe von 64 Bit überschreitet, soll
das Ergebnis 0 sein.
```c
uint64_t collatz_orbit(uint64_t n, uint64_t k)
```

Beispiel für $$ n = 10, k = 3 $$: Der Orbit für das gewählte $$ n $$ ist: $$(10,
5, 16, 8, 4, ..)$$; der nach der $$ k $$-ten Iteration erreichte Wert ist $$ 8 $$, also
$$\text{collatz\_orbit} (10, 3) = 8$$."
453,Grundlagenpraktikum Rechnerarchitektur,16494,P1-2 EAN-13 Verifier,"# EAN-13 Verifier
Die EAN-13 ist ein standardisiertes Strichcode-System, das zur Identifikation von Produkten in Geschäften und Logistik verwendet wird. Jeder Strichcode besteht aus einer 13-stelligen Zahlenkombination, die eindeutig ein Produkt identifiziert.

---

Implementieren Sie folgende Funktion, welche für eine gegebene EAN genau dann den Wert 1 zurück gibt, wenn die EAN gültig ist, andernfalls den Wert 0. Die EAN wird direkt als Zahl übergeben, d.h. für die EAN 3213213213229 wird `ean=3213213213229` gesetzt.

Eine EAN-13 besteht aus 12 Ziffern zur Produktidentifikation und einer Prüfziffer an letzter Stelle. Zur Bestimmung der Gültigkeit werden die 13 Ziffern aufaddiert, wobei Ziffern an ungerader Stelle mit 3 multipliziert werden. Die erste Ziffer hat Index 0 und ist somit an gerader Stelle. Eine EAN-13 ist gültig, wenn diese Summe ein Vielfaches von 10 ist.

```c
int ean13(uint64_t ean)
```"
453,Grundlagenpraktikum Rechnerarchitektur,16504,P2-1 Memccpy,"# Memccpy
Implementieren Sie die Funktion `memccpy` (Siehe auch `man 3 memccpy`) in C, welche maximal `n` Bytes von `src` nach `dest` kopiert, aber den Kopiervorgang abbricht, *nachdem* ein Byte kopiert wurde, welches dem Parameter `c` entspricht. Falls `c` gefunden wurde, gibt die Funktion einen Pointer zum nächsten Byte in `dest` zurück, andernfalls `NULL`.

Die Funktion hat folgende Signatur:
```c
void* memccpy (void* dest, const void* src, int c, size_t n);
```

Lesen Sie in der manpage von `memccpy`, wie genau der parameter `c` interpretiert werden soll."
453,Grundlagenpraktikum Rechnerarchitektur,16505,P2-2 List Average,"# Arithmetisches Mittel einer Linked List

Eine *Linked List* ist eine Datenstruktur, in der jedes Element der Liste zusätzlich einen Pointer auf das nachfolgende Element enthält;
oder einen `NULL`-Pointer, falls es kein nachfolgendes Element gibt.
Eine leere Liste wird ebenfalls einfach durch einen `NULL`-Pointer repräsentiert.

---

Für die folgende Aufgabe hat ein Element der Linked List folgenden Datentyp:
```c
struct node {
    struct node* next;
    double val;
};
```

Schreiben Sie in C eine Funktion `listavg` mit folgender Signatur:
```c
double listavg(const struct node* list);
```
Die Funktion soll für eine Linked List mit Elementen vom Datentyp `double` das arithmetische Mittel der enthaltenen Elemente berechnet.
Das arithmetische Mittel einer leeren Liste soll hierbei $$0$$ sein."
453,Grundlagenpraktikum Rechnerarchitektur,16506,P3-1 Brainfuck,"## Brainfuck-Interpreter

Brainfuck ist eine esoterische, aber dennoch [Turing-vollständige](https://de.wikipedia.org/wiki/Turing-Vollst%C3%A4ndigkeit) Programmiersprache. Als Zustand gibt es ein (theoretisch) unendlich großes Byte-Array und einen verschiebbaren Pointer auf dieses. Sie besteht aus lediglich acht Befehlen. Das Null-Byte zeigt das Ende eines Brainfuck-Programms, ähnlich dem nullterminal bei Strings. Alle anderen Zeichen, werden als Kommentare behandelt und ignoriert.

### Brainfuck-Befehle:
- `>` --- Inkrementiert Pointer
- `<` --- Dekrementiert Pointer
- `+` --- Erhöht Byte an der Stelle vom Pointer um 1
- `-` --- Verringert Byte an der Stelle vom Pointer um 1
- `.` --- Gibt Byte an der Stelle vom Pointer auf *stdout* aus
- `,` --- Liest Byte von *stdin* und schreibt dies an die Stelle vom Pointer
- `[` --- Springt zum *passenden* `]` nach vorn, wenn Wert am Pointer 0 ist; andernfalls wird der nächste Befehl ausgeführt.
- `]` --- Springt zum *passenden* `[` zurück, wenn Wert am Pointer ungleich 0 ist; andernfalls wird der nächste Befehl ausgeführt.

> **Hinweis:** Anders als in den meisten online Referenzen ist diese Definition ein reiner Interpreter. Das bedeutet insbesondere, dass invalide unvollständige Klammern in Programmen erst zu einem Fehler frühren, wenn das Gegenstück zu einer Klammer auch tatsächlich benötigt wird.

### Aufgabe:
Implementieren Sie einen Brainfuck-Interpreter, die Funktion sollte im
Fehlerfall den Wert `-1` zurückgeben und bei erfolgreicher Ausführung des
gesamten Programms den Wert `0`.

> **Hinweis:** Das Array kann bereits mit Daten vorinitialisiert sein und der
Datenpointer `cur` kann anfangs auch an eine andere Stelle als den Beginn
von `array` zeigen.

> **Hinweis:** Sie dürfen davon ausgehen, dass der übergebene Inizialzustand valide ist.

> **Hinweis zum Tester:** Wenngleich Lösungen grundsätzlich allgemein
funktionieren sollten, können zwecks Optimierung im Rahmen des Aufgabentesters
folgende Annahmen getroffen werden: Die maximale Programmlänge sind 8192
Bytes. Die maximale Verschachtelungstiefe von Schleifen ist 256.
Der Stack hat eine Größe von 4096 Bytes.

```c
// Interpreter state
struct BFState {
  // The array and the size of the array.
  size_t array_len;
  uint8_t* array;

  // Pointer to the current position in the array
  // array <= cur < (array+array_len)
  uint8_t* cur;
};

int brainfuck(struct BFState* state, const char* program)
```

> **Hinweis:** Der Tester unterstütz keine IO operationen. Sie können diese zum lokalen Testen implementieren, müssen aber beim Hochladen ensprechende stellen auskommentieren.

### Empfehlung:
Die folgenden Schritte können Ihnen als Hilfestellung zur Aufgabe dienen. Es kann hilfreich sein, die Ausgabe des Programms mit `./brainfuck   | hexdump -C` anzusehen.


1. Initialisieren Sie eine Variable für den Program Counter des Eingabeprogramms. Implementieren Sie nun Ihre Fallunterscheidung für die acht Instruktionen.

2. Beginnen Sie nun mit der Instruktion `.` --- dies wird Ihnen das Debugging deutlich erleichtern. Nutzen Sie hierzu die Funktion `putchar` (siehe auch `man putchar`).

   *Hinweis:* Sie können in C auf Felder eines `struct`-Pointers mit dem Operator `->` zugreifen.

(3. Implementieren Sie dann die Operation `,` mithilfe der Funktion `getchar`.)
   
4. Behandeln Sie nun die Instruktionen `+`/`-`/`>`/`<`. Achten Sie beim Verschieben des Pointers darauf, dass dieser sich nicht außerhalb des alloziierten Arrays befinden kann und behandeln Sie den Fehlerfall, indem Sie die Ausführung des Brainfuck-Programms abbrechen.

5. Für die Instruktionen `[`/`]` müssen Sie (sofern die Sprungbedingung zutrifft) eine Suche implementieren, die im String die passende Klammer findet. Sie können einfach in der entsprechenden Richtung über den String iterieren und die Verschachtelungstiefe von Klammern zählen. Wenn Sie wieder bei Tiefe 0 angekommen sind, haben Sie das Sprungziel erreicht. Sie haben nun (hoffentlich) einen funktionierenden Brainfuck-Interpreter!"
453,Grundlagenpraktikum Rechnerarchitektur,16507,T3-1 Nutzereingaben,"# Nutzereingaben
## Parsen mit `getopt`

In dieser Aufgabe wollen wir das Programm `numquad` um ein **C**ommand **L**ine **I**nterface (CLI) ergänzen. Hierzu werden wir die Funktion `getopt` verwenden, welche das Parsen der vom Benutzer übergebenen Argumente vereinfacht.

1. Bevor Sie mit der Implementierung des CLI beginnen, informieren Sie sich zunächst über die Funktion `getopt`. Nutzen Sie den Befehl `whatis getopt` (und evtl. `man man`) um herauszufinden, welche `man` page die relevanten Informationen der C-Funktion `getopt` beinhaltet. Lassen Sie sich diese anzeigen.

2.  Überschaffen Sie sich zunächst in den Abschnitten `NAME` und `SYNOPSIS` einen Überblick über die bereitgestellte Funktionalität und Signatur der `getopt` Funktion. Lesen Sie auch den ersten Absatz des Abschnitts `DESCRIPTION` um ein grobes Verständnis der Funktionsweise von `getopt` zu erlangen.


3.  Welchen Header/Welche Header müssen Sie einbinden, um `getopt` verwenden zu können? Öffnen Sie die Datei `main.c` und fügen Sie diesen hinzu.


4.  Die `getopt` Parameter `argc` und `argv` entsprechen den bereits bekannten Parametern der `main` Funktion. Finden Sie die Bedeutung des `optstring` Parameters heraus.

    > **Hinweis:**
    > Mit `/optstring ` können Sie in der `man` page nach dem Wort *optstring* suchen. Weitere Suchergebnisse können Sie mit `n` (next) anzeigen lassen.


5.  Betrachten Sie die Usage- und Help-Messages am Anfang der Datei `main.c`. Formulieren Sie einen `optstring`, der das Parsen dieses CLI ermöglicht.


6.  Welche Rückgabewerte hat die Funktion `getopt` für den eben formulierten `optstring`? Betrachten Sie hierzu den Abschnitt `RETURN VALUE` der `man` page.


7. Integrieren Sie nun das Parsen der Optionen `-t` und `-h` in das Programm. Für andere Optionen soll die Programmausführung nach Ausgabe der Usage-Meldung zunächst abgebrochen werden.


8.  Die Optionen `-a`, `-b` und `-n` erwarten jeweils ein Argument. Finden Sie mithilfe des Abschnitts `DESCRIPTION` und/oder `EXAMPLE` der `man` page heraus, wie `getopt` diese beim Parsen zur Verfügung stellt.


9.  Integrieren Sie nun auch das Parsen der verbleibenden Optionen. Für unsere Zwecke ist es ausreichend, `a` und `b` mit `atof` und `n` mit `atol` zu konvertieren.
    > **WICHTIG:** Für die Projektarbeit ist es aber nicht ausreichend! Wir werden das robuste Konvertieren von Strings zu Integern auf einem zukünftigen Blatt noch genauer betrachten.


10. Zuletzt wollen wir nun noch das Programmargument `fn` parsen. Finden Sie auch hierfür zunächst mithilfe der `man` page heraus, wie Sie darauf zugreifen können. Implementieren Sie basierend darauf die Parse-Funktionalität.




## Konvertierung von Strings zu Zahlen

Die Programmargumente in `argv` sind stets Strings, oftmals möchte man diese aber auch als numerische Werte betrachten. Im Folgenden wollen wir uns deshalb mit Funktionen beschäftigen, die eine entsprechende Konvertierung ermöglichen.

1. Die Funktionen `atol`, bzw. `atof` um Strings in `long`, bzw. `double` Werte zu konvertieren kennen Sie bereits. Warum ist deren Verwendung oft problematisch? Sehen Sie sich hierzu die relevanten `man` pages an.


2. Basierend auf den eben betrachteten `man` pages: Welche weiteren Funktionen bieten sich für die Konvertierung von Strings in `long`, bzw. `double` Werte womöglich an?


3. Finden Sie die Bedeutung der Parameter `const char* nptr` und `char** endptr` der `strtol` und `strtod` Funktionen heraus.


4. Konvertieren Sie nun mit `strtod` bzw `strtol` die Nutzereingaben für `a`, `b` und `n` in einen `double` bzw long Wert. Wie können Sie folgende Fehler abfangen?
    - Die Nutzereingabe repräsentiert keine gültige Fließkommazahl.
    - Die übergebene Fließkommazahl passt nicht in den Wertebereich eines `double`.

5. Wenn Ihrem Programm nun als Input eine ungültige Zahl gegeben wird (z.B. 12x345), soll folgende Fehlermeldung ausgegeben werden:
```
Invalid number: 12x345
```"
453,Grundlagenpraktikum Rechnerarchitektur,16508,T4-1 File IO,"# File IO

In dieser Aufgabe wollen wir uns dem Öffnen und Lesen von Dateien widmen. Hierzu werden wir das Programm `toupper_simd` so erweitern, dass der Nutzer auch eigene Eingabedateien spezifizieren kann.

> **Hinweis:**
> Ziehen Sie ggf. die relevanten `man` Pages für weitere Informationen heran. Achten Sie auch stets auf eine geeignete Fehlerbehandlung und hilfreiche Fehlermeldungen.

Für die Bearbeitung der Aufgabe müssen Sie lediglich die Funktionen `read_file` und `write_file` bearbeiten.

## Dateien lesen

1. Implementieren Sie zunächst die Funktion `read_file`. Öffnen Sie hierzu mit `fopen` die Datei, deren Pfad der Funktion übergeben wurde.

2. Finden Sie heraus, wie Sie die Funktion `fstat` verwenden können, um die Größe der Datei zu bestimmen (`man 2 fstat`). Wie können Sie zudem feststellen, ob es sich bei der Datei um eine reguläre Datei handelt?

3. Allozieren Sie nun genügend Speicher für den Dateiinhalt und lesen Sie die Datei mit `fread` ein. Was müssen Sie hierbei mit Hinblick auf das terminierende `NULL`-Byte beachten?

4. Bevor sie den String zurückgeben, denken Sie daran, die geöffnete Datei wieder mit `fclose` zu schließen. Achten Sie darauf, dass die Datei auch im Fehlerfall geschlossen wird!

## Dateien schreiben

1. Implementieren Sie nun die Funktion `write_file`. Öffnen Sie hierzu auch in dieser zunächst die Ausgabedatei.

2. Schreiben Sie nun den String *ohne* das terminierende `NULL`-Byte in die Datei. Denken Sie auch hier daran, die Datei in jedem Fall zu schließen.


> Hinweise zum Tester:
> Der Tester erwartet folgende Ausgaben im Fehlerfall:
> - `Error opening file`
> - `Error processing file`"
453,Grundlagenpraktikum Rechnerarchitektur,16509,T4-2 Valgrind,"# Valgrind

Früher oder später schleicht sich in so gut wie jedes C Programm ein Fehler bezüglich der Speicherallokation oder -freigabe, oder bezüglich Speicherzugriffen ein. Gerade diese sind allerdings häufig schwer zu debuggen, da der Fehler oftmals nicht im direkten lokalen und/oder temporalen Kontext der eigentlichen Ursache auftritt. Wir möchten uns anhand des Programms `outerprod` nun ansehen, wie uns das Tool Valgrind helfen kann, die Ursache dieser Fehler dennoch aufzuspüren und zu beheben.



1. Besprechen Sie mit Ihrem Tutor zunächst den Aufbau und die grobe Funktionsweise des Programms.

2. Kompilieren Sie das Programm mit `make` und führen Sie es aus. Verhält es sich wie erwartet?

3. Führen Sie das Programm zum Debuggen nun mit GDB aus (`gdb ./outerprod`; `r`). An welcher Stelle der Datei `outerprod.c` stürzt das Programm ab?

4. Lassen Sie sich mit dem Befehl `p mat` den Pointer auf die Ausgabematrix anzeigen. Können Sie allein hieraus erkennen, warum das Programm abstürzt?

5. Führen Sie das Programm nun mit Valgrind aus: `valgrind ./outerprod`. Wie interpretieren Sie die Ausgabe? Was ist die *unmittelbare* Ursache für den Absturz?

6. Wie groß ist der Speicherbereich, auf den zum Zeitpunkt des Programmabsturz zugegriffen wird? Wie groß *sollte* er sein?

7. Wie erklären Sie sich diese Diskrepanz?

8. Informieren Sie sich im [GCC Manual](https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html) über die Integer Overflow Built-ins und überlegen Sie, wie Sie diese nutzen können, um dieses und ähnliche Probleme allgemein zu verhindern."
453,Grundlagenpraktikum Rechnerarchitektur,16510,T4-3 Makefile,"# Makefiles
Da ständiges Wiederholen von längeren Kommandos fehleranfällig und schon bei geringfügig größeren Projekten sehr aufwändig ist, werden diese Kommandos meist von Build-Systemen automatisch generiert und in separate Dateien geschrieben.

In dieser Aufgabe werden wir hierzu die Struktur von *GNU/Unix Makefiles* betrachten.

> Hinweis: für diese Aufgabe gibt es keine Testcases

1. Öffnen Sie das enthaltene Makefile. Betrachten Sie zunächst folgenden Ausschnitt:
	
    ```make
	main: main.c helper.S
	    $(CC) $(CFLAGS) -o $@ $^
    ```
	
	Wie interpretieren Sie diese beiden Zeilen? Welche Datei stellt hierbei die zu bauende Zieldatei dar und was sind die zugehörigen Quelldateien?

	
2. Variablen werden in Makefiles offensichtlich mit der Syntax `$(varname)` referenziert. Versuchen Sie herauszufinden, wo die beiden Variablen `CC` und `CFLAGS` definiert werden. Nutzen Sie hierzu auch das *[GNU-Make Manual](https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html)*.
	
3. Versuchen Sie nun mittels des *[GNU-Make Manuals](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html)**herauszufinden, wodurch die Variablen `$@` und `$^` ersetzt werden.

	
4.  Beim Auführen des Befehls `make` werden als Argumente die *target*s angegeben, die gebaut werden sollen. Wenn kein *target* spezifiziert wird, wird das erste definierte *target* genommen. Zudem lassen sich auch Variablen definieren und weitere Optionen setzen. Finden Sie heraus, was folgende Aufrufe machen:
	

	- `make`
	- `make main`
	- `make clean all`
	- `make CFLAGS=""-O3 -Wall -Wextra""`
	- `make -j2` (nutzen Sie hierzu auch `man make`)

	
5. Führen Sie nun `make clean` aus und danach zwei Mal `make`. Wie erklären Sie sich, dass lediglich beim ersten Durchlauf tatsächlich etwas kompiliert wurde?

	
6. Erzeugen Sie nun mit *touch clean* die Datei *clean* und führen Sie `make clean` aus. Funktioniert alles wie erwartet? Wie können Sie das `Makefile` entsprechend ändern, sodass `clean` und `all` immer ausgeführt werden?
	
	> **Hinweis:** Nutzen Sie das *[GNU-Make Manual](https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html)*."
453,Grundlagenpraktikum Rechnerarchitektur,16518,P5-1 Produkt,"# Structs und Constructors

Ein Supermarkt benötigt ein Software-System, das verwendet werden kann, um alle Produkte, die es im Moment anbietet, abzuspeichern.

Dafür soll ein Struct `Product` definiert werden, das ein individuelles Produkt beschreiben kann.

Für jedes Produkt sollen folgende Werte gespeichert werden:

- `const char* name`: Der name des Produkts.
- `const char* description`: Eine Beschreibung des Produkts.
- `float price`: Der Preis des Produkts.
- `float bulkPrice`: Der Preis, wenn 10 Stücke auf einmal gekauft werden sollen.

Das Feld `bulkPrice` gibt den Preis für 10 Einheiten an. Standardmäßig entspricht dieser Preis einfach `10 * price`. Allerdings soll er für gewisse Produkte auch manuell gesetzt werden.

Das Feld `description` beinhaltet eine kurze Beschreibung des Produkts. Allerdings besitzt nicht jedes Produkt eine explizite Beschreibung. Wenn keine Beschreibung angegeben wird, wird ein leerer String (`""""`) abgespeichert.

Definiere das Struct in C++ und implementiere die dazugehörigen Constructors (siehe main.cpp), sodass jede mögliche Kombination aus optionalen Feldern übergeben werden kann, und nicht angegebene Felder wie oben beschrieben auf ihre Standardwerte gesetzt werden."
453,Grundlagenpraktikum Rechnerarchitektur,16519,P5-2 Hello SystemC,"# Hello SystemC

Implementiere ein simples C++ Programm, das drei SystemC Signale mit den Typen `int`, `float` und `bool` erstellt.

Schreibe dann die Werte `42`, `1.618` und `true` mit der Methode `sc_signal .write(...)` darauf.

Zum Abschluss, starte die Simulation mit `sc_start()`, lies die Werte mit `sc_signal .read()` wieder von den Signalen aus und gib sie folgendermaßen als Text aus:

```
int: 42
float: 1.618
bool: 1
```"
453,Grundlagenpraktikum Rechnerarchitektur,16520,T5-1 CPP Basics,"Die Vorlage beinhaltet ein simples C++ Programm mit dem Struct

```c++
struct Pet {
    const char* name;
    const char* species;
    int age;
};
```

Implementiere einen Constructor, damit eine Instanz des Structs folgendermaßen erstellt werden kann:

```c++
Pet myDog(""Snoopy"", ""Dog"", 74);
```

Implementiere außerdem eine Methode `info()`, die beim Aufrufen beispielsweise folgenden Text ausgibt:

```
My name is Snoopy, I am a Dog and I am 74 years old.
```"
453,Grundlagenpraktikum Rechnerarchitektur,16521,T5-2 SystemC sc_bv,"Installiere SystemC wie es im Vorlesungsmaterial beschrieben wurde.

Erweitere dann das Grundgerüst des gegebenen Codes, indem du ein Signal mit dem Typ `sc_bv<8>` definierst. Dieser Typ stellt einen Bit-Vektor aus 8 Bits dar.

Schreibe dann den Wert `99` in das Signal. Starte die Simulation, lies das Signal aus, und gib den Ausgabewert in der Konsole aus.

Tipp: Bit-Vektoren werden verwendet, um Zahlen als Strings aus Bits darzustellen. Dabei kann auf die individuellen Bits einzeln zugegriffen werden, oder der Vektor wird als Ganzes beschrieben oder gelesen. Wir haben `sc_bv ` noch nicht behandelt. Versuche also, in der Dokumentation von SystemC eine beispielhafte Verwendung des Datentyps zu finden."
453,Grundlagenpraktikum Rechnerarchitektur,16522,P6-1 Full Adder,"# Full Adder

Implementiere den Schaltkreis für einen Full Adder. Folge dafür der Skizze unten.

![FA.png](/api/core/files/markdown/Markdown_2024-05-20T09-36-05-879_c58242e2.png)


Der Full Adder besteht aus zwei aneinandergeschlossenen Half Addern und einem zusätzlichen Or-Gatter. Verwende für die Signale, die nach außen hin zugänglich sein sollen (Inputs/Outputs der Module) Ports (`sc_in` und `sc_out`), und für Signale die sich im ""Inneren"" eines Moduls befinden `sc_signal` als Datentyp. 


***Achtung**: Das Template dieser Aufgabe ist standardmäßig noch nicht kompilierbar. Um das Projekt kompilieren zu können, müssen zuerst die nötigen Konstruktoren definiert werden.*"
453,Grundlagenpraktikum Rechnerarchitektur,16523,P6-2 RISC-V ALU,"Implementiere eine RISC-V ALU basierend auf dem gegebenen Angabenblatt:

[alu-de.pdf](/api/core/files/markdown/Markdown_2025-05-12T13-33-52-695_3d54dce4.pdf)

[alu-en.pdf](/api/core/files/markdown/Markdown_2025-05-12T13-33-21-056_ff757d9b.pdf)"
453,Grundlagenpraktikum Rechnerarchitektur,16524,T6-2 XOR Gatter,"# XOR Gatter

Implementiere ein Modul für ein XOR Gatter mit dem Namen `XOR_GATE` und einem einfachen Constructor.

Das Modul soll eine kombinatorische Schaltung darstellen, zwei Signale (`a`, `b`) für den Input verwenden und ein Signal (`out`) für den Output.

Der Wert des Outputs erschließt sich aus der Wahrheitstafel des XOR Gatters:

| A | B | XOR |
|---|---|---|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |"
453,Grundlagenpraktikum Rechnerarchitektur,16525,T6-3 RISC-V Multiplexer,"Implementiere einen Multiplexer basierend auf dem gegebenen Angabenblatt:


[multiplexer-de.pdf](/api/core/files/markdown/Markdown_2024-11-22T10-53-19-730_4632f1aa.pdf)

[multiplexer-en.pdf](/api/core/files/markdown/Markdown_2024-11-22T10-53-26-231_0cae20c9.pdf)"
453,Grundlagenpraktikum Rechnerarchitektur,16526,P7-1 RISC-V Register File,"Implementiere eine RISC-V Registerbank basierend auf dem gegebenen Angabenblatt:

[register-file-de.pdf](/api/core/files/markdown/Markdown_2025-05-13T16-07-39-300_81d45a4d.pdf)

[register-file-en.pdf](/api/core/files/markdown/Markdown_2025-05-13T16-07-15-954_7d2a8e91.pdf)"
453,Grundlagenpraktikum Rechnerarchitektur,16527,T7-1 D-Flip-Flop,"# D-Flipflop

Ein D-Flipflop ist eine simple Speichereinheit. Es verwendet einen Input ($$D$$) und zwei Outputs ($$Q$$, $$\bar Q$$). Mit jedem Clock Zyklus wird der Wert von $$D$$ im Flipflop abgespeichert. $$Q$$ wird dann auf diesen Wert gesetzt, während $$\bar Q$$ seine Negation ist.

Implementiere das `D_FLIP_FLOP` Modul mit den gegebenen Inputs/Outputs. Es soll außerdem einen Input-Port verwenden, an dem eine Clock für die periodischen Updates angelegt werden kann."
453,Grundlagenpraktikum Rechnerarchitektur,16528,T7-2 RISC-V PC,"Implementiere einen RISC-V Program Counter basierend auf dem gegebenen Angabenblatt:

[pc-de.pdf](/api/core/files/markdown/Markdown_2025-04-29T20-28-48-976_e0bfe827.pdf)

[pc-en.pdf](/api/core/files/markdown/Markdown_2025-04-29T20-29-34-198_862bdc24.pdf)"
453,Grundlagenpraktikum Rechnerarchitektur,16529,T8-1 IO Counter,"# I/O Counter

Basierend auf dem SystemC Schaltkreis aus der Aufgabe ""_Trace File_"", implementiere einen I/O Counter für die beiden Module.

Definiere dafür das Feld `int ios` für beide Module und inkrementiere es bei jedem _read_ auf ein Signal (abgesehen von `clk`) um `1` und bei jedem _write_ um `2`."
453,Grundlagenpraktikum Rechnerarchitektur,16530,T8-2 RISC-V Main Memory,"Implementiere einen RISC-V Arbeitsspeicher basierend auf dem gegebenen Angabenblatt:

[main-memory-de.pdf](/api/core/files/markdown/Markdown_2024-11-22T10-54-55-796_294bf1f8.pdf)

[main-memory-en.pdf](/api/core/files/markdown/Markdown_2024-11-22T10-55-00-212_353bcaed.pdf)"
453,Grundlagenpraktikum Rechnerarchitektur,16531,P8-1 Trace File,"# Trace File

Gegeben ist ein SystemC Schaltkreis bestehend aus mehreren Modulen und Signalen.
Erstelle zwei Trace Files:

trace1:
Beinhaltet die Signale `a`, `b` und `c` mit den Namen `a`, `b` und `c`.

trace2
Beinhaltet nur das Signal `b` unter dem Namen `result`.

Für die Erstellung der Trace Files werden dem Programm zwei Parameter übergeben. Beispielsweise sollten mit

```bash
./tracefile out/trace1 out/trace2
```

die Dateien `trace1.vcd` und `trace2.vcd` im Ordner `out` erstellt werden.

Wenn das Programm ungültig aufgerufen wird, soll es sofort mit dem Exit-Code 1 beendet werden.
Das bezieht sich besonders auf die angegebenen Pfäde: Der User muss Schreibzugriff auf die gegebenen Trace Files und/oder deren Parent-Directory haben, um das Programm ausführen zu können."
453,Grundlagenpraktikum Rechnerarchitektur,16532,P8-2 RISC-V CU,"Implementiere eine RISC-V Control Unit basierend auf dem gegebenen Angabenblatt:

[cu-de.pdf](/api/core/files/markdown/Markdown_2025-05-12T13-34-05-020_f9361a2f.pdf)

[cu-en.pdf](/api/core/files/markdown/Markdown_2025-05-12T13-33-09-752_0c245358.pdf)"
453,Grundlagenpraktikum Rechnerarchitektur,16533,T9-1 SystemC und C,"# SystemC & C

In der Projektphase werden C-Grundgerüste verwendet, um CLI Parameter einzulesen.
C++ wird nur verwendet, um SystemC Module zu definieren und simulieren.

Dafür müssen wir eine Möglichkeit finden, C und C++ miteinander kommunizieren zu lassen. Tatsächlich ist das relativ einfach möglich.

In dieser Aufgabe arbeiten wir daran, eine SystemC Simulation von C aus zu starten.

## Repository

Das Repository dieser Aufgabe besteht aus drei Dateien:
- `main.c`: Liest CLI Argumente ein und verwertet sie. Hier ist der Einstiegspunkt des Programms über die `main` Funktion.
- `modules.hpp`: Definiert SystemC Module
- `modules.cpp`: Erstellt nötige `sc_signals`, verwendet SystemC Module, führt Simulation aus und gibt Ergebnis zurück.

Die einzelnen Dateien haben bereits ein Grundgerüst, müssen aber noch fertig ausgebaut werden.

## `modules.cpp`

- Erstelle die Clock und die Signale, die für das Modul in `modules.hpp` benötigt werden.
- Erstelle dann eine Instanz des Moduls.
- Starte die Simulation für `seconds` Sekunden.
- Gib den Wert des Signals `sum` nach der Simulation zurück.

_Achtung: Mit SystemC müssen wir immer auch eine `sc_main` Funktion definieren, auch wenn sie nicht verwendet wird. Deshalb gibt es hier eine einfache `sc_main`, die eine Fehlermeldung ausgibt und `1` zurückgibt._

## `modules.hpp`

Diese Datei definiert ein SystemC Modul mit dem Namen `ADDER`. 
In der `.hpp` Datei müssen wir aber auch Funktionen markieren, die von C aus aufgerufen werden können sollen.

Dafür verwendet man das Keyword `extern ""C""`.

- Schreibe für alle Funktionen, die von C aus verwendet werden sollen, eine Zeile mit der Form:
```C++
extern ""C""    ( );
```
mit ` ` als Name der Funktion, ` ` als Rückgabetyp und ` ` als Auflistung der verwendeten Parameter.

## `main.c`

Diese Datei beinhaltet die `main` Funktion. Hier soll ein einzelner CLI Parameters eingelesen werden: `seconds`. Er gibt an, wie lange die Simulation laufen soll.

Lies den Wert als integer ein und rufe dann die Funktion `run_simulation` aus `modules.cpp` aus. Gib das Ergebnis dieses Aufrufs in der Form
```
Simulation result:  
```
aus.

Alle C++ Funktionen, die wir hier aufrufen wollen, müssen zuerst deklariert werden. Das kann mit
```C
extern    ( );
```
gemacht werden.


Nun sollte der Aufruf
```bash
./systemcc 10
```
zum Output
```
Simulation result: 10
```
führen."
453,Grundlagenpraktikum Rechnerarchitektur,16534,P9-1 TinyRISC CPU,"Verbinde die RISC-V Komponenten, die du im Laufe des Kurses entwickelt hast, zu einer funktionsfähigen CPU!

[tiny-risc-de.pdf](/api/core/files/markdown/Markdown_2025-05-22T12-47-11-807_284c9246.pdf)

[tiny-risc-en.pdf](/api/core/files/markdown/Markdown_2025-05-22T12-37-59-284_1952e951.pdf)"
453,Grundlagenpraktikum Rechnerarchitektur,16537,P4-Mini-Projekt Assemblierer,"# TinyAssembler

In dieser Aufgabe geht es darum, die im Laufe des Semesters behandelten Themen zum Thema C-Programmierung in der Form eines Mini-Projekts anzuwenden.
Die Kerninhalte dieser Aufgabe bilden eine wichtige Basis für das Abschlussprojekt am Ende des Semesters, deshalb sollte diese Aufgabe gewissenhaft durchgeführt werden.

Im Rahmen dieser Aufgabe entwickeln wir einen Assemblierer, der eine simple Form von Assembler-Code zu Bytecode übersetzt.
Der Assemblierer soll über die CLI aufrufbar sein, verschiedene Optionen akzeptieren und Dateien bearbeiten.

Das Ziel dieser Aufgabe ist nicht wie bei vorherigen Aufgaben die Optimierung der Performance - stattdessen geht es hier um sichere Programmierung und Kommunikation mit Benutzern.

#### ***Achtung***: Um Teilpunkte für diese Aufgabe zu erhalten *muss* mindestens das Rahmenprogramm (siehe Teil 2) korrekt implementiert sein. Eine Implementierung des Assemblierers ohne Rahmenprogramm gibt keine Teilpunkte!

---

### Teil 1: Assemblierer

Der Assemblierer wird in der Datei `assembler.c` implementiert. Hier sollte die `assemble(...)` Funktion ausgefüllt werden, um folgendes Ziel zu erreichen:
`const char* input` repräsentiert einen String, der ein Assemblerprogramm beinhaltet.
Jede Zeile dieses Programms (getrennt durch `\n`), kann bis zu eine Assembler-Instruktion beinhalten.
Der Assemblierer soll jede dieser Instruktionen erkennen und sie zu Maschinencode als 4-Byte unsigned Ganzzahlen (`instruction_t`) konvertieren.
Wenn das Argument `instruction_t* output` auf `NULL` gesetzt ist, so soll die Anzahl an Instruktionen im Programm gezählt und dann zurückgegeben werden.
Ansonsten sollen alle konvertierten Instruktionen in den Buffer `output` geschrieben werden (es darf hier davon ausgegangen werden, dass `output` über genügen Platz verfügt, um alle Instruktionen aufzunehmen, wenn `output != NULL` gilt).

Um die Komplexität dieser Aufgabe zu reduzieren, arbeiten wir mit einer vereinfachten Form von RV32I Assembly. Das genaue Format wird nun erklärt:

#### 1.1 Instruktions-Format


Alle Instruktionen, die der Assemblierer lesen muss, haben folgendes Format:

```
    [, ARG-2] [, ARG-3]
```

`NAME` gibt hier den Namen der Instruktion an und `ARG-1` bis `ARG-3` die dazugehörigen Argumente. 
Nicht jede Instruktion muss aber 3 Argumente annehmen, die Anzahl an benötigten Argumenten unterscheidet sich von Instruktion zu Instruktion.

Die Argumente können zwei Formen annehmen:
- Register
- Immediates

Es sollen die Register `x0` bis `x31` unterstützt werden. Aliase und alternative Register werden nicht benötigt.
Immediates sind positive ganze Zahlen, die mit dem Präfix `0b` im Binärformat, mit `0x` im Hexadezimalformat, oder ohne Präfix im Dezimalformat angegeben werden können.
Für unsere vereinfachte Assemblyform dürfen Immediate Werte je nach Instruktion bis zu 12 oder 20 Bits annehmen.

Wenn der übergebene Input einen nicht-unterstützen Instruktionsnamen oder ungültige Argument-Werte beinhaltet, soll die Ausführung sofort mit dem Exit-Code 1 beendet werden.

Beispielanweisungen:
```
add x3, x2, x1
li x9, 0b1000100111
```

**Achtung**: Unnötiger White-Space soll vom Assemblierer ignoriert werden. 
Die folgenden Instruktionen sind also alle gültig:
```
add x3, x2, x1
add x3,      x2 , x1
add x3,x2,x1
```
Leere Zeilen sollten ebenfalls ignoriert werden und nicht als eigene Instruktionen gelten.

#### 1.2 Kommentare

Kommentare werden mit dem Symbol `#` eingeleitet. Bis zum Ende der Zeile soll der Assemblierer also alle Symbole nach einem `#` ignorieren.

Kommentare können eine volle Zeile annehmen oder am Ende einer Zeile angegeben werden.

Beispiel:
```python
# this is a full-line comment.
add x3, x2, x1 # this is an end-of-line comment.
```

#### 1.3 Instruktionen

Die folgende Tabelle beinhaltet alle Instruktionen, die vom Assemblierer unterstützt werden sollen.
`rs1`, `rs2` und `rd` stehen dabei jeweils für Register (siehe 1.4), `imm` steht für einen Immediate Wert.

![image.png](/api/core/files/markdown/Markdown_2025-04-30T10-40-53-231_0b6e7b6d.png)

**Hinweis**: In hekömmlichen Assembly-Formaten kann bei den `ld`/`sd` Instruktionen auch ein ""Offset"" angegeben werden, um den sich die tatsächlich gesuchte Adresse von der gegebenen Adresse unterscheidet. 
Hier soll das nicht unterstützt werden. Die geladene/überschriebene Adresse entspricht direkt dem Wert, der im gegebenen Register steht.

#### 1.4 Bytecode-Format

Alle Anweisung aus der Tabelle oben müssen anhand eines vorgegebenen Formats in Bytecode übersetzt werden. Dafür verwenden wir eine - für diese Aufgabe leicht angepasste - Version des herkömmlichen Instruktions-Formats für RISC-V:

![image.png](/api/core/files/markdown/Markdown_2025-04-30T10-41-17-718_c88effc9.png)

Das B-Type Format wird nur für Branch Operationen mit Branch-Bedingungen verwendet. Das U-Type Format wird nur für di `li` Instruktion verwendet. Alle anderen Instruktionen verwenden das `R`-Type Format. 

Nicht benötigte Felder sollten auf 0 gesetzt werden. Bei R-Type Instruktionen werden die ersten 7 Bits auf 0 gesetzt.
Immediate Werte werden ins Binärformat übersetzt und mit führenden Nullen ergänzt, bis sie eine Größe von 20 Bits (U-Type) oder 12 Bits (B-Type) erreicht haben. Immediate Werte, die größer als 20 Bytes sind, werden nicht unterstützt. Im B-Type Format werden die Immediates in zwei Sections aufgeteilt. Die 7 signifikantesten Bits werden an den Beginn des Bytecodes gesetzt, die 5 restlichen Bits ersetzen das `rd` Feld.


Jedem Register wird ein Zahlenwert zugewiesen, der als `rs1`, `rs2` oder `rd` für den Instruktions-Bytecode verwendet wird. Register `x0` hat den Wert `0`, `x1` hat den Wert `1`, `x31` den Wert `31` usw.

Die Werte für `opcode` und `funct` können jeweils aus der Tabelle in 1.3 entnommen werden.

So wird beispielsweise aus der Instruktion

```
add x3, x2, x1
```

der Bytecode

```
0000000 00001 00010 100 00011 0110011
```

und

```
li x10, 255
```

wird zu

```
0000000 00000 11111 111 01010 0100010
```

übersetzt.

---

### Teil 2: Rahmenprogramm

Das Rahmenprogramm wird in der Datei `main.c` implementiert. Es ist dafür zuständig, die Kommunikation mit dem Benutzer zu ermöglichen.

#### 2.1 CLI Argumente

Verwende `getopt_long(...)`, wie in den Tutorien behandelt, um CLI Argumente einzulesen. Das Programm soll die folgenden Optionen akzeptieren:

- `-h` oder `--help`: Wenn das Programm mit dieser Option aufgerufen wird, gibt es Informationen über die Verwendung und die möglichen Optionen aus und wird dann mit Exit-Code 0 beendet.
- `-o  ` oder `--output  `: Gibt den Pfad zur Output Datei, die generiert werden soll, an. Wenn die Option nicht angegeben ist, soll ein sinnvoller Standardwert verwendet werden.

Außerdem soll für jeden Aufruf des Programms ein weiteres Argument benötigt werden, das den Pfad zu einer Input Datei angibt, die den zu übersetzenden Assemblercode enthält.

Ein beispielhafter Aufruf des Programms könnte also so aussehen:

```bash
./assembler -o a.out code.asm
```

Wenn eine ungültige Option oder zu viele Argumente angegeben wurden oder die Input Datei fehlt, wird die Ausführung sofort abgebrochen und der Exit-Code 1 zurückgegeben. 

#### 2.2 Ein/Ausgabedateien

Das Rahmenprogramm muss den Assemblercode aus der angegebenen Datei auslesen und abspeichern, um den Assemblierer damit aufzufen zu können.
Verwende die `FILE*` Datenstruktur, um die Eingabedatei zu öffnen und zu lesen.

Nach der Verwendung des Assemblers enthält der `output` Buffer einen `instruction_t` Wert für jede übersetzte Instruktion.
Diese Instruktionen sollen in die Ausgabedatei gespeichert werden, die über CLI Optionen angegeben werden kann.
Dafür soll jede Instruktion zuerst zu ihrer Binärdarstellung mit 32 Bits konvertiert werden, und dieser Bitstring dann (ohne führendes `0b`) in die Ausgabedatei geschrieben werden.
Jede Instruktion soll eine Zeile in der Ausgabedatei annehmen.

Beisiel
`output`-Array:
```
[
  163,
  164403,
  37171
]
```

Ausgabedatei:
```
00000000000000000000000010100011
00000000000000101000001000110011
00000000000000001001000100110011
```

Bevor von Dateien gelesen oder auf Dateien geschrieben wird, mus immer geprüft werden, ob der Dateizugriff erlaubt ist.
Wenn der Zugriff nicht erlaubt ist, wird die Ausführung sofort abgebrochen und das Programm mit dem Exit-Code 1 beendet.

#### 2.3 Output Buffer

Der Assemblierer benötigt einen Output-Buffer, um die berechneten Instruktionen auszugeben.
Der Speicher für diesen Buffer soll dynamisch angelegt werden. Dafür muss zuerst die benötigte Größe des Buffers berechnet werden.
Wird die `assemble(...)` Funktion mit `NULL` als zweitem Parameter aufgerufen, berechnet der Assemblierer stattdessen nur die Anzahl an Instruktionen und gibt sie zurück.
Diese Anzahl kann dann verwendet werden, um genügend viel Speicher zu reservieren. Danach kann damit die `assemble` Funktion ein zweites Mal aufgerufen werden.

Jeder Buffer an dynamisch reservierten Speicher der während der Ausführung des Programms reserviert wird, soll nochvor dem Ende der Ausführung freigegeben werden."
453,Grundlagenpraktikum Rechnerarchitektur,16986,Anmeldung zur Projektphase,"# Anmeldung zur Projektphase

In dieser Aufgabe besteht die Möglichkeit, sich zur Projektphase anzumelden und eine Präferenz für die gewünschte Gruppe anzugeben.
Folge dafür bitte der Vorlage unten.

Nach Abgabe der Auswahl wird automatisch überprüft, ob die Abgabe dem vorgegebenen Format entspricht. 
Bitte bessere die Abgabe im Fall von Fehlern aus. Eine korrekte Abgabe erhält eine Bewertung von 100%, während ein Fehler zu einer Bewertung von 0% führt.

**Achtung:** Die Anmeldung zur Projektphase ist für die Teilnahme am Projekt und das erfolgreiche Bestehen des Kurses *dringend notwendig*. Es werden nur korrekte Abgaben akzeptiert. Anmeldungen, die vom automatischen Testsystem nicht als 100% bewertet wurden, werden ignoriert.

**Hinweis:** Der automatische Test überprüft nur das Format. Fehler können aber trotzdem noch passieren, wenn beispielsweise ungültige Gruppenmitglieder angegeben werden. Bitte überprüfe daher alle Angaben auch manuell.

## Abgabeformat

Die Gruppenanmeldung *muss* über die Datei `abgabe.txt` im Submission-Repository stattfinden. Die Datei darf nicht umbenannt werden.

Der Inhalt dieser Datei hat folgendes Format:

```
Kennung:  

Gruppe:
 
 
```

Diese Struktur muss für eine gültige Anmeldung eingehalten werden.
` ` muss durch deine eigene TUM-ID ersetzt werden.
Nach dem Eintrag `Gruppe:` dürfen bis zu zwei gewünschte Gruppenmitglieder, jeweils in einer eigenen Zeile, angegeben werden. Für beide Gruppenmitglieder muss ebenfalls die korrekte TUM-ID angegeben werden.

Eine mögliche Gruppenanmeldung für einen Teilnehmer mit der TUM-ID ""ka21bab"" könnte beispielsweise so aussehen:

```
Kennung: ka21bab

Gruppe:
ga54lut
mo33vir
```

## Weitere Informationen

- Falls du kein oder nur ein Gruppenmidglied hast, können dementsprechend weniger Personen in der Gruppenliste aufgeführt werden. In dem Fall wird die Gruppe
nach Ablauf der Anmeldungsfrist automatisch vervollständigt. Die Bearbeitung des Projekts alleine oder in Zweiergruppen ist nicht möglich!
- Es besteht keine Garantie, dass Gruppen entsprechend der angegebenen Präferenzen erstellt werden. Anmeldungen in Dreiergruppen sollten in den meisten Fällen die gewünschte Gruppe ermöglichen. Bei Anmeldungen in Zweiergruppen kann es sein, dass Gruppenmitglieder aufgeteilt werden müssen, um andere Gruppen zu vervollständigen.
- Bitte vergewissere dich, dass du das Praktikum auch wirklich abschließen willst, bevor du dich zur Projektphase anmeldest. Durch eventuelles Absteigen
währen der Gruppenarbeit wird das Bearbeiten des Projekts für deine Gruppenmitglieder erschwert.
- Die Gruppenanmeldung darf innerhalb der Abgabefrist dieser Aufgabe beliebig oft überarbeitet werden. Es zählt immer nur die zuletzt abgegebene Präferenz.
- Bitte stelle sicher, dass die Kennungen deiner Gruppenmitglieder korrekt geschrieben wurde.
- Bitte stelle außerdem sicher, dass auch alle anderen gewünschten Gruppenmitglieder eine entsprechende Gruppenanmeldung durchführen.

## Gruppenzuweisung

Die Gruppenzuweisung findet nach Ablauf der Abgabefrist dieser Aufgabe (spätestens am Ende der darauffolgenden Woche) statt.
Die Gruppenaufgabe ""Abschlussprojekt"" wird auf Artemis sichtbar und weist auf die Namen der Gruppenmitglieder hin.

Zu Beginn der Projektphase wird die Aufgabenstellung ebenfalls dem ""Abschlussprojekt"" Repository hinzugefügt."
